/*!
 * LMV v7.32.0
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelAlignment =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelAlignment/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/ModelAlignment/AngleToAngle.js":
/*!***************************************************!*\
  !*** ./extensions/ModelAlignment/AngleToAngle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleToAngle; });
/* harmony import */ var _ModelAlignment_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignment.css */ "./extensions/ModelAlignment/ModelAlignment.css");
/* harmony import */ var _ModelAlignment_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ModelAlignment_css__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

// Controls the user interaction workflow for rotating a model by selecting center point and two directions.

var Events = {
  CENTER_SELECTED: 'centerSelected',
  CENTER_HOVERED: 'centerHovered',

  // from/to angle: event.angle contains the angle in degrees.
  FROM_ANGLE_SELECTED: 'startAngleSelected',
  FROM_ANGLE_HOVERED: 'startAngleHovered',
  TO_ANGLE_SELECTED: 'endAngleSelected',
  TO_ANGLE_HOVERED: 'endAngleHovered' };


var Modes = {
  NotSelecting: 0,
  SelectingCenter: 1,
  SelectingStartAngle: 2,
  SelectingEndAngle: 3,
  SelectingStartAngleEdge: 4,
  SelectingEndAngleEdge: 5 };


var PickingModes = {
  SinglePoint: 0,
  Edge: 1 };


var tmpMatrix1 = new THREE.Matrix4();
var tmpMatrix2 = new THREE.Matrix4();
var tmpMatrix3 = new THREE.Matrix4();
var tmpQuat = new THREE.Quaternion();
var tmpVec = new THREE.Vector3();
var tmpVec2 = new THREE.Vector2();

// Maps an angle from (-180, 180] range to the corresponding angle in [0,360)
var toPositiveDegrees = function toPositiveDegrees(degrees) {
  return degrees >= 0 ? degrees : degrees + 360;
};var

AngleToAngle = /*#__PURE__*/function () {

  function AngleToAngle(viewer, coordPicker, screenOverlay) {var _this = this;_classCallCheck(this, AngleToAngle);

    var CoordPicker = Autodesk.Edit3D.CoordPicker;
    var PointMarker = Autodesk.Edit3D.PointMarker;
    var TwoPointPicker = Autodesk.Edit3D.TwoPointPicker;

    this.viewer = viewer;
    this.coordPicker = coordPicker;

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.mode = Modes.NotSelecting;
    this.defaultPickingMode = PickingModes.Edge;

    // Points that define the rotation. Note that these points are optional, because the rotation may also be defined 
    // just by fromAngle and toAngle or just by offset alone.
    this.center = new THREE.Vector3(); // rotation center
    this.fromEdge = { a: new THREE.Vector3(), b: new THREE.Vector3() }; // edge that determined fromDirection
    this.toEdge = { a: new THREE.Vector3(), b: new THREE.Vector3() }; // edge that determined toDirection

    this.centerValid = false;
    this.fromValid = false;
    this.toValid = false;

    // Projections of fromPoint/toPoint on the selectionPlane. Used for gizmo placement
    this.fromPointOnPlane = new THREE.Vector3();
    this.toPointOnPlane = new THREE.Vector3();

    // {Autodesk.Edit2D.ScreenOverlay}
    this.screenOverlay = screenOverlay;

    this.angleGizmo = new Autodesk.Edit2D.AngleGizmo(this.screenOverlay.layer, {
      startColor: Autodesk.Edit3D.NPointPicker.Colors.Blue,
      endColor: Autodesk.Edit3D.NPointPicker.Colors.Red,
      ignoreCameraDistance: true,
      hideArrowHead: true,
      centerLabel: true,
      labelClassName: 'angle-to-angle' });


    // AngleGizmo is always visible, because it hides itself anyway if the required points are not specified yet.
    this.angleGizmo.setVisible(true);

    // Rotation axis
    this.axis = new THREE.Vector3(0, 0, 1);

    // The plane in which we have to choose points to specify startAngle and endAngle. 
    this.selectionPlane = new THREE.Plane();

    // Lines to connect selected from/to points with their projections to the selection plane
    this.fromConnector = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();
    this.toConnector = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();

    // Configure line style for connectors
    var style = this.fromConnector.line2D.style;
    style.lineStyle = 10; // dashed line (see LineStyleDef.js)
    style.lineWidth = 1.5;
    style.lineColor = 'rgb(255, 0, 0)';
    style.lineOpacity = 0.7;

    // Apply same style to toConnector
    this.toConnector.line2D.style.copy(style);

    // Duration of the rotation animation in seconds
    this.animTime = 1.5;

    // Determines when (within the rotation animation) we start to fade-out the angle gizmo
    // Value is in [0,1], where 0="at anim start", 1="at anim end". 
    this.fadeOutAngleGizmoAfter = 0.7;

    this.angleGizmoSize = 60;
    this.angleGizmoBottomOffset = 200;

    // When enabled, the first picked point will serve as pivot.
    this.useFirstPointAsCenter = true;

    // If false, we hide all gizmos
    this.visible = true;

    this.onDragEdgeEnd = this.onDragEdgeEnd.bind(this);

    var labelStyleBlue = {
      backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.Blue };


    var edgePickerOptions = {
      draggable: true,
      labels: ['From'],
      labelStyles: [labelStyleBlue],
      icons: [Autodesk.Edit3D.PointMarker.Icons.Cross, Autodesk.Edit3D.PointMarker.Icons.Empty],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Blue],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Arrow,
        color: Autodesk.Edit3D.NPointPicker.Colors.Blue,
        getEdgeLabelText: function getEdgeLabelText() {
          if (!_this.fromValid) {
            return '';
          }

          // get angle in (0,360] degree range
          var angle = toPositiveDegrees(_this.edgeToAngle(_this.fromEdge.b, _this.fromEdge.a, true));
          var text = angle.toFixed(1) + "°";

          return text;
        },
        labelStyle: {
          backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.Black } }] };





    this.fromEdgePicker = new TwoPointPicker(viewer, coordPicker, screenOverlay, edgePickerOptions);

    this.fromEdgePicker.addEventListener(TwoPointPicker.Events.POINT_SELECTED, function () {return _this.onEdgeSelected(_this.fromEdgePicker);});
    this.fromEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingStartAngleEdge;});
    this.fromEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingStartAngleEdge;});
    this.fromEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);
    this.fromEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);

    edgePickerOptions = {
      draggable: true,
      labels: ['To'],
      labelStyles: [labelStyleBlue],
      icons: [Autodesk.Edit3D.PointMarker.Icons.Cross, Autodesk.Edit3D.PointMarker.Icons.Empty],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Red, Autodesk.Edit3D.NPointPicker.Colors.Red],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Arrow,
        color: Autodesk.Edit3D.NPointPicker.Colors.Red,
        getEdgeLabelText: function getEdgeLabelText() {
          if (!_this.toValid) {
            return '';
          }

          // get angle in (0,360] degree range
          var angle = toPositiveDegrees(_this.edgeToAngle(_this.toEdge.b, _this.toEdge.a, true));
          var text = angle.toFixed(1) + "°";

          return text;
        },
        labelStyle: {
          backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.Black } }] };





    this.toEdgePicker = new TwoPointPicker(viewer, coordPicker, screenOverlay, edgePickerOptions);
    this.toEdgePicker.addEventListener(TwoPointPicker.Events.POINT_SELECTED, function () {return _this.onEdgeSelected(_this.toEdgePicker);});
    this.toEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingEndAngleEdge;});
    this.toEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingEndAngleEdge;});
    this.toEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);
    this.toEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);

    // bind CoordPicker listeners
    this.onPointClicked = this.onPointClicked.bind(this);
    this.onPointHovered = this.onPointHovered.bind(this);
    this.coordPicker.addEventListener(CoordPicker.Events.POINT_CLICKED, this.onPointClicked);
    this.coordPicker.addEventListener(CoordPicker.Events.POINT_HOVERED, this.onPointHovered);
    this.coordPicker.addEventListener(CoordPicker.Events.ESCAPE, function () {return _this.cancelPointSelection();});

    this.updateGizmos = this.updateGizmos.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.updateGizmos);

    // If true, the next startSelect() call clears any previous state.
    this.clearOnNextStart = false;

    // Initially, all markers are hidden
    this.updateGizmos();
  }_createClass(AngleToAngle, [{ key: "dtor", value: function dtor()

    {
      this.coordPicker.removeEventListener(Autodesk.Edit3D.CoordPicker.Events.POINT_CLICKED, this.onPointClicked);
      this.coordPicker.removeEventListener(Autodesk.Edit3D.CoordPicker.Events.POINT_HOVERED, this.onPointHovered);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.updateGizmos);
    }


    //
    // --- Main Workflow -----
    //

    // Start angle-to-angle workflow
  }, { key: "start", value: function start() {

      // If the animation from a previous use is still running, skip it,
      // so that it doesn't conflict with the next rotation.
      this.skipAnim();

      // If previous workflow was finished, restart the edge-select workflow
      if (this.clearOnNextStart) {
        this.clear();
      }

      this.isActive = true;
      this.continuePointSelectionIfNeeded();
    }

    // Temporarily hide the tools, but keep editing state
  }, { key: "pause", value: function pause() {
      this.cancelPointSelection();
      this.setVisible(false);
      this.isActive = false;
      this.updateGizmos();
    }

    // Cancel angle-to-angle workflow and discard state
  }, { key: "cancel", value: function cancel() {
      this.setVisible(false);
      this.isActive = false;
      this.clear();
    }

    // Finish angle-to-angle workflow and triggers the animation.
    // Both required edges must be specified first.
  }, { key: "finish", value: function finish(model) {
      // We need to keep the state alive until animation has finished.
      // So, we have to make sure that all edits are cleared on next use.
      this.clearOnNextStart = false;

      this.updateGizmos();

      return this.apply(model);
    }

    // -----------------------
  }, { key: "startSelectCenter", value: function startSelectCenter(
    enableDrag) {

      // When selecting a new center, we clear from/to points. Otherwise it looks confusing if they keep connected during dragging.
      this.clear();
      this.isActive = true;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.centerValid ? this.center.clone() : null;

      this.viewer.toolController.activateTool(this.coordPicker.getName());
      this.mode = Modes.SelectingCenter;

      if (enableDrag) {
        this.coordPicker.setDragging(true);
      }
    } }, { key: "startCoordPicker", value: function startCoordPicker(

    selectOnPlane) {

      // If wanted, restrict selection to the selectionPlane and disable snapping.
      // TODO: Find a way how to still support reasonable snapping for this case.
      //this.coordPicker.setSelectionPlane(selectOnPlane && this.selectionPlane);
      //this.coordPicker.setSnapperEnabled(!selectOnPlane);

      this.viewer.toolController.activateTool(this.coordPicker.getName());
    } }, { key: "endCoordPicker", value: function endCoordPicker()

    {
      // Clear selection plane (if any)
      //this.coordPicker.setSelectionPlane(null);

      // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and
      //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.
      this.viewer.toolController.setIsLocked(false);
      this.viewer.toolController.deactivateTool(this.coordPicker.getName());
    } }, { key: "onDragCenterEnd", value: function onDragCenterEnd(_ref)

    {var event = _ref.event;
      if (!this.coordPicker.getDragging()) {
        return;
      }

      this.coordPicker.handleSingleClick(event, 0);
      this.coordPicker.setDragging(false);
    } }, { key: "onDragEdgeEnd", value: function onDragEdgeEnd()

    {
      if (this.useFirstPointAsCenter && this.mode === Modes.SelectingStartAngleEdge) {
        this.setCenter(this.fromEdgePicker.points[0]);
      }

      this.mode = Modes.NotSelecting;
      this.continuePointSelectionIfNeeded();
    } }, { key: "startSelectFromAngle", value: function startSelectFromAngle(

    enableDrag) {
      this.startCoordPicker(true);
      this.mode = Modes.SelectingStartAngle;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.fromValid ? this.fromEdge.b.clone() : null;
    } }, { key: "startSelectToAngle", value: function startSelectToAngle(

    enableDrag) {
      this.startCoordPicker(true);
      this.mode = Modes.SelectingEndAngle;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.toValid ? this.toEdge.b.clone() : null;
    } }, { key: "setCenter", value: function setCenter(

    center) {
      if (center) {
        this.center.copy(center);
        this.centerValid = true;

        // Adjust plane to be contain the center.
        this.selectionPlane.setFromNormalAndCoplanarPoint(this.axis, this.center);

      } else {
        this.centerValid = false;
      }
      this.updateGizmos();
    }

    // Set fromEdge that defines the start direction.
  }, { key: "setFromEdge", value: function setFromEdge(a, b) {

      this.fromValid = Boolean(a && b);

      if (this.fromValid) {
        this.fromEdge.a.copy(a);
        this.fromEdge.b.copy(b);
      }

      this.updateGizmos();
    }

    // Set toEdge that defines the end direction.
  }, { key: "setToEdge", value: function setToEdge(a, b) {
      this.toValid = Boolean(a && b);

      if (this.toValid) {
        this.toEdge.a.copy(a);
        this.toEdge.b.copy(b);
      }

      this.updateGizmos();
    }

    // Return value in in (-PI, PI] resp. (-180, 180] in degrees
  }, { key: "edgeToAngle", value: function edgeToAngle(p1, p2, convertToDegrees) {
      var dx = p1.x - p2.x;
      var dy = p1.y - p2.y;
      var angle = Math.atan2(dy, dx); // Returns values in (-PI, PI]
      return convertToDegrees ? THREE.Math.radToDeg(angle) : angle;
    } }, { key: "onPointHovered", value: function onPointHovered(

    event) {

      if (this.mode === Modes.NotSelecting || !event.point) {
        return;
      }


      switch (this.mode) {
        case Modes.SelectingCenter:{
            this.setCenter(event.point);
            this.fireEvent({ type: Events.CENTER_HOVERED, point: event.point });

            if (this.fromValid) {
              this.fireEvent({ type: Events.FROM_ANGLE_HOVERED, angle: this.edgeToAngle(this.fromEdge.b, this.center, true) });
            }

            if (this.toValid) {
              this.fireEvent({ type: Events.TO_ANGLE_HOVERED, angle: this.edgeToAngle(this.toEdge.b, this.center, true) });
            }
            break;
          }
        case Modes.SelectingStartAngle:{
            this.setFromEdge(this.center, event.point);
            this.fireEvent({ type: Events.FROM_ANGLE_HOVERED, angle: this.edgeToAngle(event.point, true) });
            break;
          }
        case Modes.SelectingEndAngle:{
            this.setToEdge(this.center, event.point);
            this.fireEvent({ type: Events.TO_ANGLE_HOVERED, angle: this.edgeToAngle(event.point, true) });
            break;
          }
        case Modes.SelectingStartAngleEdge:{
            // If we are selecting the second point of a direction edge, reflect the edge direction immediately
            if (this.fromEdgePicker.selectingIndex === 1 || this.fromValid) {
              this.setFromEdge(this.fromEdgePicker.points[0], this.fromEdgePicker.points[1]);
              this.fireEvent({
                type: Events.FROM_ANGLE_HOVERED,
                angle: this.edgeToAngle(
                this.fromEdgePicker.points[1],
                this.fromEdgePicker.points[0]) });


            }
            break;
          }
        case Modes.SelectingEndAngleEdge:{
            // Same if are selecting an edge for the to direction
            if (this.toEdgePicker.selectingIndex === 1 || this.toValid) {
              this.setToEdge(this.toEdgePicker.points[0], this.toEdgePicker.points[1]);
              this.fireEvent({
                type: Events.TO_ANGLE_HOVERED,
                angle: this.edgeToAngle(
                this.toEdgePicker.points[1],
                this.toEdgePicker.points[0]) });


            }
            break;
          }}

    } }, { key: "updateAngleGizmo", value: function updateAngleGizmo()

    {
      if (this.fromValid && this.toValid && this.centerValid) {
        // Center
        var canvasBounds = this.viewer.impl.getCanvasBoundingClientRect();
        this.angleGizmo.setCenter(tmpVec2.set(canvasBounds.width / 2, canvasBounds.height - this.angleGizmoBottomOffset));

        // From: Always pointing up
        var fromAngle = Math.PI / 2;
        this.setPointFromAngle(tmpVec2, -fromAngle, this.angleGizmoSize, this.angleGizmo.center);
        this.angleGizmo.setStart(tmpVec2);

        // To:
        var toAngle = fromAngle + this.getOffsetAngle();
        this.setPointFromAngle(tmpVec2, -toAngle, this.angleGizmoSize, this.angleGizmo.center);
        this.angleGizmo.setEnd(tmpVec2);
      } else {
        this.angleGizmo.setCenter(null);
        this.angleGizmo.setStart(null);
        this.angleGizmo.setEnd(null);
      }

      this.angleGizmo.update();
    } }, { key: "updateGizmos", value: function updateGizmos()

    {

      // TODO: Remove fromPointOnPlane & toPointOnPlane if they are not needed anymore.

      // Compute projections of fromPoint/toPoint on selection plane
      // this.fromPointOnPlane = this.selectionPlane.projectPoint(this.fromPoint, this.fromPointOnPlane);
      // this.toPointOnPlane   = this.selectionPlane.projectPoint(this.toPoint, this.toPointOnPlane);

      // Selected edges are only shown during the edge-selection workflow.
      var showEdgePicker = this.visible && this.isActive;

      this.fromEdgePicker.setVisible(showEdgePicker && this.fromValid);
      this.toEdgePicker.setVisible(showEdgePicker && this.toValid);

      this.fromEdgePicker.updateGizmos();
      this.toEdgePicker.updateGizmos();

      // Angle gizmo keeps visible during the animation as well.
      var showAngleGizmo = this.visible && (this.fromValid || this.toValid) && (this.isActive || this.isAnimationActive());

      if (!showAngleGizmo) {
        // Fade-out gizmo if not needed
        this.angleGizmo.fadeTo(0.0);
        this.angleGizmo.setLabelEnabled(false);
        this.angleGizmo.update();
      } else {
        this.angleGizmo.fadeTo(1.0);
        this.angleGizmo.setLabelEnabled(true);

        // If we start selecting a from/toPoint, show the gizmo immediately.
        // For this case, the fading looks rather confusing than helpful.
        if (this.mode !== Modes.NotSelecting) {
          this.angleGizmo.skipFade();
        }

        this.updateAngleGizmo();
      }

      // TODO: Remove fromConnector & toConnector if they are not needed anymore.

      // Update connector gizmos
      // this.fromConnector.setLine(this.fromPoint, this.fromPointOnPlane);
      // this.toConnector.setLine(this.toPoint, this.toPointOnPlane);

      // Update connector gizmo visibility
      // this.screenOverlay.setGizmoVisible(this.fromConnector, this.visible && this.mode === Modes.SelectingStartAngle);
      // this.screenOverlay.setGizmoVisible(this.toConnector,   this.visible && this.mode === Modes.SelectingEndAngle);

      this.screenOverlay.update();
    } }, { key: "onPointClicked", value: function onPointClicked(_ref2)

    {var point = _ref2.point;var pickAnother = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.mode === Modes.NotSelecting) {
        return;
      }

      // These modes are handled separately in the onEdgeSelected() event handler 
      if (this.mode === Modes.SelectingStartAngleEdge || this.mode == Modes.SelectingEndAngleEdge) {
        return;
      }

      // In case not point was selected, try restoring point backup.
      point = point || this.pointBackup;

      // Clear point backup
      this.pointBackup = null;

      // remember mode before we reset it
      var mode = this.mode;

      // Finish interaction
      this.mode = Modes.NotSelecting;

      this.endCoordPicker();

      if (point) {
        // Set pivot to selected point, so that we can orbit around it
        this.viewer.impl.camera.pivot.copy(point);
        this.viewer.impl.camera.dirty = true;
      }

      var angleInDegrees = point ? this.edgeToAngle(point, this.center, true) : null;

      // Fire events at the very end, so that AngleToAngle is in final state when the events are evaluated.
      switch (mode) {
        case Modes.SelectingCenter:
          this.setCenter(point);
          this.fireEvent({ type: Events.CENTER_SELECTED, point: point });
          break;
        case Modes.SelectingStartAngle:
          this.setFromEdge(this.center, point);
          this.fireEvent({ type: Events.FROM_ANGLE_SELECTED, angle: angleInDegrees });
          break;
        case Modes.SelectingEndAngle:
          this.setToEdge(this.center, point);
          this.fireEvent({ type: Events.TO_ANGLE_SELECTED, angle: angleInDegrees });
          break;
        case Modes.SelectingStartAngleEdge:
        case Modes.SelectingEndAngleEdge:
          break; // this case is handled in onEdgeSelected 
        default:console.error('Unexpeced mode');}


      if (pickAnother) {
        this.continuePointSelectionIfNeeded();
      }
    } }, { key: "cancelPointSelection", value: function cancelPointSelection()

    {
      this.onPointClicked({}, false);

      // If the process was canceled during picking of the second point of an edge, mark it as not valid,
      // so when the process will be continued it will start from that point.
      if (this.mode === Modes.SelectingStartAngleEdge) {
        this.fromValid = false;
      } else if (this.mode === Modes.SelectingEndAngleEdge) {
        this.toValid = false;
      }

      this.fromEdgePicker.cancelPointSelection();
      this.toEdgePicker.cancelPointSelection();
    } }, { key: "continuePointSelectionIfNeeded", value: function continuePointSelectionIfNeeded()

    {var _this2 = this;
      if (!this.isPickerActive()) {
        return;
      }

      // Make sure the tool is visible.
      this.setVisible(true);

      // For simplicity, wait for the next frame before continue picking another point.
      // This is needed so the click event won't populate from the first pick to the second pick immediately after it starts.
      setTimeout(function () {
        if (!_this2.centerValid && !_this2.useFirstPointAsCenter) {
          _this2.startSelectCenter();
        } else if (!_this2.fromValid) {
          if (_this2.defaultPickingMode === PickingModes.Edge) {
            _this2.startSelectFromAngleEdge();
          } else if (_this2.defaultPickingMode === PickingModes.SinglePoint) {
            _this2.startSelectFromAngle();
          }
        } else if (!_this2.toValid) {
          if (_this2.defaultPickingMode === PickingModes.Edge) {
            _this2.startSelectToAngleEdge();
          } else if (_this2.defaultPickingMode === PickingModes.SinglePoint) {
            _this2.startSelectToAngle();
          }
        }
      }, 1);
    } }, { key: "getOffsetAngle", value: function getOffsetAngle()

    {

      // If all points are specified, compute offset from from/to directions
      var fromToValid = this.fromValid && this.toValid;
      if (fromToValid) {

        var fromAngle = this.edgeToAngle(this.fromEdge.b, this.fromEdge.a);
        var toAngle = this.edgeToAngle(this.toEdge.b, this.toEdge.a);
        return toAngle - fromAngle;
      }

      // Alternatvely, the offset angle can be specified numerically.
      return this.offset;
    }

    // Setup rotation matrix to rotate around this.axis centered at this.center.
    //  @param {number}  angle  - in radians
    //  @param {Vector3} center
  }, { key: "createRotation", value: function createRotation(angle, target, center) {
      var centerToOrigin = tmpMatrix1.makeTranslation(-center.x, -center.y, -center.z);
      var originToCenter = tmpMatrix2.makeTranslation(center.x, center.y, center.z);

      var quat = tmpQuat.setFromAxisAngle(this.axis, angle);
      var rot = tmpMatrix3.makeRotationFromQuaternion(quat);

      return target.copy(originToCenter).multiply(rot).multiply(centerToOrigin);
    } }, { key: "clear", value: function clear()

    {

      this.clearOnNextStart = false;

      // reset state
      this.fromValid = false;
      this.toValid = false;
      this.centerValid = false;
      this.fromEdgePicker.clear();
      this.toEdgePicker.clear();
      this.isActive = false;

      this.updateGizmos();
    }

    // Rotates the given model, so that "from" angle is rotated to "to" angle
  }, { key: "apply", value: function apply(model) {var _this3 = this;
      return new Promise(function (resolve) {
        // If possible, use fromPoint/toPoint. In this case, we also show the PointMarkers.
        // Otherwise, we only use the model of an offset value is specified directly.
        var offsetAngle = _this3.getOffsetAngle();

        // Force offsetAngle to (-Pi, Pi] range. 
        // This makes sure that the animation takes the shortest path
        // to interpolate the angles.
        offsetAngle = Autodesk.Extensions.CompGeom.normalizeAngle(offsetAngle); // result is in [0,2Pi) range
        if (offsetAngle > Math.PI) {
          // Map values > Pi to negative angles.
          // The effect is to flip the direction to clockwise.
          offsetAngle -= 2 * Math.PI;
        }

        // Backup model matrix in "before" state.
        var modelMatrix = model.getPlacementTransform();
        var startMatrix = modelMatrix.clone();

        // Reused during animation
        var matrix = new Autodesk.Viewing.Private.LmvMatrix4(true);

        // Note: this.center is in viewer coords, i.e. with subtracted globalOffset.
        // If we modify the placementMatrix, we must use the center in world-coords, i.e. without subtracted globalOffset
        var globalOffset = model.getGlobalOffset();
        var centerWorld = globalOffset ? _this3.center.clone().add(globalOffset) : _this3.center;

        // blend between start/end position
        var onTimer = function onTimer(unitTime) {

          var t = THREE.Math.smootherstep(unitTime, 0.0, 1.0);

          // interpolate angle
          var angle = t * offsetAngle;

          // create rotation matrix
          matrix = _this3.createRotation(angle, matrix, _this3.center);

          // let 'from' arrow follow the animation
          var fromAngle = Math.PI / 2;
          _this3.setPointFromAngle(tmpVec2, -(fromAngle + angle), _this3.angleGizmoSize, _this3.angleGizmo.center);
          _this3.angleGizmo.setStart(tmpVec2);
          _this3.angleGizmo.update();

          // fade-out angle gizmo shortly before end of the animation
          if (unitTime > _this3.fadeOutAngleGizmoAfter) {
            _this3.angleGizmo.fadeTo(0.0);
          }

          // Note: this.center is in viewer coords, i.e. with subtracted globalOffset.
          // If we modify the placementMatrix, we must use the center in world-coords, i.e. without subtracted globalOffset
          matrix = _this3.createRotation(angle, matrix, centerWorld).multiply(startMatrix);

          // apply this rotation to the model placement
          _this3.viewer.impl.setPlacementTransform(model, matrix);
        };

        _this3.fromEdgePicker.markers[0].setDraggable(false);
        _this3.fromEdgePicker.markers[1].setDraggable(false);
        _this3.toEdgePicker.markers[0].setDraggable(false);
        _this3.toEdgePicker.markers[1].setDraggable(false);

        var onEnd = function onEnd() {
          // Fade-out label
          _this3.angleGizmo.setLabelEnabled(false);

          _this3.clear();
          _this3.anim = null;

          resolve();
        };

        _this3.anim = Autodesk.Viewing.Private.fadeValue(0, 1, _this3.animTime, onTimer, onEnd);
      });
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible !== this.visible) {
        this.visible = visible;
        this.updateGizmos();
      }
    }

    // Helper function to update a given point (from/to) based on current center and an angle value indicating the direction
    // NOTE: This function needs to be generalized if we support other rotation axes than Z.
    //
    //  @param {Vector3} target
    //  @param {number}  angle    - target direction angle in radians. 0 = positive x-axis.
    //  @param {number}  distance - distance from center
    //  @param {Vector3}  center - center point
  }, { key: "setPointFromAngle", value: function setPointFromAngle(target, angle, distance, center) {
      target.set(1, 0, 0);
      Autodesk.Edit2D.Math2D.rotateAround(target, angle);
      target.multiplyScalar(distance).add(center);
    }

    // Update fromPoint to another direction. It requires that a previous fromPoint was already set to define the length.
    //  @param {number|undefined} ccw angle in radians. 0 corresponds to positive x-axis.
  }, { key: "changeFromAngle", value: function changeFromAngle(angle) {

      if (!this.fromValid) {
        return;
      }

      if (angle !== undefined) {
        // Recompute toPoint based on angle and prior length
        var dist = this.fromPointOnPlane.distanceTo(this.center);
        this.setPointFromAngle(this.fromEdge.b, angle, dist, this.center);
      } else {
        // Setting an undefined angle just invalidates the fromPoint
        this.fromValid = false;
      }

      this.updateGizmos();
    }

    // Update toPoint to another direction. It requires that a previous toPoint was already set to define the length.
    //  @param {number|undefined} ccw angle in radians. 0 corresponds to positive x-axis.
  }, { key: "changeToAngle", value: function changeToAngle(angle) {

      if (!this.toValid) {
        return;
      }

      if (angle !== undefined) {
        // Recompute toPoint based on angle and prior length
        var dist = this.toPointOnPlane.distanceTo(this.center);
        this.setPointFromAngle(this.toEdge.b, angle, dist, this.center);
      } else {
        // Setting an undefined angle just invalidates the toPoint
        this.toValid = false;
      }

      this.updateGizmos();
    }

    // Update offset according to a specific angle (Used when typing an offset in the panel)
    // Enables to set all of the points according to a single angle.
  }, { key: "changeOffset", value: function changeOffset(angle) {
      if (!this.centerValid) {
        return;
      }

      // If we are in the middle of point selection, cancel it until the operation is finished.
      this.cancelPointSelection();

      // If From point is not set, set it as zero.
      if (!this.fromValid) {
        this.startSelectFromAngle();
        this.fromValid = true;
        this.changeFromAngle(0);
        this.onPointClicked({ point: this.fromEdge.b });
      }

      // If To point is not set, set it as From point + given angle.
      if (!this.toValid) {
        this.startSelectToAngle();
        this.toValid = true;
        this.changeToAngle(this.edgeToAngle(this.fromEdge.b, this.fromEdge.a) + angle);
        this.onPointClicked({ point: this.toEdge.b });
      }

      this.continuePointSelectionIfNeeded();
    }

    // Start selecting an edge whose direction we use for aligning fromAngle.
  }, { key: "startSelectFromAngleEdge", value: function startSelectFromAngleEdge() {
      this.mode = Modes.SelectingStartAngleEdge;
      this.fromEdgePicker.startSelect();
    }

    // Start selecting an edge whose direction we use for aligning toAngle
  }, { key: "startSelectToAngleEdge", value: function startSelectToAngleEdge() {
      this.mode = Modes.SelectingEndAngleEdge;
      this.toEdgePicker.startSelect();
    }

    // TODO: Remove this function if it's not needed anymore

    // // Helper function to update a given point (from/to)
    // // in a way that the vector (center->to) is the projection
    // // of (a->b) to the selection plane.
    // setPointFromEdge(target, a, b) {

    //     // Do nothing if (a,b) are nearly the same. Otherwise, we don't get any direction information and instead
    //     // would just set target to the same position as center. 
    //     if (a.distanceTo(b) < 1.e-5) {
    //         return;
    //     }

    //     // We are only interested in the edge direction, not its length. So we preserve the original one
    //     const length = target.distanceTo(this.center);

    //     target.copy(b).sub(a)                   // vector (a->b)
    //         .normalize().multiplyScalar(length) // ...rescaled to length
    //         .add(this.center);
    //     this.selectionPlane.projectPoint(target, tmpVec);
    // }
  }, { key: "onEdgeSelected", value: function onEdgeSelected(
    edgePicker) {
      var selectingFrom = this.mode === Modes.SelectingStartAngleEdge;
      var selectingTo = this.mode === Modes.SelectingEndAngleEdge;
      if (!selectingFrom && !selectingTo) {
        return;
      }

      var a = edgePicker.points[0];
      var b = edgePicker.points[1];

      if (selectingFrom) {
        if (this.useFirstPointAsCenter) {
          this.setCenter(a);
        }

        this.setFromEdge(a, b);
      } else {
        this.setToEdge(a, b);
      }

      this.updateGizmos();

      // Fire event to signal that angle has changed
      if (selectingFrom) {
        var angle = this.edgeToAngle(b, a, true);
        this.fireEvent({ type: Events.FROM_ANGLE_SELECTED, angle: angle });
      } else {
        var _angle = this.edgeToAngle(b, a, true);
        this.fireEvent({ type: Events.TO_ANGLE_SELECTED, angle: _angle });
      }

      // Finish interaction and remove gizmos from edgePicker
      if (edgePicker.areAllPointsSet()) {
        this.mode = Modes.NotSelecting;
        this.continuePointSelectionIfNeeded();
      }
    } }, { key: "isPickerActive", value: function isPickerActive()

    {
      return this.isActive;
    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {
      this.anim && this.anim.skip();
    } }, { key: "isAnimationActive", value: function isAnimationActive()

    {
      return this.anim && this.anim.isRunning;
    } }]);return AngleToAngle;}();


AngleToAngle.Events = Events;
AngleToAngle.Modes = Modes;
AngleToAngle.PickingModes = PickingModes;

/***/ }),

/***/ "./extensions/ModelAlignment/FourPointsAlignment.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignment/FourPointsAlignment.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FourPointsAlignment; });
/* harmony import */ var _TransformCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransformCommon */ "./extensions/ModelAlignment/TransformCommon.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var Events = {
  SOURCE_POINT_SELECTION_STARTED: 'sourcePointSelectionStarted',
  DEST_POINT_SELECTION_STARTED: 'destPointSelectionStarted' };


var firstFromIndex = 0;
var secondFromIndex = 1;
var firstToIndex = 2;
var secondToIndex = 3;

// Pick two points on the source model, and two point on the target model, and align accordingly.
var FourPointsAlignment = /*#__PURE__*/function (_Autodesk$Edit3D$NPoi) {_inherits(FourPointsAlignment, _Autodesk$Edit3D$NPoi);var _super = _createSuper(FourPointsAlignment);

  function FourPointsAlignment(viewer, coordPicker, screenOverlay) {var _this;_classCallCheck(this, FourPointsAlignment);
    var commonLabelStyle = {
      width: '34px',
      height: '34px',
      padding: '7px',
      boxSizing: 'border-box',
      borderRadius: '20px',
      border: '1px solid',
      backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.White };


    var labelStyleBlue = Object.assign({}, commonLabelStyle, {
      borderColor: Autodesk.Edit3D.NPointPicker.Colors.Blue,
      color: Autodesk.Edit3D.NPointPicker.Colors.Blue });


    var labelStyleRed = Object.assign({}, commonLabelStyle, {
      borderColor: Autodesk.Edit3D.NPointPicker.Colors.Red,
      color: Autodesk.Edit3D.NPointPicker.Colors.Red });


    var options = {
      draggable: true,
      colors: [
      Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Red,
      Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Red],

      icons: [
      Autodesk.Edit3D.PointMarker.Icons.Circle, Autodesk.Edit3D.PointMarker.Icons.Circle,
      Autodesk.Edit3D.PointMarker.Icons.Circle, Autodesk.Edit3D.PointMarker.Icons.Circle],

      labels: ['1', '2', '1', '2'],
      labelStyles: [labelStyleBlue, labelStyleRed, labelStyleBlue, labelStyleRed],
      connections: [
      {
        fromIndex: 0,
        toIndex: 2,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Blue },

      {
        fromIndex: 1,
        toIndex: 3,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Red }] };




    _this = _super.call(this, viewer, coordPicker, screenOverlay, 4, options);

    _this.tmpVec = new THREE.Vector3();

    _this.addEventListener(Autodesk.Edit3D.NPointPicker.Events.POINT_SELECTION_STARTED, function (_ref) {var index = _ref.index;
      if (index === firstFromIndex && !_this.pointValid[firstFromIndex]) {
        _this.fireEvent({ type: Events.SOURCE_POINT_SELECTION_STARTED });
      } else if (index === firstToIndex && !_this.pointValid[firstToIndex]) {
        _this.fireEvent({ type: Events.DEST_POINT_SELECTION_STARTED });
      }
    });return _this;
  }_createClass(FourPointsAlignment, [{ key: "apply", value: function apply(

    model, offset) {var _this2 = this;
      if (this.anim) {
        return;
      }

      // Backup current state in case restorePreviousTransform will be called later.
      var alignmentBackup = {
        transform: model.getPlacementTransform().clone(),
        model: model,
        s0: this.points[0].clone(),
        s1: this.points[1].clone(),
        t0: this.points[2].clone(),
        t1: this.points[3].clone() };


      var originalMatrix = model.getPlacementTransform().clone();

      var s0 = this.points[0].clone();
      var s1 = this.points[1].clone();
      var t0 = this.points[2].clone();
      var t1 = this.points[3].clone();

      if (offset) {
        t0.add(offset);
        t1.add(offset);
      }

      this.anim = Object(_TransformCommon__WEBPACK_IMPORTED_MODULE_0__["animateEdgeToEdge"])(s0, s1, t0, t1,
      {
        onChange: function onChange(matrix) {
          // Transform source marker points
          _this2.setPoint(0, _this2.tmpVec.copy(s0).applyMatrix4(matrix));
          _this2.setPoint(1, _this2.tmpVec.copy(s1).applyMatrix4(matrix));

          // Transform model
          _this2.viewer.impl.setPlacementTransform(model, matrix.multiply(originalMatrix));
        },
        onEnd: function onEnd() {
          _this2.alignmentBackup = alignmentBackup;
          _this2.anim = null;
          _this2.clear();
        } });


    } }, { key: "restorePreviousTransform", value: function restorePreviousTransform(

    restoreSelection) {var _this3 = this;
      if (!this.alignmentBackup) {
        return;
      }

      if (this.anim) {
        return;
      }var _this$alignmentBackup =

      this.alignmentBackup,transform = _this$alignmentBackup.transform,model = _this$alignmentBackup.model,s0 = _this$alignmentBackup.s0,s1 = _this$alignmentBackup.s1,t0 = _this$alignmentBackup.t0,t1 = _this$alignmentBackup.t1;

      this.anim = Object(_TransformCommon__WEBPACK_IMPORTED_MODULE_0__["animateMatrixToMatrix"])(model.getPlacementTransform().clone(), transform,
      {
        onChange: function onChange(matrix) {
          _this3.viewer.impl.setPlacementTransform(model, matrix);
        },
        onEnd: function onEnd() {
          if (restoreSelection) {
            _this3.setPoint(0, s0);
            _this3.setPoint(1, s1);
            _this3.setPoint(2, t0);
            _this3.setPoint(3, t1);

            _this3.lastSelectedPoint = 3;


            _this3.anim = null;
            _this3.clearAlignmentBackup();

            // Make picker active
            _this3.startSelect();

            _this3.fireEvent({ type: Autodesk.Edit3D.NPointPicker.Events.POINT_SELECTED, point: t0, index: 3 });
          } else {
            _this3.anim = null;
            _this3.clearAlignmentBackup();
          }
        } });


    } }, { key: "hasAlignmentBackup", value: function hasAlignmentBackup()

    {
      return !!this.alignmentBackup;
    } }, { key: "clearAlignmentBackup", value: function clearAlignmentBackup()

    {
      this.alignmentBackup = null;
    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {var _this$anim;
      (_this$anim = this.anim) === null || _this$anim === void 0 ? void 0 : _this$anim.skip();
    } }, { key: "isSelectingSourcePointsDone", value: function isSelectingSourcePointsDone()

    {
      // Verify that the first or second points are not being dragged now.
      if (this.selectingIndex === firstFromIndex || this.selectingIndex === secondFromIndex) {
        return false;
      }

      return this.pointValid[firstFromIndex] && this.pointValid[secondFromIndex];
    } }, { key: "isAnimationActive", value: function isAnimationActive()

    {var _this$anim2;
      return (_this$anim2 = this.anim) === null || _this$anim2 === void 0 ? void 0 : _this$anim2.isRunning;
    } }]);return FourPointsAlignment;}(Autodesk.Edit3D.NPointPicker);


FourPointsAlignment.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignment.css":
/*!******************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignment.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./ModelAlignment.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignment.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignment.js":
/*!*****************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignment.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentExtension; });
/* harmony import */ var _ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignmentBase.js */ "./extensions/ModelAlignment/ModelAlignmentBase.js");
/* harmony import */ var _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelAlignmentPanel.js */ "./extensions/ModelAlignment/ModelAlignmentPanel.js");
/* harmony import */ var _PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PointToPoint.js */ "./extensions/ModelAlignment/PointToPoint.js");
/* harmony import */ var _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AngleToAngle.js */ "./extensions/ModelAlignment/AngleToAngle.js");
/* harmony import */ var _ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ModelSelector.js */ "./extensions/ModelAlignment/ModelSelector.js");
/* harmony import */ var _ModelAlignmentLocales__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ModelAlignmentLocales */ "./extensions/ModelAlignment/ModelAlignmentLocales.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);} /** 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * ModelAlignment extension provides tools to edit/fix spatially alignment of multiple models in an aggregated view.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @example
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *   viewer.loadExtension('Autodesk.ModelAlignment')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @memberof Autodesk.Viewing.Extensions
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @alias Autodesk.Viewing.Extensions.ModelAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */








var extensionName = "Autodesk.ModelAlignment";
var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

var namespace = AutodeskNamespace("Autodesk.ModelAlignment");

// set color for all dbIds that are associated with shapes. Note that some dbIds may appear more
// than once, but this is not a problem here.
var setModelThemingColor = function setModelThemingColor(model, color) {
  // Note: Calling setThemingColor with the rootId and recursive=true would mostly work as well, but
  //       would fail if the instance tree is not loaded yet.
  if (model.isLeaflet()) {
    model.setThemingColor(null, color); // dbId is irrelevant for leaflet. The whole model is colored.
    return;
  }

  var dbIds = model.myData.fragments.fragId2dbId;
  for (var i = 0; i < dbIds.length; i++) {
    var dbId = dbIds[i];
    if (Array.isArray(dbId)) {// Can be an array for 2D
      for (var j = 0; j < dbId.length; j++) {
        model.setThemingColor(dbId[j], color);
      }
    } else {
      model.setThemingColor(dbId, color);
    }
  }
};

// Degrees to radians with support for undefined angles
var toRadians = function toRadians(angle) {
  return angle !== undefined ? THREE.Math.degToRad(angle) : undefined;
};

var ToolModes = {
  Default: "Default", // TransformTool is shown (if a model is selected)
  Animating: "Animating", // Animation is playing.
  SelectModel: "SelectModel",
  PointToPoint: "PointToPoint",
  AngleToAngle: "AngleToAngle" };var


ModelAlignmentExtension = /*#__PURE__*/function (_ModelAlignmentBase) {_inherits(ModelAlignmentExtension, _ModelAlignmentBase);var _super = _createSuper(ModelAlignmentExtension);

  // @param {Object} [options]
  // @param {function()} onSaveButton - Triggered if "Save" button is pressed.
  function ModelAlignmentExtension(viewer, options) {var _this;_classCallCheck(this, ModelAlignmentExtension);
    _this = _super.call(this, viewer, options);

    _this.name = extensionName;

    // bind handlers in ctor to ensure that it only happens once
    _this.onPlacementChanged = _this.onPlacementChanged.bind(_assertThisInitialized(_this));
    _this.onSaveButton = _this.onSaveButton.bind(_assertThisInitialized(_this));
    _this.onTabChanged = _this.onTabChanged.bind(_assertThisInitialized(_this));
    _this.onStateChanged = _this.onStateChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(ModelAlignmentExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extendLocalization(_ModelAlignmentLocales__WEBPACK_IMPORTED_MODULE_5__["locales"]);_context.next = 3;return _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "load", this).call(this);case 3:



                this.panel = new _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.viewer, 'ModelAlignmentPanel', 'Model Alignment');

                // This ensures that the Panel keeps visible within the viewer canvas on resize.
                this.viewer.addPanel && this.viewer.addPanel(this.panel);

                // Make sure that panel always displays the correct matrix
                this.viewer.addEventListener(av.MODEL_PLACEMENT_CHANGED_EVENT, this.onPlacementChanged);

                // bind it so that we can use it for event listeners
                this.onModelPanelSelect = this.onModelPanelSelect.bind(this);
                this.pointToPoint = new _PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.viewer, this.coordPicker, this.screenOverlay);
                this.angleToAngle = new _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.viewer, this.coordPicker, this.screenOverlay);

                this.modelSelector = new _ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.viewer);
                this.viewer.toolController.registerTool(this.modelSelector);

                // Synchronize with ModelsPanel (if any).
                this.connectModelsPanel();

                this.connectPointToPoint();
                this.connectAngleToAngle();
                this.connectModelSelector();
                this.connectModelMoveTool();

                // Connect user-defined behavior for save-button
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.SAVE_BUTTON_PRESSED, this.onSaveButton);

                // Mark model as modified if transform was modified in the panel
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.MODEL_TRANSFORM_EDITED, function () {
                  _this2.modified();
                  _this2.onTabChanged(); // Close other tools if they were open during the modification in the panel.
                });

                // Make sure that we only show the gizmos of the tool for the current tab
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TAB_CHANGED, this.onTabChanged);

                // Color applied to selected models in selection mode
                this.selectionColor = new THREE.Vector4(1, 1, 0, 0.25);case 20:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "unload", this).call(this);

      // Remove Panel from GuiViewer if we added it on load.
      this.viewer.removePanel && this.viewer.removePanel(this.panel);

      this.panel.uninitialize();
      this.panel = null;

      this.viewer.removeEventListener(av.MODEL_PLACEMENT_CHANGED_EVENT, this.onPlacementChanged);

      // Stop watching extension loads
      if (this.onExtensionLoaded) {
        this.viewer.removeEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, this.onExtensionLoaded);
      }

      if (this.pointToPoint) {
        this.pointToPoint.dtor();
        this.pointToPoint = null;
      }

      if (this.angleToAngle) {
        this.angleToAngle = null;
      }

      this.disconnectModelsPanel();
    }

    /// ---------------------------------------------------------------------------------------------------------------
    /// Main API: 
    ///     This section contains all entry points to connect the core functionality of ModeAlignment with your own UI.
    /// ---------------------------------------------------------------------------------------------------------------
  }, { key: "getToolMode", value: function getToolMode()
    {

      if (this.isAnimationActive()) {
        return ToolModes.Animating;
      }

      if (this.isAngleToAngleActive()) {
        return ToolModes.AngleToAngle;
      }

      if (this.isPointToPointActive()) {
        return ToolModes.PointToPoint;
      }

      if (this.isModelSelectorActive()) {
        return ToolModes.SelectModel;
      }

      return ToolModes.Default;
    }

    // Start angle-to-angle workflow: Tool will show up and lets you select the first point.
  }, { key: "startAngleToAngle", value: function startAngleToAngle() {
      if (this.isAngleToAngleActive()) {
        return;
      }

      // Start tool and stop previous ones
      this.stopTools(true);
      this.angleToAngle.start();
      this.onStateChanged();
    } }, { key: "pauseAngleToAngle", value: function pauseAngleToAngle()

    {
      this.angleToAngle.pause();
      this.onStateChanged();
    } }, { key: "cancelAngleToAngle", value: function cancelAngleToAngle()

    {
      this.angleToAngle.cancel();
      this.onStateChanged();
    }

    // Checks if AngleToAngle workflow is currently active.
    //
    // Note: After calling finishAngleToAngle, it changes immediately to false, i.e., it
    //       will already return false while the animation is running.
  }, { key: "isAngleToAngleActive", value: function isAngleToAngleActive() {
      return this.angleToAngle.isActive;
    }

    // Run the rotation animation after from/to edge have been specified. After the animation,
    // AngleToAngle is cleared and hidden.
  }, { key: "finishAngleToAngle", value: function finishAngleToAngle() {var _this3 = this;
      // Note: We don't clear here, because the state of AngleToAngle is still needed as long the animation
      // is playing. Instead, angleToAngle clears itself if we start using it.
      this.angleToAngle.finish(this.model).then(function () {
        _this3.modified();
        _this3.onStateChanged();
      });

      this.onStateChanged();
    } }, { key: "startPointToPoint", value: function startPointToPoint()

    {
      if (this.isPointToPointActive()) {
        return;
      }

      // Start tool and stop previous ones
      this.stopTools(true);
      this.pointToPoint.start();
      this.onStateChanged();
    } }, { key: "pausePointToPoint", value: function pausePointToPoint()

    {
      this.pointToPoint.pause();
      this.onStateChanged();
    } }, { key: "cancelPointToPoint", value: function cancelPointToPoint()

    {
      this.pointToPoint.cancel();
      this.onStateChanged();
    } }, { key: "isPointToPointActive", value: function isPointToPointActive()

    {
      return this.pointToPoint.isActive;
    } }, { key: "finishPointToPoint", value: function finishPointToPoint()

    {var _this4 = this;
      this.pointToPoint.finish(this.model).then(function () {
        _this4.modified();
        _this4.onStateChanged();
      });

      this.onStateChanged();
    } }, { key: "startModelSelector", value: function startModelSelector()

    {
      if (this.isModelSelectorActive()) {
        return;
      }

      // Start tool and stop previous ones
      this.stopTools(true);
      this.viewer.toolController.activateTool(this.modelSelector.getName());
      this.onStateChanged();
    } }, { key: "isModelSelectorActive", value: function isModelSelectorActive()

    {
      return this.modelSelector.active;
    } }, { key: "stopModelSelector", value: function stopModelSelector()

    {
      if (this.isModelSelectorActive()) {
        // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and
        //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.
        this.viewer.toolController.setIsLocked(false);
        this.viewer.toolController.deactivateTool(this.modelSelector.getName()); // model-select finished
      }
    } }, { key: "startFreeTransform", value: function startFreeTransform()

    {
      if (this.isFreeTransformActive()) {
        return;
      }

      // Start tool and stop previous ones
      this.stopTools(true);
      this.setTransformToolActive(true);
      this.onStateChanged();
    } }, { key: "pauseFreeTransform", value: function pauseFreeTransform()

    {
      this.setTransformToolActive(false);
    } }, { key: "isFreeTransformActive", value: function isFreeTransformActive()

    {
      var modelTransformToolName = this.modelTransformTool.getName();
      var isActive = this.viewer.toolController.isToolActivated(modelTransformToolName);
      return isActive;
    }

    // Call when leaving the transform UI. Makes sure that any active tools
    // are closed and no gizmos are left behind.
    //
    //  @param {bool} preserveState - If true, point-to-point and angle-to-angle workflows are only paused, i.e.,
    //                                the workflow is resumed after restarting.
  }, { key: "stopTools", value: function stopTools(preserveState) {

      // Point-to-Point
      if (this.isPointToPointActive()) {
        preserveState ? this.pausePointToPoint() : this.cancelPointToPoint();
      }

      // Angle-to-Angle
      if (this.isAngleToAngleActive()) {
        preserveState ? this.pauseAngleToAngle() : this.cancelAngleToAngle();
      }

      // Move-Gizmo
      if (this.isFreeTransformActive()) {
        this.pauseFreeTransform();
      }

      // Model Selector
      if (this.isModelSelectorActive()) {
        this.stopModelSelector();
      }
    }

    // set model to be aligned next
  }, { key: "setModel", value: function setModel(model) {
      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "setModel", this).call(this, model);

      this.panel.setModel(model);
      this.updateColorTheming();
      this.onTabChanged();

      // Deactivate ModelSelector if needed
      if (model) {
        this.stopModelSelector();
      }
    } }, { key: "isAnimationActive", value: function isAnimationActive()

    {
      return this.pointToPoint.isAnimationActive() || this.angleToAngle.isAnimationActive();
    }

    // Reset should be enabled only when:
    // - Model selected
    // - Changes were made to the model transform during this session OR model was loaded with a custom transform
  }, { key: "isResetEnabled", value: function isResetEnabled() {
      if (!this.model) {
        return false;
      }

      // Disable if reset already pending.
      if (this.isPendingReset(this.model)) {
        return false;
      }

      // If any other edit is pending, enable reset.
      if (this.hasPendingChanges(this.model)) {
        return true;
      }

      // No pending changes: Only enable reset if there was a saved transform before.
      return this.hasSavedTransform(this.model);
    }

    // Reset alignment for currently selected model, so that the model is using the original refPointTransform
    // from its source file.
    // I.e., for the selected model, we
    //  - Revert any previously saved alignment
    //  - Revert any alignment edits in current session
  }, { key: "resetToOriginalFileTransform", value: function resetToOriginalFileTransform() {
      if (!this.isResetEnabled()) {
        return false;
      }

      var originalFileTransform = this.getOriginalFileTransform(this.model);

      this.viewer.impl.setPlacementTransform(this.model, originalFileTransform);

      this.modified(true);

      return true;
    }

    // Returns a list of models that are currently selectable for alignment.
  }, { key: "getSelectableModels", value: function getSelectableModels() {
      return this.panel.getSelectableModels();
    }

    // --------------------------------------------------
    // ------------------ Main API End ------------------
    // --------------------------------------------------

    // Triggered when the state of the tools have changed. E.g.,
    //  - after selecting a model
    //  - Point-to-Point or Angle-to-Angle workflow was started or stopped
    //  - An animation has started or stopped
  }, { key: "onStateChanged", value: function onStateChanged() {
      // Determine whether to show transform gizmo
      this.updateTransformTool();
      this.fireEvent({ type: Autodesk.ModelAlignment.Events.STATE_CHANGED });
    } }, { key: "setTransformToolActive", value: function setTransformToolActive(

    active) {
      var isActive = this.isFreeTransformActive();

      if (isActive == active) {
        return;
      }

      var modelTransformToolName = this.modelTransformTool.getName();

      if (active) {
        this.viewer.toolController.activateTool(modelTransformToolName);
      } else {
        this.viewer.toolController.deactivateTool(modelTransformToolName);
      }
    }

    // Show/Hide transform gizmo if a model is selected and no other tool or animation is active
  }, { key: "updateTransformTool", value: function updateTransformTool() {
      var mode = this.getToolMode();
      var showTransformTool = this.model && mode === ToolModes.Default;
      this.setTransformToolActive(showTransformTool);
    } }, { key: "onTabChanged", value: function onTabChanged()

    {
      var selectedTabId = this.panel.selectedTabId;

      this.onStateChanged();

      // PointToPoint
      if (selectedTabId === _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].TabIds.PointToPoint) {
        this.startPointToPoint();
      } else {
        this.cancelPointToPoint();
      }

      // AngleToAngle
      if (selectedTabId === _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].TabIds.AngleToAngle) {
        this.startAngleToAngle();
      } else {
        this.cancelAngleToAngle();
      }
    } }, { key: "connectModelsPanel", value: function connectModelsPanel()

    {var _this5 = this;
      var ext = this.viewer.getExtension('Autodesk.ModelsPanel');

      // If not loaded, try again if ModelsPanel is loaded later
      if (!ext) {
        this.onExtensionLoaded = function (event) {return event.extensionId === 'Autodesk.ModelsPanel' && _this5.connectModelsPanel();};
        this.viewer.addEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, this.onExtensionLoaded);
        return;
      }

      this.modelsPanel = ext.panel;
      this.modelsPanel.addEventListener(Autodesk.Viewing.UI.ListPanelEvents.ITEM_SELECT, this.onModelPanelSelect);
      this.modelsPanel.setModelSelectionModeEnabled(true);
    } }, { key: "disconnectModelsPanel", value: function disconnectModelsPanel()

    {
      if (this.modelsPanel) {
        this.modelsPanel.removeEventListener(
        Autodesk.Viewing.UI.ListPanelEvents.ITEM_SELECT,
        this.onModelPanelSelect);


        // Todo: This assumes exclusive control on the ModelsPanel selection behavior.
        this.modelsPanel.setModelSelectionModeEnabled(false);
      }
    }

    // If a model is selected in ModelsPanel, synchronize transform panel and models tool
  }, { key: "onModelPanelSelect", value: function onModelPanelSelect(event) {
      this.setModel(event.item.model);
    }

    // Connects PointToPoint workflow with Alignment panel
  }, { key: "connectPointToPoint", value: function connectPointToPoint() {var _this6 = this;

      // Update from/to point indicators when they are changed in the panel
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_POINT_CHANGED, function (event) {return _this6.pointToPoint.setFrom(event.fromPoint);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_POINT_CHANGED, function (event) {return _this6.pointToPoint.setTo(event.toPoint);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.OFFSET_CHANGED, function (event) {return _this6.pointToPoint.setOffset(event.offset);});

      // Trigger tool to select from/to-point when pressing the corresponding button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_POINT_BUTTON_PRESSED, function () {return _this6.pointToPoint.startSelectFrom();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_POINT_BUTTON_PRESSED, function () {return _this6.pointToPoint.startSelectTo();});

      // connect apply button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.APPLY_PTP_PRESSED, function () {
        _this6.pointToPoint.apply(_this6.panel.model);
        _this6.modified();
      });

      // connect fitToView button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FIT_TO_VIEW_BUTTON_PRESSED, function () {
        _this6.pointToPoint.fitModelToView(_this6.panel.model);
        _this6.modified();
      });

      // After picking a from/to point, fill in the values to the panel
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.FROM_POINT_SELECTED, function (event) {return _this6.panel.onFromSelected(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.FROM_POINT_HOVERED, function (event) {return _this6.panel.onFromHovered(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.TO_POINT_HOVERED, function (event) {return _this6.panel.onToHovered(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.TO_POINT_SELECTED, function (event) {return _this6.panel.onToSelected(event.point);});
    }

    // Connects AngleToAngle workflow with Alignment panel
  }, { key: "connectAngleToAngle", value: function connectAngleToAngle() {var _this7 = this;

      // synchronize model selection
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.MODEL_SELECTED, function () {return _this7.setModel(_this7.panel.model);});

      // Update from/to point indicators when they are changed in the panel
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.CENTER_CHANGED, function (event) {return _this7.angleToAngle.setCenter(event.center);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_ANGLE_CHANGED, function (event) {return _this7.angleToAngle.changeFromAngle(toRadians(event.angle));});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_ANGLE_CHANGED, function (event) {return _this7.angleToAngle.changeToAngle(toRadians(event.angle));});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.OFFSET_ANGLE_CHANGED, function (event) {return _this7.angleToAngle.changeOffset(toRadians(event.angle));});

      // Trigger tool to select center/fromAngle/toAngle when pressing the corresponding button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.CENTER_BUTTON_PRESSED, function () {return _this7.angleToAngle.startSelectCenter();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_ANGLE_BUTTON_PRESSED, function () {return _this7.angleToAngle.startSelectFromAngle();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_ANGLE_BUTTON_PRESSED, function () {return _this7.angleToAngle.startSelectToAngle();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_EDGE_BUTTON_PRESSED, function () {return _this7.angleToAngle.startSelectFromAngleEdge();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_EDGE_BUTTON_PRESSED, function () {return _this7.angleToAngle.startSelectToAngleEdge();});

      // connect apply button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.APPLY_ATA_PRESSED, function () {
        _this7.angleToAngle.apply(_this7.panel.model);
        _this7.modified();
      });

      // After picking a from/to point, fill in the values to the panel
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.CENTER_HOVERED, function (event) {return _this7.panel.onCenterHovered(event.point);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.CENTER_SELECTED, function (event) {return _this7.panel.onCenterSelected(event.point);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.FROM_ANGLE_HOVERED, function (event) {return _this7.panel.onFromAngleHovered(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.FROM_ANGLE_SELECTED, function (event) {return _this7.panel.onFromAngleSelected(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.TO_ANGLE_HOVERED, function (event) {return _this7.panel.onToAngleHovered(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.TO_ANGLE_SELECTED, function (event) {return _this7.panel.onToAngleSelected(event.angle);});
    } }, { key: "connectModelMoveTool", value: function connectModelMoveTool()

    {var _this8 = this;
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.EDIT_POSITION_PRESSED, function () {return _this8.viewer.toolController.activateTool(_this8.modelTransformTool.getName());});
    }

    // Connect modelSelectorTool with UI
  }, { key: "connectModelSelector", value: function connectModelSelector() {var _this9 = this;
      // Trigger Model-select when pressing the button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.SELECT_MODEL_PRESSED, function (event) {
        _this9.startModelSelector();
      });

      // After selecting a model, apply it to panel and placement tool
      this.modelSelector.addEventListener(_ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.MODEL_SELECTED, function (event) {

        // Just unselecting a model is not really helpful.
        // If a model was selected before but you clicked to void, we interpret this as 
        // "Okay, get rid of the selector and keep the same model selected".
        if (!event.model && _this9.model) {
          _this9.stopModelSelector();
          return;
        }

        _this9.setModel(event.model);
      });
    }

    // Mark selected model by color theming
  }, { key: "updateColorTheming", value: function updateColorTheming() {

      // We may have multiple views of the same model file. Since alignment can only be saved per model file,
      // placement is synced for all views of the same model. Therefore, we highlight all views of the selected urn.
      var selectedUrn = this.model && this.model.myData.urn;
      var isSelected = function isSelected(model) {return selectedUrn && model.myData.urn === selectedUrn;};

      // Make sure no other theming is leaked.
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        var model = models[i];

        // Color theming is not supported for leaflets
        if (model.isLeaflet()) {
          continue;
        }

        if (isSelected(model)) {
          // colorize selected model
          setModelThemingColor(model, this.selectionColor);
        } else {
          this.viewer.clearThemingColors(model);
        }
      }

      this.viewer.impl.invalidate(true);
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      // Make sure that any in-progress animation is skipped before we start saving.
      this.pointToPoint.skipAnim();
      this.angleToAngle.skipAnim();

      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "onSaveButton", this).call(this);
    }

    // Triggered if placementTransform was changed for a model.
  }, { key: "onPlacementChanged", value: function onPlacementChanged(event) {

      // Note that syncAlignments() may cause nested placementChanged events of other models.
      // So, it's important to only handle changes of the selected model here.
      if (event.model !== this.model) {
        return;
      }

      this.panel.updateMatrix();

      // If selected model was edited, make sure that other views of the same model file follow.
      this.syncAlignments();
    }

    // Sync placement for multiple views of the same urn:
    // If the viewer contains multiple views of the same urn, editing one of them moves all others with it.
  }, { key: "syncAlignments", value: function syncAlignments() {

      // Stop if no 3D model is selected
      if (!this.model || this.model.is2d()) {
        return;
      }
      var selectedUrn = this.model.myData.urn;
      var placementTf = this.model.getPlacementTransform();

      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        // Check if model is another view of the same modelUrn.
        var model = models[i];
        var urn = model.myData.urn;
        var needsSync = urn == selectedUrn && model !== this.model;

        // Note that syncing does only make sense for 3D views
        if (model.is3d() && needsSync) {
          this.viewer.impl.setPlacementTransform(model, placementTf);
        }
      }
    } }]);return ModelAlignmentExtension;}(_ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


ModelAlignmentExtension.ToolModes = ToolModes;

namespace.ModelAlignment = ModelAlignmentExtension;
namespace.ModelAlignmentPanel = _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.AngleToAngle = _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"];

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, ModelAlignmentExtension);

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentBase.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentBase.js ***!
  \*********************************************************/
/*! exports provided: default, AlignmentChange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignmentChange", function() { return AlignmentChange; });
/* harmony import */ var _ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelTransformTool.js */ "./extensions/ModelAlignment/ModelTransformTool.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

// Used in order to create a unique id for each screenOverlay per extension.
var screenOverlayId = 0;

var namespace = AutodeskNamespace("Autodesk.ModelAlignment");

var SnapperName = "Snapper_ModelAlignment";

var Events = {
  MODEL_SELECTED: "modelSelected",
  STATE_CHANGED: "stateChanged" };


// Note: applyClientScaling and revertClientScaling are only relevant if a client used unitScaling via loadOptions.applyScaling.
//       Otherwise, they have no effect.

// Returns a matrix that corresponds to
//  1. Applying the input matrix first
//  2. Then, apply the scaling
var appendScaling = function appendScaling(matrix, scalingFactor) {

  // If no scaling is needed, just return the input matrix
  if (!matrix || !scalingFactor) {
    return matrix;
  }

  // Compose combined transform (remember that apply-transform is opposite to matrix-multiply order)
  return new avp.LmvMatrix4(true).
  makeScale(scalingFactor, scalingFactor, scalingFactor) // 2. Then, apply scaling
  .multiply(matrix); // 1. Apply input transform first.
};

// If the client uses loadOptions.applyScaling, a scaling is applied to the model at load time. This combines the given matrix with the same scaling.
// Input is usually a refPointTransform. This function converts it to the corresponding placementTransform including unitScaling.
var applyClientScaling = function applyClientScaling(matrix, model) {
  return appendScaling(matrix, model.myData.scalingFactor);
};

// PlacementTransforms cannot be saved 1:1 to alignment service, because they might contain a unitScaling if the client used loadOptions.applyScaling.
// This function reverts this scaling, so that the resulting matrix works in model coordinates and does not depend on client-specific choice of unitScaling anymore.
var revertClientScaling = function revertClientScaling(matrix, model) {
  return appendScaling(matrix, 1.0 / model.myData.scalingFactor);
};

// Helper function: Returns the viewablePartId parameter needed for alignmentService API.
var getViewablePartId = function getViewablePartId(model) {
  var docNode = model.getDocumentNode();
  var urn = docNode.getRootNode().urn();
  return model.is2d() ? av.toUrlSafeBase64(docNode.name()) : undefined;
};var

ModelAlignmentBase = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentBase, _av$Extension);var _super = _createSuper(ModelAlignmentBase);

  function ModelAlignmentBase(viewer, options) {var _this;_classCallCheck(this, ModelAlignmentBase);
    _this = _super.call(this, viewer, options);

    // Should be overwritten by the extending class.
    _this.name = 'ModelAlignmentBase';

    _this.onModelTransformChanged = _this.onTransformChanged.bind(_assertThisInitialized(_this));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));return _this;
  }_createClass(ModelAlignmentBase, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (





                  this.viewer.loadExtension('Autodesk.Section'));case 2:_context.next = 4;return (

                  this.viewer.loadExtension('Autodesk.Snapping'));case 4:_context.next = 6;return (


                  this.viewer.loadExtension('Autodesk.Edit2D'));case 6:_context.next = 8;return (

                  this.viewer.loadExtension('Autodesk.Edit3D'));case 8:

                this.initTransformTool();

                // init snapper
                this.snapper = this.viewer.toolController.getTool(SnapperName);

                if (!this.snapper) {
                  this.snapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(this.viewer, {
                    renderSnappedTopology: true,
                    toolName: SnapperName });


                  this.viewer.toolController.registerTool(this.snapper);
                }

                // Init coordinate picker tool
                this.coordPicker = this.viewer.toolController.getTool(Autodesk.Edit3D.CoordPicker.Name);

                if (!this.coordPicker) {
                  this.coordPicker = new Autodesk.Edit3D.CoordPicker(this.viewer, this.snapper);
                  this.viewer.toolController.registerTool(this.coordPicker);
                }

                // Create layer for temporary 2D vector overlays
                this.screenOverlay = new Autodesk.Edit2D.ScreenOverlay(this.viewer, "Autodesk.ModelAlignment.ScreenOverlay_".concat(screenOverlayId++));

                // Model whose alignment we are currently editing
                this.model = null;

                // Dictionary of AlignmentChanges indexed by alignmentItemKey 
                this.pendingChanges = {};

                // Local representation of the state that saved in the service.
                // Gets updated when saving to the service, and when selecting a model for the first time.
                this.syncedState = {};

                // Map used for caching the lock status for each model
                this.alignmentLockMap = {};case 18:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "initTransformTool", value: function initTransformTool()


    {var _this2 = this;
      // create & register
      this.modelTransformTool = new _ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, this.name);
      this.viewer.toolController.registerTool(this.modelTransformTool);

      // Mark model as edited when using the tool
      this.modelTransformTool.addEventListener(_ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.MODEL_MOVED_EVENT, function () {
        _this2.modified();
      });

      // Make sure that panel always displays the correct matrix
      this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);
    } }, { key: "destroyTransformTool", value: function destroyTransformTool()

    {
      // Disconnect and remove transform tool
      if (this.modelTransformTool) {var _this$modelTransformT;
        // Disconnect from toolController & viewer
        this.viewer.toolController.deregisterTool(this.modelTransformTool);
        this.viewer.removeEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);

        (_this$modelTransformT = this.modelTransformTool) === null || _this$modelTransformT === void 0 ? void 0 : _this$modelTransformT.dtor();
        this.modelTransformTool = null;
      }
    } }, { key: "unload", value: function unload()

    {

      this.destroyTransformTool();
      this.model = null;

      // Drop any pending changes
      this.pendingChanges = {};

      this.syncedState = {};

      this.alignmentLockMap = {};
    }

    // An alignmentService must be set to manage loading/saving of transforms.
  }, { key: "setAlignmentService", value: function setAlignmentService(service) {
      this.options.alignmentService = service;
    } }, { key: "onTransformChanged", value: function onTransformChanged()

    {
      this.modelTransformTool.initGizmo();
    }

    // set model to be aligned next
  }, { key: "setModel", value: function setModel(model) {var _this$modelTransformT2;
      if (this.model === model) {
        return;
      }

      this.model = model;
      (_this$modelTransformT2 = this.modelTransformTool) === null || _this$modelTransformT2 === void 0 ? void 0 : _this$modelTransformT2.setModel(model);

      if (model) {
        var key = this.getAlignmentItemKey(model);

        // Updating the syncedState at this step guarantees that we get the matrix as it is currently arrived from the service.
        if (!this.syncedState[key]) {
          this.syncedState[key] = {
            matrix: this.model.getPlacementTransform().clone() };

        }
      }

      this.fireEvent({ type: Events.MODEL_SELECTED });
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      this.options.onSaveButton && this.options.onSaveButton();
    }

    // Save & clear all pending changes. Requires an alignment service.
  }, { key: "saveChanges", value: function saveChanges() {

      if (!this.options.alignmentService) {
        console.error('AlignmentService must be set for saving transforms');
      }

      // Used below to do unit scaling from viewer world-units to model units
      var toModelUnits = new THREE.Matrix4();

      for (var key in this.pendingChanges) {var _this$options$alignme;
        var item = this.pendingChanges[key];
        if (!item) {
          continue;
        }

        var model = item.model;
        var matrix = item.resetPlacement ? null : model.getPlacementTransform().clone();

        // Notice that the actual synced matrix may be different due to scalingFactor usage, but we
        // save it here with scaling anyway, so it will be easier to compare later.
        this.syncedState[key].matrix = matrix;

        var docNode = model.getDocumentNode();

        // The urn, used as the key, has to match _applyAlignmentService in AggregatedView
        var urn = docNode.getRootNode().urn();
        var viewablePartId = getViewablePartId(model);

        // The matrix we save must work in model units and must be independent on which unitScaling the client is using in the loadOptions.
        // So, if the client applied any unitScaling, we have to revert it first.
        matrix = revertClientScaling(matrix, model);

        (_this$options$alignme = this.options.alignmentService) === null || _this$options$alignme === void 0 ? void 0 : _this$options$alignme.saveTransform(urn, viewablePartId, undefined, matrix);
      }

      // Reset pending changes
      this.pendingChanges = {};
    } }, { key: "isAlignmentLocked",

    // Whether a model is locked for alignment
    //  @param {AlignmentService} alignmentService
    //  @param {Model} model
    value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(alignmentService, model) {var key, docNode, urn, viewableName;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                key = this.getAlignmentItemKey(model);

                // Result already cached - use it.
                if (!this.alignmentLockMap[key]) {_context2.next = 3;break;}return _context2.abrupt("return",
                this.alignmentLockMap[key]);case 3:


                docNode = model.getDocumentNode();
                urn = docNode.getRootNode().urn();
                viewableName = model.is2d() ? av.toUrlSafeBase64(docNode.name()) : undefined;_context2.next = 8;return (

                  alignmentService.isAlignmentLocked(urn, viewableName));case 8:this.alignmentLockMap[key] = _context2.sent;return _context2.abrupt("return",

                this.alignmentLockMap[key]);case 10:case "end":return _context2.stop();}}}, _callee2, this);}));function isAlignmentLocked(_x, _x2) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()


    // Unique string for items for which alignment can be saved separately.
    // Mostly, the alignmentKey will be unique per model. Only exception is if two
    // models are 3D views of the same urn, because the alignment is the same for all 3D views
    // of a model file.
  }, { key: "getAlignmentItemKey", value: function getAlignmentItemKey(model) {

      var urn = model.myData.urn;

      // Only 2D views get separate IDs. 3D are all aligned together.
      var docNode = model.getDocumentNode();
      var viewPostfix = model.is2d() && docNode ? docNode.guid() : '';

      return urn + viewPostfix;
    }

    // Called whenever the user modified the transform of the current model.
    // Needed to track pending changes until we save.
  }, { key: "modified", value: function modified() {var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this.model) {

        var key = this.getAlignmentItemKey(this.model);

        // If the model has no saved transform, reset just discards pending changes
        if (reset && !this.hasSavedTransform(this.model)) {
          delete this.pendingChanges[key];
          return;
        }

        this.pendingChanges[key] = new AlignmentChange(this.model, reset);
      }
    }

    // Return the placementTransform that we would get without any alignment transform.
    //
    // We assume here that applyRefPoint was initially enabled, and was only disabled when loading the customPlacementTransform.
    // For this reason, when reset the model transform, we reset it to refPointTransform.
    // If we find out later that this assumption is wrong for some other apps that are using this API, we can add another "applyRefPointBackup" flag in aggregatedView inside _applyAlignmentService()
  }, { key: "getOriginalFileTransform", value: function getOriginalFileTransform(model) {

      // matrix may be undefined
      var matrix = model.myData.refPointTransform || new avp.LmvMatrix4(true);

      // apply client unitScaling (depends on loadOptions.applyScaling settings used by the client)
      matrix = applyClientScaling(matrix, model);

      return matrix;
    }

    // Compares current transform with original file transform.
    // Original file transform === The transform of the model before loading any custom transform into it.
  }, { key: "isModelTransformDifferentThanOriginalFileTransform", value: function isModelTransformDifferentThanOriginalFileTransform(model) {
      var matrix = model.getPlacementTransform();
      var originalFileTransform = this.getOriginalFileTransform(model);

      return !matrix.equals(originalFileTransform);
    }

    // Compares last synced transform with a given matrix.
    // If there is no previous saved transform, compare with original model's transform.
  }, { key: "isMatrixDifferentThanLastSyncedMatrix", value: function isMatrixDifferentThanLastSyncedMatrix(matrix, model) {
      if (!matrix || !model) {
        return false;
      }

      var key = this.getAlignmentItemKey(model);
      var syncedStateTrasform = this.syncedState[key].matrix || this.getOriginalFileTransform(model);

      return !matrix.equals(syncedStateTrasform);
    }

    // Returns true if a model already have a saved alignment transform.
    // Note:
    //  - alignment service must be set
    //  - We assume that the model was already loaded using the alignment service, so that the last saved transform is in memory.
  }, { key: "hasSavedTransform", value: function hasSavedTransform(model) {

      // get alignment service
      var as = this.options.alignmentService;
      if (!as) {
        console.error('Alignment service must be set first');
        return false;
      }

      // get last saved alignment transform
      var urn = model.getDocumentNode().getRootNode().urn();
      var viewablePartId = getViewablePartId(model);
      var tf = as.getTransform(urn, viewablePartId);

      // Transform state should already be in cache
      if (tf === undefined) {
        console.error('Alignment service transform state should already be known.');
      }

      return tf !== null;
    } }, { key: "hasPendingChanges", value: function hasPendingChanges(

    model) {
      // Checkes for a specific model.
      if (model) {
        var key = this.getAlignmentItemKey(model);
        return !!this.pendingChanges[key];
      }

      // Checks if there are any pending changes.
      return Boolean(Object.keys(this.pendingChanges).length);
    } }, { key: "isPendingReset", value: function isPendingReset(

    model) {var _this3 = this;
      // Checkes for a specific model.
      if (model) {var _this$pendingChanges$;
        var key = this.getAlignmentItemKey(model);
        return (_this$pendingChanges$ = this.pendingChanges[key]) === null || _this$pendingChanges$ === void 0 ? void 0 : _this$pendingChanges$.resetPlacement;
      }

      // Checks if there are any pending changes.
      return Boolean(Object.keys(this.pendingChanges).some(function (key) {var _this3$pendingChanges;return (_this3$pendingChanges = _this3.pendingChanges[key]) === null || _this3$pendingChanges === void 0 ? void 0 : _this3$pendingChanges.resetPlacement;}));
    } }]);return ModelAlignmentBase;}(av.Extension);


// Encodes alignment change of a single model
var AlignmentChange =

function AlignmentChange(model, resetPlacement) {_classCallCheck(this, AlignmentChange);

  // The model that was realigned
  this.model = model;

  // False: Matrix was edited and needs to be saved
  // True:  Placement was reset to original source-file transform
  this.resetPlacement = resetPlacement;
};


namespace.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentLocales.js":
/*!************************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentLocales.js ***!
  \************************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-modelAlignment.loc.json */ "./res/locales/en/nobundle-modelAlignment.loc.json");
var _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-modelAlignment.loc.json */ "./res/locales/en/nobundle-modelAlignment.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentPanel.css":
/*!***********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentPanel.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./ModelAlignmentPanel.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentPanel.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentPanel.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentPanel; });
/* harmony import */ var _ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignmentPanel.css */ "./extensions/ModelAlignment/ModelAlignmentPanel.css");
/* harmony import */ var _ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ModelSelector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelSelector.js */ "./extensions/ModelAlignment/ModelSelector.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // IMPORTANT!!


var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

var Events = {
  MODEL_TRANSFORM_EDITED: 'transformEdited',
  SELECT_MODEL_PRESSED: 'selectModelPressed',
  EDIT_POSITION_PRESSED: 'editPositionPressed',
  TAB_CHANGED: 'tabChanged', // Fired when tab is changed. Params: { tabId: string }
  VECTOR_INPUT_VALUE_CHANGED: 'vectorInputValueChanged',
  MODEL_SELECTED: 'modelSelected',

  SAVE_BUTTON_PRESSED: 'saveButtonPressed',

  // Position
  FIT_TO_VIEW_BUTTON_PRESSED: 'fitToViewButtonPressed',

  // Point-to-Point
  FROM_POINT_BUTTON_PRESSED: 'fromPointButtonPressed',
  TO_POINT_BUTTON_PRESSED: 'toPointButtonPressed',
  APPLY_PTP_PRESSED: 'applyPointToPointPressed',
  FROM_POINT_CHANGED: 'fromPointChanged', // Indicates that fromPoint was changed by panel editing. Params: { fromPoint: Vec3 }. May be undefined if entries are invalid. 
  TO_POINT_CHANGED: 'toPointChanged', // Indicates that toPoint was changed by modifying toPoint or offset in the panel. Params: { toPoint: Vec3 }
  OFFSET_CHANGED: 'offsetChanged', // Offset value was edited.

  // Angle-to-Angle
  CENTER_BUTTON_PRESSED: 'centerButtonPressed',
  FROM_ANGLE_BUTTON_PRESSED: 'fromAngleButtonPressed',
  TO_ANGLE_BUTTON_PRESSED: 'toAngleButtonPressed',
  APPLY_ATA_PRESSED: 'applyAngleToAnglePressed',
  CENTER_CHANGED: 'centerChanged',
  OFFSET_ANGLE_CHANGED: 'offsetAngleChanged', // Params: {angle: number|undefined}. Angle may be undefined if input is empty.
  FROM_ANGLE_CHANGED: 'fromAngleChanged', //
  TO_ANGLE_CHANGED: 'toAngleChanged', //
  FROM_EDGE_BUTTON_PRESSED: 'fromEdgeButtonPressed',
  TO_EDGE_BUTTON_PRESSED: 'toEdgeButtonPressed' };


var addHeaderBar = function addHeaderBar(parent) {
  var header = document.createElement('div');
  parent.appendChild(header);

  header.style.height = '55px';
  header.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';
  header.style.display = 'flex';
  header.style.flexDirection = 'row';
  header.style.padding = '10px';
  header.style.width = '100%';
  header.style.boxSizing = 'border-box'; // body including padding should span to 100%
  header.style.alignItems = 'center'; // vertical center
  header.style.marginTop = '15px';

  return header;
};

var addHeader = function addHeader(parent, text, button, id, button2) {

  // A bar containing text and (optionally) button
  var header = addHeaderBar(parent);

  if (id) {
    header.id = id;
  }

  // add text
  var textDiv = document.createElement('div');
  textDiv.textContent = text;
  textDiv.style.flexGrow = '90';
  textDiv.style.fontWeight = 'bold';

  header.appendChild(textDiv);

  // If no button is wanted, we are done
  if (!button) {
    return header;
  }

  var configureButtonStyle = function configureButtonStyle(button) {
    var bStyle = button.container.style;
    bStyle.backgroundColor = 'rgb(80,80,80)';
    bStyle.flexGrow = '10';
    bStyle.height = '15px';
    bStyle.width = 'auto'; // overwrite the fixed pixel-width enforced by adsk button style
    bStyle.textAlign = 'center';
    bStyle.fontSize = '12px';
  };

  // configure button and add it to header 
  configureButtonStyle(button);
  header.appendChild(button.container);

  if (!button2) {
    return header;
  }

  // configure and add button2
  configureButtonStyle(button2);
  header.appendChild(button2.container);

  return header;
};

var addEntry = function addEntry(parent, name) {

  var entry = document.createElement('div');
  parent.appendChild(entry);

  // add label
  var nameDiv = document.createElement('div');
  nameDiv.textContent = name;
  nameDiv.fontSize = '10px';
  entry.appendChild(nameDiv);

  // add input field
  var inputDiv = document.createElement('input');
  inputDiv.type = 'text';
  entry.appendChild(inputDiv);

  // TODO: auto-stretch to panel width.
  inputDiv.style.width = '80px';

  // return input element for external access
  return inputDiv;
};

// Verifys if the input value is a valid numeric prefix.
// Valid examples: 1, -13, 0, 0.1, .1, ., -, -., -1.112
var isNumericPrefix = function isNumericPrefix(value) {
  return !!value.match(/^-?\d*\.?\d*$/);
};var

ValueInput = /*#__PURE__*/function () {

  function ValueInput(parent, onInput) {var _this = this;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;_classCallCheck(this, ValueInput);
    av.EventDispatcher.prototype.apply(this);

    this.container = document.createElement('div');
    this.container.style.display = 'flex';
    this.container.style.flexDirection = 'row';
    this.container.style.padding = '0px 10px 30px 10px';
    this.container.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';

    parent.appendChild(this.container);

    // add input field
    this.input = document.createElement('input');
    this.input.type = 'text';
    this.input.style.width = '100px';

    this.container.appendChild(this.input);

    this.updateInput = true;

    if (onInput) {
      this.handleInput = function () {
        _this.updateInput = false;
        onInput();
        _this.updateInput = true;
      };

      this.input.addEventListener("input", this.handleInput);
    }

    this.input.addEventListener("blur", this.onBlur.bind(this));

    this.digits = digits;
  }_createClass(ValueInput, [{ key: "validate", value: function validate(

    val) {
      return val.toFixed(this.digits);
    } }, { key: "setValue", value: function setValue(

    value) {
      if (value == undefined || value === null) {
        this.clear();
        return;
      }

      var trimmedValue = parseFloat(value).toFixed(this.digits);

      if (isNaN(trimmedValue)) {
        return;
      }

      if (this.updateInput) {
        this.input.value = trimmedValue;
      }

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "setRawValue", value: function setRawValue(

    value) {
      if (isNumericPrefix(value)) {
        this.input.value = value;
      }
    } }, { key: "getValue", value: function getValue()

    {
      return this.valid() ? parseFloat(this.input.value) : undefined;
    } }, { key: "onBlur", value: function onBlur()

    {
      this.setValue(this.input.value);
    } }, { key: "clear", value: function clear()

    {
      this.input.value = '';

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "valid", value: function valid()

    {
      return isFinite(parseFloat(this.input.value));
    } }]);return ValueInput;}();


// Helper class to combine 3 table rows with entries for x,y,z of a vector
var VectorInput = /*#__PURE__*/function () {

  function VectorInput(parent, onInput) {var _this2 = this;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;_classCallCheck(this, VectorInput);
    av.EventDispatcher.prototype.apply(this);

    this.container = document.createElement('div');
    this.container.style.display = 'flex';
    this.container.style.flexDirection = 'row';
    this.container.style.padding = '0px 10px 30px 10px';
    this.container.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';

    parent.appendChild(this.container);

    this.x = addEntry(this.container, 'X');
    this.y = addEntry(this.container, 'Y');
    this.z = addEntry(this.container, 'Z');

    this.digits = digits;

    this._value = new THREE.Vector3();

    this.updateInput = true;

    // register event handlers
    if (onInput) {
      this.handleInput = function () {
        _this2.updateInput = false;
        onInput();
        _this2.updateInput = true;
      };

      this.x.addEventListener("input", this.handleInput);
      this.y.addEventListener("input", this.handleInput);
      this.z.addEventListener("input", this.handleInput);
    }

    this.x.addEventListener("blur", this.onBlur.bind(this));
    this.y.addEventListener("blur", this.onBlur.bind(this));
    this.z.addEventListener("blur", this.onBlur.bind(this));

    // If true, we interpret empty inputs as 0.0 and consider them as valid
    this.enableEmpty = false;
  }_createClass(VectorInput, [{ key: "validate", value: function validate(

    val) {
      return val.toFixed(this.digits);
    } }, { key: "parseValue", value: function parseValue(

    str) {
      // If wanted, return 0.0 for empty fields
      if (this.enableEmpty && !str.length) {
        return 0.0;
      }
      return parseFloat(str);
    }

    // Returns true if all 3 components have values
  }, { key: "valid", value: function valid() {
      return this.enableEmpty || this.x.value.length && this.y.value.length && this.z.value.length;
    } }, { key: "getValue", value: function getValue()

    {
      var x = this.parseValue(this.x.value);
      var y = this.parseValue(this.y.value);
      var z = this.parseValue(this.z.value);
      this._value.set(x, y, z);
      return this._value;
    } }, { key: "isZero", value: function isZero()

    {
      var val = this.getValue();
      return val.x == 0 && val.y == 0 && val.z == 0;
    } }, { key: "setValue", value: function setValue(

    vec) {
      if (!vec) {
        this.clear();
        return;
      }

      var xValidated = this.validate(vec.x);
      var yValidated = this.validate(vec.y);
      var zValidated = this.validate(vec.z);

      if (isNaN(xValidated) || isNaN(yValidated) || isNaN(zValidated)) {
        return;
      }

      this._value.copy(vec);

      if (this.updateInput) {
        this.x.value = xValidated;
        this.y.value = yValidated;
        this.z.value = zValidated;
      }

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "setRawValue", value: function setRawValue(

    strVec) {
      if (
      isNumericPrefix(strVec.x) &&
      isNumericPrefix(strVec.y) &&
      isNumericPrefix(strVec.z))
      {
        this.x.value = strVec.x;
        this.y.value = strVec.y;
        this.z.value = strVec.z;
      }
    } }, { key: "onBlur", value: function onBlur()

    {
      this.setValue(this._value);
    } }, { key: "clear", value: function clear()

    {
      this.x.value = '';
      this.y.value = '';
      this.z.value = '';

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }]);return VectorInput;}();


var addButton = function addButton(parent, id, name) {

  var button = new Autodesk.Viewing.UI.Button(id);
  parent.appendChild(button.container);

  button.container.textContent = name;
  button.container.style.textAlign = 'center';

  // center button in column
  button.container.style.left = '50%';
  button.container.style.transform = 'translateX(-50%)';

  // adjust button size to text extents
  button.container.style.width = 'auto';
  button.container.style.height = 'auto';

  button.container.style.backgroundColor = 'rgb(80,80,80)';

  return button;
};


// Simple glow-highlight effect
// TODO: Use css class to avoid overwriting box-shadow setting on disable
var setButtonHighlight = function setButtonHighlight(button, enable) {
  button.container.style.boxShadow = enable ? '0px 0px 10px' : 'initial';
  button.highlight = enable; // Used by external UI.
};

var TabIds = {
  Transform: 'Transform',
  PointToPoint: 'Point-to-Point',
  AngleToAngle: 'Angle-to-Angle' };var


ModelAlignmentPanel = /*#__PURE__*/function (_Autodesk$Viewing$UI$) {_inherits(ModelAlignmentPanel, _Autodesk$Viewing$UI$);var _super = _createSuper(ModelAlignmentPanel);

  function ModelAlignmentPanel(viewer, id, title, options) {var _this3;_classCallCheck(this, ModelAlignmentPanel);
    _this3 = _super.call(this, viewer.container, id, title, options);

    _this3.viewer = viewer;

    av.EventDispatcher.prototype.apply(_assertThisInitialized(_this3));

    // Contains a table for each tab
    _this3.pages = [];

    // Selected Tab ID.
    _this3.selectedTabId = null;

    // Style like settings panel
    _this3.title.style.borderBottomColor = 'rgb(74, 85, 91)';

    _this3.container.classList.add('model-alignment-panel');

    // default size and position
    _this3.container.style.width = '300px';
    _this3.container.style.height = '815px';
    _this3.container.style.top = '6px';
    _this3.container.style.left = '6px';

    // Body is the part between header and footer
    _this3.body = document.createElement('div');
    _this3.body.style.backgroundColor = 'rgba(34, 34, 34, 0.9)';
    _this3.body.style.height = '100%';
    _this3.body.style.padding = '10px';

    _this3.container.appendChild(_this3.body);

    _this3.addModelSection(_this3.body);
    _this3.addTabHeaderSection(_this3.body);

    _this3.positionTab = _this3.addTab(TabIds.Transform, 'Position');
    _this3.pointToPointTab = _this3.addTab(TabIds.PointToPoint, 'Move');
    _this3.angleToAngleTab = _this3.addTab(TabIds.AngleToAngle, 'Rotate');

    _this3.initPositionTab();
    _this3.initPointToPointTab();
    _this3.initAngleToAngleTab();

    _this3.selectTab(TabIds.Transform);

    // Number of digits for numeric values
    // TODO: This should be synchronized with Measure settings
    _this3.digits = 2;return _this3;
  }

  // Restrict digits of automatically set values
  _createClass(ModelAlignmentPanel, [{ key: "filterValue", value: function filterValue(val) {
      return val.toFixed(this.digits);
    } }, { key: "addModelSection", value: function addModelSection(

    parent) {var _this4 = this;
      // create tab content
      var section = document.createElement('div');
      section.id = 'ModelSection';

      // Create "Select" button for model
      this.selectModelButton = new Autodesk.Viewing.UI.Button('SelectModel');
      this.selectModelButton.container.textContent = 'Select';
      this.selectModelButton.onClick = function () {
        _this4.fireEvent({ type: Events.SELECT_MODEL_PRESSED });
        setButtonHighlight(_this4.selectModelButton, true);
      };

      addHeader(section, 'Model', this.selectModelButton);

      // Create model-select combo-box
      this.modelCombo = document.createElement('select');
      //this.modelCombo.classList.add('option-drop-down');
      this.modelCombo.classList.add('model-select-combo');
      section.appendChild(this.modelCombo);
      this.updateModelCombo();

      // Make sure that it's updated if the list of models changes
      this.updateModelCombo = this.updateModelCombo.bind(this);
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateModelCombo);
      this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.updateModelCombo);

      this.modelCombo.addEventListener('change', function () {
        var index = _this4.modelCombo.selectedIndex;
        var item = _this4.modelCombo.items[index];
        _this4.setModel(item.model);
      });

      parent.appendChild(section);
    }

    // Returns a list of models that are currently selectable for alignment.
  }, { key: "getSelectableModels", value: function getSelectableModels() {

      // There may be multiple views of the same urn. In this case, we only show an item for the first view
      // of the urn. For all other views, the placement is synced anyway.
      var urns = {};

      // Define filter that excludes models if it has the same urn as a previous item in the list
      var removeDuplicateUrns = function removeDuplicateUrns(model) {

        // Ignore preview raster for PDF
        if (model.getData().underlayRaster) {
          return false;
        }

        // Collapsing multiple 3D views into a single item is only needed for 3D views. 2D views can be aligned individually.
        if (model.is2d()) {
          return true;
        }

        // Check if we already visited another model with the same urn
        var urn = model.myData.urn;
        if (urns[urn]) {
          // Urn already known for this 3d view => skip
          return false;
        }
        // First 3d view of this versionUrn: Keep it and remember urn.
        urns[urn] = true;
        return true;
      };
      return this.viewer.getVisibleModels().filter(removeDuplicateUrns);
    }

    // Update item list in model-select combo-box
  }, { key: "updateModelCombo", value: function updateModelCombo() {var _this5 = this;
      this.modelCombo.length = 0;

      var items = [];
      items.push({ name: "Please select", model: null });

      this.getSelectableModels().forEach(function (model) {
        var modelName = model.getDocumentNode().getModelName();
        items.push({ name: modelName, model: model, urn: model.myData.urn });
      });

      items.forEach(function (item, index) {
        var option = document.createElement("option");
        option.value = index;
        option.textContent = item.name;

        option.addEventListener('mouseenter', function () {return Object(_ModelSelector_js__WEBPACK_IMPORTED_MODULE_1__["rolloverModel"])(_this5.viewer, item.model);});
        option.addEventListener('mouseleave', function () {return Object(_ModelSelector_js__WEBPACK_IMPORTED_MODULE_1__["rolloverModel"])(_this5.viewer, null);});

        _this5.modelCombo.add(option);
      });
      this.modelCombo.items = items;
    } }, { key: "initPositionTab", value: function initPositionTab()

    {var _this6 = this;

      this.positionTab.padding = '10px';

      // Create "Edit" button for model position
      this.editPositionButton = this.createEventButton('EditPositionButton', 'Edit', Events.EDIT_POSITION_PRESSED);
      this.fitToViewButton = this.createEventButton('FitToViewButton', 'Fit to View', Events.FIT_TO_VIEW_BUTTON_PRESSED, null, false);

      // add table body
      addHeader(this.positionTab, 'Position', this.editPositionButton, 'PositionHeader', this.fitToViewButton);
      this.position = new VectorInput(this.positionTab, function () {return _this6.onTransformChanged();});

      addHeader(this.positionTab, 'Rotation');
      this.rotation = new ValueInput(this.positionTab, function () {return _this6.onTransformChanged();});

      this.saveButton = this.createEventButton('SaveButton', 'Save Transforms', Events.SAVE_BUTTON_PRESSED);
      addHeader(this.body, '', this.saveButton);
    } }, { key: "initPointToPointTab", value: function initPointToPointTab()

    {var _this7 = this;

      // Create "Select" buttons for FromPoint and ToPoint
      this.selectFromButton = this.createEventButton('SelectFromButton', 'Select', Events.FROM_POINT_BUTTON_PRESSED);
      this.selectToButton = this.createEventButton('SelectToButton', 'Select', Events.TO_POINT_BUTTON_PRESSED);

      addHeader(this.pointToPointTab, 'From point', this.selectFromButton, 'FromPointHeader');
      this.fromPoint = new VectorInput(this.pointToPointTab, function () {return _this7.onFromPointChanged(true);});

      addHeader(this.pointToPointTab, 'To point', this.selectToButton, 'ToPointHeader');
      this.toPoint = new VectorInput(this.pointToPointTab, function () {return _this7.onToPointChanged(true);});

      addHeader(this.pointToPointTab, 'Offset', null, 'OffsetHeader');
      this.offset = new VectorInput(this.pointToPointTab, function () {return _this7.onOffsetChanged(true);});

      // For offset values, we allow empty entries, because we can use 0.0 by default.
      this.offset.enableEmpty = true;

      // add separator
      var separator = addHeaderBar(this.pointToPointTab);

      // Add apply button
      this.applyPointToPointButton = addButton(separator, 'ApplyP2P', 'Apply');
      this.applyPointToPointButton.onClick = function () {
        // Clear point-to-point entries after applying them
        _this7.clearPointToPoint();

        // Fire event to trigger actual operation
        _this7.fireEvent({ type: Events.APPLY_PTP_PRESSED });
      };
    } }, { key: "initAngleToAngleTab", value: function initAngleToAngleTab()

    {var _this8 = this;

      // Create "Select" buttons for FromPoint and ToPoint
      this.selectCenterButton = this.createEventButton('SelectCenterButton', 'Select', Events.CENTER_BUTTON_PRESSED, function () {return _this8.onSelectCenterButton();});
      this.selectFromAngleButton = this.createEventButton('SelectFromAngleButton', 'Direction', Events.FROM_ANGLE_BUTTON_PRESSED);
      this.selectToAngleButton = this.createEventButton('SelectToAngleButton', 'Direction', Events.TO_ANGLE_BUTTON_PRESSED);

      this.selectFromEdgeButton = this.createEventButton('SelectFromEdgeButton', 'Edge', Events.FROM_EDGE_BUTTON_PRESSED);
      this.selectToEdgeButton = this.createEventButton('SelectToEdgeButton', 'Edge', Events.TO_EDGE_BUTTON_PRESSED);


      addHeader(this.angleToAngleTab, 'Center', this.selectCenterButton, 'CenterHeader');
      this.center = new VectorInput(this.angleToAngleTab, function () {return _this8.onCenterChanged(true);});

      addHeader(this.angleToAngleTab, 'From angle', this.selectFromEdgeButton, 'FromAngleHeader', this.selectFromAngleButton);
      this.fromAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onFromAngleChanged(true);});

      addHeader(this.angleToAngleTab, 'To angle', this.selectToEdgeButton, 'ToPointHeader', this.selectToAngleButton);
      this.toAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onToAngleChanged(true);});

      addHeader(this.angleToAngleTab, 'Offset angle', null, 'OffsetHeader');
      this.offsetAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onOffsetAngleChanged(true);});

      // For offset values, we allow empty entries, because we can use 0.0 by default.
      this.offset.enableEmpty = true;

      // add separator
      var separator = addHeaderBar(this.angleToAngleTab);

      // Add apply button
      this.applyAngleToAngleButton = addButton(separator, 'ApplyA2A', 'Apply');
      this.applyAngleToAngleButton.onClick = function () {
        // Clear point-to-point entries after applying them
        _this8.clearAngleToAngle();

        // Fire event to trigger actual operation
        _this8.fireEvent({ type: Events.APPLY_ATA_PRESSED });
      };
    } }, { key: "setModel", value: function setModel(

    model) {

      this.model = model;

      // Sync modelCombo
      var items = this.modelCombo.items;
      this.modelCombo.selectedIndex = items.findIndex(function (item) {return item.model === model;});

      this.updateMatrix();

      // If model selector was running, finish it now.
      setButtonHighlight(this.selectModelButton, false);

      // Fire event - while avoiding recursive event triggers
      if (!this.blockEvents) {
        this.blockEvents = true;
        this.fireEvent({ type: Events.MODEL_SELECTED });
        this.blockEvents = false;
      }
    } }, { key: "updateMatrix", value: function updateMatrix()

    {
      if (this.model) {

        // Note about unit-scaling:
        //     If the viewer client uses a unit-scaling for the model, the viewer world coords may be different from the model units.
        //     In this case, the position offset values are in viewer world units instead of model units. This ensures that position
        //     offsets of different models are comparable.
        //
        //     However, the unit scaling must finally be reverted again before saving the transform, because the saved transform
        //     must keep independent of current unitScaling settings of the viewer client.
        //
        //     TODO: Ideally, we should consider the display units from MeasureSettings as well.

        // Initialize panel with current placementTransform. If the model was not aligned in ACC before, the
        // placemenTransform will correspond with the refPointTransform of the source file.
        // I.e., rotation will match with the true-north angle and the offset with the refPointLMV of the model.
        var matrix = this.model.getPlacementTransform();
        this.setMatrix(matrix);
      }
    } }, { key: "setPosition", value: function setPosition(

    pos) {
      this.position.setValue(pos);
    } }, { key: "setRotation", value: function setRotation(

    rotation) {
      this.rotation.setValue(rotation);
    } }, { key: "setFromPoint", value: function setFromPoint(

    from) {
      this.fromPoint.setValue(from);
      this.onFromPointChanged();
    } }, { key: "setToPoint", value: function setToPoint(

    to) {
      this.toPoint.setValue(to);
      this.onToPointChanged();
    } }, { key: "setOffset", value: function setOffset(

    offset) {
      this.offset.setValue(offset);
      this.onOffsetChanged();
    } }, { key: "setCenter", value: function setCenter(

    center) {
      this.center.setValue(center);
    } }, { key: "setFromAngle", value: function setFromAngle(

    angle) {
      this.fromAngle.setValue(angle);
      this.onFromAngleChanged();
    } }, { key: "setToAngle", value: function setToAngle(

    angle) {
      this.toAngle.setValue(angle);
      this.onToAngleChanged();

    } }, { key: "fromPointValid", value: function fromPointValid()

    {return this.fromPoint.valid();} }, { key: "toPointValid", value: function toPointValid()
    {return this.toPoint.valid();} }, { key: "offsetValid", value: function offsetValid()
    {return this.offset.valid();} }, { key: "clearPointToPoint", value: function clearPointToPoint()

    {
      this.fromPoint.clear();
      this.toPoint.clear();
      this.offset.clear();
    } }, { key: "clearAngleToAngle", value: function clearAngleToAngle()

    {
      this.center.clear();
      this.fromAngle.clear();
      this.toAngle.clear();
      this.offsetAngle.clear();
    }

    // Get Vector3 values. Note that result may be undefined if not all components are set.
  }, { key: "getPosition", value: function getPosition() {return this.position.valid() && this.position.getValue();} }, { key: "getRotation", value: function getRotation()
    {return this.rotation.valid() && this.rotation.getValue();} }, { key: "getFromPoint", value: function getFromPoint()
    {return this.fromPoint.valid() && this.fromPoint.getValue();} }, { key: "getToPoint", value: function getToPoint()
    {return this.toPoint.valid() && this.toPoint.getValue();}

    // Note: Unlike from/to, the offset is considered valid as soon as >= one component is specified
  }, { key: "getOffset", value: function getOffset() {return !this.offset.isZero() && this.offset.getValue();} }, { key: "getCenter", value: function getCenter()

    {return this.center.valid() && this.center.getValue();}

    // Recover original scaling value based on the "unedited" placementTransform, i.e., the placement that was used at load-time
  }, { key: "extractModelScale", value: function extractModelScale() {
      // If no placement was applied, scaling is (1,1,1)
      var scale = new THREE.Vector3(1, 1, 1);
      var tf = this.model.getPlacementTransform();
      if (!tf) {
        return scale;
      }

      // Decompose original transform to obtain scaling
      return scale.setFromMatrixScale(tf);
    } }, { key: "onTransformChanged", value: function onTransformChanged()

    {
      if (!this.model) {
        return;
      }

      var pos = this.getPosition();
      var zAxis = new THREE.Vector3(0, 0, 1);
      var angle = THREE.Math.degToRad(this.getRotation());
      var rot = new THREE.Quaternion().setFromAxisAngle(zAxis, angle);
      var scale = this.extractModelScale(); // Preserve original scaling

      // Do nothing if values is not fully specified
      if (!pos || !rot) {
        return;
      }

      // compose placementMatrix from panel values
      var newPlacement = new avp.LmvMatrix4(true).compose(pos, rot, scale);
      this.viewer.impl.setPlacementTransform(this.model, newPlacement);

      this.fireEvent({ type: Events.MODEL_TRANSFORM_EDITED });
    } }, { key: "onFromPointChanged", value: function onFromPointChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      // Use offset only if any 

      if (from && to) {
        // Update offset
        this.offset.setValue(to.sub(from));
      } else if (from && offset) {
        // Setting from and offset also sets the toPoint
        this.toPoint.setValue(from.add(offset));
        fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
      }

      fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
    } }, { key: "onToPointChanged", value: function onToPointChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      if (from && to) {
        // Update offset
        this.offset.setValue(to.sub(from));
        fireEvent && this.fireEvent({ type: Events.OFFSET_CHANGED, offset: this.getOffset() });
      } else if (to && offset) {
        // Setting to and offset also sets the fromPoint
        this.fromPoint.setValue(to.sub(offset));
        fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
      }
      fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
    } }, { key: "onOffsetChanged", value: function onOffsetChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      if (from && offset) {
        this.toPoint.setValue(from.add(offset));
        fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
      } else if (to && offset) {
        this.fromPoint.setValue(to.sub(offset));
        fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
      }
      fireEvent && this.fireEvent({ type: Events.OFFSET_CHANGED, offset: this.getOffset() });
    }

    // Helper functions to update one entry based on two others. The two others must be valid.
  }, { key: "updateFromAngle", value: function updateFromAngle(fireEvent) {
      var fromAngle = this.toAngle.getValue() - this.offsetAngle.getValue();
      this.fromAngle.setValue(fromAngle);
      fireEvent && this.fireEvent({ type: Events.FROM_ANGLE_CHANGED, angle: fromAngle });
    } }, { key: "updateToAngle", value: function updateToAngle(

    fireEvent) {
      var toAngle = this.fromAngle.getValue() + this.offsetAngle.getValue();
      this.toAngle.setValue(toAngle);
      fireEvent && this.fireEvent({ type: Events.TO_ANGLE_CHANGED, angle: toAngle });
    } }, { key: "updateOffsetAngle", value: function updateOffsetAngle(

    fireEvent) {
      var offsetAngle = this.toAngle.getValue() - this.fromAngle.getValue();
      this.offsetAngle.setValue(offsetAngle);
      fireEvent && this.fireEvent({ type: Events.OFFSET_ANGLE_CHANGED, angle: offsetAngle });
    } }, { key: "onCenterChanged", value: function onCenterChanged(

    fireEvent) {
      // TODO: Add additional logic here to clear / update the other angle input boxes according to the new center.

      fireEvent && this.fireEvent({ type: Events.CENTER_CHANGED, center: this.getCenter() });
    } }, { key: "onFromAngleChanged", value: function onFromAngleChanged(

    fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      // Update one value based on two others to keep from/to/center consistent.
      if (fromValid && toValid) {
        this.updateOffsetAngle(fireEvent);
      } else if (fromValid && offsetValid) {
        this.updateToAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.FROM_ANGLE_CHANGED, angle: this.fromAngle.getValue() });
    } }, { key: "onToAngleChanged", value: function onToAngleChanged(

    fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      // Update one value based on two others to keep from/to/center consistent.
      if (fromValid && toValid) {
        this.updateOffsetAngle(fireEvent);
      } else if (toValid && offsetValid) {
        this.updateFromAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.TO_ANGLE_CHANGED, angle: this.toAngle.getValue() });
    }

    // If offsetAngle changed, update fromAngle or toAngle to keep them consistent
  }, { key: "onOffsetAngleChanged", value: function onOffsetAngleChanged(fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      if (fromValid && offsetValid) {
        this.updateToAngle(fireEvent);
      } else if (toValid && offsetValid) {
        this.updateFromAngle(fireEvent);
      } else if (offsetValid && !fromValid && !toValid) {
        this.fromAngle.setValue(0);
        this.toAngle.setValue(this.offsetAngle.getValue());
        this.updateFromAngle(fireEvent);
        this.updateToAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.OFFSET_ANGLE_CHANGED, angle: this.offsetAngle.getValue() });
    } }, { key: "setMatrix", value: function setMatrix(

    matrix) {

      matrix = matrix || new THREE.Matrix4().identity();

      // decompose into pos/scale/rotation
      var pos = new THREE.Vector3();
      var rot = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      THREE.Matrix4.prototype.decompose.call(matrix, pos, rot, scale); // Note that matrix.decompose would not exist on LmvMatrix4

      // apply pos
      this.setPosition(pos);

      // Extract absolute rotation angle
      var euler = new THREE.Euler().setFromQuaternion(rot);
      var angle = THREE.Math.radToDeg(euler._z);

      // apply rotation
      this.setRotation(angle);
    } }, { key: "addTabHeaderSection", value: function addTabHeaderSection(

    parent) {
      this.tabHeaders = document.createElement("div");
      this.tabHeaders.id = 'TabHeaders';

      this.tabHeaders.style.paddingTop = '15px';
      this.tabHeaders.style.paddingLeft = '10px';
      this.tabHeaders.style.backgroundColor = 'rgb(34, 34, 34, 0.94)';
      this.tabHeaders.style.display = 'flex';
      this.tabHeaders.style.flexDirection = 'row';

      // Add 3px border in the same color - as a placeholder for the understroke of selected item
      this.tabHeaders.style.borderBottomStyle = 'solid';
      this.tabHeaders.style.borderBottomWidth = '3px';
      this.tabHeaders.style.borderColor = 'rgb(34, 34, 34, 0.94)';

      parent.appendChild(this.tabHeaders);
    } }, { key: "addTabHeader", value: function addTabHeader(

    tabId, title) {var _this9 = this;

      // add text span to title element
      var tab = document.createElement("div");
      tab.style.paddingRight = '10px';

      var span = document.createElement("span");
      span.textContent = title;

      span.classList.add('tab-header');

      tab.appendChild(span);

      tab.tabId = tabId;
      tab.text = span;

      this.tabHeaders.appendChild(tab);

      // Select this tab on click
      var select = function select() {return _this9.selectTab(tabId);};
      tab.addEventListener('click', select);
    } }, { key: "addTab", value: function addTab(

    tabId, title) {
      this.addTabHeader(tabId, title);

      // create tab content
      var page = document.createElement('div');
      page.tabId = tabId;

      this.pages.push(page);
      this.body.append(page);

      return page;
    } }, { key: "selectTab", value: function selectTab(

    selectedTabId) {
      if (this.selectedTabId === selectedTabId) {
        return;
      }

      // highlight header of selected tab
      for (var i = 0; i < this.tabHeaders.children.length; i++) {
        var tab = this.tabHeaders.children[i];
        var isSelected = tab.tabId == selectedTabId;

        if (isSelected) {
          tab.text.classList.add('selected');
        } else {
          tab.text.classList.remove('selected');
        }
      }

      // set selected page visible
      for (var _i = 0; _i < this.pages.length; _i++) {
        var page = this.pages[_i];
        var _isSelected = page.tabId === selectedTabId;
        page.style.display = _isSelected ? 'block' : 'none';
      }

      this.selectedTabId = selectedTabId;

      this.fireEvent({ type: Events.TAB_CHANGED, tabId: selectedTabId });
    }

    // Called when point-to-point tool finished
  }, { key: "onFromSelected", value: function onFromSelected(point) {
      this.setFromPoint(point);
      setButtonHighlight(this.selectFromButton, false);

      // If toPoint is not specified yet, immediately trigger toPoint selected as well.
      if (this.fromPoint.valid() && !this.toPoint.valid()) {
        setButtonHighlight(this.selectToButton, true);
        this.fireEvent({ type: Events.TO_POINT_BUTTON_PRESSED });
      }
    } }, { key: "onToSelected", value: function onToSelected(

    point) {
      this.setToPoint(point);
      setButtonHighlight(this.selectToButton, false);
    }

    // Reflect coordinates on hover
  }, { key: "onFromHovered", value: function onFromHovered(point) {
      this.setFromPoint(point);
    } }, { key: "onToHovered", value: function onToHovered(
    point) {
      this.setToPoint(point);
    }

    // Create a button that triggers an event of the given type and sets itself to highlighted when pressed.
  }, { key: "createEventButton", value: function createEventButton(id, text, eventType, onClick) {var _this10 = this;var highlightOnClick = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var button = new Autodesk.Viewing.UI.Button(id);
      button.container.textContent = text;
      button.onClick = function () {
        onClick && onClick();
        _this10.fireEvent({ type: eventType });
        highlightOnClick && setButtonHighlight(button, true);
      };
      return button;
    } }, { key: "onCenterHovered", value: function onCenterHovered(

    point) {
      this.setCenter(point);
    } }, { key: "onCenterSelected", value: function onCenterSelected(

    point) {

      this.setCenter(point);
      setButtonHighlight(this.selectCenterButton, false);

      // If fromAngle is not specified yet, immediately trigger fromAngle selection as well.
      if (this.center.valid() && !this.fromAngle.valid()) {
        setButtonHighlight(this.selectFromAngleButton, true);
      }
    } }, { key: "onFromAngleHovered", value: function onFromAngleHovered(

    angle) {
      this.setFromAngle(angle);
    } }, { key: "onFromAngleSelected", value: function onFromAngleSelected(

    angle) {
      this.setFromAngle(angle);
      setButtonHighlight(this.selectFromAngleButton, false);
      setButtonHighlight(this.selectFromEdgeButton, false);

      // If toAngle is not specified yet, immediately trigger fromAngle selection as well.
      if (this.center.valid() && this.fromAngle.valid() && !this.toAngle.valid()) {
        setButtonHighlight(this.selectToAngleButton, true);
      }
    } }, { key: "onToAngleHovered", value: function onToAngleHovered(

    angle) {
      this.setToAngle(angle);
    } }, { key: "onToAngleSelected", value: function onToAngleSelected(

    angle) {
      this.setToAngle(angle);
      setButtonHighlight(this.selectToAngleButton, false);
      setButtonHighlight(this.selectToEdgeButton, false);
    }

    // When selecting a new center, clear all previous entries
  }, { key: "onSelectCenterButton", value: function onSelectCenterButton() {
      this.clearAngleToAngle();
    } }, { key: "uninitialize", value: function uninitialize()

    {
      _get(_getPrototypeOf(ModelAlignmentPanel.prototype), "uninitialize", this).call(this);
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateModelCombo);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.updateModelCombo);
    } }]);return ModelAlignmentPanel;}(Autodesk.Viewing.UI.DockingPanel);


ModelAlignmentPanel.Events = Events;
ModelAlignmentPanel.TabIds = TabIds;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelSelector.js":
/*!****************************************************!*\
  !*** ./extensions/ModelAlignment/ModelSelector.js ***!
  \****************************************************/
/*! exports provided: rolloverModel, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rolloverModel", function() { return rolloverModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSelector; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var Events = {
  MODEL_SELECTED: 'modelSelected' // event.model contains selected model (may be null when clicking without a model under mouse)
};

var ToolName = 'ModelAlignment.ModelSelector';

// Trigger rollover highlight for all 3D views of a given (base64-encoded) versionUrn
var rollover3DViews = function rollover3DViews(viewer, urn) {

  // Filter to define which models to highlight
  var needsHighlight = function needsHighlight(m) {return m.is3d() && m.myData.urn == urn;};

  // Activate highlighting for all models that match the filter
  var modelIds = viewer.getVisibleModels().filter(needsHighlight).map(function (m) {return m.id;});
  viewer.impl.renderer().rollOverModelId(modelIds);
};

// Trigger rollover highlighting when hovering a model.
// For 3D, it means: Hover all 3D views of the same urn.
// For 2D, it means: Just hover the single sheet (because they are aligned separately)
var rolloverModel = function rolloverModel(viewer, model) {

  if (!model) {
    viewer.impl.clearHighlight();
    return;
  }

  if (model.is3d()) {
    // 3D model: Highlight all views of the same urn
    var urn = model.myData.urn;
    rollover3DViews(viewer, urn);
  } else {
    // 2D model: Hover item individually
    viewer.impl.renderer().rollOverModelId(model.id);
  }

  // rerun blend-pass to update selection highlighting
  viewer.impl.invalidate(false, false, true);
};

// Simple tool for selecting a model in canvas within an aggregated view
var ModelSelector = /*#__PURE__*/function () {

  function ModelSelector(viewer) {_classCallCheck(this, ModelSelector);
    this.viewer = viewer;

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.hoverColor = new THREE.Color(0.5, 0.5, 0.1);
  }_createClass(ModelSelector, [{ key: "getName", value: function getName()

    {
      return ToolName;
    } }, { key: "getNames", value: function getNames()

    {
      return [ToolName];
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.viewer.impl.renderer().setRollOverHighlightColor(this.hoverColor);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;

      // Make sure that we don't leak rollover-highlighting
      this.viewer.impl.clearHighlight();

      // reset to default rollOver highlight color
      this.viewer.impl.renderer().setRollOverHighlightColor();
    } }, { key: "register", value: function register()

    {}

    // Returns modelID under mouse or 0 if nothing is hit
  }, { key: "modelIdAtPixel", value: function modelIdAtPixel(canvasX, canvasY) {

      var res = [];

      // get model under mouse
      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);
      var dbId = this.viewer.impl.renderer().idAtPixel(vpVec.x, vpVec.y, res);

      // If there is only a single model, we don't get valid modelId values, because RenderContext may
      // just use a single idTarget for only dbIds. But for this case, it's not hard to tell which model was hit.
      var models = this.viewer.getVisibleModels();
      if (dbId && models.length === 1) {
        return models[0].id;
      }

      // If we have multiple models, we require the ID buffer.
      return res[1] ? res[1] : 0;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Don't apply hover highlight during dragging
      if (event.buttons !== 0) {
        this.viewer.impl.clearHighlight();
        return false;
      }

      // find model under mouse (model may be undefined)
      var modelId = this.modelIdAtPixel(event.canvasX, event.canvasY);
      var model = this.viewer.impl.findModel(modelId);

      rolloverModel(this.viewer, model);

      // consume event to avoid the regular rollover-highlight per object 
      return true;
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Find selected model (may be null)
      var modelId = this.modelIdAtPixel(event.canvasX, event.canvasY);
      var model = modelId && this.viewer.impl.findModel(modelId);

      this.fireEvent({ type: Events.MODEL_SELECTED, model: model });

      return true;
    } }]);return ModelSelector;}();
;

ModelSelector.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelTransformTool.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelTransformTool.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelTransformTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var OverlayName = 'Autodesk.ModelAlignment_Gizmo';

var Events = {
  MODEL_MOVED_EVENT: 'modelMoved' };


var av = Autodesk.Viewing;

// Tool for moving and rotating a model 
var ModelTransformTool = /*#__PURE__*/function () {

  function ModelTransformTool(viewer, id) {_classCallCheck(this, ModelTransformTool);

    av.EventDispatcher.prototype.apply(this);

    this.viewer = viewer;
    this.id = id;

    // Anchor point in local model coordinates where
    // we place the gizmo
    // (local = excluding model transform)
    this.anchor = new THREE.Vector3();

    // Anchor after applying model matrix
    this.startPos = new THREE.Vector3();

    // Create overlay scene (no effect if alreay existing)
    this.viewer.impl.createOverlayScene(OverlayName);

    // Create axis gizmo
    this.gizmo = new THREE.TransformControls(this.viewer.impl.camera, this.viewer.canvas, 'translate');

    // The edit gizmo must be attached to a 3D object to work.
    // We use an empty target object here and sync the model matrix to the movements of this object.
    this.target = new THREE.Object3D();
    this.gizmo.attach(this.target);

    // Track activate/deactivate calls
    this.active = false;

    // reused tmp matrix
    this.tmpMatrix = new THREE.Matrix4();

    // bind event listeners
    this.onCameraChange = this.onCameraChange.bind(this);
  }_createClass(ModelTransformTool, [{ key: "dtor", value: function dtor()

    {
      this.deactivate();

      // Note that this only works as long no one needs multiple instances of this tool in parallel
      this.viewer.impl.removeOverlayScene(OverlayName);
    } }, { key: "setModel", value: function setModel(

    model, box) {

      this.model = model;

      if (!model) {
        this.setGizmoVisible(false);
        return;
      }

      // Compute anchor point in local model-coordinates
      // (unaffected by model matrix)
      box = box || this.model.getFuzzyBox({ ignoreTransforms: true });
      this.anchor.copy(box.min);

      this.initGizmo();
      this.setGizmoVisible(true);
    } }, { key: "setGizmoVisible", value: function setGizmoVisible(

    visible) {
      this.gizmo.visible = visible;
      this.viewer.impl.invalidate(false, false, true);
    }

    // Init gizmo to be located at minPoint of the model box
  }, { key: "initGizmo", value: function initGizmo() {

      if (!this.model) {
        return;
      }

      // compute start position for the gizmo:
      // This is where the anchor point goes
      this.startPos.copy(this.anchor);

      // ...after applying model transform
      var matrix = this.model.getModelToViewerTransform();
      if (matrix) {
        this.startPos.applyMatrix4(matrix);
      }

      // move gizmo to model anchor
      this.target.position.copy(this.startPos);

      // update gizmo position
      this.gizmo.update();
      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "getNames", value: function getNames()


    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return "ModelTransformTool_".concat(this.id);
    } }, { key: "activate", value: function activate()

    {
      if (this.active) {
        return;
      }

      // Show gizmo
      this.viewer.impl.addOverlay(OverlayName, this.gizmo);

      // update gizmo on camera change
      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      this.active = true;
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.active) {
        return;
      }

      // Hide gizmo
      this.viewer.impl.removeOverlay(OverlayName, this.gizmo);

      // Stop listening to camera changes
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      this.active = false;
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.gizmo.update();
      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // perform hover/move on gizmo
      var moved = this.gizmo.onPointerMove(event);
      var onGizmo = this.gizmo.onPointerHover(event);

      // update overlay. Also update model if gizmo was moved
      this.viewer.impl.invalidate(moved, moved, true);

      // If gizmo was dragged, move the model as well
      if (moved) {

        // get delta between current gizmo position and start position
        var delta = this.target.position.clone().sub(this.startPos);

        // apply same offset to the model placement
        var placement = this.model.getPlacementTransform();
        var el = placement.elements;
        el[12] += delta.x;
        el[13] += delta.y;
        el[14] += delta.z;

        this.viewer.impl.setPlacementTransform(this.model, placement);
        this.fireEvent({ type: Events.MODEL_MOVED_EVENT });
      }

      if (onGizmo || moved) {
        this.viewer.impl.clearHighlight();
      }

      return onGizmo || moved;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event) {
      if (event.button !== 0) {
        return false;
      }
      return this.gizmo.onPointerDown(event);
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event) {
      if (event.button !== 0) {
        return false;
      }
      return this.gizmo.onPointerUp(event);
    }

    // Make sure that this tool takes preference over OrbitDollyPanTool (which has default priority 0)
  }, { key: "getPriority", value: function getPriority() {
      return 1;
    } }]);return ModelTransformTool;}();


ModelTransformTool.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/PointToPoint.js":
/*!***************************************************!*\
  !*** ./extensions/ModelAlignment/PointToPoint.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointToPoint; });
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var Events = Object.assign({}, Autodesk.Edit3D.TwoPointPicker.Events);var

PointToPoint = /*#__PURE__*/function (_Autodesk$Edit3D$TwoP) {_inherits(PointToPoint, _Autodesk$Edit3D$TwoP);var _super = _createSuper(PointToPoint);

  function PointToPoint(viewer, coordPicker, screenOverlay) {var _this;_classCallCheck(this, PointToPoint);

    var labelStyleBlue = {
      backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.Blue };


    var options = {
      draggable: true,
      labels: ['From', 'To'],
      labelStyles: [labelStyleBlue, labelStyleBlue],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Red],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Black,
        getEdgeLabelText: function getEdgeLabelText() {
          var deltaX = Math.abs(_this.points[0].x - _this.points[1].x);
          var deltaY = Math.abs(_this.points[0].y - _this.points[1].y);
          var deltaZ = Math.abs(_this.points[0].z - _this.points[1].z);

          var deltaXStr = _this.unitHandler.lengthToString(deltaX);
          var deltaYStr = _this.unitHandler.lengthToString(deltaY);
          var deltaZStr = _this.unitHandler.lengthToString(deltaZ);

          var text = "X: ".concat(deltaXStr, ", Y: ").concat(deltaYStr, ", Z: ").concat(deltaZStr);
          return text;
        },
        labelStyle: {
          backgroundColor: Autodesk.Edit3D.NPointPicker.Colors.Black } }] };





    _this = _super.call(this, viewer, coordPicker, screenOverlay, options);

    _this.unitHandler = new Autodesk.Edit2D.DefaultUnitHandler(_this.viewer);

    _this.updateGizmos = _this.updateGizmos.bind(_assertThisInitialized(_this));

    _this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, _this.updateGizmos);return _this;
  }_createClass(PointToPoint, [{ key: "dtor", value: function dtor()

    {
      _get(_getPrototypeOf(PointToPoint.prototype), "dtor", this).call(this);

      this.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, this.updateGizmos);
    }

    // ---- Main workflow ----
  }, { key: "start", value: function start()
    {
      this.setVisible(true);
      this.startSelect();
    } }, { key: "pause", value: function pause()

    {
      this.cancelPointSelection();
      this.isActive = false;
      this.setVisible(false);
    } }, { key: "cancel", value: function cancel()

    {
      this.cancelPointSelection();
      this.clear();
      this.setVisible(false);
    } }, { key: "finish", value: function finish(

    model) {
      this.isActive = false;
      return this.apply(model);
    }

    /// -----------

    // Moves the given model, so that "from" point moves to "to" point
  }, { key: "apply", value: function apply(model) {var _this2 = this;
      return new Promise(function (resolve) {
        var matrix = model.getPlacementTransform();

        // If possible, use fromPoint/toPoint. In this case, we also show the PointMarkers.
        // Otherwise, we only use the model of an offset value is specified directly.
        var fromToValid = _this2.pointValid[0] && _this2.pointValid[1];
        var offset = fromToValid ?
        _this2.points[1].clone().sub(_this2.points[0]) :
        _this2.offset;

        var startPos = new THREE.Vector3().setFromMatrixPosition(matrix);
        var endPos = startPos.clone().add(offset);
        var pos = new THREE.Vector3();

        // from-marker-position during animation
        var markerPos = new THREE.Vector3();

        // Fade-out lineGizmo during transition
        _this2.screenOverlay.fadeOutGizmo(_this2.connectors[0].gizmo);
        _this2.connectors[0].label.setOpacity(0, true);

        // blend between start/end position
        var onTimer = function onTimer(t) {
          t = THREE.Math.smootherstep(t, 0.0, 1.0);

          pos.lerpVectors(startPos, endPos, t);

          // move marker with the model
          markerPos.lerpVectors(_this2.points[0], _this2.points[1], t);
          _this2.markers[0].setPosition(markerPos);

          // Update model matrix
          matrix.setPosition(pos);
          _this2.viewer.impl.setPlacementTransform(model, matrix);
        };

        // Fade-out marker labels immediately, because it looks weird if they overlap.
        _this2.markers[0].setLabelVisible(false);
        _this2.markers[1].setLabelVisible(false);

        var onEnd = function onEnd(t) {
          _this2.clear();
          _this2.anim = null;
          resolve();
        };

        _this2.anim = Autodesk.Viewing.Private.fadeValue(0, 1, 1.0, onTimer, onEnd);
      });
    }

    // Move model to the center of the current view
  }, { key: "fitModelToView", value: function fitModelToView(model) {

      // Compute a camera that would fit the model bbox
      var box = model.getBoundingBox();
      var cam = this.viewer.impl.camera;
      var view = Autodesk.Viewing.UnifiedCamera.getViewParamsFromBox(box, false, cam.aspect, cam.up, cam.fov);

      var fromPoint = box.center();

      // Choose toPoint in a way that it is:
      //  - at the current view center
      //  - at the same distance as 
      var dist = view.position.distanceTo(view.target);
      var dir = cam.getWorldDirection();
      var offset = dir.clone().multiplyScalar(dist);
      var toPoint = cam.position.clone().add(offset);

      // If the model is too far away, just animate a small piece of the movement to indicate from which direction the model came.
      // Animating over the full distance would not help anyway, because the model would be invisible for most animation frames.
      var moveDist = fromPoint.distanceTo(toPoint);
      var maxDist = 2.0 * box.size().length();
      if (moveDist > maxDist) {
        var skipDist = Math.max(moveDist - maxDist, 0.0);
        var skipOffset = toPoint.clone().sub(fromPoint).normalize().multiplyScalar(skipDist);

        // Move model immediately by skipOffset
        var matrix = model.getPlacementTransform();
        var modelPos = new THREE.Vector3().setFromMatrixPosition(matrix);
        modelPos.add(skipOffset);
        matrix.setPosition(modelPos);
        this.viewer.impl.setPlacementTransform(model, matrix);

        // Apply same offset to fromPoint
        fromPoint.add(skipOffset);
      }

      this.setPoint(0, fromPoint);
      this.setPoint(1, toPoint);

      this.apply(model);
    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {
      this.anim && this.anim.skip();
    } }, { key: "isAnimationActive", value: function isAnimationActive()

    {
      return this.anim && this.anim.isRunning;
    } }]);return PointToPoint;}(Autodesk.Edit3D.TwoPointPicker);


PointToPoint.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/SheetAlignment.js":
/*!*****************************************************!*\
  !*** ./extensions/ModelAlignment/SheetAlignment.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetAlignmentExtension; });
/* harmony import */ var _FourPointsAlignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FourPointsAlignment.js */ "./extensions/ModelAlignment/FourPointsAlignment.js");
/* harmony import */ var _SheetAlignmentLocals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetAlignmentLocals */ "./extensions/ModelAlignment/SheetAlignmentLocals.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ModelAlignmentBase.js */ "./extensions/ModelAlignment/ModelAlignmentBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



/**
                                       * SheetAlignment extension provides tools to align a 2D sheet and a 3D model.
                                       * 
                                       * @example
                                       *   viewer.loadExtension('Autodesk.SheetAlignment')
                                       *
                                       * @memberof Autodesk.Viewing.Extensions
                                       * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                       * @alias Autodesk.Viewing.Extensions.SheetAlignment
                                       * @class
                                       */



var extensionName = "Autodesk.SheetAlignment";

var namespace = AutodeskNamespace("Autodesk.SheetAlignment");

var EPSILON = 0.0001;

var Events = {
  ADD_DRAWING_CLICKED: "addDrawingClicked" };


var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;var

SheetAlignmentExtension = /*#__PURE__*/function (_ModelAlignmentBase) {_inherits(SheetAlignmentExtension, _ModelAlignmentBase);var _super = _createSuper(SheetAlignmentExtension);

  function SheetAlignmentExtension(viewer, options) {var _this;_classCallCheck(this, SheetAlignmentExtension);
    _this = _super.call(this, viewer, options);

    _this.name = extensionName;

    _this.tmpBox = new THREE.Box3();

    _this.onCropChanged = _this.onCropChanged.bind(_assertThisInitialized(_this));

    _this.fadeDuration = 0.3;return _this;
  }_createClass(SheetAlignmentExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extendLocalization(_SheetAlignmentLocals__WEBPACK_IMPORTED_MODULE_1__["locales"]);

                // 2D sheet model to align.
                this.model = null;

                // 3D model that the sheet should be aligned to.
                this.target3DModel = null;_context.next = 5;return _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "load", this).call(this);case 5:_context.next = 7;return (



                  this.viewer.loadExtension('Autodesk.Crop', { disableMoveTool: true }));case 7:this.cropExtension = _context.sent;

                this.cropExtension.addEventListener(Autodesk.Crop.Events.CROP_MODIFIED, this.onCropChanged);

                this.fourPointsAlignment = new _FourPointsAlignment_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, this.coordPicker, this.screenOverlay);

                this.onPointSelectionStarted = this.onPointSelectionStarted.bind(this);
                this.onPointPicked = this.onPointPicked.bind(this);
                this.fourPointsAlignment.addEventListener(Autodesk.Edit3D.NPointPicker.Events.POINT_SELECTION_STARTED, this.onPointSelectionStarted);
                this.fourPointsAlignment.addEventListener(Autodesk.Edit3D.NPointPicker.Events.POINT_SELECTED, this.onPointPicked);

                this.onContextMenu = this.onContextMenu.bind(this);
                // Invoked when the context menu is about to get opened.
                this.viewer.registerContextMenuCallback(extensionName, this.onContextMenu);

                // When selecting a sheet for alignment, use these values for initial positioning.
                this.targetPos = null;
                this.targetNormal = null;

                this.animationHandleMap = {};case 19:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "unload", this).call(this);

      if (this.fourPointsAlignment) {
        this.fourPointsAlignment.dtor();
        this.fourPointsAlignment = null;
      }

      this.cropExtension.removeEventListener(Autodesk.Crop.Events.CROP_MODIFIED, this.onCropChanged);

      this.model = null;
      this.target3DModel = null;

      this.viewer.unregisterContextMenuCallback(extensionName);

      this.animationHandleMap = {};
    }

    // Given a normal to a face, calculate right vector.
  }, { key: "getRightVector", value: function getRightVector(normal) {
      var up = this.viewer.navigation.getWorldUpVector();

      var right = new THREE.Vector3();
      right.crossVectors(normal, up);
      if (right.lengthSq() < EPSILON) {
        // If normal and up are collinear, choose vector:
        // If the normal direction is mostly along the y axis, choose +Z as up, else choose +Y as up.
        // If they match (e.g., both are zero), pick +Z, the default for maps and most mechanical.
        if (Math.abs(normal.z) >= Math.abs(normal.y)) {
          up.set(0, 1, 0);
        } else {
          up.set(0, 0, 1);
        }

        right.crossVectors(normal, up);
      }

      return right.normalize();
    }

    // Set initial sheet transform according to targetPos & targetNormal
  }, { key: "applyInitialSheetTransform", value: function applyInitialSheetTransform() {
      if (!this.targetPos || !this.targetNormal) {
        return;
      }

      // get delta between current gizmo position and start position.
      var center = this.model.getBoundingBox(true, true).center();

      var normal = this.targetNormal.clone().negate();

      // Add epsilon to prevent Z fighting once the sheet is on top of the face.
      var delta = this.targetPos.sub(center).sub(normal.clone().multiplyScalar(EPSILON));

      var right = this.getRightVector(normal);
      var up = right.cross(normal).normalize();

      var orientation = new THREE.Matrix4();
      orientation.lookAt(new THREE.Vector3(), normal, up);

      var centerToOrigin = new THREE.Matrix4().makeTranslation(-center.x, -center.y, -center.z);
      var originToCenter = new THREE.Matrix4().makeTranslation(center.x, center.y, center.z);

      // apply same offset to the model placement
      var translation = new THREE.Matrix4().makeTranslation(delta.x, delta.y, delta.z);

      var transform = translation.
      multiply(originToCenter).
      multiply(orientation).
      multiply(centerToOrigin);

      this.viewer.impl.setPlacementTransform(this.model, transform);

      this.modified();

      this.targetPos = null;
    }

    // Set 2D model to be aligned next
  }, { key: "setModel", value: function setModel(model) {
      if (this.model === model) {
        return;
      }

      // This has to be first, before supet.setModel, in order that the tool will get activated only after the model and default cropRegion is being set.
      this.cropExtension.setModel(model);

      this.cropExtension.cropToModelBounds(true);

      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "setModel", this).call(this, model);

      // Prevent sheets from getting cut by cutplanes
      this.model.setDoNotCut(this.viewer.impl.matman(), true);

      this.fourPointsAlignment.clear();

      // We call modelTransformTool.setModel here with a specific bounding box - according to the intersection of the model bounds and crop bounds.
      this.modelTransformTool.setModel(model, this.getMinCroppedBox());

      this.applyInitialSheetTransform();
    }

    // Optionally set target 3D model. Used in order to later fit the camera to it.
  }, { key: "setTarget3DModel", value: function setTarget3DModel(targetModel) {
      this.target3DModel = targetModel;
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      // Make sure that any in-progress animation is skipped before we start saving.
      this.fourPointsAlignment.skipAnim();

      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "onSaveButton", this).call(this);
    }

    // Activates point to point selection.
  }, { key: "startPointToPointSelection", value: function startPointToPointSelection() {
      this.fourPointsAlignment.startSelect();
    }

    // Applies point to point transform on the 2D sheet.
  }, { key: "applyPointsToPoints", value: function applyPointsToPoints() {var _this$targetNormal;
      this.transformBackup = this.model.getPlacementTransform().clone();

      var offset = (_this$targetNormal = this.targetNormal) === null || _this$targetNormal === void 0 ? void 0 : _this$targetNormal.clone().multiplyScalar(EPSILON);
      this.fourPointsAlignment.apply(this.model, offset);

      // Hide crop when alignment is done.
      this.cropExtension.deactivate();

      this.modified();
    } }, { key: "restorePreviousTransform", value: function restorePreviousTransform(

    restoreSelection) {
      this.fourPointsAlignment.restorePreviousTransform(restoreSelection);
    } }, { key: "cancel", value: function cancel()

    {
      this.restorePreviousTransform();
      this.fourPointsAlignment.clearAlignmentBackup();
      this.fourPointsAlignment.clear();
    }

    // Are all points ready. Used in order to identify if we can use applyPointsToPoints.
  }, { key: "areAllPointsSet", value: function areAllPointsSet() {
      return this.fourPointsAlignment.areAllPointsSet();
    }

    // Fit camera to 2D sheet.
  }, { key: "fitCameraToSheet", value: function fitCameraToSheet() {var _this2 = this;
      if (!this.model) {
        return;
      }

      // Switch to an orthographic camera when aligning a sheet.
      this.viewer.navigation.toOrthographic();

      var bbox = this.getMinCroppedBox();
      var size = bbox.size();

      // Add extra margin
      bbox.expandByVector(new THREE.Vector3(
      size.x * this.viewer.navigation.FIT_TO_VIEW_HORIZONTAL_MARGIN,
      size.y * this.viewer.navigation.FIT_TO_VIEW_VERTICAL_MARGIN,
      0));


      var pt = this.model.getModelToViewerTransform() || new THREE.Matrix4();
      var center = bbox.center();

      // Apply transform to position.
      var position = center.clone().applyMatrix4(pt);

      var target = center;
      target.z -= bbox.size().y;

      // Apply transform to target.
      target.applyMatrix4(pt);

      var rotation = new THREE.Matrix4();
      rotation.extractRotation(pt);

      // Apply rotation to up vector - according to 2D model default up direction.
      var up = new THREE.Vector3(0, 1, 0).applyMatrix4(rotation).normalize();

      var dstView = {
        position: position,
        target: target,
        up: up };


      return new Promise(function (resolve) {
        Autodesk.Viewing.Private.flyToView(_this2.viewer, dstView, 0.5, resolve, false);
      });
    }

    // Fit camera to 3D target model.
  }, { key: "fitCameraToTargetModel", value: function fitCameraToTargetModel() {
      if (!this.target3DModel) {
        return;
      }

      // model.getBoundingBox returns an LmvBox3 instead of THREE.Box3.
      var bbox = new THREE.Box3().copy(this.target3DModel.getBoundingBox());
      this.viewer.navigation.fitBounds(false, bbox, false);
    } }, { key: "show", value: function show()

    {
      if (!this.model || this.active) {
        return;
      }

      this.active = true;

      this.fourPointsAlignment.setVisible(true);
      this.fourPointsAlignment.continuePointSelectionIfNeeded();

      this.cropExtension.activate();

      // Temporarily disabled modelTransformTool. We'll need to see if we want to use it or not eventually.
      // if (!this.viewer.toolController.isToolActivated(this.modelTransformTool.getName())) {
      //     this.viewer.toolController.activateTool(this.modelTransformTool.getName());
      // }
    } }, { key: "hide", value: function hide()

    {
      if (!this.active) {
        return;
      }

      this.active = false;

      this.fourPointsAlignment.cancelPointSelection();
      this.fourPointsAlignment.setVisible(false);

      this.cropExtension.deactivate();

      this.viewer.toolController.deactivateTool(this.modelTransformTool.getName());

      this.clearIsolation();
    }

    // Get the intersection of the sheet's original bounding box and the crop box.
  }, { key: "getMinCroppedBox", value: function getMinCroppedBox() {var _this$cropExtension$g;
      if (!this.model) {
        return null;
      }

      // Get the bounding box without a transform.
      var bbox = this.tmpBox.copy(this.model.getBoundingBox(true)); // Need to copy since the inner vectors of model.getBoundingBox are not THREE.Vector3.
      var cropBox = (_this$cropExtension$g = this.cropExtension.getCurrentCropRegion()) === null || _this$cropExtension$g === void 0 ? void 0 : _this$cropExtension$g.bbox;

      // Fit to the minimum box (intersection) of the original bounding box and the cropped area.
      if (cropBox) {
        bbox.intersect(cropBox);
      }

      return bbox;
    } }, { key: "onCropChanged", value: function onCropChanged()

    {
      var bbox = this.getMinCroppedBox();
      this.modelTransformTool.setModel(this.model, bbox);

      var cropRegion = this.cropExtension.getCurrentCropRegion();
      this.modified(cropRegion);
    } }, { key: "onPointSelectionStarted", value: function onPointSelectionStarted(_ref)

    {var index = _ref.index;
      // 2D Sheet
      if (index === 0 || index === 1) {
        this.isolate2DSheet();
      } else {
        // 3D Model
        this.isolate3DModel();
      }

      // Activate crop when starting to select points.
      // Could be removed at a later step, when we'll implement the full blown panel.
      this.cropExtension.activate();
    } }, { key: "onPointPicked", value: function onPointPicked()

    {
      if (this.fourPointsAlignment.areAllPointsSet()) {
        this.clearIsolation();
      }
    } }, { key: "isolate2DSheet", value: function isolate2DSheet()

    {
      this.animateModelVisibility(this.model, true);
      this.animateModelVisibility(this.target3DModel, false);
    } }, { key: "isolate3DModel", value: function isolate3DModel()

    {
      this.animateModelVisibility(this.model, false);
      this.animateModelVisibility(this.target3DModel, true);
    } }, { key: "clearIsolation", value: function clearIsolation()

    {
      this.animateModelVisibility(this.model, true);
      this.animateModelVisibility(this.target3DModel, true);
    } }, { key: "isAnimationActive", value: function isAnimationActive()

    {
      return this.fourPointsAlignment.isAnimationActive();
    } }, { key: "animateModelVisibility", value: function animateModelVisibility(

    model, show) {
      if (model.is2d()) {
        return this.animateModelVisibility2D(model, show);
      } else {
        return this.animateModelVisibility3D(model, show);
      }

    }

    // TODO: add animation for 2D.
  }, { key: "animateModelVisibility2D", value: function animateModelVisibility2D(model, show) {
      model.visibilityManager.setAllVisibility(show);
      // Make sure paper stays hidden.
      this.viewer.impl.changePaperVisibility(model, false);
    } }, { key: "animateModelVisibility3D", value: function animateModelVisibility3D(

    model, show) {var _this3 = this;
      if (show) {
        model.visibilityManager.setAllVisibility(true);
      }

      var matman = this.viewer.impl.matman();
      var materials = Object.values(matman.getModelMaterials(model, true).mats);
      var fadeOpacity = this.viewer.impl.fadeMaterial.opacity;

      var onTimer = function onTimer(t) {
        materials.forEach(function (m) {
          var startOpacity = m.opacity;
          var endOpacity = show ? m.origOpacity : fadeOpacity;
          m.opacity = (1 - t) * startOpacity + endOpacity * t;
        });

        _this3.viewer.impl.invalidate(true);
      };

      var restoreOriginal = function restoreOriginal() {
        materials.forEach(function (m) {
          m.opacity = m.origOpacity;
          m.transparent = m.origTransparent;
          delete m.origOpacity;
          delete m.origTransparent;
        });
      };

      if (this.animationHandleMap[model.id]) {
        this.animationHandleMap[model.id].stop();
        delete this.animationHandleMap[model.id];
      }

      // Save original opacity.
      materials.forEach(function (m) {
        if (m.origOpacity === undefined) {
          m.origOpacity = m.opacity;
          m.origTransparent = m.transparent;
          m.transparent = true;
        }
      });

      return new Promise(function (resolve) {
        var onFinished = function onFinished() {
          // Restore original values
          if (show) {
            restoreOriginal();
          } else {
            model.visibilityManager.setAllVisibility(false);
          }

          delete _this3.animationHandleMap[model.id];

          resolve();
        };

        _this3.animationHandleMap[model.id] = Autodesk.Viewing.Private.fadeValue(0, 1, _this3.fadeDuration, onTimer, onFinished);
      });
    }

    // Mirror sheet on X axis
  }, { key: "mirrorX", value: function mirrorX() {
      var matrix = this.model.getPlacementTransform();
      var reflection = new THREE.Matrix4();
      reflection.elements[5] = -1; // Mirror on X axis

      var size = this.model.getBoundingBox(true, true).size();
      var translation = new THREE.Matrix4().makeTranslation(0, -size.y, 0);

      matrix.multiply(reflection).multiply(translation);
      this.viewer.impl.setPlacementTransform(this.model, matrix);
    }

    // Mirror sheet on Y axis
  }, { key: "mirrorY", value: function mirrorY() {
      var matrix = this.model.getPlacementTransform();
      var reflection = new THREE.Matrix4();
      reflection.elements[0] = -1; // Mirror on Y axis

      var size = this.model.getBoundingBox(true, true).size();
      var translation = new THREE.Matrix4().makeTranslation(-size.x, 0, 0);

      matrix.multiply(reflection).multiply(translation);
      this.viewer.impl.setPlacementTransform(this.model, matrix);
    } }, { key: "onContextMenu", value: function onContextMenu(

    menu, status) {var _intersection$model,_intersection$face,_this4 = this;
      var intersection = this.viewer.impl.hitTest(status.canvasX, status.canvasY, false);

      // If the intersected object does not belong to a 3D model, ignore it.
      if (!(intersection === null || intersection === void 0 ? void 0 : (_intersection$model = intersection.model) === null || _intersection$model === void 0 ? void 0 : _intersection$model.is3d())) {
        return;
      }

      // Already in the middle of alignment process.
      if (this.fourPointsAlignment.isPickerActive()) {
        return;
      }

      // Make sure that the intersection has a valid face & normal.
      if (!(intersection === null || intersection === void 0 ? void 0 : (_intersection$face = intersection.face) === null || _intersection$face === void 0 ? void 0 : _intersection$face.normal)) {
        return;
      }

      var point = intersection.point;
      var mesh = this.viewer.impl.getRenderProxy(intersection.model, intersection.fragId);
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
      var normal = intersection.face.normal.clone().applyMatrix3(normalMatrix).normalize();

      var onSheetLoaded = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(model) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                  _this4.setModel(model);_context2.next = 3;return (

                    _this4.fitCameraToSheet());case 3:

                  _this4.viewer.impl.changePaperVisibility(_this4.model, false, true, function () {
                    _this4.startPointToPointSelection();
                  }, 1);case 4:case "end":return _context2.stop();}}}, _callee2);}));return function onSheetLoaded(_x) {return _ref2.apply(this, arguments);};}();


      var menuEntry = {
        title: 'Add drawing', // Gets translated inside ContextMenu.js
        target: function target() {
          _this4.viewer.clearSelection();
          _this4.targetPos = point;
          _this4.targetNormal = normal;
          _this4.setTarget3DModel(intersection.model);

          _this4.fireEvent({
            type: Events.ADD_DRAWING_CLICKED,
            onSheetLoaded: onSheetLoaded });

        } };


      menu.push(menuEntry);
    }

    /**
       * Saving sheet alignment changes is a process that involves:
       * 
       * - Creating a relationship between the 2D sheet and the target 3D model. Once the relationship is made, it returns a unique id.
       *   In case the relationship already exists, it won't create a new one - but return the existing id.
       * - Now that we have a relationshipId, we use it as an additional key in order to save with it the viewport & the transform of the 2D sheet.
       * - Notice that a 2D sheet viewport & transform is defined by three keys: urn, guid & relationshipId.
       */ }, { key: "saveChanges", value: function () {var _saveChanges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      alignmentService) {var matrix, sheetNode, sheetUrn, sheetViewableName, target3DModelNode, target3DModelUrn, target3DModelViewableName, cropRegion;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:if (!(


                !this.model || !this.target3DModel)) {_context3.next = 2;break;}return _context3.abrupt("return");case 2:



                matrix = this.model.getPlacementTransform();
                sheetNode = this.model.getDocumentNode();
                sheetUrn = sheetNode.getRootNode().urn();
                sheetViewableName = av.toUrlSafeBase64(sheetNode.name());

                target3DModelNode = this.target3DModel.getDocumentNode();
                target3DModelUrn = target3DModelNode.getRootNode().urn();
                target3DModelViewableName = av.toUrlSafeBase64(target3DModelNode.name());

                cropRegion = this.cropExtension.getCurrentCropRegion();

                // In case of a new region, generate a unique ID, and store it in the model for future usage.
                this.model.regionId = this.model.regionId || Object(uuid__WEBPACK_IMPORTED_MODULE_2__["v4"])();

                // Save relationship of 2D region and 3D model.
                _context3.next = 13;return alignmentService.saveRelationship(
                target3DModelUrn,
                target3DModelViewableName,
                sheetUrn,
                sheetViewableName,
                this.model.regionId);case 13:_context3.next = 15;return (



                  alignmentService.saveViewport(
                  sheetUrn,
                  sheetViewableName,
                  this.model.regionId,
                  cropRegion.bbox,
                  cropRegion.units));case 15:_context3.next = 17;return (



                  alignmentService.saveTransform(
                  sheetUrn,
                  sheetViewableName,
                  this.model.regionId,
                  matrix));case 17:


                this.pendingChanges = [];
                this.fourPointsAlignment.clearAlignmentBackup();case 19:case "end":return _context3.stop();}}}, _callee3, this);}));function saveChanges(_x2) {return _saveChanges.apply(this, arguments);}return saveChanges;}() }]);return SheetAlignmentExtension;}(_ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);



namespace.SheetAlignment = SheetAlignmentExtension;
namespace.Events = Events;

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, SheetAlignmentExtension);

/***/ }),

/***/ "./extensions/ModelAlignment/SheetAlignmentLocals.js":
/*!***********************************************************!*\
  !*** ./extensions/ModelAlignment/SheetAlignmentLocals.js ***!
  \***********************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-sheetAlignment.loc.json */ "./res/locales/en/nobundle-sheetAlignment.loc.json");
var _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-sheetAlignment.loc.json */ "./res/locales/en/nobundle-sheetAlignment.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/ModelAlignment/TransformCommon.js":
/*!******************************************************!*\
  !*** ./extensions/ModelAlignment/TransformCommon.js ***!
  \******************************************************/
/*! exports provided: animateEdgeToEdge, animateMatrixToMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateEdgeToEdge", function() { return animateEdgeToEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateMatrixToMatrix", function() { return animateMatrixToMatrix; });
/**
 * Transforms a model according to 2 pairs of points.
 * 
 * @param {THREE.Vector3} s0 - source point 1
 * @param {THREE.Vector3} s1 - source point 2
 * @param {THREE.Vector3} t0 - target point 1
 * @param {THREE.Vector3} t0 - target point 2
 * @param {Object}    [options] - Additional options. Not mandatory.
 * @param {Function}  [options.onChange] - callback called when an animation frame is being processed. Recives the calculated matrix as an argument.
 * @param {Function}  [options.onEnd] - callback called when transform is complete.
 * @param {Boolean}   [options.originalMatrix]    - Source matrix to start with.
 * @param {Boolean}   [options.applyTranslation]  - Whether to apply translation to the transform. Default to true.
 * @param {Boolean}   [options.applyRotation]     - Whether to apply rotation to the transform. Default to true.
 * @param {Boolean}   [options.applyScale]        - Whether to apply scale to the transform. Default to true.
 * @param {Number}    [options.duration]          - Duration for the transform in seconds. Default to 1s.
 */
var animateEdgeToEdge = function () {
  var endQuaternion = new THREE.Quaternion();
  var startQuaternion = new THREE.Quaternion();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Matrix4();
  var matrix = new THREE.Matrix4();
  var rotation = new THREE.Matrix4();
  var newPos = new THREE.Vector3();
  var startPos = new THREE.Vector3();
  var originToPivot = new THREE.Matrix4();
  var pivotToOrigin = new THREE.Matrix4();

  return function (s0, s1, t0, t1) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};var

    onChange =





    options.onChange,onEnd = options.onEnd,_options$applyTransla = options.applyTranslation,applyTranslation = _options$applyTransla === void 0 ? true : _options$applyTransla,_options$applyRotatio = options.applyRotation,applyRotation = _options$applyRotatio === void 0 ? true : _options$applyRotatio,_options$applyScale = options.applyScale,applyScale = _options$applyScale === void 0 ? true : _options$applyScale,_options$duration = options.duration,duration = _options$duration === void 0 ? 1.0 : _options$duration;

    var originalMatrix = options.originalMatrix ? options.originalMatrix.clone() : undefined;
    var offset = t0.clone().sub(s0);

    var sLength = s0.distanceTo(s1);
    var tLength = t0.distanceTo(t1);
    var scaleTarget = tLength / sLength;

    var sDir = s1.clone().sub(s0).normalize();
    var tDir = t1.clone().sub(t0).normalize();
    endQuaternion.setFromUnitVectors(sDir, tDir);
    originToPivot.identity().setPosition(s0);
    pivotToOrigin.identity().setPosition(s0.clone().multiplyScalar(-1));

    var onTimer = function onTimer(t) {
      t = THREE.Math.smootherstep(t, 0.0, 1.0);

      // Reset matrix.
      matrix.identity();

      if (applyTranslation) {
        newPos.lerpVectors(startPos, offset, t);
        matrix.makeTranslation(newPos.x, newPos.y, newPos.z);
      }

      // Restore origin.
      matrix.multiply(originToPivot);

      // Apply rotation.
      if (applyRotation) {
        THREE.Quaternion.slerp(startQuaternion, endQuaternion, quaternion, t);
        rotation.makeRotationFromQuaternion(quaternion);
        matrix.multiply(rotation);
      }

      // Apply scale.
      if (applyScale) {
        var s = Autodesk.Viewing.Private.lerp(1.0, scaleTarget, t);
        scale.makeScale(s, s, s);
        matrix.multiply(scale);
      }

      // Set pivot at origin.
      matrix.multiply(pivotToOrigin);

      // Initialize based on previous model matrix, if given.
      if (originalMatrix) {
        matrix.multiply(originalMatrix);
      }

      if (onChange) {
        onChange(matrix);
      }
    };

    var control = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onEnd);

    return control;
  };
}();

// Interpolate between two given Matrix4 transforms. Note that this requires the transforms
// to be invertible combinations of pos/rotate/scale.
var lerpTransforms = function () {
  var startPos = new THREE.Vector3();
  var endPos = new THREE.Vector3();
  var startScale = new THREE.Vector3();
  var endScale = new THREE.Vector3();
  var startRotate = new THREE.Quaternion();
  var endRotate = new THREE.Quaternion();

  var pos = new THREE.Vector3();
  var scale = new THREE.Vector3();
  var rotate = new THREE.Quaternion();

  return function (startMatrix, endMatrix, t, dstTransform) {
    startMatrix.decompose(startPos, startRotate, startScale);
    endMatrix.decompose(endPos, endRotate, endScale);

    pos.lerpVectors(startPos, endPos, t);
    scale.lerpVectors(startScale, endScale, t);
    THREE.Quaternion.slerp(startRotate, endRotate, rotate, t);

    dstTransform.compose(pos, rotate, scale);

    return dstTransform;
  };
}();

/**
      * Animates an interpolation of two matrices.
      * 
      * @param {THREE.Matrix4} startMatrix       - source matrix
      * @param {THREE.Matrix4} endMatrix         - end matrix
      * @param {Object}    [options]             - Additional options. Not mandatory.
      * @param {Function}  [options.onChange]    - callback called when an animation frame is being processed. Receives the calculated matrix as an argument.
      * @param {Function}  [options.onEnd]       - callback called when transform is complete.
      * @param {Number}    [options.duration]    - Duration for the transform in seconds. Default to 1s.
      */
var animateMatrixToMatrix = function animateMatrixToMatrix(startMatrix, endMatrix) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var

  onChange =


  options.onChange,onEnd = options.onEnd,_options$duration2 = options.duration,duration = _options$duration2 === void 0 ? 1.0 : _options$duration2;

  var tmpMatrix = new Autodesk.Viewing.Private.LmvMatrix4(endMatrix.isDoublePrecision);

  var onTimer = function onTimer(t) {
    t = Autodesk.Viewing.Private.smootherStep(t);

    lerpTransforms(startMatrix, endMatrix, t, tmpMatrix);

    if (onChange) {
      onChange(tmpMatrix);
    }
  };

  return Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onEnd);
};

/***/ }),

/***/ "./extensions/ModelAlignment/index.js":
/*!********************************************!*\
  !*** ./extensions/ModelAlignment/index.js ***!
  \********************************************/
/*! exports provided: ModelAlignment, SheetAlignment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ModelAlignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignment.js */ "./extensions/ModelAlignment/ModelAlignment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModelAlignment", function() { return _ModelAlignment_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _SheetAlignment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetAlignment.js */ "./extensions/ModelAlignment/SheetAlignment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SheetAlignment", function() { return _SheetAlignment_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });







/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignment.css":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignment.css ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".adsk-viewing-viewer .edit2d-label.angle-to-angle {\n  width: 84px;\n  height: 84px;\n  border-radius: 100px;\n  background: #FFFFFF;\n  box-shadow: 0px 1px 6px rgba(12, 44, 84, 0.12);\n  font-size: 18px;\n  line-height: 20px;\n  display: flex; }\n\n.adsk-viewing-viewer .edit2d-label.angle-to-angle.visible {\n  display: flex; }\n\n.adsk-viewing-viewer .edit2d-label.angle-to-angle .edit2d-label-text {\n  font-size: 18px;\n  line-height: 20px;\n  align-self: center;\n  width: 100%;\n  color: black; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".model-alignment-panel .tab-header {\n  border-bottom-color: transparent;\n  font-size: 12px;\n  font-weight: bold;\n  border-bottom-style: solid;\n  border-bottom-width: 3px;\n  padding-bottom: 2px; }\n\n.model-alignment-panel .tab-header.selected {\n  color: #1dc6f2;\n  border-bottom-color: #1dc6f2; }\n\n.model-alignment-panel .tab-header:hover {\n  color: #1dc6f2; }\n\n.model-alignment-panel .model-select-combo {\n  width: calc(100% - 20px);\n  margin: 15px 10px 15px 10px;\n  /* top-right-bottom-left */\n  font-size: 15px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./res/locales/en/nobundle-modelAlignment.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/en/nobundle-modelAlignment.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Pivot, From, To, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"ModelAlignment Extension\",\"Pivot\":\"Pivot\",\"From\":\"From\",\"To\":\"To\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-sheetAlignment.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/en/nobundle-sheetAlignment.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Add drawing, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"SheetAlignment Extension\",\"Add drawing\":\"Add drawing\"}");

/***/ })

/******/ });
//# sourceMappingURL=ModelAlignment.js.map