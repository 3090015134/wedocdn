/*!
 * LMV v7.32.0
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelSheetTransition =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelSheetTransition/ModelSheetTransition.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/AEC/common/AecModelData.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/common/AecModelData.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. 
// Currently only available for Revit files.
//

var isUsingModelSheetTransform = function isUsingModelSheetTransform() {return Autodesk.Viewing.getGlobal().AEC_MODELTOSHEET_TRANSFORM;};

var namespace = AutodeskNamespace('Autodesk.AEC');

// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.
var remapRectangle = function remapRectangle(
xMinFrom, yMinFrom, xMaxFrom, yMaxFrom,
xMinTo, yMinTo, xMaxTo, yMaxTo)
{
  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);
  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);

  // Note that the translation component of the matrix works on the scaled values.
  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want 
  // to map it to xMinTo instead. (analog for y)
  var offsetX = xMinTo - scaleX * xMinFrom;
  var offsetY = yMinTo - scaleY * yMinFrom;

  // Create Matrix4 that applies both
  var matrix = new THREE.Matrix4();
  matrix.elements[0] = scaleX;
  matrix.elements[5] = scaleY;
  matrix.elements[12] = offsetX;
  matrix.elements[13] = offsetY;
  return matrix;
};

var getFeetToSheetUnits = function getFeetToSheetUnits(sheetUnitScale) {
  var FeetToMeter = 0.3048;
  var MeterToSheetUnits = 1.0 / sheetUnitScale;
  return FeetToMeter * MeterToSheetUnits;
};

// Returns the 2D bbox of a viewport on a sheet.
// 
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
// @returns {THREE.Box2|null}
var getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {

  // viewport region in foot as array (6 floats)
  var values = vp.geometryViewportRegion;
  if (!values) {
    return null;
  }

  // Convert from foot to sheet units (usually inches)
  var scale = getFeetToSheetUnits(sheetUnitScale);

  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.
  // We remove that offset before scaling. 
  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)
  var boundsCorrection = 0.01;

  var res = new THREE.Box2();
  res.min.x = (values[0] + boundsCorrection) * scale;
  res.min.y = (values[1] + boundsCorrection) * scale;
  res.max.x = (values[3] - boundsCorrection) * scale;
  res.max.y = (values[4] - boundsCorrection) * scale;
  return res;
};

// Handle available view rotation modes in Revit
// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.
// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])
//
//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:
//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm
//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation
var getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {

  var matrix = new THREE.Matrix4();
  switch (viewRotationType) {
    // No rotation => done
    case 0:return matrix;

    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw
    case 1:{
        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the
        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.
        // Therefore, the desired effect of the matrix is:
        //
        //  (x, y) => (1-y, x)
        //
        // Note the memory layout of THREE matrices is column-major.

        // out.x = (1-y)
        matrix.elements[0] = 0; //  0 * in.x
        matrix.elements[4] = -1; // -1 * in.y
        matrix.elements[12] = 1; // + 1

        // out.y = x
        matrix.elements[1] = 1; // 1 * in.x
        matrix.elements[5] = 0; // 0 * in.y

        break;
      }

    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw
    case 2:{
        // Desired transform here is:
        //
        // (x, y) => (y, 1-x)

        // out.x = y
        matrix.elements[0] = 0; // 0 * in.x
        matrix.elements[4] = 1; // 1 * in.y

        // out.y = (1-x)
        matrix.elements[1] = -1; //    -in.x
        matrix.elements[5] = 0; // 0 * in.y
        matrix.elements[13] = 1; // + 1

        break;
      }
    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}

  return matrix;
};

// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.
//
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
//
// @returns {THREE.Matrix4|null} May return null if a viewport does not support a 2D/3D transform.
//
// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. 
var get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get the 3DTo2D matrix directly.
  if (isUsingModelSheetTransform() && vp.modelToSheetTransform) {
    var matrix = get3DTo2DMatrix(vp, sheetUnitScale);
    return matrix.getInverse(matrix);
  }

  // Viewport bbox on sheet (Box2)
  var sheetRegion = getViewportBounds(vp, sheetUnitScale);

  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume
  // that is mapped to the sheet.
  var sectionBox = vp.sectionBox;
  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var sheetToViewport = remapRectangle(
  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates
  0, 0, 1, 1 // ...to [0,1] 
  );

  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)
  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var viewportToSectionBox = remapRectangle(
  0, 0, 1, 1, // ...from normalized viewport coords
  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox
  );

  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.
  return sectionBoxTransform.
  multiply(viewportToSectionBox).
  multiply(vpRotationInv).
  multiply(sheetToViewport);
};

// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().
var get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get a matrix directly.
  if (isUsingModelSheetTransform() && vp.modelToSheetTransform) {

    // So far, we only support a single matrix per viewport
    var values = vp.modelToSheetTransform;
    var _matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(values);

    // apply post-scaling from feet to sheet-units
    // Note that using multiplyScalar() here is only similar, but not the same: E.g., it would also multiply component 15
    // which may cause weird side-effects when multiplying with other matrices.
    // The Z value of the scale is set to feetToSheetUnits as well so that getMaxScaleOnAxis
    // returns a meaningful result (used to be 1, which would skew the results)
    var feetToSheetUnits = getFeetToSheetUnits(sheetUnitScale);
    var scaleTf = new THREE.Matrix4().makeScale(feetToSheetUnits, feetToSheetUnits, feetToSheetUnits);
    _matrix.multiplyMatrices(scaleTf, _matrix);

    return _matrix;
  }

  var matrix = get2DTo3DMatrix(vp, sheetUnitScale);
  matrix.getInverse(matrix);
  return matrix;
};

// Find Sheet BubbleNode containing the given viewport.
//
//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets
//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)
//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).
var findSheetForViewport = function findSheetForViewport(root, vp) {
  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);
  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};
  return sheetNodes.find(linkedByVp);
};

// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.
// Note that not all viewports support 2D/3D transform.
//
//  @param {av.BubbleNode|av.Model} sheet
var findViewportsOnSheet = function findViewportsOnSheet(sheet) {

  // get aecModelData from model or node
  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;
  var sheetNode = isNode ? sheet : sheet.getDocumentNode();
  var aec = sheetNode.getAecModelData();
  if (!aec || !aec.viewports) {
    return [];
  }

  // Find viewports linking the sheet guid
  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});
};

// Given a sheet and a point on that sheet, this function returns the viewport containing it.
// If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
// where the distance from the viewport edges is largest.
//
//  @param {av.Model}         sheet
//  @param {Vector2}          point            - Point in sheet world-coords.
//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports
//
//  @returns {Object|undefined} 
var findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  // Find sheets linking this sheet
  var viewports = findViewportsOnSheet(sheet);

  // Apply option filter
  if (viewportFilter) {
    viewports = viewports.filter(viewportFilter);
  }

  // Couple each viewport with viewport bounds 
  viewports = viewports.map(function (vp) {
    return {
      viewport: vp,
      bounds: getViewportBounds(vp, sheet.getUnitScale()) };

  });

  // Reduce to viewports containing the given point
  var containsPoint = function containsPoint(vp) {
    return vp.bounds && vp.bounds.containsPoint(point);
  };
  viewports = viewports.filter(containsPoint);

  // Point may be outside of all viewports
  if (!viewports.length) {
    return;
  }

  // Viewports may overlap. For this case, we need a heuristic metric
  // to choose the best match. For this, we use the
  // distance to the viewport boundary edges.
  var distanceFromEdge = function distanceFromEdge(box, p) {
    return Math.min(
    Math.min(p.x - box.min.x, box.max.x - p.x),
    Math.min(p.y - box.min.y, box.max.y - p.y));

  };

  // Pick the viewport that minimizes distanceFromEdge
  var getBestMatch = function getBestMatch(vp1, vp2) {
    var d1 = distanceFromEdge(vp1.bounds, point);
    var d2 = distanceFromEdge(vp2.bounds, point);
    return d2 > d1 ? vp2 : vp1;
  };
  return viewports.reduce(getBestMatch).viewport;
};

// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)
//  @param {Object} vp - viewport object from aecModelData
//  @returns {string|undefined} levelGuid
var getLinkedLevel = function getLinkedLevel(vp) {

  // Viewports come directly from aecModelData json and do not always reference a level. 
  // So, we should not crash if anything is null here.
  var viewRange = vp.extensions && vp.extensions.viewRange;
  var cutPlane = viewRange && viewRange.cutPlane;
  return cutPlane && cutPlane.levelGuid;
};

// Find all viewports in the document that link the level indicated by levelGuid
//
// @param {Object} aecData   - as obtained from AECModelData.json
// @param {string} levelGuid
// @retuns {Object[]} Array of viewport data objects
var findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {

  // Find viewports that links this level
  var viewports = aecData.viewports || [];

  var matchesLevel = function matchesLevel(vp) {
    var vpLevelGuid = getLinkedLevel(vp);
    return vpLevelGuid === levelGuid;
  };
  return viewports.filter(matchesLevel);
};

// Find level in aecModelData that links the given viewport.
//
// @param {Object} aecData - as obtained from AECModelData.json
// @param {Object} viewport object
// @retuns {Object|undefined} level object from aecModelData
var findLevelForViewport = function findLevelForViewport(aecData, viewport) {
  var levelGuid = getLinkedLevel(viewport);

  // Search for a level with this levelGuid
  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};
  return levelGuid && aecData.levels.find(hasLevelGuid);
};

// Checks if a viewport provides all required information to compute a 2D/3D transform.
//  @param {Object} vp - vieport data object as obtained from AecModelData.json
var supports2DTo3DTransform = function supports2DTo3DTransform(vp) {

  // If AECModelData contains a modelToSheetTransform (only possible for models produced using latest RevitAPI changes), we get a matrix directly
  // and don't have to care for sectionBox or isCropBoxActive anymore.
  var canUseTransform = Boolean(isUsingModelSheetTransform() && vp.modelToSheetTransform);

  // Check if we can use the old code path to reverse-engineer the transform from the SectionBox
  var canUseWorkaround = Boolean(vp.sectionBox && vp.isCropBoxActive);

  // If neither of the two work, we can stop here.
  if (!canUseTransform && !canUseWorkaround) {
    return false;
  }

  // Viewport types for which we know that we get valid transform data.
  // For 'Section', it worked for some examples, but wasn't reliably enough to enable it by default yet.
  var supportedTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];

  return Boolean(supportedTypes.includes(vp.viewType) &&
  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)
  !vp.hasBreaks && // A view in Revit may be split into separate parts using "View breaks". This is not supported yet.
  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.
};

var AEC_CACHE = {};

// Returns all the fragments that belong to a specific dbId. This only takes the leaf nodes, so we can't
// just call enumNodeFragments with recurse directly.
var getLevelFragmentsIds = function getLevelFragmentsIds(instanceTree, levelDbId) {
  var leafIds = [];
  var _collectLeafNodeIds = function _collectLeafNodeIds(id) {
    var childCount = 0;
    instanceTree.enumNodeChildren(id, function (childId) {
      _collectLeafNodeIds(childId);
      childCount += 1;
    });
    if (childCount === 0) {
      leafIds.push(id);
    }
  };
  _collectLeafNodeIds(levelDbId);

  var fragIds = [];
  leafIds.forEach(function (leafId) {
    instanceTree.enumNodeFragments(leafId, function (fragId) {fragIds.push(fragId);});
  });
  return fragIds;
};

// This function holds heuristics around getting bounding boxes for levels:
// 1. Compute fuzzyBoundingBox to make sure things like pipes coming through multiple floors do not make bounding box too large
// 2. Given that levels are coming in bottom up order, we check that newly computed bounding box does not intersect with the last known level
//    and if it does, reduce the largest box among both levels. This step helps when bounding box is large by nature (e.g. due to high walls spreading over multiple levels)
var getLevelBoundingBox = function getLevelBoundingBox(dbId, model, lastLevel) {
  var instanceTree = model.getData().instanceTree;
  if (!instanceTree) {
    return;
  }

  var fragIds = getLevelFragmentsIds(instanceTree, dbId);
  var newBox = model.getFuzzyBox({ allowlist: fragIds });

  // If there is some levels in the storage already, we need to check for intersection
  if (lastLevel.min.z !== Infinity && lastLevel.max.z > newBox.min.z) {
    // there is an intersection and some box need to be cropped
    var newBoxHeight = Math.abs(newBox.max.z - newBox.min.z);
    var lastKnownBoxHeight = Math.abs(lastLevel.max.z - lastLevel.min.z);
    if (lastKnownBoxHeight > newBoxHeight) {
      lastLevel.max.z = lastLevel.min.z;
    } else {
      newBox.min.z = lastLevel.max.z;
    }
  }
  lastLevel.copy(newBox);
  return newBox;
};

var computeLevels = function computeLevels(levels, model) {
  // Need to get and apply opposite to elevation as it will be reapplied elsewhere
  var refPointTf = model.myData.placementWithOffset;
  if (!refPointTf) {
    refPointTf = new THREE.Matrix4();
  }

  var lastLevel = new THREE.Box3();
  levels.forEach(function (level, idx) {
    var levelBox = getLevelBoundingBox(level.dbId, model, lastLevel);
    if (levelBox && levelBox.min.z !== Infinity && levelBox.max.z !== Infinity) {
      level.elevation = levelBox.min.z - (refPointTf ? refPointTf.elements[14] : 0);
      if (idx === levels.length - 1) {
        level.height = model.getBoundingBox().max.z - levelBox.min.z;
      } else {
        level.height = levelBox.max.z - levelBox.min.z;
      }
    }
  });

  if (levels.some(function (l) {return !l.elevation;})) {
    console.warn('Failed to derive elevation for some levels');
    return;
  }

  var refP = [
  refPointTf.elements[0], refPointTf.elements[1], refPointTf.elements[2],
  refPointTf.elements[4], refPointTf.elements[5], refPointTf.elements[6],
  refPointTf.elements[8], refPointTf.elements[9], refPointTf.elements[10],
  refPointTf.elements[12], refPointTf.elements[13], refPointTf.elements[14]];

  var aecModelData = {
    version: '1.0.0', phases: [{ name: 'Default' }], levels: levels, scopeBoxes: [], refPointTransformation: refP };


  return aecModelData;
};

// Couple of queries used here will only work for OTG property database
// In order to make it work for SVF we need to use other property names, coming from Navisworks (Lc*)
var findLevelsOTG = function findLevelsOTG(onDone, onError, model) {
  model.search(
  'IFCBUILDING',
  function (dbIds) {
    model.getBulkProperties(
    dbIds, null,
    function (elements) {
      if (elements.length !== 1) {
        // Should find one element (if not, we consider it an edge case --maybe 2 buildings within
        // single IFC file-- for now and do nothing)
        return onDone(undefined);
      }
      var levelCandidates = elements[0].properties.
      filter(function (e) {return e.displayName === 'child';}) // get direct children
      .map(function (e) {return e.displayValue;}); // get dbId of each child

      model.getBulkProperties(
      levelCandidates, ['Name', 'Type'],
      function (levelElements) {
        // Levels are stored in Db as they are presented in IFC -> bottom up order, so we must not mess it up
        var levels = levelElements.map(function (lev) {
          var type = lev.properties.find(function (p) {return p.displayName === 'Type';});
          var name = lev.properties.find(function (p) {return p.displayName === 'Name';});
          // TODO: this might be localization dependent
          if (type && type.displayValue.includes('Level') && name) {
            return {
              // This likely does not matter too much, so just assign dbId to simplify debugging
              guid: lev.dbId,
              name: name.displayValue,
              // NOTE: elevation and height will be populated later
              dbId: lev.dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } };


          }
        }).filter(Boolean);

        onDone(levels);
      },
      onError);

    },
    onError);

  }, onError, ['Type']);

};

var findLevelsSVF = function findLevelsSVF(onDone, onError, model) {
  model.search(
  'IfcBuildingStorey',
  function (dbIds) {
    model.getBulkProperties(
    dbIds,
    ['Type', 'GUID', 'NAME', 'Name', 'ELEVATION', 'Elevation', 'IfcElevation'],
    function (elements) {
      var levels = [];
      for (var i = 0; i < elements.length; i++) {
        if (elements[i].properties.length > 1) {
          var guidIdx = elements[i].properties.findIndex(function (element) {return element.displayName === 'GUID';});
          var levelIdx = elements[i].properties.findIndex(function (element) {return element.displayValue === 'Levels: Level: Level 1';});
          var nameIdx = -1;
          var elevationIdx = -1;
          if (levelIdx >= 0) {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                (element.attributeName.toLowerCase() === 'name' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName') &&
                element.displayCategory === 'Item');});
          } else {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName.toLowerCase() === 'name' && (
                element.displayCategory === 'IFC' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName' &&
                element.displayCategory === 'Item' ||
                element.attributeName ===
                'LcRevitData_Element:LcRevitPropertyElementName' &&
                element.displayCategory === 'Element'));});
            elevationIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName === 'ELEVATION' &&
                element.displayCategory === 'IFC' ||
                (element.displayName === 'IfcElevation' ||
                element.displayName === 'Elevation') &&
                element.displayCategory === 'Element');});
          }
          if (nameIdx >= 0 && (elevationIdx >= 0 || levelIdx >= 0)) {
            levels.push({
              guid: guidIdx > -1 ? elements[i].properties[guidIdx].displayValue : elements[i].dbId,
              name: elements[i].properties[nameIdx].displayValue,
              dbId: elements[i].dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } });


          }
        }
      }

      onDone(levels);
    },
    onError);

  },
  onError, ['Type']);

};

var computeAecModelDataForIfc = function computeAecModelDataForIfc(model, cacheKey) {
  if (!model) {
    return null;
  }

  if (AEC_CACHE[cacheKey]) {// We had a heavy computation already, return result from cache
    return AEC_CACHE[cacheKey];
  }

  var promise = new Promise(function (resolve) {
    var onDone = function onDone(levels) {
      if (!levels || !levels.length) {
        return resolve(null);
      }

      var aecModelData = computeLevels(levels, model);
      if (cacheKey) {
        AEC_CACHE[cacheKey] = Object.assign({}, aecModelData);
      }
      resolve(aecModelData);
    };

    var onError = function onError(error) {
      console.error(error);
      resolve(null);
    };

    if (model.isOTG()) {
      findLevelsOTG(onDone, onError, model);
    } else {
      findLevelsSVF(onDone, onError, model);
    }
  });

  if (cacheKey) {
    // Cache the promise so if this is called multiple times it won't start the same computation in parallel
    AEC_CACHE[cacheKey] = promise;
  }

  return promise;
};

var AecModelData = {
  get2DTo3DMatrix: get2DTo3DMatrix,
  get3DTo2DMatrix: get3DTo2DMatrix,
  getViewportBounds: getViewportBounds,
  remapRectangle: remapRectangle,
  findSheetForViewport: findSheetForViewport,
  findViewportsForLevel: findViewportsForLevel,
  supports2DTo3DTransform: supports2DTo3DTransform,
  getLinkedLevel: getLinkedLevel,
  findViewportsOnSheet: findViewportsOnSheet,
  findViewportAtPoint: findViewportAtPoint,
  findLevelForViewport: findLevelForViewport,
  computeAecModelDataForIfc: computeAecModelDataForIfc };


/* harmony default export */ __webpack_exports__["default"] = (AecModelData);

namespace.AecModelData = AecModelData;

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransition.css":
/*!******************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransition.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./ModelSheetTransition.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransition.js":
/*!*****************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSheetTransitionExtension; });
/* harmony import */ var _ModelSheetTransitionLocals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelSheetTransitionLocals */ "./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js");
/* harmony import */ var _ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelSheetTransition.css */ "./extensions/ModelSheetTransition/ModelSheetTransition.css");
/* harmony import */ var _ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AEC/common/AecModelData */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



/**
                                                   * ModelSheetTransition is an extension for transitioning from a 2D model to its context inside a 3D model.
                                                   * Prerequisite is that the context (relationship and transform) exists and can be provided by a service.
                                                   *
                                                   *  * @example
                                                   *   viewer.loadExtension('Autodesk.ModelSheetTransition')
                                                   *
                                                   * @memberof Autodesk.Viewing.Extensions
                                                   * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                                   * @alias Autodesk.Viewing.Extensions.ModelSheetTransition
                                                   * @class
                                                   */

var extensionName = 'Autodesk.ModelSheetTransition';
var namespace = AutodeskNamespace(extensionName);

var Prefix = {
  Urn: 'urn=',
  Name: 'viewableName=' };


var HIDE_DURATION = 2.5; // In seconds
var
ModelSheetTransitionExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(ModelSheetTransitionExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(ModelSheetTransitionExtension);
  /**
                                                                                                                                                                                                          * @param viewer
                                                                                                                                                                                                          * @param options - Can include a getService function that provides the alignment service. If no service is provided
                                                                                                                                                                                                          *                  will just default to looking for available AEC data.
                                                                                                                                                                                                          *                  Can include a loadRelatedDocument function that fetches the document for a related model
                                                                                                                                                                                                          *                  Can include a showRelatedDocument function that shows the related model
                                                                                                                                                                                                          *                  Can include a displayError function that uses a custom UI to show errors
                                                                                                                                                                                                          */
  function ModelSheetTransitionExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, ModelSheetTransitionExtension);
    _this = _super.call(this, viewer, options);

    _this.cache = _this.getCache();
    _this.getService = options.getService;
    _this.loadRelatedDocument = options.loadRelatedDocument || _this._loadRelatedDocument.bind(_assertThisInitialized(_this));
    _this.showRelatedDocument = options.showRelatedDocument || _this._showRelatedDocument.bind(_assertThisInitialized(_this));
    _this.displayError = options.displayError || _this._displayError.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));return _this;
  }_createClass(ModelSheetTransitionExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this$getService;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extendLocalization(_ModelSheetTransitionLocals__WEBPACK_IMPORTED_MODULE_0__["locales"]);_context.next = 3;return (_this$getService =
                this.getService) === null || _this$getService === void 0 ? void 0 : _this$getService.call(this);case 3:this.service = _context.sent;

                this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.update);
                this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.update);return _context.abrupt("return",

                true);case 7:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.update);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.update);

      this.destroyUI();

      this.service = null;
      this.viewer = null;
      this.options = null;

      return true;
    } }, { key: "update", value: function () {var _update = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var model2D, _yield$this$fetchView, toolbarUIEnabled;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:


                model2D = this.getSuitable2DModel();if (!

                model2D) {_context2.next = 20;break;}
                this.createUI();

                this.resetModelIfNeeded(model2D);_context2.next = 6;return (

                  this.fetchViewportsForModel(model2D));case 6:_context2.t1 = _yield$this$fetchView = _context2.sent.viewports;_context2.t0 = _context2.t1 === null;if (_context2.t0) {_context2.next = 10;break;}_context2.t0 = _yield$this$fetchView === void 0;case 10:if (!_context2.t0) {_context2.next = 14;break;}_context2.t2 = void 0;_context2.next = 15;break;case 14:_context2.t2 = _yield$this$fetchView.length;case 15:_context2.t3 = _context2.t2;toolbarUIEnabled = _context2.t3 > 0;
                // Check that while fetching from the service, the model didn't change
                if (model2D === this.getSuitable2DModel()) {
                  this.setButtonEnabled(toolbarUIEnabled);
                }_context2.next = 21;break;case 20:

                this.destroyUI();case 21:case "end":return _context2.stop();}}}, _callee2, this);}));function update() {return _update.apply(this, arguments);}return update;}()



    /**
                                                                                                                                                                                  * Invoked by the viewer when the toolbar UI is available.
                                                                                                                                                                                  *
                                                                                                                                                                                  * @param {Autodesk.Viewing.UI.ToolBar} toolbar - toolbar instance.
                                                                                                                                                                                  *
                                                                                                                                                                                  * @alias Autodesk.Viewing.Extensions.ModelSheetTransitionExtension#onToolbarCreated
                                                                                                                                                                                  */ }, { key: "onToolbarCreated", value: function onToolbarCreated(
    toolbar) {
      this.update();
    }

    /**
       * @private
       */ }, { key: "createUI", value: function createUI()
    {var _this2 = this;
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (!toolbar || this.toolbarButton) {
        return;
      }

      var toolbarGroup = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
      if (!toolbarGroup) {
        return;
      }

      // Create the button first.
      this.toolbarButton = new Autodesk.Viewing.UI.Button('toolbar-model-sheet-transition');
      this.toolbarButton.setToolTip('Fetching alignment information...');
      this.toolbarButton.setIcon('viewericon-model-sheet-transition');
      this.toolbarButton.setState(Autodesk.Viewing.UI.Button.State.DISABLED);
      this.toolbarButton.onClick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:if (!
                _this2.transitionStarted) {_context3.next = 2;break;}return _context3.abrupt("return");case 2:



                Autodesk.Viewing.Private.analytics.track('viewer.model_sheet_transition', {
                  from: 'UI' });


                _this2.transitionStarted = true;_context3.next = 6;return (
                  _this2.transition2Dto3D());case 6:
                _this2.transitionStarted = false;case 7:case "end":return _context3.stop();}}}, _callee3);}));


      toolbarGroup.addControl(this.toolbarButton);
    } }, { key: "setButtonEnabled", value: function setButtonEnabled(

    enabled) {
      if (!this.toolbarButton) {
        return;
      }

      var supportedTooltip = 'Show in 3D context';
      var unsupportedTooltip = 'Current view is not supported by Show in 3D context';

      this.toolbarButton.setState(enabled ? Autodesk.Viewing.UI.Button.State.INACTIVE : Autodesk.Viewing.UI.Button.State.DISABLED);
      this.toolbarButton.setToolTip(enabled ? supportedTooltip : unsupportedTooltip);
    }

    /**
       * @private
       */ }, { key: "destroyUI", value: function destroyUI()
    {
      if (!this.toolbarButton) {
        return;
      }

      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();
      if (!toolbar) {
        return;
      }

      this.toolbarButton.removeFromParent();
      this.toolbarButton = null;
    } }, { key: "getSuitable2DModel", value: function getSuitable2DModel()

    {
      return this.viewer.impl.is2d && this.viewer.impl.get2DModels()[0];
    }

    // If this model was changed due to a transition, reset those changes
  }, { key: "resetModelIfNeeded", value: function resetModelIfNeeded(model) {var _this$cache$key,_this3 = this;
      var key = model.getModelKey();

      if (((_this$cache$key = this.cache[key]) === null || _this$cache$key === void 0 ? void 0 : _this$cache$key.model) === model) {
        // Reset transform
        this.viewer.impl.setPlacementTransform(model, new THREE.Matrix4());

        model.changePaperVisibility(true);
        model.setDoNotCut(this.viewer.impl.matman(), false);

        // Reset viewport bounds (without animation - duration set to 0)
        this.setViewportBounds(model, null, 0);
        this.fitToBounds(model);

        this.viewer.impl.invalidate(true);

        // Make sure home view is synced (since we are changing the transform after the model has been added)
        // Wait for next frame to make sure view is updated
        setTimeout(function () {return _this3.viewer.impl.controls.recordHomeView();});

        this.cache[key].model = null;
      }
    } }, { key: "fetchViewportsForModel", value: function () {var _fetchViewportsForModel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(

      model) {var key;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                key = model.getModelKey();if (

                this.cache[key]) {_context4.next = 7;break;}
                // Create initial cache that this model doesn't contain any alignments.
                // Will also prevent multiple calls to fetch viewports if we are already in the middle of fetch
                // (can happen since we can reach here from onToolbarCreated as well as from onModelAdded)
                this.cache[key] = {};_context4.next = 5;return (
                  this.fetchViewportsFromService(model, key));case 5:if (_context4.sent) {_context4.next = 7;break;}
                this.fetchViewportsFromAECData(model, key);case 7:return _context4.abrupt("return",



                this.cache[key]);case 8:case "end":return _context4.stop();}}}, _callee4, this);}));function fetchViewportsForModel(_x) {return _fetchViewportsForModel.apply(this, arguments);}return fetchViewportsForModel;}()


    // Fetches viewports for a model and save it in cache, using the provided service
  }, { key: "fetchViewportsFromService", value: function () {var _fetchViewportsFromService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(model, key) {var _this$service;var urn2D, encodedName2D, viewports;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                urn2D = model.getData().urn;
                encodedName2D = Autodesk.Viewing.toUrlSafeBase64(model.getDocumentNode().name());_context5.next = 4;return (_this$service =

                this.service) === null || _this$service === void 0 ? void 0 : _this$service.getViewports(urn2D, encodedName2D);case 4:viewports = _context5.sent;if (!(
                !viewports || !viewports.length)) {_context5.next = 7;break;}return _context5.abrupt("return",
                false);case 7:


                this.cache[key] = {
                  viewports: viewports,
                  urn2D: urn2D,
                  encodedName2D: encodedName2D,
                  isFromService: true };return _context5.abrupt("return",


                true);case 9:case "end":return _context5.stop();}}}, _callee5, this);}));function fetchViewportsFromService(_x2, _x3) {return _fetchViewportsFromService.apply(this, arguments);}return fetchViewportsFromService;}()


    // Fetches viewports for a model and save it in cache, using AEC data
  }, { key: "fetchViewportsFromAECData", value: function fetchViewportsFromAECData(model, key) {
      // PDFs are not supported, but PDFs originating from Revit are, since they have the required viewbox data.
      var is2dAEC = model.isAEC() && !model.isPdf(true);
      if (!is2dAEC || !model.getDocumentNode()) {
        return false;
      }

      var viewports = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].findViewportsOnSheet(model);

      viewports.filter(_AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].supports2DTo3DTransform);
      if (!viewports.length) {
        return false;
      }

      this.cache[key] = {
        viewports: viewports,
        isFromAEC: true };


      return true;
    } }, { key: "getDocumentAndTransformFromAEC", value: function getDocumentAndTransformFromAEC(

    model2D, viewport) {
      var sheetUnitScale = model2D.getUnitScale();
      var matrix = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].get2DTo3DMatrix(viewport, sheetUnitScale);

      var node2D = model2D.getDocumentNode();
      // Document will be the same
      var doc = node2D.getDocument();
      var views = node2D.getRootNode().search(Autodesk.Viewing.BubbleNode.MODEL_NODE);
      if (!views || !views.length) {
        throw 'No AEC views';
      }

      var bubbleNode = views[0]; // Taking first 3D view

      if (viewport.viewType === 'FloorPlan') {
        var aec = model2D.getDocumentNode().getAecModelData();
        var level = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].findLevelForViewport(aec, viewport);

        // Take elevation from level
        if (level) {
          var zOffsetHack = 1 / 120; // Offset to place slightly above floor
          var pos = new THREE.Vector3();
          pos.setFromMatrixPosition(matrix);
          pos.z = level.elevation + zOffsetHack;
          matrix.setPosition(pos);
        }
      }

      var crop = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].getViewportBounds(viewport, sheetUnitScale);

      return { doc: doc, bubbleNode: bubbleNode, matrix: matrix, crop: crop };
    }

    // Fetches the related document and transform from the service. If no alignment is available, it will fallback
    // to AEC data (if supported and exists)
  }, { key: "getDocumentAndTransformFromService", value: function () {var _getDocumentAndTransformFromService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(model2D, urn2D, encodedName2D, regionId) {var _yield$this$service$g, _yield$this$service$g2, relationship, relatedModel, _relatedModel$id$spli, _relatedModel$id$spli2, urn3D, name3D, nodePromise, tfAndCropPromise;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return (
                  this.service.getRelationships('region', urn2D, encodedName2D, regionId));case 2:_yield$this$service$g = _context6.sent;_yield$this$service$g2 = _slicedToArray(_yield$this$service$g, 1);relationship = _yield$this$service$g2[0]; // Get first relationship
                relatedModel = relationship === null || relationship === void 0 ? void 0 : relationship.entities.find(function (e) {return e.type === 'viewable';});if (

                relatedModel) {_context6.next = 8;break;}throw (
                  'No related model found for sheet to model transition');case 8:


                model2D.regionId = regionId; // Save in model, in case the sheet is realigned (so it won't create a new region)
                _relatedModel$id$spli =
                relatedModel.id.split('&'), _relatedModel$id$spli2 = _slicedToArray(_relatedModel$id$spli, 2), urn3D = _relatedModel$id$spli2[0], name3D = _relatedModel$id$spli2[1];

                urn3D = urn3D.slice(Prefix.Urn.length);
                name3D = name3D.slice(Prefix.Name.length);

                nodePromise = this.getRelatedModelNode(model2D, urn2D, urn3D, name3D);
                tfAndCropPromise = this.getTransformAndCrop(urn2D, encodedName2D, regionId);return _context6.abrupt("return",

                Promise.all([nodePromise, tfAndCropPromise]).then(function (res) {return _objectSpread(_objectSpread({},
                  res[0]), res[1]);}));case 15:case "end":return _context6.stop();}}}, _callee6, this);}));function getDocumentAndTransformFromService(_x4, _x5, _x6, _x7) {return _getDocumentAndTransformFromService.apply(this, arguments);}return getDocumentAndTransformFromService;}() }, { key: "getDocumentAndTransform", value: function () {var _getDocumentAndTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(



      model) {var vpMetadata, viewports, viewport, urn2D, encodedName2D, regionId;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:_context7.next = 2;return (
                  this.fetchViewportsForModel(model));case 2:vpMetadata = _context7.sent; // Should be cached by now (when creating UI)
                viewports = vpMetadata.viewports;
                viewport = viewports[0]; // Taking the first viewport for now. Eventually need to provide an option here

                vpMetadata.model = model; // Save the model in cache to restore its state later (showing page, clear transform, etc.)
                if (
                viewport.cachedDocAndTransform) {_context7.next = 16;break;}if (!
                vpMetadata.isFromAEC) {_context7.next = 11;break;}
                viewport.cachedDocAndTransform = this.getDocumentAndTransformFromAEC(model, viewport);_context7.next = 16;break;case 11:
                // isFromService
                urn2D = vpMetadata.urn2D, encodedName2D = vpMetadata.encodedName2D;
                regionId = viewport.id;_context7.next = 15;return (
                  this.getDocumentAndTransformFromService(model, urn2D, encodedName2D, regionId));case 15:viewport.cachedDocAndTransform = _context7.sent;case 16:return _context7.abrupt("return",



                viewport.cachedDocAndTransform);case 17:case "end":return _context7.stop();}}}, _callee7, this);}));function getDocumentAndTransform(_x8) {return _getDocumentAndTransform.apply(this, arguments);}return getDocumentAndTransform;}() }, { key: "transition2Dto3D", value: function () {var _transition2Dto3D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {var model2D, doc, bubbleNode, matrix, crop, _yield$this$getDocume;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:



                model2D = this.getSuitable2DModel();if (
                model2D) {_context8.next = 4;break;}
                console.warn('No suitable 2D model found for sheet to model transition');return _context8.abrupt("return");case 4:_context8.prev = 4;_context8.next = 7;return (





                  this.getDocumentAndTransform(model2D));case 7:_yield$this$getDocume = _context8.sent;doc = _yield$this$getDocume.doc;bubbleNode = _yield$this$getDocume.bubbleNode;matrix = _yield$this$getDocume.matrix;crop = _yield$this$getDocume.crop;_context8.next = 19;break;case 14:_context8.prev = 14;_context8.t0 = _context8["catch"](4);

                this.displayError(Autodesk.Viewing.i18n.translate('No suitable model found for transition.'));
                console.warn(_context8.t0);return _context8.abrupt("return");case 19:



                // Prevent sheets from getting cut by cutplanes
                model2D.setDoNotCut(this.viewer.impl.matman(), true);

                // First transition to showing whole sheet. Lock navigation until transition is finished.
                this.viewer.setNavigationLock(true);_context8.next = 23;return (
                  this.fitToBoundsWithAnimation(model2D));case 23:

                // Set the transform to the sheet
                model2D.setPlacementTransform(matrix);
                this.fitAfterTransformImmediate(model2D, matrix);

                // Show the 3D model
                _context8.next = 27;return this.showRelatedDocument(bubbleNode, doc);case 27:_context8.next = 29;return (



                  this.setCutPlane(matrix));case 29:

                // Navigation is free from this point
                this.viewer.setNavigationLock(false);

                // Hide paper and crop to viewport
                this.viewer.impl.changePaperVisibility(model2D, false, true, null, HIDE_DURATION);
                if (crop) {
                  this.setViewportBounds(model2D, crop, HIDE_DURATION);
                }case 32:case "end":return _context8.stop();}}}, _callee8, this, [[4, 14]]);}));function transition2Dto3D() {return _transition2Dto3D.apply(this, arguments);}return transition2Dto3D;}()


    // Pass endBox=null to reset to original bounds
    // Pass a duration > 0 to animate
  }, { key: "setViewportBounds", value: function setViewportBounds(model, endBox, duration) {var _this4 = this;
      if (model.isLeaflet()) {
        //TODO - Leaflet models are based on MeshBasicMaterial.
        // We need to find another way to change their viewport bounds.
        // One idea is to change it inside ModelIteratorTexQuad directly, by changing the texture's UV.
        return;
      }

      var startBox = model.getBoundingBox(true, true);
      var dstBox = new THREE.Box3();
      var matman = this.viewer.impl.matman();
      var modelMaterials = matman.getModelMaterials(model);

      var mats = Object.values(modelMaterials.mats);
      var matsNonHDR = Object.values(modelMaterials.matsNonHDR);
      var selectionMats = Object.values(modelMaterials.selectionMats);

      var setViewportBounds = function setViewportBounds() {
        var cb = function cb(m) {return matman.setMaterialViewportBounds(m, endBox ? dstBox : null);};
        mats.forEach(cb);
        matsNonHDR.forEach(cb);
        selectionMats.forEach(cb);
      };

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        dstBox.min.lerpVectors(startBox.min, endBox.min, t);
        dstBox.max.lerpVectors(startBox.max, endBox.max, t);

        setViewportBounds();
        _this4.viewer.impl.invalidate(true);
      };
      var onFinished = function onFinished() {
        _this4.viewportBoundsAnim = null;
      };

      if (duration === 0) {// Call directly
        setViewportBounds();
      } else {
        this.viewportBoundsAnim = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onFinished);
      }
    }

    // From matrix we take only position and rotation. Scale will come from fitBounds.
  }, { key: "fitAfterTransformImmediate", value: function fitAfterTransformImmediate(model, matrix) {
      var pos = new THREE.Vector3();
      var rotate = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      matrix.decompose(pos, rotate, scale);

      var camera = this.viewer.getCamera();
      var matrixWithoutScale = new THREE.Matrix4();
      matrixWithoutScale.makeRotationFromQuaternion(rotate);
      matrixWithoutScale.setPosition(pos);
      camera.applyMatrix4(matrixWithoutScale);
      camera.updateCameraMatrices();

      this.fitToBounds(model);
    } }, { key: "fitToBounds", value: function fitToBounds(

    model) {
      var bounds = model.getVisibleBounds();
      // fitBounds will also set the pivot point from the camera's target
      this.viewer.navigation.fitBounds(true, bounds, false, true);
    } }, { key: "fitToBoundsWithAnimation", value: function () {var _fitToBoundsWithAnimation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(

      model) {var _this5 = this;var FLY_TO_TIME, bounds2D, camera, fit, dstView;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
                FLY_TO_TIME = 1.0;
                bounds2D = model.getVisibleBounds();
                camera = this.viewer.getCamera();
                fit = this.viewer.navigation.computeFit(camera.position, camera.target, camera.fov, bounds2D, camera.aspect);

                dstView = {
                  position: fit.position,
                  target: fit.target,
                  up: camera.up };return _context9.abrupt("return",


                new Promise(function (resolve) {
                  Autodesk.Viewing.Private.flyToView(_this5.viewer, dstView, FLY_TO_TIME, function () {
                    // Wait a frame for last invalidate to take hold, before allowing to continue.
                    // Avoids a graphical glitch when the 3D model is already loaded
                    setTimeout(resolve);
                  }, false);
                }));case 6:case "end":return _context9.stop();}}}, _callee9, this);}));function fitToBoundsWithAnimation(_x9) {return _fitToBoundsWithAnimation.apply(this, arguments);}return fitToBoundsWithAnimation;}() }, { key: "setCutPlane", value: function () {var _setCutPlane = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(


      matrix) {var pos, rot, scale, sectionExt, normal, prevLock;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:
                pos = new THREE.Vector3();
                rot = new THREE.Quaternion();
                scale = new THREE.Vector3();
                matrix.decompose(pos, rot, scale);_context10.next = 6;return (
                  this.viewer.getExtensionAsync('Autodesk.Section'));case 6:sectionExt = _context10.sent;
                // Assuming original's sheet normal is +Z (which should be the case)
                normal = new THREE.Vector3(0, 0, 1);
                normal.applyQuaternion(rot);

                // Tool controller can be locked if the user tries an interaction such as panning
                prevLock = this.viewer.toolController.setIsLocked(false);
                sectionExt.setSectionPlane(normal, pos, false);
                this.viewer.toolController.setIsLocked(prevLock);case 12:case "end":return _context10.stop();}}}, _callee10, this);}));function setCutPlane(_x10) {return _setCutPlane.apply(this, arguments);}return setCutPlane;}() }, { key: "getRelatedModelNode", value: function () {var _getRelatedModelNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(


      model2D, urn2D, urn3D, name3D) {var doc;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:if (!(

                urn3D === urn2D)) {_context11.next = 4;break;}
                doc = model2D.getDocumentNode().getDocument();_context11.next = 14;break;case 4:_context11.prev = 4;_context11.next = 7;return (


                  this.loadRelatedDocument(urn3D));case 7:doc = _context11.sent;_context11.next = 14;break;case 10:_context11.prev = 10;_context11.t0 = _context11["catch"](4);

                console.warn('Could not load related model', _context11.t0);return _context11.abrupt("return");case 14:return _context11.abrupt("return",




                { doc: doc, bubbleNode: this.getNode(doc, name3D) });case 15:case "end":return _context11.stop();}}}, _callee11, this, [[4, 10]]);}));function getRelatedModelNode(_x11, _x12, _x13, _x14) {return _getRelatedModelNode.apply(this, arguments);}return getRelatedModelNode;}() }, { key: "getTransformAndCrop", value: function () {var _getTransformAndCrop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(


      urn2D, name2D, regionId) {var tfPromise, cropPromise;return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:
                tfPromise = this.service.loadTransform(urn2D, name2D, regionId);
                cropPromise = this.service.loadViewport(urn2D, name2D, regionId);return _context12.abrupt("return",

                Promise.all([tfPromise, cropPromise]).then(function (res) {var _res$;return {
                    matrix: res[0],
                    crop: (_res$ = res[1]) === null || _res$ === void 0 ? void 0 : _res$.bbox };}));case 3:case "end":return _context12.stop();}}}, _callee12, this);}));function getTransformAndCrop(_x15, _x16, _x17) {return _getTransformAndCrop.apply(this, arguments);}return getTransformAndCrop;}() }, { key: "getNode", value: function getNode(



    doc, name) {
      var rootNode = doc.getRoot();
      var node;
      if (name) {
        node = rootNode.search({ name: name })[0];
      }

      // If no guid is specified, just load first 3D viewable
      if (!node) {
        node = rootNode.search({ type: 'geometry' })[0];
      }

      return node;
    }

    // Default loadRelatedDocument function. Can be overriden through options
  }, { key: "_loadRelatedDocument", value: function _loadRelatedDocument(urn) {
      return new Promise(function (resolve, reject) {
        Autodesk.Viewing.Document.load(
        'urn:' + urn,
        function (doc) {
          doc.downloadAecModelData(function () {
            resolve(doc);
          });
        },
        reject);

      });
    }

    // Default showRelatedDocument function. Can be overriden through options
    // Returns the loaded model
  }, { key: "_showRelatedDocument", value: function () {var _showRelatedDocument2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(bubbleNode, doc) {var options;return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:
                options = {
                  applyRefPoint: true,
                  bubbleNode: bubbleNode,
                  disablePrecomputedNodeBoxes: true,
                  preserveView: true,
                  disable3DModelLayers: true,
                  keepCurrentModels: true };_context13.next = 3;return (


                  this.viewer.loadDocumentNode(doc, bubbleNode, options));case 3:return _context13.abrupt("return", _context13.sent);case 4:case "end":return _context13.stop();}}}, _callee13, this);}));function _showRelatedDocument(_x18, _x19) {return _showRelatedDocument2.apply(this, arguments);}return _showRelatedDocument;}()


    // Default displayError function. Can be overriden through options
  }, { key: "_displayError", value: function _displayError(message) {
      Autodesk.Viewing.Private.AlertBox.displayError(this.viewer.container, message, 'Model Sheet Transition');
    } }]);return ModelSheetTransitionExtension;}(Autodesk.Viewing.Extension);


namespace.ModelSheetTransitionExtension = ModelSheetTransitionExtension;
// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, ModelSheetTransitionExtension);

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js":
/*!***********************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js ***!
  \***********************************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-modelSheetTransition.loc.json */ "./res/locales/en/nobundle-modelSheetTransition.loc.json");
var _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-modelSheetTransition.loc.json */ "./res/locales/en/nobundle-modelSheetTransition.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".viewericon-model-sheet-transition:before {\n  font-family: 'modelSheetTransitionIcon';\n  content: \"M\"; }\n\n@font-face {\n  font-family: 'modelSheetTransitionIcon';\n  src: url(\"data:application/font-woff;base64,d09GRgABAAAAAAP8AAoAAAAABjgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAAA9AAAAD4AAABWVsFjP2NtYXAAAAE0AAAAPAAAAUoArAFrZ2x5ZgAAAXAAAADAAAAAwMOBpSJoZWFkAAACMAAAACsAAAA2GlHbmWhoZWEAAAJcAAAAGwAAACQIPQQDaG10eAAAAngAAAAIAAAACAgAAABsb2NhAAACgAAAAAYAAAAGAGAAAG1heHAAAAKIAAAAIAAAACABEABGbmFtZQAAAqgAAAE7AAACbdWMZSRwb3N0AAAD5AAAABUAAAApARAAAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGBwYfBl8WUDcGBaIMCOIAACZnwe0AAB4nGNgYGBmgGAZBkYGEHAB8hjBfBYGDSDNBqQZGZiALN///8EqwPT/LVD1QMDIxkBdwEhYyWADAMFRBxMABAAAAAAD4AQAACEAKQAxADkAAAEuAicjJSMmIgcFBgcGBxQVER4BFwUXMyU+ATURNCc4AQEmLwERBREwEyYvASUNATABBg8BESURMAPeAQUFAwP+SQUJFQn+TQYEBwUBDQsBsQ0ZAbcLDQL9+BacsgFkKhaUqgFUAVP+rQGNF5yyAWUDFAUHBgPSBQXNBAcGCQUG/eEMFAXABcIFFAwCIgUG/VQJRU8BxJ3+PAILCkJLoaGX/pIKRU4BxJ3+PAB4nGNgZGBgAOKs5tdr4/ltvjJwszCAwO2Vp/2QaeYHYHEOBiYQBQBAlgphAHicY2BkYGBhAIIYMMnA/ICBkQEVMAEAG9IBTAAEAAAABAAAAAAAAAAAYAAAAAEAAAACADoABAAAAAAAAgAAAAoACgAAAP8AAAAAAAB4nHWPS07DMBCGf/cFtBKqqGCH5AViASh9iFU37Jp9F92nrdOH0jhy3Eo9AOfhCJyAI9AbcAd+0gGhUmJ5/M03k3EC4AI7KOyfS+49K5wy23MJJ7gWLtPfCFfID8JVNPAoXKN/Eq7jHqFwAy04TlCVM2Z3eBZWaOJFuIRzvAqX6d+EK+R34Squ8CFcQ1OVhesYqZZwA7dqEZrUuMibqR5vdZhss7k37vscmtk6idyhHhmXL2yqu0Hnp/R7TL6Z9byPdezsSg9s6k2SWJ05uzQTH8y9z/rtdiw+mNgVf98g5XaI4HlOoTHGljFEwjPDvPDuTz5knGFNGx2pHuajIuZYwPI+jS4CdI689d/X5Njwth6tR8w8Zo/FijQoJn51J1yWJitqS5oJfVBM97R9tLnig/6AXZz0CTRjb6QAeJxjYGKAAC4G7AAozwhSAwAB1gASAAAA\") format(\"woff\");\n  font-weight: normal;\n  font-style: normal; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./res/locales/en/nobundle-modelSheetTransition.loc.json":
/*!***************************************************************!*\
  !*** ./res/locales/en/nobundle-modelSheetTransition.loc.json ***!
  \***************************************************************/
/*! exports provided: @@locale, @@context, Show in 3D context, Fetching alignment information..., Current view is not supported by Show in 3D context, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"ModelSheetTransition Extension\",\"Show in 3D context\":\"Show in 3D context\",\"Fetching alignment information...\":\"Fetching alignment information...'\",\"Current view is not supported by Show in 3D context\":\"Current view is not supported by Show in 3D context\"}");

/***/ })

/******/ });
//# sourceMappingURL=ModelSheetTransition.js.map