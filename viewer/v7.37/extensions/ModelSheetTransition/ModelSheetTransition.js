/*!
 * LMV v7.37.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelSheetTransition =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelSheetTransition/ModelSheetTransition.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/AEC/common/AecModelData.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/common/AecModelData.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. 
// Currently only available for Revit files.
//

var isUsingModelSheetTransform = function isUsingModelSheetTransform() {return Autodesk.Viewing.getGlobal().AEC_MODELTOSHEET_TRANSFORM;};

var namespace = AutodeskNamespace('Autodesk.AEC');

// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.
var remapRectangle = function remapRectangle(
xMinFrom, yMinFrom, xMaxFrom, yMaxFrom,
xMinTo, yMinTo, xMaxTo, yMaxTo)
{
  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);
  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);

  // Note that the translation component of the matrix works on the scaled values.
  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want 
  // to map it to xMinTo instead. (analog for y)
  var offsetX = xMinTo - scaleX * xMinFrom;
  var offsetY = yMinTo - scaleY * yMinFrom;

  // Create Matrix4 that applies both
  var matrix = new THREE.Matrix4();
  matrix.elements[0] = scaleX;
  matrix.elements[5] = scaleY;
  matrix.elements[12] = offsetX;
  matrix.elements[13] = offsetY;
  return matrix;
};

var getFeetToSheetUnits = function getFeetToSheetUnits(sheetUnitScale) {
  var FeetToMeter = 0.3048;
  var MeterToSheetUnits = 1.0 / sheetUnitScale;
  return FeetToMeter * MeterToSheetUnits;
};

// Returns the 2D bbox of a viewport on a sheet.
// 
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
// @returns {THREE.Box2|null}
var getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {

  // viewport region in foot as array (6 floats)
  var values = vp.geometryViewportRegion;
  if (!values) {
    return null;
  }

  // Convert from foot to sheet units (usually inches)
  var scale = getFeetToSheetUnits(sheetUnitScale);

  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.
  // We remove that offset before scaling. 
  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)
  var boundsCorrection = 0.01;

  var res = new THREE.Box2();
  res.min.x = (values[0] + boundsCorrection) * scale;
  res.min.y = (values[1] + boundsCorrection) * scale;
  res.max.x = (values[3] - boundsCorrection) * scale;
  res.max.y = (values[4] - boundsCorrection) * scale;
  return res;
};

// Handle available view rotation modes in Revit
// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.
// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])
//
//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:
//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm
//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation
var getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {

  var matrix = new THREE.Matrix4();
  switch (viewRotationType) {
    // No rotation => done
    case 0:return matrix;

    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw
    case 1:{
        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the
        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.
        // Therefore, the desired effect of the matrix is:
        //
        //  (x, y) => (1-y, x)
        //
        // Note the memory layout of THREE matrices is column-major.

        // out.x = (1-y)
        matrix.elements[0] = 0; //  0 * in.x
        matrix.elements[4] = -1; // -1 * in.y
        matrix.elements[12] = 1; // + 1

        // out.y = x
        matrix.elements[1] = 1; // 1 * in.x
        matrix.elements[5] = 0; // 0 * in.y

        break;
      }

    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw
    case 2:{
        // Desired transform here is:
        //
        // (x, y) => (y, 1-x)

        // out.x = y
        matrix.elements[0] = 0; // 0 * in.x
        matrix.elements[4] = 1; // 1 * in.y

        // out.y = (1-x)
        matrix.elements[1] = -1; //    -in.x
        matrix.elements[5] = 0; // 0 * in.y
        matrix.elements[13] = 1; // + 1

        break;
      }
    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}

  return matrix;
};

// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.
//
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
//
// @returns {THREE.Matrix4|null} May return null if a viewport does not support a 2D/3D transform.
//
// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. 
var get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get the 3DTo2D matrix directly.
  if (isUsingModelSheetTransform() && vp.modelToSheetTransform) {
    var matrix = get3DTo2DMatrix(vp, sheetUnitScale);
    return matrix.getInverse(matrix);
  }

  // Viewport bbox on sheet (Box2)
  var sheetRegion = getViewportBounds(vp, sheetUnitScale);

  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume
  // that is mapped to the sheet.
  var sectionBox = vp.sectionBox;
  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var sheetToViewport = remapRectangle(
  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates
  0, 0, 1, 1 // ...to [0,1] 
  );

  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)
  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var viewportToSectionBox = remapRectangle(
  0, 0, 1, 1, // ...from normalized viewport coords
  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox
  );

  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.
  return sectionBoxTransform.
  multiply(viewportToSectionBox).
  multiply(vpRotationInv).
  multiply(sheetToViewport);
};

// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().
var get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get a matrix directly.
  if (isUsingModelSheetTransform() && vp.modelToSheetTransform) {

    // So far, we only support a single matrix per viewport
    var values = vp.modelToSheetTransform;
    var _matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(values);

    // apply post-scaling from feet to sheet-units
    // Note that using multiplyScalar() here is only similar, but not the same: E.g., it would also multiply component 15
    // which may cause weird side-effects when multiplying with other matrices.
    // The Z value of the scale is set to feetToSheetUnits as well so that getMaxScaleOnAxis
    // returns a meaningful result (used to be 1, which would skew the results)
    var feetToSheetUnits = getFeetToSheetUnits(sheetUnitScale);
    var scaleTf = new THREE.Matrix4().makeScale(feetToSheetUnits, feetToSheetUnits, feetToSheetUnits);
    _matrix.multiplyMatrices(scaleTf, _matrix);

    return _matrix;
  }

  var matrix = get2DTo3DMatrix(vp, sheetUnitScale);
  matrix.getInverse(matrix);
  return matrix;
};

// Find Sheet BubbleNode containing the given viewport.
//
//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets
//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)
//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).
var findSheetForViewport = function findSheetForViewport(root, vp) {
  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);
  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};
  return sheetNodes.find(linkedByVp);
};

// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.
// Note that not all viewports support 2D/3D transform.
//
//  @param {av.BubbleNode|av.Model} sheet
var findViewportsOnSheet = function findViewportsOnSheet(sheet) {

  // get aecModelData from model or node
  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;
  var sheetNode = isNode ? sheet : sheet.getDocumentNode();
  var aec = sheetNode.getAecModelData();
  if (!aec || !aec.viewports) {
    return [];
  }

  // Find viewports linking the sheet guid
  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});
};

// Given a sheet and a point on that sheet, this function returns the viewport containing it.
// If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
// where the distance from the viewport edges is largest.
//
//  @param {av.Model}         sheet
//  @param {Vector2}          point            - Point in sheet world-coords.
//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports
//
//  @returns {Object|undefined} 
var findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  // Find sheets linking this sheet
  var viewports = findViewportsOnSheet(sheet);

  // Apply option filter
  if (viewportFilter) {
    viewports = viewports.filter(viewportFilter);
  }

  // Couple each viewport with viewport bounds 
  viewports = viewports.map(function (vp) {
    return {
      viewport: vp,
      bounds: getViewportBounds(vp, sheet.getUnitScale()) };

  });

  // Reduce to viewports containing the given point
  var containsPoint = function containsPoint(vp) {
    return vp.bounds && vp.bounds.containsPoint(point);
  };
  viewports = viewports.filter(containsPoint);

  // Point may be outside of all viewports
  if (!viewports.length) {
    return;
  }

  // Viewports may overlap. For this case, we need a heuristic metric
  // to choose the best match. For this, we use the
  // distance to the viewport boundary edges.
  var distanceFromEdge = function distanceFromEdge(box, p) {
    return Math.min(
    Math.min(p.x - box.min.x, box.max.x - p.x),
    Math.min(p.y - box.min.y, box.max.y - p.y));

  };

  // Pick the viewport that minimizes distanceFromEdge
  var getBestMatch = function getBestMatch(vp1, vp2) {
    var d1 = distanceFromEdge(vp1.bounds, point);
    var d2 = distanceFromEdge(vp2.bounds, point);
    return d2 > d1 ? vp2 : vp1;
  };
  return viewports.reduce(getBestMatch).viewport;
};

// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)
//  @param {Object} vp - viewport object from aecModelData
//  @returns {string|undefined} levelGuid
var getLinkedLevel = function getLinkedLevel(vp) {

  // Viewports come directly from aecModelData json and do not always reference a level. 
  // So, we should not crash if anything is null here.
  var viewRange = vp.extensions && vp.extensions.viewRange;
  var cutPlane = viewRange && viewRange.cutPlane;
  return cutPlane && cutPlane.levelGuid;
};

// Find all viewports in the document that link the level indicated by levelGuid
//
// @param {Object} aecData   - as obtained from AECModelData.json
// @param {string} levelGuid
// @retuns {Object[]} Array of viewport data objects
var findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {

  // Find viewports that links this level
  var viewports = aecData.viewports || [];

  var matchesLevel = function matchesLevel(vp) {
    var vpLevelGuid = getLinkedLevel(vp);
    return vpLevelGuid === levelGuid;
  };
  return viewports.filter(matchesLevel);
};

// Find level in aecModelData that links the given viewport.
//
// @param {Object} aecData - as obtained from AECModelData.json
// @param {Object} viewport object
// @retuns {Object|undefined} level object from aecModelData
var findLevelForViewport = function findLevelForViewport(aecData, viewport) {
  var levelGuid = getLinkedLevel(viewport);

  // Search for a level with this levelGuid
  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};
  return levelGuid && aecData.levels.find(hasLevelGuid);
};

// Checks if a viewport provides all required information to compute a 2D/3D transform.
//  @param {Object} vp - vieport data object as obtained from AecModelData.json
var supports2DTo3DTransform = function supports2DTo3DTransform(vp) {

  // If AECModelData contains a modelToSheetTransform (only possible for models produced using latest RevitAPI changes), we get a matrix directly
  // and don't have to care for sectionBox or isCropBoxActive anymore.
  var canUseTransform = Boolean(isUsingModelSheetTransform() && vp.modelToSheetTransform);

  // Check if we can use the old code path to reverse-engineer the transform from the SectionBox
  var canUseWorkaround = Boolean(vp.sectionBox && vp.isCropBoxActive);

  // If neither of the two work, we can stop here.
  if (!canUseTransform && !canUseWorkaround) {
    return false;
  }

  // Viewport types for which we know that we get valid transform data.
  // For 'Section', it worked for some examples, but wasn't reliably enough to enable it by default yet.
  var supportedTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];

  return Boolean(supportedTypes.includes(vp.viewType) &&
  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)
  !vp.hasBreaks && // A view in Revit may be split into separate parts using "View breaks". This is not supported yet.
  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.
};

var AEC_CACHE = {};

// Returns all the fragments that belong to a specific dbId. This only takes the leaf nodes, so we can't
// just call enumNodeFragments with recurse directly.
var getLevelFragmentsIds = function getLevelFragmentsIds(instanceTree, levelDbId) {
  var leafIds = [];
  var _collectLeafNodeIds = function _collectLeafNodeIds(id) {
    var childCount = 0;
    instanceTree.enumNodeChildren(id, function (childId) {
      _collectLeafNodeIds(childId);
      childCount += 1;
    });
    if (childCount === 0) {
      leafIds.push(id);
    }
  };
  _collectLeafNodeIds(levelDbId);

  var fragIds = [];
  leafIds.forEach(function (leafId) {
    instanceTree.enumNodeFragments(leafId, function (fragId) {fragIds.push(fragId);});
  });
  return fragIds;
};

// This function holds heuristics around getting bounding boxes for levels:
// 1. Compute fuzzyBoundingBox to make sure things like pipes coming through multiple floors do not make bounding box too large
// 2. Given that levels are coming in bottom up order, we check that newly computed bounding box does not intersect with the last known level
//    and if it does, reduce the largest box among both levels. This step helps when bounding box is large by nature (e.g. due to high walls spreading over multiple levels)
var getLevelBoundingBox = function getLevelBoundingBox(dbId, model, lastLevel) {
  var instanceTree = model.getData().instanceTree;
  if (!instanceTree) {
    return;
  }

  var fragIds = getLevelFragmentsIds(instanceTree, dbId);
  var newBox = model.getFuzzyBox({ allowlist: fragIds });

  // If there is some levels in the storage already, we need to check for intersection
  if (lastLevel.min.z !== Infinity && lastLevel.max.z > newBox.min.z) {
    // there is an intersection and some box need to be cropped
    var newBoxHeight = Math.abs(newBox.max.z - newBox.min.z);
    var lastKnownBoxHeight = Math.abs(lastLevel.max.z - lastLevel.min.z);
    if (lastKnownBoxHeight > newBoxHeight) {
      lastLevel.max.z = lastLevel.min.z;
    } else {
      newBox.min.z = lastLevel.max.z;
    }
  }
  lastLevel.copy(newBox);
  return newBox;
};

var computeLevels = function computeLevels(levels, model) {
  // Need to get and apply opposite to elevation as it will be reapplied elsewhere
  var refPointTf = model.myData.placementWithOffset;
  if (!refPointTf) {
    refPointTf = new THREE.Matrix4();
  }

  var lastLevel = new THREE.Box3();
  levels.forEach(function (level, idx) {
    var levelBox = getLevelBoundingBox(level.dbId, model, lastLevel);
    if (levelBox && levelBox.min.z !== Infinity && levelBox.max.z !== Infinity) {
      level.elevation = levelBox.min.z - (refPointTf ? refPointTf.elements[14] : 0);
      if (idx === levels.length - 1) {
        level.height = model.getBoundingBox().max.z - levelBox.min.z;
      } else {
        level.height = levelBox.max.z - levelBox.min.z;
      }
    }
  });

  if (levels.some(function (l) {return !l.elevation;})) {
    console.warn('Failed to derive elevation for some levels');
    return;
  }

  var refP = [
  refPointTf.elements[0], refPointTf.elements[1], refPointTf.elements[2],
  refPointTf.elements[4], refPointTf.elements[5], refPointTf.elements[6],
  refPointTf.elements[8], refPointTf.elements[9], refPointTf.elements[10],
  refPointTf.elements[12], refPointTf.elements[13], refPointTf.elements[14]];

  var aecModelData = {
    version: '1.0.0', phases: [{ name: 'Default' }], levels: levels, scopeBoxes: [], refPointTransformation: refP };


  return aecModelData;
};

// Couple of queries used here will only work for OTG property database
// In order to make it work for SVF we need to use other property names, coming from Navisworks (Lc*)
var findLevelsOTG = function findLevelsOTG(onDone, onError, model) {
  model.search(
  'IFCBUILDING',
  function (dbIds) {
    model.getBulkProperties(
    dbIds, null,
    function (elements) {
      if (elements.length !== 1) {
        // Should find one element (if not, we consider it an edge case --maybe 2 buildings within
        // single IFC file-- for now and do nothing)
        return onDone(undefined);
      }
      var levelCandidates = elements[0].properties.
      filter(function (e) {return e.displayName === 'child';}) // get direct children
      .map(function (e) {return e.displayValue;}); // get dbId of each child

      model.getBulkProperties(
      levelCandidates, ['Name', 'Type'],
      function (levelElements) {
        // Levels are stored in Db as they are presented in IFC -> bottom up order, so we must not mess it up
        var levels = levelElements.map(function (lev) {
          var type = lev.properties.find(function (p) {return p.displayName === 'Type';});
          var name = lev.properties.find(function (p) {return p.displayName === 'Name';});
          // TODO: this might be localization dependent
          if (type && type.displayValue.includes('Level') && name) {
            return {
              // This likely does not matter too much, so just assign dbId to simplify debugging
              guid: lev.dbId,
              name: name.displayValue,
              // NOTE: elevation and height will be populated later
              dbId: lev.dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } };


          }
        }).filter(Boolean);

        onDone(levels);
      },
      onError);

    },
    onError);

  }, onError, ['Type']);

};

var findLevelsSVF = function findLevelsSVF(onDone, onError, model) {
  model.search(
  'IfcBuildingStorey',
  function (dbIds) {
    model.getBulkProperties(
    dbIds,
    ['Type', 'GUID', 'NAME', 'Name', 'ELEVATION', 'Elevation', 'IfcElevation'],
    function (elements) {
      var levels = [];
      for (var i = 0; i < elements.length; i++) {
        if (elements[i].properties.length > 1) {
          var guidIdx = elements[i].properties.findIndex(function (element) {return element.displayName === 'GUID';});
          var levelIdx = elements[i].properties.findIndex(function (element) {return element.displayValue === 'Levels: Level: Level 1';});
          var nameIdx = -1;
          var elevationIdx = -1;
          if (levelIdx >= 0) {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                (element.attributeName.toLowerCase() === 'name' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName') &&
                element.displayCategory === 'Item');});
          } else {
            nameIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName.toLowerCase() === 'name' && (
                element.displayCategory === 'IFC' ||
                element.attributeName === 'LcOaNode:LcOaSceneBaseUserName' &&
                element.displayCategory === 'Item' ||
                element.attributeName ===
                'LcRevitData_Element:LcRevitPropertyElementName' &&
                element.displayCategory === 'Element'));});
            elevationIdx = elements[i].properties.findIndex(function (element) {return (
                element.displayName === 'ELEVATION' &&
                element.displayCategory === 'IFC' ||
                (element.displayName === 'IfcElevation' ||
                element.displayName === 'Elevation') &&
                element.displayCategory === 'Element');});
          }
          if (nameIdx >= 0 && (elevationIdx >= 0 || levelIdx >= 0)) {
            levels.push({
              guid: guidIdx > -1 ? elements[i].properties[guidIdx].displayValue : elements[i].dbId,
              name: elements[i].properties[nameIdx].displayValue,
              dbId: elements[i].dbId,
              extension: {
                buildingStory: true,
                structure: false,
                computationHeight: 0,
                groundPlane: false,
                hasAssociatedViewPlans: false } });


          }
        }
      }

      onDone(levels);
    },
    onError);

  },
  onError, ['Type']);

};

var computeAecModelDataForIfc = function computeAecModelDataForIfc(model, cacheKey) {
  if (!model) {
    return null;
  }

  if (AEC_CACHE[cacheKey]) {// We had a heavy computation already, return result from cache
    return AEC_CACHE[cacheKey];
  }

  var promise = new Promise(function (resolve) {
    var onDone = function onDone(levels) {
      if (!levels || !levels.length) {
        return resolve(null);
      }

      var aecModelData = computeLevels(levels, model);
      if (cacheKey) {
        AEC_CACHE[cacheKey] = Object.assign({}, aecModelData);
      }
      resolve(aecModelData);
    };

    var onError = function onError(error) {
      console.error(error);
      resolve(null);
    };

    if (model.isOTG()) {
      findLevelsOTG(onDone, onError, model);
    } else {
      findLevelsSVF(onDone, onError, model);
    }
  });

  if (cacheKey) {
    // Cache the promise so if this is called multiple times it won't start the same computation in parallel
    AEC_CACHE[cacheKey] = promise;
  }

  return promise;
};

var AecModelData = {
  get2DTo3DMatrix: get2DTo3DMatrix,
  get3DTo2DMatrix: get3DTo2DMatrix,
  getViewportBounds: getViewportBounds,
  remapRectangle: remapRectangle,
  findSheetForViewport: findSheetForViewport,
  findViewportsForLevel: findViewportsForLevel,
  supports2DTo3DTransform: supports2DTo3DTransform,
  getLinkedLevel: getLinkedLevel,
  findViewportsOnSheet: findViewportsOnSheet,
  findViewportAtPoint: findViewportAtPoint,
  findLevelForViewport: findLevelForViewport,
  computeAecModelDataForIfc: computeAecModelDataForIfc };


/* harmony default export */ __webpack_exports__["default"] = (AecModelData);

namespace.AecModelData = AecModelData;

/***/ }),

/***/ "./extensions/ModelSheetTransition/BoundsPlane.js":
/*!********************************************************!*\
  !*** ./extensions/ModelSheetTransition/BoundsPlane.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BoundsPlane; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var FillOpacity = 0.7;
var EdgeOpacity = 1.0;
var FadeDuration = 0.3; // In seconds
var
BoundsPlane = /*#__PURE__*/function () {
  function BoundsPlane(viewer, overlayName) {_classCallCheck(this, BoundsPlane);
    this.viewer = viewer;
    this.overlayName = overlayName;
    this.materialManager = viewer.impl.matman();
    this.isVisible = false;
    this.lock = false;
  }_createClass(BoundsPlane, [{ key: "createBoundsPlane", value: function createBoundsPlane()

    {
      this.viewer.impl.createOverlayScene(this.overlayName);
      // Fill geometry
      var geometry = new THREE.PlaneBufferGeometry(1, 1);

      var points = [];
      points.push(new THREE.Vector3(-0.5, -0.5, 0));
      points.push(new THREE.Vector3(-0.5, 0.5, 0));
      points.push(new THREE.Vector3(0.5, 0.5, 0));
      points.push(new THREE.Vector3(0.5, -0.5, 0));

      // Outline geometry
      var linesGeometry = new THREE.Geometry();
      var verts = linesGeometry.vertices;
      verts.push(points[0]);
      verts.push(points[1]);

      verts.push(points[1]);
      verts.push(points[2]);

      verts.push(points[2]);
      verts.push(points[3]);

      verts.push(points[3]);
      verts.push(points[0]);

      this.fillMaterial = new THREE.MeshPhongMaterial({
        color: 0xCDEAF7,
        specular: 0x000000,
        transparent: true,
        opacity: FillOpacity,
        polygonOffset: true,
        polygonOffsetFactor: 1.0,
        polygonOffsetUnits: 5,
        depthTest: false,
        depthWrite: false });

      this.edgeMaterial = new THREE.LineBasicMaterial({
        color: 0x000000,
        side: THREE.DoubleSide,
        opacity: EdgeOpacity,
        transparent: true,
        depthTest: false,
        depthWrite: false });

      this.fillMaterial.doNotCut = true;
      this.edgeMaterial.doNotCut = true;

      this.solidName = this.materialManager._getMaterialHash(null, 'ModelSheetTransition.solid');
      this.materialManager.addMaterial(this.solidName, this.fillMaterial, true);

      this.edgesName = this.materialManager._getMaterialHash(null, 'ModelSheetTransition.edges');
      this.materialManager.addMaterialNonHDR(this.edgesName, this.edgeMaterial);

      var boundariesMesh = new THREE.Mesh(geometry, this.fillMaterial);
      var lineMesh = new THREE.Line(linesGeometry, this.edgeMaterial, THREE.LinePieces);
      var boundsGroup = new THREE.Group();
      boundsGroup.add(boundariesMesh);
      boundsGroup.add(lineMesh);

      boundsGroup.matrixAutoUpdate = false;

      return boundsGroup;
    } }, { key: "getBoundsPlane", value: function getBoundsPlane()

    {
      if (!this.boundsPlane) {
        this.boundsPlane = this.createBoundsPlane();
      }

      return this.boundsPlane;
    } }, { key: "setFromMatrix", value: function setFromMatrix(

    matrix) {
      var boundsPlane = this.getBoundsPlane();

      boundsPlane.matrix.copy(matrix);
      boundsPlane.matrixWorldNeedsUpdate = true;
    }

    // Set the material opacitiy to a percentage of their full value
  }, { key: "setMaterialsOpacity", value: function setMaterialsOpacity(t) {
      this.fillMaterial.opacity = t * FillOpacity;
      this.edgeMaterial.opacity = t * EdgeOpacity;
      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "setVisible", value: function setVisible(

    isVisible) {var _this = this;var withAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (this.isVisible === isVisible) {
        return;
      }

      if (this.fadeAnim) {
        this.fadeAnim.stop();
        this.fadeAnim = null;
      }

      this.isVisible = isVisible;
      var boundsPlane = this.getBoundsPlane();

      var startValue = isVisible ? 0 : 1;

      if (isVisible) this.viewer.impl.addOverlay(this.overlayName, boundsPlane);

      if (withAnimation) {
        var onTimer = function onTimer(t) {
          t = Autodesk.Viewing.Private.smootherStep(t);
          _this.setMaterialsOpacity(t);
        };

        var onFadeEnd = function onFadeEnd() {
          if (!isVisible) _this.viewer.impl.removeOverlay(_this.overlayName, boundsPlane);
          _this.fadeAnim = null;
        };

        this.fadeAnim = Autodesk.Viewing.Private.fadeValue(startValue, 1 - startValue, FadeDuration, onTimer, onFadeEnd);
      } else {
        if (isVisible) {
          this.setMaterialsOpacity(1);
        } else {
          this.viewer.impl.removeOverlay(this.overlayName, boundsPlane);
        }
      }

      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "destroy", value: function destroy()

    {
      this.setVisible(false);

      if (this.solidName) {
        this.materialManager.removeMaterial(this.solidName);
        this.materialManager.removeMaterial(this.edgesName);
      }

      this.viewer.impl.removeOverlayScene(this.overlayName);
    } }]);return BoundsPlane;}();

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetCommon.js":
/*!*************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetCommon.js ***!
  \*************************************************************/
/*! exports provided: getSuitable2DModel, setCutPlane, setViewportBounds, resetModelTransformAndViewport, fitAfterTransformImmediate, fitToBounds, fitToBoundsWithAnimation, fitCameraToSheet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSuitable2DModel", function() { return getSuitable2DModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCutPlane", function() { return setCutPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setViewportBounds", function() { return setViewportBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetModelTransformAndViewport", function() { return resetModelTransformAndViewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitAfterTransformImmediate", function() { return fitAfterTransformImmediate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitToBounds", function() { return fitToBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitToBoundsWithAnimation", function() { return fitToBoundsWithAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitCameraToSheet", function() { return fitCameraToSheet; });
/* harmony import */ var _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelSheetConstants */ "./extensions/ModelSheetTransition/ModelSheetConstants.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}

var getSuitable2DModel = function getSuitable2DModel(viewer) {
  return viewer.impl.is2d && viewer.impl.get2DModels()[0];
};

var setCutPlane = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(viewer, matrix) {var pos, rot, scale, sectionExt, normal, prevLock;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
            pos = new THREE.Vector3();
            rot = new THREE.Quaternion();
            scale = new THREE.Vector3();
            matrix.decompose(pos, rot, scale);_context.next = 6;return (
              viewer.getExtensionAsync('Autodesk.Section'));case 6:sectionExt = _context.sent;
            // Assuming original's sheet normal is +Z (which should be the case)
            normal = new THREE.Vector3(0, 0, 1);
            normal.applyQuaternion(rot);

            // Tool controller can be locked if the user tries an interaction such as panning
            prevLock = viewer.toolController.setIsLocked(false);
            sectionExt.setSectionPlane(normal, pos, false);
            viewer.toolController.setIsLocked(prevLock);case 12:case "end":return _context.stop();}}}, _callee);}));return function setCutPlane(_x, _x2) {return _ref.apply(this, arguments);};}();


// Pass endBox=null to reset to original bounds
// Pass a duration > 0 to animate
var setViewportBounds = function () {
  var viewportBoundsAnim = null;

  var convertToBox3 = function convertToBox3(box) {
    if (!box || box instanceof THREE.Box3) {
      return box;
    }

    // The crop box that is passed sometimes contains only (x, y).
    // To make the lerping consistent this converts the box to a Box3
    box.min.z = box.max.z = 0;
    return new THREE.Box3(box.min, box.max);
  };

  return /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(viewer, model, endBox, duration) {var dstBox, originalBounds, currentBounds, startBox, setBounds, onTimer;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
              if (viewportBoundsAnim) {
                viewportBoundsAnim.stop();
                viewportBoundsAnim = null;
              }if (!

              model.isLeaflet()) {_context2.next = 3;break;}return _context2.abrupt("return");case 3:






              dstBox = new THREE.Box3();

              // The initial box is the bounding box
              originalBounds = model.getBoundingBox(true, false).clone();

              // If the cropping area was changed from the initial one, get the current one
              currentBounds = model.getViewportBounds();

              // When endBox is null, it means we want to restore the original box
              startBox = currentBounds || originalBounds;
              endBox = convertToBox3(endBox) || originalBounds;

              setBounds = function setBounds() {
                viewer.impl.setViewportBounds(model, dstBox);
              };

              onTimer = function onTimer(t) {
                t = Autodesk.Viewing.Private.smootherStep(t);
                dstBox.min.lerpVectors(startBox.min, endBox.min, t);
                dstBox.max.lerpVectors(startBox.max, endBox.max, t);

                setBounds();
              };return _context2.abrupt("return",

              new Promise(function (resolve) {
                var onFinished = function onFinished() {
                  viewportBoundsAnim = null;
                  setTimeout(resolve);
                };

                if (duration === 0) {// Call directly
                  dstBox.copy(endBox);
                  setBounds();
                  resolve();
                } else {
                  viewportBoundsAnim = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onFinished);
                }
              }));case 11:case "end":return _context2.stop();}}}, _callee2);}));return function (_x3, _x4, _x5, _x6) {return _ref2.apply(this, arguments);};}();

}();

var resetModelTransformAndViewport = function resetModelTransformAndViewport(viewer, model) {
  // Reset transform
  viewer.impl.setPlacementTransform(model, new THREE.Matrix4());

  model.changePaperVisibility(true);
  viewer.impl.setDoNotCut(model, true);

  // Reset viewport bounds (without animation - duration set to 0)
  setViewportBounds(viewer, model, null, 0);
  fitToBounds(viewer, model);

  viewer.impl.invalidate(true);
};

// When transitioning from 2D to 3D, the sheet might end in a completely different position.
// Assuming the sheet has already been fitted, and applying the transform to the camera, we make sure the fitting remains
// while still facing the sheet.
var fitAfterTransformImmediate = function fitAfterTransformImmediate(viewer, matrix) {
  var camera = viewer.getCamera();
  camera.applyMatrix4(matrix);
  camera.updateCameraMatrices();
  // Set pivot point to current target
  viewer.navigation.setPivotPoint(camera.target);
  viewer.navigation.setPivotSetFlag(true);
};

var fitToBounds = function fitToBounds(viewer, model) {
  var bounds = model.getVisibleBounds();
  // fitBounds will also set the pivot point from the camera's target
  viewer.navigation.fitBounds(true, bounds, false, true);
};

var fitToBoundsWithAnimation = /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(viewer, model) {var bounds, camera, fit, dstView;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
            bounds = model.getVisibleBounds();
            camera = viewer.getCamera();
            fit = viewer.navigation.computeFit(camera.position, camera.target, camera.fov, bounds, camera.aspect);

            dstView = {
              position: fit.position,
              target: fit.target,
              up: camera.up };return _context3.abrupt("return",


            new Promise(function (resolve) {
              Autodesk.Viewing.Private.flyToView(viewer, dstView, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["FLY_TO_DURATION"], function () {
                // Wait a frame for last invalidate to take hold, before allowing to continue.
                // Avoids a graphical glitch when the 3D model is already loaded
                setTimeout(resolve);
              }, false);
            }));case 5:case "end":return _context3.stop();}}}, _callee3);}));return function fitToBoundsWithAnimation(_x7, _x8) {return _ref3.apply(this, arguments);};}();


var fitCameraToSheet = function fitCameraToSheet(viewer, model) {
  viewer.navigation.toOrthographic();

  var bbox = model.getBoundingBox(true, false).clone();

  var matrix = model.getModelToViewerTransform() || new THREE.Matrix4();
  var center = bbox.center();

  // Set the center of the sheet as the target, then move away in the z direction towards the camera
  // to set the desired position. Then apply transform to both.
  // Using this as parameters for computeFit will give us the destination that would be the same as fit To View.
  var position = center.clone();
  position.z += bbox.size().y;
  position.applyMatrix4(matrix);

  var target = center.applyMatrix4(matrix);

  var rotation = new THREE.Matrix4();
  rotation.extractRotation(matrix);

  // Apply rotation to up vector - according to 2D model default up direction.
  var up = new THREE.Vector3(0, 1, 0).applyMatrix4(rotation).normalize();

  // Transform box to the current state
  bbox.applyMatrix4(matrix);var _viewer$getCamera =

  viewer.getCamera(),fov = _viewer$getCamera.fov,aspect = _viewer$getCamera.aspect;
  var fit = viewer.navigation.computeFit(position, target, fov, bbox, aspect);
  var dstView = {
    position: fit.position,
    target: fit.target,
    up: up };


  return new Promise(function (resolve) {
    Autodesk.Viewing.Private.flyToView(viewer, dstView, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["FIT_TO_SHEET_DURATION"], function () {
      // Wait a frame for last invalidate to take hold, before allowing to continue.
      // Avoids a graphical glitch
      setTimeout(resolve);
    }, false);
  });
};

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetConstants.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetConstants.js ***!
  \****************************************************************/
/*! exports provided: HIDE_DURATION, SHOW_DURATION, FLY_TO_DURATION, FIT_TO_SHEET_DURATION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIDE_DURATION", function() { return HIDE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW_DURATION", function() { return SHOW_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLY_TO_DURATION", function() { return FLY_TO_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIT_TO_SHEET_DURATION", function() { return FIT_TO_SHEET_DURATION; });
var HIDE_DURATION = 2.5; // In seconds
var SHOW_DURATION = 1.5; // In seconds
var FLY_TO_DURATION = 1.0; // In seconds
var FIT_TO_SHEET_DURATION = 0.5; // In seconds

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransition.css":
/*!******************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransition.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./ModelSheetTransition.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransition.js":
/*!*****************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSheetTransitionExtension; });
/* harmony import */ var _ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelSheetCommon */ "./extensions/ModelSheetTransition/ModelSheetCommon.js");
/* harmony import */ var _ModelSheetTransitionLocals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelSheetTransitionLocals */ "./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js");
/* harmony import */ var _ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModelSheetTransition.css */ "./extensions/ModelSheetTransition/ModelSheetTransition.css");
/* harmony import */ var _ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ModelSheetTransition_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../AEC/common/AecModelData */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _SheetToModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SheetToModel */ "./extensions/ModelSheetTransition/SheetToModel.js");
/* harmony import */ var _ModelToSheet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ModelToSheet */ "./extensions/ModelSheetTransition/ModelToSheet.js");
/* harmony import */ var _UI_ModelSheetGenericUI__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UI/ModelSheetGenericUI */ "./extensions/ModelSheetTransition/UI/ModelSheetGenericUI.js");
/* harmony import */ var _UI_ModelSheet3DMarker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UI/ModelSheet3DMarker */ "./extensions/ModelSheetTransition/UI/ModelSheet3DMarker.js");
/* harmony import */ var _BoundsPlane__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BoundsPlane */ "./extensions/ModelSheetTransition/BoundsPlane.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}









/**
                                         * ModelSheetTransition is an extension for transitioning from a 2D model to its context inside a 3D model.
                                         * Prerequisite is that the context (relationship and transform) exists and can be provided by a service.
                                         *
                                         *  * @example
                                         *   viewer.loadExtension('Autodesk.ModelSheetTransition')
                                         *
                                         * @memberof Autodesk.Viewing.Extensions
                                         * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                         * @alias Autodesk.Viewing.Extensions.ModelSheetTransition
                                         * @class
                                         */

var extensionName = 'Autodesk.ModelSheetTransition';
var namespace = AutodeskNamespace(extensionName);

var Prefix = {
  LineageUrn: 'lineageUrn=',
  Name: 'viewablePart=' };


var OverlayName = 'ModelSheetTransition_Extension_Overlay';var

ModelSheetTransitionExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(ModelSheetTransitionExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(ModelSheetTransitionExtension);
  /**
                                                                                                                                                                                                         * @param viewer
                                                                                                                                                                                                         * @param options - If no service is provided will just default to looking for available AEC data.
                                                                                                                                                                                                         *                  Must include a loadDocument function that fetches the document for a related model
                                                                                                                                                                                                         *                  Must include a loadModel function that loads the related model (to load as hidden)
                                                                                                                                                                                                         *                  Must include a showModel function that shows the related model
                                                                                                                                                                                                         *                  Must include a hideModel function that hides the related model
                                                                                                                                                                                                         *                  Must include a getVersionUrn function that given a lineageUrn returns the latest versionUrn
                                                                                                                                                                                                         *                  Can include a displayError function that uses a custom UI to show errors
                                                                                                                                                                                                         */
  function ModelSheetTransitionExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, ModelSheetTransitionExtension);
    _this = _super.call(this, viewer, options);

    _this.cache = _this.getCache();
    _this.loadDocument = options.loadDocument;
    _this.loadModel = options.loadModel;
    _this.showModel = options.showModel;
    _this.hideModel = options.hideModel;
    _this.getVersionUrn = options.getVersionUrn;
    _this.displayError = options.displayError || _this._displayError.bind(_assertThisInitialized(_this));

    // Bindings
    _this.updateUI = _this.updateUI.bind(_assertThisInitialized(_this));
    _this.updateMarkersClientLocation = _this.updateMarkersClientLocation.bind(_assertThisInitialized(_this));
    _this.updateMarkers = _this.updateMarkers.bind(_assertThisInitialized(_this));
    _this.addMarkersForModel = _this.addMarkersForModel.bind(_assertThisInitialized(_this));
    _this.removeMarkersForModel = _this.removeMarkersForModel.bind(_assertThisInitialized(_this));

    _this.sheetToModel = new _SheetToModel__WEBPACK_IMPORTED_MODULE_4__["default"](_assertThisInitialized(_this));
    _this.modelToSheet = new _ModelToSheet__WEBPACK_IMPORTED_MODULE_5__["default"](_assertThisInitialized(_this));

    _this.areMarkersVisible = false;return _this;
  }_createClass(ModelSheetTransitionExtension, [{ key: "load", value: function load()

    {
      if (!this.loadDocument || !this.loadModel || !this.showModel || !this.hideModel || !this.getVersionUrn) {
        console.error('One of ModelSheetTransition callbacks is missing.');
        return false;
      }

      this.extendLocalization(_ModelSheetTransitionLocals__WEBPACK_IMPORTED_MODULE_1__["locales"]);

      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.updateUI);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.updateUI);

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.updateUI);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.updateUI);

      this.hideSelectedSheet();

      this.destroyUIFor2D();
      this.destroyUIFor3D();

      this.service = null;
      this.viewer = null;
      this.options = null;

      return true;
    } }, { key: "updateUI", value: function () {var _updateUI = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _ref,type,model,_ref$resetTransformAn,resetTransformAndViewport,model2D,_yield$this$fetchView,toolbarUIEnabled,_args = arguments;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_ref = _args.length > 0 && _args[0] !== undefined ? _args[0] :

                {}, type = _ref.type, model = _ref.model, _ref$resetTransformAn = _ref.resetTransformAndViewport, resetTransformAndViewport = _ref$resetTransformAn === void 0 ? true : _ref$resetTransformAn;
                model2D = Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__["getSuitable2DModel"])(this.viewer);if (!

                model2D) {_context.next = 22;break;} // A suitable 2D model is only returned in 2D mode
                this.destroyUIFor3D();
                this.createUIfor2D();

                this.resetModelIfNeeded(model2D, resetTransformAndViewport);_context.next = 8;return (

                  this.fetchViewportsForModel(model2D));case 8:_context.t1 = _yield$this$fetchView = _context.sent.viewports;_context.t0 = _context.t1 === null;if (_context.t0) {_context.next = 12;break;}_context.t0 = _yield$this$fetchView === void 0;case 12:if (!_context.t0) {_context.next = 16;break;}_context.t2 = void 0;_context.next = 17;break;case 16:_context.t2 = _yield$this$fetchView.length;case 17:_context.t3 = _context.t2;toolbarUIEnabled = _context.t3 > 0;
                // Check that while fetching from the service, the model didn't change
                if (model2D === Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__["getSuitable2DModel"])(this.viewer)) {
                  this.setButtonEnabled(toolbarUIEnabled);
                }_context.next = 24;break;case 22:

                this.destroyUIFor2D();
                if (!this.viewer.impl.is2d) {// Is 3D
                  this.createUIfor3D();

                  if (type === Autodesk.Viewing.MODEL_ADDED_EVENT) {
                    this.addMarkersForModel(model);
                  } else if (type === Autodesk.Viewing.MODEL_REMOVED_EVENT) {
                    this.removeMarkersForModel(model);
                  }
                }case 24:case "end":return _context.stop();}}}, _callee, this);}));function updateUI() {return _updateUI.apply(this, arguments);}return updateUI;}() }, { key: "setAlignmentService", value: function setAlignmentService(



    service) {
      this.service = service;
    }

    /**
      * Invoked by the viewer when the toolbar UI is available.
      *
      * @param {Autodesk.Viewing.UI.ToolBar} toolbar - toolbar instance.
      *
      * @alias Autodesk.Viewing.Extensions.ModelSheetTransitionExtension#onToolbarCreated
      */ }, { key: "onToolbarCreated", value: function onToolbarCreated(
    toolbar) {
      this.updateUI();
    }

    /**
      * @private
      */ }, { key: "createUIfor2D", value: function createUIfor2D()
    {var _this2 = this;
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (!toolbar || this.toolbarButton) {
        return;
      }

      var toolbarGroup = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
      if (!toolbarGroup) {
        return;
      }

      // Create the button first.
      this.toolbarButton = new Autodesk.Viewing.UI.Button('toolbar-model-sheet-transition');
      this.toolbarButton.setToolTip('Fetching alignment information...');
      this.toolbarButton.setIcon('viewericon-model-sheet-transition');
      this.toolbarButton.setState(Autodesk.Viewing.UI.Button.State.DISABLED);
      this.toolbarButton.onClick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var model;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!
                _this2.transitionStarted) {_context2.next = 2;break;}return _context2.abrupt("return");case 2:



                Autodesk.Viewing.Private.analytics.track('viewer.model_sheet_transition', {
                  from: 'UI' });


                _this2.transitionStarted = true;
                model = Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__["getSuitable2DModel"])(_this2.viewer);if (
                model) {_context2.next = 8;break;}
                console.warn('No suitable 2D model found for sheet to model transition');return _context2.abrupt("return");case 8:


                _this2.setButtonEnabled(false, true);_context2.next = 11;return (
                  _this2.sheetToModel.transition2Dto3D(model));case 11:
                _this2.setButtonEnabled(true, true);

                _this2.transitionStarted = false;case 13:case "end":return _context2.stop();}}}, _callee2);}));


      toolbarGroup.addControl(this.toolbarButton);
    } }, { key: "setButtonEnabled", value: function setButtonEnabled(

    enabled) {var supported = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : enabled;
      if (!this.toolbarButton) {
        return;
      }

      var supportedTooltip = 'Show in 3D context';
      var unsupportedTooltip = 'Current view is not supported by Show in 3D context';

      this.toolbarButton.setState(enabled ? Autodesk.Viewing.UI.Button.State.INACTIVE : Autodesk.Viewing.UI.Button.State.DISABLED);
      this.toolbarButton.setToolTip(supported ? supportedTooltip : unsupportedTooltip);
    }

    /**
      * @private
      */ }, { key: "destroyUIFor2D", value: function destroyUIFor2D()
    {
      if (!this.toolbarButton) {
        return;
      }

      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();
      if (!toolbar) {
        return;
      }

      this.toolbarButton.removeFromParent();
      this.toolbarButton = null;
    }

    /**
       * @private
       */ }, { key: "createUIfor3D", value: function createUIfor3D()
    {var _this3 = this;
      if (this.ui3DCreated) {
        return;
      }

      var onHide = function onHide() {
        if (!_this3.markers) {
          return;
        }

        for (var key in _this3.markers) {
          _this3.markers[key].setDefaultStyle();
        }

        // When exiting the context menu, remove any bounds plane
        _this3.boundsPlane.lock = false;
        _this3.boundsPlane.setVisible(false);
      };

      this.ui3D = this.options.ui3D && new this.options.ui3D(onHide) || new _UI_ModelSheetGenericUI__WEBPACK_IMPORTED_MODULE_6__["default"](this.viewer, onHide);

      this.markers = {};
      this.modelsWithMarkers = {};

      this.boundsPlane = new _BoundsPlane__WEBPACK_IMPORTED_MODULE_8__["default"](this.viewer, OverlayName);

      // For each 3D model in scene, search for viewports in AEC model data. TODO: Also search in alignment service.
      var models3D = this.viewer.impl.get3DModels();

      models3D.forEach(this.addMarkersForModel);

      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.updateMarkersClientLocation);
      this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.updateMarkersClientLocation);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_VIEWPORT_BOUNDS_CHANGED_EVENT, this.updateMarkers);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.updateMarkers);

      this.ui3DCreated = true;
    } }, { key: "addMarkersForModel", value: function addMarkersForModel(

    model) {var _bubbleNode$getAecMod,_this4 = this;
      if (!model.is3d() || this.modelsWithMarkers[model.getModelKey()]) {
        return;
      }

      var bubbleNode = model.getDocumentNode();
      var rootNode = bubbleNode.getRootNode();
      var viewports = (_bubbleNode$getAecMod = bubbleNode.getAecModelData()) === null || _bubbleNode$getAecMod === void 0 ? void 0 : _bubbleNode$getAecMod.viewports.filter(Autodesk.AEC.AecModelData.supports2DTo3DTransform);

      viewports.forEach(function (vp, index) {
        // Support only models with modelToSheetTransform
        if (!vp.modelToSheetTransform) {
          return;
        }

        var geometries = rootNode.search({ type: 'geometry', role: '2d', guid: vp.sheetGuid });
        if (!geometries.length) {
          return;
        }

        var node = geometries[0];

        var scale = model.getUnitScale();
        var matrix = Autodesk.AEC.AecModelData.get2DTo3DMatrix(vp, scale);
        var region = Autodesk.AEC.AecModelData.getViewportBounds(vp, scale);

        var vpData = {
          model3D: model,
          vp: vp,
          matrix: matrix,
          region: region,
          node: node,
          index: index };


        var marker = new _UI_ModelSheet3DMarker__WEBPACK_IMPORTED_MODULE_7__["default"](vpData, _this4, _this4.ui3D, _this4.areMarkersVisible);
        _this4.markers[node.name() + index] = marker;
      });

      this.modelsWithMarkers[model.getModelKey()] = model;
    } }, { key: "removeMarkersForModel", value: function removeMarkersForModel(

    model) {
      if (!model.is3d() || !this.modelsWithMarkers[model.getModelKey()]) {
        return;
      }

      for (var key in this.markers) {
        var marker = this.markers[key];
        if (marker.vpData.model3D === model) {
          this.markers[key].destroy();
          delete this.markers[key];
        }
      }

      delete this.modelsWithMarkers[model.getModelKey()];
    } }, { key: "showSheetAndSetTransform", value: function () {var _showSheetAndSetTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      node, viewportGuid, model3D) {var model, matrix, crop, _yield$this$getDocume, model3DMatrix;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return (
                  this.loadModel(node));case 2:model = _context3.sent;_context3.prev = 3;_context3.next = 6;return (



                  this.getDocumentAndTransform(model, viewportGuid));case 6:_yield$this$getDocume = _context3.sent;matrix = _yield$this$getDocume.matrix;crop = _yield$this$getDocume.crop;_context3.next = 16;break;case 11:_context3.prev = 11;_context3.t0 = _context3["catch"](3);

                console.error('Could not get transform');
                this.hideModel(node);return _context3.abrupt("return");case 16:



                model3DMatrix = model3D.getModelToViewerTransform();
                if (model3DMatrix) {
                  matrix = new THREE.Matrix4().multiplyMatrices(model3DMatrix, matrix);
                }

                model.setPlacementTransform(matrix);
                model.setViewportBounds(this.viewer.impl.matman(), crop);

                Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__["setCutPlane"])(this.viewer, matrix);

                model.changePaperVisibility(false);
                this.viewer.impl.setDoNotCut(model, true);

                // Show model only when everything is ready
                this.showModel(node);return _context3.abrupt("return",

                model);case 25:case "end":return _context3.stop();}}}, _callee3, this, [[3, 11]]);}));function showSheetAndSetTransform(_x, _x2, _x3) {return _showSheetAndSetTransform.apply(this, arguments);}return showSheetAndSetTransform;}() }, { key: "hideSelectedSheet", value: function hideSelectedSheet()



    {var _this$selectedMarker;
      if ((_this$selectedMarker = this.selectedMarker) === null || _this$selectedMarker === void 0 ? void 0 : _this$selectedMarker.isSheetVisible) {
        this.selectedMarker.hideSheet();
      }
    } }, { key: "onMarkerSelected", value: function onMarkerSelected(

    marker) {
      // Hide previosuly selected node
      this.hideSelectedSheet();

      this.selectedMarker = marker;
    } }, { key: "setAllMarkersVisible", value: function setAllMarkersVisible(

    isVisible) {
      if (this.areMarkersVisible === isVisible) {
        return;
      }

      this.areMarkersVisible = isVisible;

      for (var key in this.markers) {
        this.markers[key].setVisible(isVisible);
      }
    }

    /**
       * @private
       */ }, { key: "destroyUIFor3D", value: function destroyUIFor3D()
    {
      if (!this.ui3DCreated) {
        return;
      }

      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.updateMarkersClientLocation);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.updateMarkersClientLocation);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_VIEWPORT_BOUNDS_CHANGED_EVENT, this.updateMarkers);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.updateMarkers);

      for (var key in this.markers) {
        this.markers[key].destroy();
      }

      this.boundsPlane.destroy();
      this.boundsPlane = null;

      this.markers = null;
      this.modelsWithMarkers = null;
      this.selectedMarker = null;

      this.ui3DCreated = false;
    }

    // Update the element's location when the camera moves
  }, { key: "updateMarkersClientLocation", value: function updateMarkersClientLocation() {
      if (!this.markers) {
        return;
      }

      for (var key in this.markers) {
        this.markers[key].updateClientLocation();
      }
    }

    // When the bounds move, the marker's world position needs to be readjusted
  }, { key: "updateMarkers", value: function updateMarkers() {
      if (!this.markers) {
        return;
      }

      for (var key in this.markers) {
        this.markers[key].update();
      }
    }

    // If this model was changed due to a transition, reset those changes
  }, { key: "resetModelIfNeeded", value: function resetModelIfNeeded(model) {var _this$cache$key,_this5 = this;var resetTransformAndViewport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var key = model.getModelKey();

      if (((_this$cache$key = this.cache[key]) === null || _this$cache$key === void 0 ? void 0 : _this$cache$key.model) !== model) {
        return false;
      }

      if (resetTransformAndViewport) {
        Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_0__["resetModelTransformAndViewport"])(this.viewer, model);
      }

      // Make sure home view is synced (since we are changing the transform after the model has been added)
      // Wait for next frame to make sure view is updated
      setTimeout(function () {return _this5.viewer.impl.controls.recordHomeView();});

      this.cache[key].model = null;

      return true;
    } }, { key: "fetchViewportsForModel", value: function () {var _fetchViewportsForModel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(

      model) {var key;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                key = model.getModelKey();if (

                this.cache[key]) {_context4.next = 7;break;}
                // Create initial cache that this model doesn't contain any alignments.
                // Will also prevent multiple calls to fetch viewports if we are already in the middle of fetch
                // (can happen since we can reach here from onToolbarCreated as well as from onModelAdded)
                this.cache[key] = {};_context4.next = 5;return (
                  this.fetchViewportsFromService(model, key));case 5:if (_context4.sent) {_context4.next = 7;break;}
                this.fetchViewportsFromAECData(model, key);case 7:return _context4.abrupt("return",



                this.cache[key]);case 8:case "end":return _context4.stop();}}}, _callee4, this);}));function fetchViewportsForModel(_x4) {return _fetchViewportsForModel.apply(this, arguments);}return fetchViewportsForModel;}()


    // Fetches viewports for a model and save it in cache, using the provided service
  }, { key: "fetchViewportsFromService", value: function () {var _fetchViewportsFromService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(model, key) {var _this$service;var urn2D, lineageUrn2D, encodedName2D, viewports;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                urn2D = model.getDocumentNode().getRootNode().urn();
                lineageUrn2D = model.getDocumentNode().lineageUrn();
                encodedName2D = encodeURIComponent(model.getDocumentNode().name());_context5.next = 5;return (_this$service =

                this.service) === null || _this$service === void 0 ? void 0 : _this$service.loadViewports(urn2D, encodedName2D);case 5:viewports = _context5.sent;if (!(
                !viewports || !viewports.length)) {_context5.next = 8;break;}return _context5.abrupt("return",
                false);case 8:


                this.cache[key] = {
                  viewports: viewports,
                  urn2D: urn2D,
                  lineageUrn2D: lineageUrn2D,
                  encodedName2D: encodedName2D,
                  isFromService: true };return _context5.abrupt("return",


                true);case 10:case "end":return _context5.stop();}}}, _callee5, this);}));function fetchViewportsFromService(_x5, _x6) {return _fetchViewportsFromService.apply(this, arguments);}return fetchViewportsFromService;}()


    // Fetches viewports for a model and save it in cache, using AEC data
  }, { key: "fetchViewportsFromAECData", value: function fetchViewportsFromAECData(model, key) {
      // PDFs are not supported, but PDFs originating from Revit are, since they have the required viewbox data.
      var is2dAEC = model.isAEC() && !model.isPdf(true);
      if (!is2dAEC || !model.getDocumentNode()) {
        return false;
      }

      var viewports = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__["default"].findViewportsOnSheet(model);

      viewports.filter(_AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__["default"].supports2DTo3DTransform);
      if (!viewports.length) {
        return false;
      }

      this.cache[key] = {
        viewports: viewports,
        isFromAEC: true };


      return true;
    } }, { key: "getDocumentAndTransformFromAEC", value: function getDocumentAndTransformFromAEC(

    model2D, viewport) {
      var sheetUnitScale = model2D.getUnitScale();
      var matrix = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__["default"].get2DTo3DMatrix(viewport, sheetUnitScale);

      var node2D = model2D.getDocumentNode();
      // Document will be the same
      var doc = node2D.getDocument();
      var views = node2D.getRootNode().search(Autodesk.Viewing.BubbleNode.MODEL_NODE);
      if (!views || !views.length) {
        throw 'No AEC views';
      }

      var bubbleNode = views[0]; // Taking first 3D view

      var aec = model2D.getDocumentNode().getAecModelData();
      this.setElevationFromLevel(matrix, viewport, aec);

      var crop = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__["default"].getViewportBounds(viewport, sheetUnitScale);

      return { doc: doc, bubbleNode: bubbleNode, matrix: matrix, crop: crop };
    } }, { key: "setElevationFromLevel", value: function setElevationFromLevel(

    matrix, viewport, aecModelData) {
      if (viewport.viewType !== 'FloorPlan') {
        return;
      }

      var level = _AEC_common_AecModelData__WEBPACK_IMPORTED_MODULE_3__["default"].findLevelForViewport(aecModelData, viewport);

      // Take elevation from level
      if (level) {
        var zOffsetHack = 1 / 120; // Offset to place slightly above floor
        var pos = new THREE.Vector3();
        pos.setFromMatrixPosition(matrix);
        pos.z = level.elevation + zOffsetHack;
        matrix.setPosition(pos);
      }
    }

    // Fetches the related document and transform from the service. If no alignment is available, it will fallback
    // to AEC data (if supported and exists)
  }, { key: "getDocumentAndTransformFromService", value: function () {var _getDocumentAndTransformFromService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(model2D, urn2D, lineageUrn2D, encodedName2D, regionId, viewport) {var _relationship;var relationship, _yield$this$service$g, _yield$this$service$g2, relatedModel, _relatedModel$id$spli, _relatedModel$id$spli2, lineageUrn3D, name3D, versionUrn3D, urn3DEncoded, nodePromise;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.prev = 0;_context6.next = 3;return (



                  this.service.getRelationships('viewpartregion2d', lineageUrn2D, encodedName2D, regionId));case 3:_yield$this$service$g = _context6.sent;_yield$this$service$g2 = _slicedToArray(_yield$this$service$g, 1);relationship = _yield$this$service$g2[0];_context6.next = 12;break;case 8:_context6.prev = 8;_context6.t0 = _context6["catch"](0);

                console.warn('No relationship found. Error: ' + _context6.t0);throw _context6.t0;case 12:



                relatedModel = (_relationship = relationship) === null || _relationship === void 0 ? void 0 : _relationship.entities.find(function (e) {return e.type === 'viewpart3d';});if (

                relatedModel) {_context6.next = 15;break;}throw (
                  'No related model found for sheet-model transition');case 15:


                model2D.regionId = regionId; // Save in model, in case the sheet is realigned (so it won't create a new region)
                _relatedModel$id$spli =
                relatedModel.id.split('&'), _relatedModel$id$spli2 = _slicedToArray(_relatedModel$id$spli, 2), lineageUrn3D = _relatedModel$id$spli2[0], name3D = _relatedModel$id$spli2[1];

                // Decode lineageUrn
                lineageUrn3D = lineageUrn3D.slice(Prefix.LineageUrn.length);

                // Given lineageUrn, get latest versionUrn.
                _context6.next = 20;return this.options.getVersionUrn(lineageUrn3D);case 20:versionUrn3D = _context6.sent;

                // Encode versionUrn
                urn3DEncoded = Autodesk.Viewing.toUrlSafeBase64(versionUrn3D);

                name3D = decodeURIComponent(name3D.slice(Prefix.Name.length));

                nodePromise = this.getRelatedModelNode(model2D, urn2D, urn3DEncoded, name3D);return _context6.abrupt("return",

                nodePromise.then(function (res) {return _objectSpread(_objectSpread({},
                  res), {}, {
                    matrix: viewport.transform,
                    crop: viewport.boundingBox });}));case 25:case "end":return _context6.stop();}}}, _callee6, this, [[0, 8]]);}));function getDocumentAndTransformFromService(_x7, _x8, _x9, _x10, _x11, _x12) {return _getDocumentAndTransformFromService.apply(this, arguments);}return getDocumentAndTransformFromService;}() }, { key: "getDocumentAndTransform", value: function () {var _getDocumentAndTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(



      model, vpGuid) {var vpMetadata, viewports, viewport, urn2D, lineageUrn2D, encodedName2D, regionId;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:_context7.next = 2;return (
                  this.fetchViewportsForModel(model));case 2:vpMetadata = _context7.sent; // Should be cached by now (when creating UI)
                viewports = vpMetadata.viewports;
                viewport = vpGuid ? viewports.find(function (vp) {return vp.viewportGuid === vpGuid;}) : viewports[0];

                vpMetadata.model = model; // Save the model in cache to restore its state later (showing page, clear transform, etc.)
                if (
                viewport.cachedDocAndTransform) {_context7.next = 17;break;}if (!
                vpMetadata.isFromAEC) {_context7.next = 12;break;}
                viewport.cachedDocAndTransform = this.getDocumentAndTransformFromAEC(model, viewport);
                viewport.cachedDocAndTransform.isFromAEC = true;_context7.next = 17;break;case 12:
                // isFromService
                urn2D = vpMetadata.urn2D, lineageUrn2D = vpMetadata.lineageUrn2D, encodedName2D = vpMetadata.encodedName2D;
                regionId = viewport.regionId;_context7.next = 16;return (
                  this.getDocumentAndTransformFromService(model, urn2D, lineageUrn2D, encodedName2D, regionId, viewport));case 16:viewport.cachedDocAndTransform = _context7.sent;case 17:return _context7.abrupt("return",



                viewport.cachedDocAndTransform);case 18:case "end":return _context7.stop();}}}, _callee7, this);}));function getDocumentAndTransform(_x13, _x14) {return _getDocumentAndTransform.apply(this, arguments);}return getDocumentAndTransform;}() }, { key: "getRelatedModelNode", value: function () {var _getRelatedModelNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(


      model2D, urn2D, urn3D, name3D) {var doc;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:if (!(



                urn3D === urn2D)) {_context8.next = 4;break;}
                doc = model2D.getDocumentNode().getDocument();_context8.next = 14;break;case 4:_context8.prev = 4;_context8.next = 7;return (


                  this.loadDocument(urn3D));case 7:doc = _context8.sent;_context8.next = 14;break;case 10:_context8.prev = 10;_context8.t0 = _context8["catch"](4);

                console.warn('Could not load related model', _context8.t0);return _context8.abrupt("return");case 14:return _context8.abrupt("return",




                { doc: doc, bubbleNode: this.getNode(doc, name3D) });case 15:case "end":return _context8.stop();}}}, _callee8, this, [[4, 10]]);}));function getRelatedModelNode(_x15, _x16, _x17, _x18) {return _getRelatedModelNode.apply(this, arguments);}return getRelatedModelNode;}() }, { key: "getNode", value: function getNode(


    doc, name) {
      var rootNode = doc.getRoot();
      var node;
      if (name) {
        node = rootNode.search({ name: name })[0];
      }

      // If no guid is specified, just load first 3D viewable
      if (!node) {
        node = rootNode.search({ type: 'geometry' })[0];
      }

      return node;
    }

    // Default displayError function. Can be overriden through options
  }, { key: "_displayError", value: function _displayError(message) {
      Autodesk.Viewing.Private.AlertBox.displayError(this.viewer.container, message, 'Model Sheet Transition');
    } }, { key: "transitionModelToSheet", value: function transitionModelToSheet(

    model) {
      this.destroyUIFor3D();
      this.modelToSheet.transition3Dto2D(model);
    } }]);return ModelSheetTransitionExtension;}(Autodesk.Viewing.Extension);


namespace.ModelSheetTransitionExtension = ModelSheetTransitionExtension;
// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, ModelSheetTransitionExtension);

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js":
/*!***********************************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelSheetTransitionLocals.js ***!
  \***********************************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-modelSheetTransition.loc.json */ "./res/locales/en/nobundle-modelSheetTransition.loc.json");
var _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-modelSheetTransition.loc.json */ "./res/locales/en/nobundle-modelSheetTransition.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_modelSheetTransition_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/ModelSheetTransition/ModelToSheet.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelSheetTransition/ModelToSheet.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelToSheet; });
/* harmony import */ var _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelSheetConstants */ "./extensions/ModelSheetTransition/ModelSheetConstants.js");
/* harmony import */ var _ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelSheetCommon */ "./extensions/ModelSheetTransition/ModelSheetCommon.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

ModelToSheet = /*#__PURE__*/function () {
  function ModelToSheet(extension) {_classCallCheck(this, ModelToSheet);
    this.ext = extension;
    this.viewer = extension.viewer;
  }_createClass(ModelToSheet, [{ key: "transition3Dto2D", value: function () {var _transition3Dto2D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      model) {var _this = this;var matrix, invMatrix, otherModels;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (!
                this.viewer.impl.is2d) {_context.next = 2;break;}return _context.abrupt("return");case 2:



                matrix = model.getPlacementTransform();
                invMatrix = new Autodesk.Viewing.Private.LmvMatrix4(matrix.isDoublePrecision).getInverse(matrix);
                this.viewer.setNavigationLock(true);_context.next = 7;return (

                  Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["setCutPlane"])(this.viewer, matrix));case 7:_context.next = 9;return (

                  Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["fitCameraToSheet"])(this.viewer, model));case 9:

                // Hide other models
                otherModels = this.viewer.getVisibleModels().filter(function (m) {return m !== model;});
                otherModels.forEach(function (m) {return _this.ext.hideModel(m.getDocumentNode());});

                // Show paper and restore viewport
                this.viewer.impl.changePaperVisibility(model, true, true, null, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["SHOW_DURATION"]);_context.next = 14;return (
                  Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["setViewportBounds"])(this.viewer, model, null, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["SHOW_DURATION"]));case 14:

                // Reset transform
                this.viewer.impl.setPlacementTransform(model, new THREE.Matrix4());
                this.viewer.impl.invalidate(true);
                Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["fitAfterTransformImmediate"])(this.viewer, invMatrix);

                this.ext.updateUI({ resetTransformAndViewport: false });

                this.viewer.impl.setDoNotCut(model, false);

                this.viewer.setNavigationLock(false);case 20:case "end":return _context.stop();}}}, _callee, this);}));function transition3Dto2D(_x) {return _transition3Dto2D.apply(this, arguments);}return transition3Dto2D;}() }]);return ModelToSheet;}();

/***/ }),

/***/ "./extensions/ModelSheetTransition/SheetToModel.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelSheetTransition/SheetToModel.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetToModel; });
/* harmony import */ var _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelSheetConstants */ "./extensions/ModelSheetTransition/ModelSheetConstants.js");
/* harmony import */ var _ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelSheetCommon */ "./extensions/ModelSheetTransition/ModelSheetCommon.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

SheetToModel = /*#__PURE__*/function () {
  function SheetToModel(extension) {_classCallCheck(this, SheetToModel);
    this.ext = extension;
    this.viewer = extension.viewer;
  }_createClass(SheetToModel, [{ key: "transition2Dto3D", value: function () {var _transition2Dto3D = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      model2D) {var docAndTfPromise, doc, bubbleNode, matrix, crop, isFromAEC, _yield$docAndTfPromis, model3D, modelToViewerTransform;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (
                this.viewer.impl.is2d) {_context.next = 2;break;}return _context.abrupt("return");case 2:



                // Start fetching the transforms
                docAndTfPromise = this.ext.getDocumentAndTransform(model2D);

                // First transition to showing whole sheet. Lock navigation until transition is finished.
                this.viewer.setNavigationLock(true);_context.next = 6;return (
                  Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["fitToBoundsWithAnimation"])(this.viewer, model2D));case 6:_context.prev = 6;_context.next = 9;return (




                  docAndTfPromise);case 9:_yield$docAndTfPromis = _context.sent;doc = _yield$docAndTfPromis.doc;bubbleNode = _yield$docAndTfPromis.bubbleNode;matrix = _yield$docAndTfPromis.matrix;crop = _yield$docAndTfPromis.crop;isFromAEC = _yield$docAndTfPromis.isFromAEC;_context.next = 23;break;case 17:_context.prev = 17;_context.t0 = _context["catch"](6);

                // Restore navigation
                this.viewer.setNavigationLock(false);

                this.ext.displayError(Autodesk.Viewing.i18n.translate('No suitable model found for transition.'));
                console.warn(_context.t0);return _context.abrupt("return");case 23:



                // Prevent sheets from getting cut by cutplanes
                this.viewer.impl.setDoNotCut(model2D, true);

                // Show the 3D model
                _context.next = 26;return this.ext.showModel(bubbleNode, doc);case 26:model3D = _context.sent;

                if (isFromAEC) {
                  modelToViewerTransform = model3D.getModelToViewerTransform();
                  if (modelToViewerTransform) {
                    matrix = matrix.clone().multiplyMatrices(modelToViewerTransform, matrix);
                  }
                }

                // Set the transform to the sheet
                model2D.setPlacementTransform(matrix);
                Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["fitAfterTransformImmediate"])(this.viewer, matrix);

                // Define a cutplane with the sheet's plane, so that it's fully visible and not occluded by the model when we start
                // This cutplane can then be moved in the sheet's normal axis.
                _context.next = 32;return Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["setCutPlane"])(this.viewer, matrix);case 32:

                // Navigation is free from this point
                this.viewer.setNavigationLock(false);

                // Hide paper and crop to viewport
                this.viewer.impl.changePaperVisibility(model2D, false, true, null, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["HIDE_DURATION"]);
                if (crop) {
                  Object(_ModelSheetCommon__WEBPACK_IMPORTED_MODULE_1__["setViewportBounds"])(this.viewer, model2D, crop, _ModelSheetConstants__WEBPACK_IMPORTED_MODULE_0__["HIDE_DURATION"]);
                }case 35:case "end":return _context.stop();}}}, _callee, this, [[6, 17]]);}));function transition2Dto3D(_x) {return _transition2Dto3D.apply(this, arguments);}return transition2Dto3D;}() }]);return SheetToModel;}();

/***/ }),

/***/ "./extensions/ModelSheetTransition/UI/ModelSheet3DMarker.js":
/*!******************************************************************!*\
  !*** ./extensions/ModelSheetTransition/UI/ModelSheet3DMarker.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSheet3DMarker; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ModelSheet3DMarker = /*#__PURE__*/function () {
  function ModelSheet3DMarker(vpData, extension, ui, isVisible) {_classCallCheck(this, ModelSheet3DMarker);
    this.extension = extension;
    this.viewer = extension.viewer;
    this.vpData = vpData;

    this.node = vpData.node;
    this.name = this.node.name();
    this.ui = ui;

    // Generic shared plane to use when sheet is not visible
    this.boundsPlane = extension.boundsPlane;

    // Bounded functions
    this.onShowHide = this.onShowHide.bind(this);
    this.onGoToSheet = this.onGoToSheet.bind(this);
    this.update = this.update.bind(this);
    this.onClick = this.onClick.bind(this);
    this.onMouseEnter = this.onMouseEnter.bind(this);
    this.onMouseLeave = this.onMouseLeave.bind(this);
    this.onMouseWheel = this.onMouseWheel.bind(this);

    this.matrix = new THREE.Matrix4();
    this.createAndAddMarker();
    this.setVisible(isVisible);
  }_createClass(ModelSheet3DMarker, [{ key: "createAndAddMarker", value: function createAndAddMarker()

    {
      // Index is added to the hash to allow multiple copies of the same sheet to be loaded, with different placements
      this.hash = "".concat(this.name.replace(/\s/g, ''), "-").concat(this.vpData.index);
      this.button = new Autodesk.Viewing.UI.Button("mst-b-".concat(this.hash));
      this.button.setToolTip(this.name);

      this.container = this.button.container;
      this.container.classList.add('hyper-sheet-marker', 'hyper-sheet-marker-icon');
      // The icon class adds some styling we don't need (and enlarges the click area)
      this.button.icon.remove("adsk-button-icon");

      this.container.addEventListener('click', this.onClick);
      this.container.addEventListener('mouseenter', this.onMouseEnter);
      this.container.addEventListener('mouseleave', this.onMouseLeave);
      this.container.addEventListener('mousewheel', this.onMouseWheel);

      this.viewer.container.appendChild(this.container);

      this.update();
    } }, { key: "setVisible", value: function setVisible(

    isVisible) {var _this$button;
      (_this$button = this.button) === null || _this$button === void 0 ? void 0 : _this$button.setVisible(isVisible);
    } }, { key: "setDefaultStyle", value: function setDefaultStyle()

    {
      this.container.classList.remove('clicked');
    } }, { key: "onClick", value: function onClick(

    e) {
      this.boundsPlane.lock = true;
      var viewport = this.viewer.container.getBoundingClientRect();

      // Normalize Hammer events
      if (Array.isArray(e.changedPointers) && e.changedPointers.length > 0) {
        e.clientX = e.changedPointers[0].clientX;
        e.clientY = e.changedPointers[0].clientY;
      }

      var x = e.clientX - viewport.left;
      var y = e.clientY - viewport.top;

      this.container.classList.add('clicked');

      this.ui.show({ x: x, y: y }, this.node, this.isSheetVisible, this.onShowHide, this.onGoToSheet);
    } }, { key: "onShowHide", value: function onShowHide()

    {
      if (this.isSheetVisible) {
        this.hideSheet();
      } else {
        this.showSheet();
      }
    } }, { key: "hideSheet", value: function hideSheet()

    {
      this.extension.hideModel(this.node);
      this.container.classList.remove('selected');
      this.isSheetVisible = false;
    } }, { key: "showSheet", value: function () {var _showSheet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extension.onMarkerSelected(this);
                this.container.classList.add('selected');
                this.isSheetVisible = true;_context.next = 5;return (
                  this.extension.showSheetAndSetTransform(this.node, this.vpData.vp.viewportGuid, this.vpData.model3D));case 5:return _context.abrupt("return", _context.sent);case 6:case "end":return _context.stop();}}}, _callee, this);}));function showSheet() {return _showSheet.apply(this, arguments);}return showSheet;}() }, { key: "onGoToSheet", value: function () {var _onGoToSheet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var model;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:



                model = this.getModel();if (!(
                !this.isSheetVisible || !model)) {_context2.next = 5;break;}_context2.next = 4;return (
                  this.showSheet());case 4:model = _context2.sent;case 5:


                this.extension.transitionModelToSheet(model);case 6:case "end":return _context2.stop();}}}, _callee2, this);}));function onGoToSheet() {return _onGoToSheet.apply(this, arguments);}return onGoToSheet;}() }, { key: "onMouseEnter", value: function onMouseEnter()


    {var _this = this;
      if (this.isSheetVisible) {
        return;
      }

      this.enterTimeout = setTimeout(function () {
        _this.addPlane();
      }, 300);
    } }, { key: "onMouseLeave", value: function onMouseLeave()

    {
      if (!this.boundsPlane.lock) {
        clearTimeout(this.enterTimeout);
        this.enterTimeout = null;
        this.removePlane();
      }
    } }, { key: "addPlane", value: function addPlane()

    {
      // When the sheet is not visible, show a plane to give a sense of its dimensions
      var min = new THREE.Vector3(this.vpData.region.min.x, this.vpData.region.min.y, 0);
      var max = new THREE.Vector3(this.vpData.region.max.x, this.vpData.region.max.y, 0);
      var bbox = new THREE.Box3(min, max);

      var size = bbox.size();
      var scaleMatrix = new THREE.Matrix4().makeScale(size.x, size.y, 1);
      scaleMatrix.setPosition(bbox.center());
      var matrix = this.matrix.clone();
      matrix.multiply(scaleMatrix);
      var model3DTransform = this.vpData.model3D.getModelToViewerTransform();
      if (model3DTransform) {
        matrix.multiplyMatrices(model3DTransform, matrix);
      }
      this.boundsPlane.setFromMatrix(matrix);
      this.boundsPlane.setVisible(true);
    } }, { key: "removePlane", value: function removePlane()

    {
      this.boundsPlane.setVisible(false);
    } }, { key: "onMouseWheel", value: function onMouseWheel(

    e) {
      // Propagate mouse wheel event to viewer
      this.viewer.toolController.mousewheel(e);
    } }, { key: "getModel", value: function getModel()

    {var _this2 = this;
      var models = this.viewer.getAllModels();
      var model = models.find(function (m) {
        return m.getDocumentNode() === _this2.node;
      });

      return model;
    } }, { key: "setWorldPosition", value: function setWorldPosition()

    {
      var maxX = this.vpData.region.max.x;
      var minY = this.vpData.region.min.y;

      this.matrix.copy(this.vpData.matrix);
      var aec = this.node.getAecModelData();
      this.extension.setElevationFromLevel(this.matrix, this.vpData.vp, aec);

      var bottomRight = new THREE.Vector3(maxX, minY, 0.0).applyMatrix4(this.matrix);

      var model3DTransform = this.vpData.model3D.getModelToViewerTransform();
      if (model3DTransform) {
        bottomRight.applyMatrix4(model3DTransform);
      }

      this.location = bottomRight;
    } }, { key: "updateClientLocation", value: function updateClientLocation()

    {
      var pos = this.viewer.impl.worldToClient(this.location);

      this.container.style.transform = "translate(".concat(pos.x, "px, ").concat(pos.y, "px)");
    } }, { key: "update", value: function update()

    {
      this.setWorldPosition();
      this.updateClientLocation();
    } }, { key: "destroy", value: function destroy()

    {
      if (this.container) {
        this.viewer.container.removeChild(this.container);
      }

      this.button = null;
    } }]);return ModelSheet3DMarker;}();

/***/ }),

/***/ "./extensions/ModelSheetTransition/UI/ModelSheetGenericUI.js":
/*!*******************************************************************!*\
  !*** ./extensions/ModelSheetTransition/UI/ModelSheetGenericUI.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSheetGenericUI; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              UI needs to receive the location to display (not dynamic - clicking outside closes the menu)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              UI needs to receive the urn / or bubble (see utils in UI repo) to show the correct thumbnail
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              UI needs to receive state of sheet (is it shown/hidden)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              UI needs to receive 2 callbacks to run when show/hide is called, and when go to sheet is called
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              */var

ModelSheetGenericUI = /*#__PURE__*/function () {
  function ModelSheetGenericUI(viewer, onHide) {_classCallCheck(this, ModelSheetGenericUI);
    this.viewer = viewer;
    this.ctxMenu = new Autodesk.Viewing.Private.ContextMenu(this.viewer, { onHide: onHide });
  }_createClass(ModelSheetGenericUI, [{ key: "show", value: function show(

    position, bubbleNode, isVisible, onShowHide, onGoToSheet) {var
      x = position.x,y = position.y;

      var menu = [];
      menu.push({
        icon: isVisible ? 'viewericon-model-sheet-eye-hide' : 'viewericon-model-sheet-eye-show',
        title: isVisible ? 'Hide sheet' : 'Show sheet',
        target: onShowHide });

      menu.push({
        icon: 'viewericon-model-sheet-sheet',
        title: 'Go to sheet',
        target: onGoToSheet });


      this.ctxMenu.showMenu(menu, x, y);
      this.ctxMenu.open = true;
    } }]);return ModelSheetGenericUI;}();

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelSheetTransition/ModelSheetTransition.css ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".viewericon-model-sheet-transition:before {\n  font-family: 'modelSheetTransitionIcon';\n  content: \"M\"; }\n\n@font-face {\n  font-family: 'modelSheetTransitionIcon';\n  src: url(\"data:application/font-woff;base64,d09GRgABAAAAAAP8AAoAAAAABjgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAAA9AAAAD4AAABWVsFjP2NtYXAAAAE0AAAAPAAAAUoArAFrZ2x5ZgAAAXAAAADAAAAAwMOBpSJoZWFkAAACMAAAACsAAAA2GlHbmWhoZWEAAAJcAAAAGwAAACQIPQQDaG10eAAAAngAAAAIAAAACAgAAABsb2NhAAACgAAAAAYAAAAGAGAAAG1heHAAAAKIAAAAIAAAACABEABGbmFtZQAAAqgAAAE7AAACbdWMZSRwb3N0AAAD5AAAABUAAAApARAAAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGBwYfBl8WUDcGBaIMCOIAACZnwe0AAB4nGNgYGBmgGAZBkYGEHAB8hjBfBYGDSDNBqQZGZiALN///8EqwPT/LVD1QMDIxkBdwEhYyWADAMFRBxMABAAAAAAD4AQAACEAKQAxADkAAAEuAicjJSMmIgcFBgcGBxQVER4BFwUXMyU+ATURNCc4AQEmLwERBREwEyYvASUNATABBg8BESURMAPeAQUFAwP+SQUJFQn+TQYEBwUBDQsBsQ0ZAbcLDQL9+BacsgFkKhaUqgFUAVP+rQGNF5yyAWUDFAUHBgPSBQXNBAcGCQUG/eEMFAXABcIFFAwCIgUG/VQJRU8BxJ3+PAILCkJLoaGX/pIKRU4BxJ3+PAB4nGNgZGBgAOKs5tdr4/ltvjJwszCAwO2Vp/2QaeYHYHEOBiYQBQBAlgphAHicY2BkYGBhAIIYMMnA/ICBkQEVMAEAG9IBTAAEAAAABAAAAAAAAAAAYAAAAAEAAAACADoABAAAAAAAAgAAAAoACgAAAP8AAAAAAAB4nHWPS07DMBCGf/cFtBKqqGCH5AViASh9iFU37Jp9F92nrdOH0jhy3Eo9AOfhCJyAI9AbcAd+0gGhUmJ5/M03k3EC4AI7KOyfS+49K5wy23MJJ7gWLtPfCFfID8JVNPAoXKN/Eq7jHqFwAy04TlCVM2Z3eBZWaOJFuIRzvAqX6d+EK+R34Squ8CFcQ1OVhesYqZZwA7dqEZrUuMibqR5vdZhss7k37vscmtk6idyhHhmXL2yqu0Hnp/R7TL6Z9byPdezsSg9s6k2SWJ05uzQTH8y9z/rtdiw+mNgVf98g5XaI4HlOoTHGljFEwjPDvPDuTz5knGFNGx2pHuajIuZYwPI+jS4CdI689d/X5Njwth6tR8w8Zo/FijQoJn51J1yWJitqS5oJfVBM97R9tLnig/6AXZz0CTRjb6QAeJxjYGKAAC4G7AAozwhSAwAB1gASAAAA\") format(\"woff\");\n  font-weight: normal;\n  font-style: normal; }\n\n.viewericon-model-sheet-eye-hide:before {\n  font-family: 'modelSheetContextMenuIcons';\n  font-size: 20px;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\EA01\"; }\n\n.viewericon-model-sheet-eye-show:before {\n  font-family: 'modelSheetContextMenuIcons';\n  font-size: 20px;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\EA02\"; }\n\n.viewericon-model-sheet-sheet:before {\n  font-family: 'modelSheetContextMenuIcons';\n  font-size: 20px;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\EA03\"; }\n\n@font-face {\n  font-family: 'modelSheetContextMenuIcons';\n  src: url(\"data:application/font-woff;base64,d09GRgABAAAAAAa4AAsAAAAACbgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAPgAAAFZAIEusY21hcAAAAYQAAABWAAABjOswaepnbHlmAAAB3AAAAvgAAAO41hvwkmhlYWQAAATUAAAAKAAAADZi0kRjaGhlYQAABPwAAAAYAAAAJAedA+1obXR4AAAFFAAAAA8AAAAQC7gAAGxvY2EAAAUkAAAACgAAAAoCrAFqbWF4cAAABTAAAAAfAAAAIAETAJhuYW1lAAAFUAAAAS0AAAIixR1gBnBvc3QAAAaAAAAANQAAAE5rRiCweJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGR6xziBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+YmZ+AeRGgUmgRhABAAGpC08AAHic7ZCxDYBADAMv70CBmIOKkkmo2L9kif8kzxhEOke2ohQGFkDBGTjYg5FzR2qVi61y56gbz/xV76GWGt5LW36ylX/20utzyqYm1V2bkFsTNACOhQ1lAAB4nEWSz4/TRhTH5409Yzuxsxs7tkMaO+vxYm9+bmLHdne9CVXYKjmwlB/hABIcWAEXbnDmhJDa/gG9tOf23PIncOBP4ISQEJV676lt0o5DKPOdw5un995oPt9BBPElvBTuoxCN0ALdQ98jBGkYcGVTGA8woxLQmu1ClF4Cy47T7KOS8UVLqlWwz0Kb11pxNMVJygObShuF/gD4iCx1hQqWKsB3VoEuBD77WCBZtosrQrC5LBkn28lxxC8TfgUopceLRyIliqqq4uqBoohF8PT2A/Xqzfnl43ZA1j9psOsEZsMeXZ1nnbE3ObwA7vzxqewFo/xk/ppoO1i+klCtRDGWS5QdEqx/wNWyxPzZ/CQfBUxuTwgFQS6rKmmzPiFhOz9dLL/ptDUN/sF4/8u8/4iUNVURCVk9VBoK4etJXwDmRr1RvymJg3rDDNxd7QXsZU7jcOLF3a8nD439A79bd95gU02vKCBIJU0tUaBDr7yzKldkp971277x1UAshlMsil4QtSRBbA5GvdhhsmAhJG79MdEBmqNb6Px/d7g+caxR29rqsz1pSNi2cJuLtjWf/GEDmGIXTG6iwCrg4ikk3HDhNwAadjiEmz8uF6cn7ZAASEE7n82vn6lnNzboJYzXs9miIOjJihcOOe3nBdDQk2W2gT+Ll4GxOL97VBDZS+pqf5r73C34G8DhTxw5nlcQPGyKMnH6wyIBwJyoN+w3sST9wQFxhIbBKXGOzoWuf7Cv1/wN1fzo7vnCCJYxt7wBO34+7av1ZM8MnN0tsx+EZ8hGXXSCrnFmXsJhmdWai2Ov+KhV/lCjRn2PBRMIptiOq15kmQI/j9PYS8ZpZDlQoxfZAE9gnGZxZNVol8Oi+K/Vv2edYb131MJq66hX59GlLFz9GWZQNpuVPQxh9vP6nabrGoDe0PX1W6oqRNeeFKllVegsXbZYN7a9LXjWOu7Zq9/DLAuVnS/MMsB3Wbj+hbe+0gxDe6/p3xJZpXc0HYyGnqsG+g9mCJAJeJxjYGRgYADioweev47nt/nKwM38ggELYN7CXAekOBiYQDwABocHMXicY2BkYGB+wcAAJ7cwMDKgAhYAQWIClHicY2BgYGB+gcAAE2ACwgAAAAAAANABagHcAAB4nGNgZGBgYGHoYWBlAAEmIOYCQgaG/2A+AwAW1QGsAHicbY9BTsJAFIb/QsEIiSGamLibuHBjbIEFCw4AexbsSzuFktJppgMJF/AEnsEzeAKXnsGj+Le+dKHMJC/f+94/rymAET7hoT4erptanw6u2P1ylzQS9skPwj0M8Sjcp38RHuAZM+Eh7hBxg+fX227hhDu4watwl/5N2Ce/C/dwjw/hPv2X8ABrfAsP8eTNsiLJ4sgZu9LbYx7Ztm9hrW2VmUJNgnHrlrrQNnI6UZuzqk7bqXOpSq05qIUpnM5zo0pr9jp2wc65ch6GqfggNgdkKJCwxvw/BwOLFTS2OCKnsRfm/82aLywqOsOZwgQBxhdyS+aKJlsbzanCBmfWCid+c0rrkLJPmTE4kBbNzjqd8xqaspntaWL6ALvmVYk5Qt70Tz5gipt+AOdFYfIAAAB4nGNgYoAALgbsgIWRiZGZkYWRlYE7Mzk+tTI1PiMzJRXGLs7IL+cAsoszUlNLGBgA64UMegAAAA==\") format(\"woff\");\n  font-weight: 400;\n  font-style: normal; }\n\n.hyper-sheet-marker.adsk-button {\n  position: absolute;\n  width: 32px;\n  height: 32px;\n  left: 0;\n  top: 0;\n  margin: 0;\n  padding: 0;\n  background: rgba(255, 255, 255, 0.7);\n  border-radius: 50%;\n  box-sizing: content-box;\n  transition: color .2s ease-in-out;\n  will-change: transform;\n  border: none; }\n\n.hyper-sheet-marker-icon:before {\n  font-family: 'modelSheetContextMenuIcons';\n  font-size: 16px;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\EA03\";\n  display: flex;\n  flex-direction: row;\n  transform: translate(-50%, -50%);\n  position: absolute;\n  left: 50%;\n  top: 50%; }\n\n.hyper-sheet-marker.adsk-button:hover {\n  color: #3C3C3C !important;\n  background: white; }\n\n.hyper-sheet-marker.adsk-button.clicked {\n  box-shadow: 0px 0px 0px 2px #006EAF; }\n\n.hyper-sheet-marker.adsk-button.selected {\n  box-shadow: 0px 0px 0px 2px #000000; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./res/locales/en/nobundle-modelSheetTransition.loc.json":
/*!***************************************************************!*\
  !*** ./res/locales/en/nobundle-modelSheetTransition.loc.json ***!
  \***************************************************************/
/*! exports provided: @@locale, @@context, Show in 3D context, Fetching alignment information..., Current view is not supported by Show in 3D context, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"ModelSheetTransition Extension\",\"Show in 3D context\":\"Show in 3D context\",\"Fetching alignment information...\":\"Fetching alignment information...'\",\"Current view is not supported by Show in 3D context\":\"Current view is not supported by Show in 3D context\"}");

/***/ })

/******/ });
//# sourceMappingURL=ModelSheetTransition.js.map