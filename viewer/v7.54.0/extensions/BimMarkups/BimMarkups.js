/*!
 * LMV v7.54.0
 *
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Forge Viewer Usage Limitations:
 *
 * The Autodesk Forge Viewer JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineFrag.glsl":
/*!*************************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineFrag.glsl ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "#define MESHLINE_PATH_FLAT_CAP      3.0\nuniform vec3 color;\nuniform float opacity;\nvarying float vCounters;\nvarying float vDistance;\nvarying float aaRange;\nvarying float totalWidth;\nvarying vec2 center;\nvarying vec2 finalPos;\nvarying float vPointType;\nfloat when_eq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\nfloat getSmoothStep(float t, float d) {\n    return smoothstep(t - aaRange, t + aaRange, abs(d));\n}\nvoid main() {\n    float t = totalWidth / 2.0;\n    float d = vDistance;\n    float aa = 1.0;\n    if (vCounters < 0.0 || vCounters > 1.0) {\n        d = length(finalPos - center);\n        if (vPointType == MESHLINE_PATH_FLAT_CAP) {\n            t = aaRange;\n        }\n        if (d > t + aaRange) {\n            discard;\n        }\n        aa = 1.0 - getSmoothStep(t, d);       \n    }\n        \n#ifdef IS_IE_11\n    aa = (1.0 - when_eq(opacity, 1.0) * getSmoothStep(totalWidth / 2.0, vDistance)) * aa;\n#else\n    aa = (1.0 - getSmoothStep(totalWidth / 2.0, vDistance)) * aa;\n#endif\n    gl_FragColor = vec4(color, opacity * aa);\n}\n";

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineVert.glsl":
/*!*************************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineVert.glsl ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "\n#define MESHLINE_PATH_ROUND_CAP     2.\n#define MESHLINE_PATH_FLAT_CAP      3.\nattribute vec3 position;\nattribute vec2 previous;\nattribute vec2 next;\nattribute float side;\nattribute float width;\nattribute float counters;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float opacity;\nvarying float vCounters;\nvarying float vPointType;\nvarying float vDistance;\nvarying float aaRange;\nvarying float totalWidth;\nvarying vec2 center;\nvarying vec2 finalPos;\nfloat when_eq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\nfloat when_neq(float x, float y) {\n  return abs(sign(x - y));\n}\nvoid main() {\n    float pixelsPerUnit = 0.5 * resolution.x * projectionMatrix[0][0];\n    vCounters = counters;\n    vPointType = abs(side);\n    float sideSgn = sign(side);\n    vec4 curPosition = modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    vec2 prevPos = (modelViewMatrix * vec4(previous, 0.0, 1.0)).xy;\n    vec2 nextPos = (modelViewMatrix * vec4(next, 0.0, 1.0)).xy;\n#ifdef IS_IE_11\n    aaRange = when_neq(width, 0.0) * when_eq(opacity, 1.0) * 1.0 / pixelsPerUnit;\n#else\n    aaRange = when_neq(width, 0.0) * 1.0 / pixelsPerUnit;\n#endif\n    \n    float minSize = when_neq(width, 0.0) * 0.5 / pixelsPerUnit;    \n   \n    totalWidth = lineWidth * width;\n    \n    float w = max(.5 * totalWidth, minSize) + aaRange;\n    \n    vDistance = w * sideSgn;\n    vec2 dir;\n    if (nextPos == curPosition.xy) {\n        dir = normalize(curPosition.xy - prevPos);\n    } else if (prevPos == curPosition.xy) {\n        dir = normalize(nextPos - curPosition.xy);\n    } else {\n#ifdef MITER\n        vec2 dir1 = normalize(curPosition.xy - prevPos);\n        vec2 dir2 = normalize(nextPos - curPosition.xy);\n        dir = normalize(dir1 + dir2);\n        vec2 perp = vec2(-dir1.y, dir1.x);\n        vec2 miter = vec2(-dir.y, dir.x);\n        w = clamp(w / dot(miter, perp), minSize + aaRange, 20. * w);\n#else\n        dir = normalize(curPosition.xy - prevPos);\n#endif\n    }\n    vec2 normal = vec2(-dir.y, dir.x);\n    normal *= w * sideSgn;\n    \n    if (vPointType == MESHLINE_PATH_ROUND_CAP) {\n        center = curPosition.xy;\n        curPosition.xy += normal;\n    } else  {\n        curPosition.xy += normal;\n        center = curPosition.xy;\n    }\n    \n    if (vCounters < 0.0 || vCounters > 1.0) {\n        normal = vec2(dir.x, dir.y);\n        normal *= sign(vCounters) * w;\n        curPosition.xy += normal;\n    }\n  \n    finalPos = curPosition.xy;\n    gl_Position = projectionMatrix * curPosition;\n}\n";

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/FrameRenderer.css":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/FrameRenderer.css ***!
  \******************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ "./node_modules/css-loader/dist/runtime/noSourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".markup-frames-container {\n  transform: translateZ(0);\n  left: 0;\n  top: 0;\n  position: absolute; }\n\n.markup-selection-frame-container {\n  display: none; }\n\n.markup-selection-frame-container.visible {\n  display: block; }\n\n.markup-selection-frame {\n  transform: translateZ(0);\n  position: absolute;\n  pointer-events: none; }\n\n.markup-selection-frame.fill {\n  display: none;\n  background-color: rgba(6, 150, 215, 0.05); }\n\n/* iOS devices won't update the border without it. */\n.markup-selection-frame.fill.ios,\n.markup-selection-frame.border.ios {\n  transform: translateZ(0);\n  -webkit-transform: rotateZ(0deg); }\n\n.markup-selection-frame.fill.visible {\n  display: block; }\n\n.markup-selection-frame.border {\n  background-color: rgba(6, 150, 215, 0.6); }\n\n.markup-selection-frame.segment {\n  display: none; }\n\n.markup-selection-frame.segment.visible {\n  display: block; }\n\n.markup-anchor {\n  transform: translateZ(0);\n  display: none;\n  position: absolute;\n  background: #FFFFFF;\n  box-shadow: 0 0 0 1px rgba(107, 120, 127, 0.7);\n  pointer-events: none;\n  border-radius: 20px;\n  z-index: 1; }\n\n.markup-anchor-fill.rectangle,\n.markup-anchor.rectangle {\n  border-radius: 0px; }\n\n.markup-anchor-fill {\n  display: none;\n  width: 100%;\n  margin: 1px;\n  border-radius: 20px;\n  background: #0696D7; }\n\n.markup-anchor-fill.visible {\n  display: block; }\n\n.markup-anchor.visible {\n  display: flex; }\n\n.rect-selector-frame {\n  transform: translateZ(0);\n  position: absolute;\n  pointer-events: none;\n  border: #222222 dashed 1px;\n  border-radius: 5px; }\n\n.rect-selector-frame.visible {\n  display: block; }\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/Links/LinksRenderer.css":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/Links/LinksRenderer.css ***!
  \************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ "./node_modules/css-loader/dist/runtime/noSourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".markup-links-container {\n  transform: translateZ(0);\n  left: 0;\n  top: 0;\n  position: absolute; }\n\n.link {\n  display: none;\n  position: absolute;\n  pointer-events: none;\n  z-index: 1; }\n\n.link.visible {\n  display: block; }\n\n.link.transparent {\n  opacity: 0.3; }\n\n/* Document attachment link */\n.link-document-attachment {\n  transform: translateZ(0);\n  display: block;\n  position: absolute;\n  text-align: center;\n  font-family: \"Artifakt Element\";\n  background-color: #0696D7;\n  border-radius: 10.5px;\n  color: white;\n  cursor: pointer;\n  font-size: 13px;\n  font-weight: 500;\n  line-height: 19px;\n  height: 20px;\n  width: 40px; }\n\n.link-document-attachment:before {\n  font-family: \"bimviewericon\", sans-serif;\n  content: \"\\e911\";\n  font-size: 11px;\n  padding-right: 4px; }\n\n.link.selected .link-document-attachment {\n  background-color: #0584BD; }\n\n.link.hover .link-document-attachment {\n  background-color: #38ABDF; }\n\n.link.editable .link-document-attachment {\n  outline: 1px solid rgba(6, 150, 215, 0.6); }\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/RendererHelpers/TextRenderer.css":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/RendererHelpers/TextRenderer.css ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ "./node_modules/css-loader/dist/runtime/noSourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".markup-text-container {\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  pointer-events: none; }\n\n.markup-text {\n  /* Optimization */\n  will-change: contents;\n  transform: translateZ(0);\n  text-rendering: geometricPrecision;\n  display: none;\n  position: absolute;\n  /* changing position to fixed solves the 'out of screen' text expansion, but cause the text be visible on top of other element */\n  pointer-events: none;\n  text-align: left;\n  white-space: pre-wrap;\n  overflow-wrap: break-word;\n  word-wrap: break-word;\n  /* IE11 replacement for overflow-wrap */\n  outline: none;\n  -webkit-user-select: none;\n  user-select: none; }\n\n/* IE uses <p> tag elements instead of divs inside contentedible,\n   inherit style to mimic div style.\n   add min width to edge cases.\n*/\n.markup-text p {\n  display: block;\n  box-sizing: content-box;\n  font-weight: inherit;\n  font-size: inherit;\n  font-family: inherit;\n  font-style: inherit;\n  word-wrap: inherit;\n  white-space: inherit;\n  line-height: inherit;\n  text-rendering: geometricPrecision;\n  -ms-text-size-adjust: 100%;\n  text-align: left;\n  margin: 0 0 0 0;\n  padding: 0 0 0 0;\n  user-select: text; }\n\n.markup-text.single-line br {\n  display: none; }\n\n.markup-text.visible {\n  display: block; }\n\n.markup-text-area {\n  pointer-events: all;\n  position: absolute;\n  z-index: 100; }\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var _i = 0; _i < this.length; _i++) {
        var id = this[_i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i2 = 0; _i2 < modules.length; _i2++) {
      var item = [].concat(modules[_i2]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/endOfDay/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/endOfDay/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ endOfDay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isWithinInterval/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/date-fns/esm/isWithinInterval/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isWithinInterval)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The function was renamed from `isWithinRange` to `isWithinInterval`.
 *   This change was made to mirror the use of the word "interval" in standard ISO 8601:2004 terminology:
 *
 *   ```
 *   2.1.3
 *   time interval
 *   part of the time axis limited by two instants
 *   ```
 *
 *   Also, this function now accepts an object with `start` and `end` properties
 *   instead of two arguments as an interval.
 *   This function now throws `RangeError` if the start of the interval is after its end
 *   or if any date in the interval is `Invalid Date`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *
 *   isWithinRange(
 *     new Date(2014, 0, 3),
 *     new Date(2014, 0, 1), new Date(2014, 0, 7)
 *   )
 *
 *   // v2.0.0 onward
 *
 *   isWithinInterval(
 *     new Date(2014, 0, 3),
 *     { start: new Date(2014, 0, 1), end: new Date(2014, 0, 7) }
 *   )
 *   ```
 *
 * @param {Date|Number} date - the date to check
 * @param {Interval} interval - the interval to check
 * @returns {Boolean} the date is within the interval
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date }) // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end }) // => true
 */

function isWithinInterval(dirtyDate, dirtyInterval) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var interval = dirtyInterval || {};
  var time = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var startTime = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(interval.start).getTime();
  var endTime = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(interval.end).getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`

  if (!(startTime <= endTime)) {
    throw new RangeError('Invalid interval');
  }

  return time >= startTime && time <= endTime;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/parseISO/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/parseISO/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseISO)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The previous `parse` implementation was renamed to `parseISO`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward
 *   parseISO('2016-01-01')
 *   ```
 *
 * - `parseISO` now validates separate date and time values in ISO-8601 strings
 *   and returns `Invalid Date` if the date is invalid.
 *
 *   ```javascript
 *   parseISO('2018-13-32')
 *   //=> Invalid Date
 *   ```
 *
 * - `parseISO` now doesn't fall back to `new Date` constructor
 *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * var result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO(argument, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.additionalDigits);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (isNaN(date) || !date) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);

    if (isNaN(time) || time === null) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }

  return new Date(timestamp + time + offset);
}

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString; // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].

  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: null
  };
  var year = captures[1] && parseInt(captures[1]);
  var century = captures[2] && parseInt(captures[2]);
  return {
    year: century == null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return null;
  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

  if (!captures) return null;
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return null; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
}

function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100;
}

function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfDay/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfDay/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfDay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/toDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/toDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),

/***/ "./extensions/BimMarkups/Actions/AddMarkupAction.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/Actions/AddMarkupAction.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AddMarkupAction)
/* harmony export */ });
/* harmony import */ var _Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/ActionManager/Action */ "./extensions/BimMarkups/Utils/ActionManager/Action.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

AddMarkupAction = /*#__PURE__*/function (_Action) {_inherits(AddMarkupAction, _Action);var _super = _createSuper(AddMarkupAction);
  function AddMarkupAction(markupsManager, markup, layer) {var _this;_classCallCheck(this, AddMarkupAction);
    _this = _super.call(this, markupsManager.actionManager);

    _this.markupsManager = markupsManager;
    _this.markup = markup;
    _this.layer = layer;return _this;
  }_createClass(AddMarkupAction, [{ key: "undo", value: function undo()

    {
      this.markupsManager.removeMarkupFromLayer(this.markup);
    } }, { key: "redo", value: function redo()

    {
      this.markupsManager.addMarkupToLayer(this.markup, this.layer);
    } }]);return AddMarkupAction;}(_Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Actions/DeleteMarkupAction.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/Actions/DeleteMarkupAction.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteMarkupAction)
/* harmony export */ });
/* harmony import */ var _Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/ActionManager/Action */ "./extensions/BimMarkups/Utils/ActionManager/Action.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

DeleteMarkupAction = /*#__PURE__*/function (_Action) {_inherits(DeleteMarkupAction, _Action);var _super = _createSuper(DeleteMarkupAction);
  function DeleteMarkupAction(markupsManager, markup) {var _this;_classCallCheck(this, DeleteMarkupAction);
    _this = _super.call(this, markupsManager.actionManager);

    _this.markupsManager = markupsManager;
    _this.markup = markup;
    _this.layer = _this.markup.layer;return _this;
  }_createClass(DeleteMarkupAction, [{ key: "undo", value: function undo()

    {
      this.markupsManager.addMarkupToLayer(this.markup, this.layer);
    } }, { key: "redo", value: function redo()

    {
      this.markupsManager.removeMarkupFromLayer(this.markup);
    } }]);return DeleteMarkupAction;}(_Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Actions/UpdateMarkupAction.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/Actions/UpdateMarkupAction.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateMarkupAction)
/* harmony export */ });
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/ActionManager/Action */ "./extensions/BimMarkups/Utils/ActionManager/Action.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

UpdateMarkupAction = /*#__PURE__*/function (_Action) {_inherits(UpdateMarkupAction, _Action);var _super = _createSuper(UpdateMarkupAction);
  function UpdateMarkupAction(markupsManager, markup, newState) {var _this;_classCallCheck(this, UpdateMarkupAction);
    _this = _super.call(this, markupsManager.actionManager);

    _this.markupsManager = markupsManager;
    _this.markup = markup;
    _this.layer = _this.markup.layer;

    _this.oldState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(_this.markup.getState());
    _this.newState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(newState);return _this;
  }_createClass(UpdateMarkupAction, [{ key: "undo", value: function undo()

    {
      this.markup.setState(this.oldState);
      this.markup.syncEditState();
    } }, { key: "redo", value: function redo()

    {
      this.markup.setState(this.newState);
      this.markup.syncEditState();
    } }]);return UpdateMarkupAction;}(_Utils_ActionManager_Action__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/CacheObject.js":
/*!**********************************************!*\
  !*** ./extensions/BimMarkups/CacheObject.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CacheObject)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var CacheObject = /*#__PURE__*/function () {
  function CacheObject() {_classCallCheck(this, CacheObject);
    this.cache = {};
    this.currentUrn = 'default';
  }_createClass(CacheObject, [{ key: "setCurrentUrn", value: function setCurrentUrn(

    urn) {
      this.currentUrn = urn;
      this.cache[urn] = this.cache[urn] || {};
    } }, { key: "add", value: function add(

    id, item) {var urn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.currentUrn;
      this.cache[urn][id] = item;
    } }, { key: "remove", value: function remove(

    id) {var urn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentUrn;
      delete this.cache[urn][id];
    } }, { key: "get", value: function get(

    id) {var urn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentUrn;
      return this.cache[urn][id];
    } }, { key: "getAsList", value: function getAsList()

    {var _this = this;var urn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentUrn;
      var list = [];

      Object.keys(this.cache[urn]).forEach(function (key) {
        list.push(_this.cache[urn][key]);
      });

      return list;
    } }, { key: "getCache", value: function getCache()

    {var urn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentUrn;
      return this.cache[urn];
    } }, { key: "cleanCache", value: function cleanCache()

    {var _this2 = this;var urn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentUrn;
      Object.keys(this.cache[urn]).forEach(function (key) {
        _this2.remove(key);
      });
    } }, { key: "length", value: function length()

    {var urn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentUrn;
      return Object.keys(this.cache[urn]).length;
    } }, { key: "isEmpty", value: function isEmpty()

    {var urn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentUrn;
      return this.length(urn) === 0;
    } }]);return CacheObject;}();

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/AnchorHandler.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/AnchorHandler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnchorHandler)
/* harmony export */ });
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

AnchorHandler = /*#__PURE__*/function (_EditHandler) {_inherits(AnchorHandler, _EditHandler);var _super = _createSuper(AnchorHandler);function AnchorHandler() {_classCallCheck(this, AnchorHandler);return _super.apply(this, arguments);}_createClass(AnchorHandler, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {
      if (this.activeAnchor) {
        point = this.getSnappedPosition();

        this.markup.applyInverseRotation(point);
        this.markup.applyInverseScaleAndTranslation(point);

        if (this.markupsExtension.markupsTool.shiftDown) {
          this.snapAxis(point);
        }

        this.updateActiveAnchor(point);

        return true;
      }

      return false;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.activeAnchor) {
        this.activeAnchor = this.intersect(point);

        if (this.activeAnchor) {
          this.originalAnchor = this.activeAnchor.clone();
          this.editStart();
        }

        return !!this.activeAnchor;
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.activeAnchor) {
        point = this.getSnappedPosition();

        this.markup.applyInverseRotation(point);
        this.markup.applyInverseScaleAndTranslation(point);

        if (this.markupsExtension.markupsTool.shiftDown) {
          this.snapAxis(point);
        }

        this.updateActiveAnchor(point);

        if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__.isEqualVectors)(this.activeAnchor, this.originalAnchor, this.getMinChangeDistanceWorld())) {
          this.cancelAnchorEditing();
        } else {
          this.submitChanges();
          this.editEnd();
        }

        this.activeAnchor = null;

        return true;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (this.activeAnchor) {
        switch (keyCode) {
          case Autodesk.Viewing.KeyCode.BACKSPACE:
          case Autodesk.Viewing.KeyCode.DELETE:
          case Autodesk.Viewing.KeyCode.ESCAPE:
            this.cancelAnchorEditing();
            return true;
          default:
            break;}

      }

      return false;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
    } }, { key: "updateActiveAnchor", value: function updateActiveAnchor(

    point) {
      this.activeAnchor.copy(point);
      this.updateEditStateAnchors();
      this.handleCompensation();
    } }, { key: "cancelAnchorEditing", value: function cancelAnchorEditing()

    {
      this.activeAnchor = null;
      this.markup.syncEditState();
      this.updateEditStateAnchors();
      this.editEnd();
    } }, { key: "isDragging", value: function isDragging()

    {
      return !!this.activeAnchor;
    } }, { key: "snapAxis", value: function snapAxis(

    point) {var _this = this;
      var anchors = this.markup.getAnchors();
      var index = anchors.findIndex(function (anchor) {return anchor === _this.activeAnchor;});

      if (anchors[index - 1]) {
        this.snapPointToAxis(point, anchors[index - 1], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES);
      } else if (anchors[index + 1]) {
        this.snapPointToAxis(point, anchors[index + 1], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES);
      }
    } }, { key: "intersect", value: function intersect(

    point) {var _this2 = this;
      point = point.clone();
      this.markup.applyInverseRotation(point);
      this.markup.applyInverseScaleAndTranslation(point);

      var p = this.markupsExtension.renderer.worldToClient(point);

      var anchors = this.markup.getAnchors();

      return anchors.find(function (anchor) {
        if (!_this2.markup.isAnchorHandlingAllowed(anchor)) return;

        var a = _this2.markupsExtension.renderer.worldToClient(anchor);
        return a.distanceTo(p) <= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.TOUCH_RADIUS;
      });
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.activeAnchor) {
        return 'grabbing';
      } else {
        return 'grab';
      }
    } }]);return AnchorHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js":
/*!********************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandler)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var

CreationHandler = /*#__PURE__*/function (_EditHandler) {_inherits(CreationHandler, _EditHandler);var _super = _createSuper(CreationHandler);
  function CreationHandler(markupsExtension, markup) {var _this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, CreationHandler);
    _this = _super.call(this, markupsExtension, markup, options);

    // Used for compound markups.
    _this.onCreationStartCB = options.onCreationStart;
    _this.onCreationEndCB = options.onCreationEnd;return _this;
  }

  // Use creationStart when markup creation begins (First click).
  _createClass(CreationHandler, [{ key: "creationStart", value: function creationStart() {
      this.creationStarted = true;

      if (this.onCreationStartCB) {
        this.onCreationStartCB();
      } else {
        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DRAWING_START, markup: this.markup });
        this.markupsExtension.markupsManager.deselectAllMarkups();
        this.markupsExtension.markupsManager.deselectAllLinks();

        this.editStart();
      }
    }

    // TODO: Replace this logic with initial rotation of the markup.

    // Initial markup's bounding box should always be aligned with the screen.
    // In case the camera's rotation is not 0 in markup's creation time, we have to rotate it accordingly.
    // The process is not trivial when the markup has several creation steps (like polyline). In this scenario,
    // What we need to do is modifying the rotation for all the history of the markup's creation.
    // In order to do that, we traverse through all the actions that's relevant to the markup's creation, and change their history.
  }, { key: "fixInitialRotation", value: function fixInitialRotation() {var _this2 = this;
      // rotationNotAllowed check: for group components not allowed to rotate through interaction
      if (this.markup.rotationHandler || this.markup.options.rotationNotAllowed) {(function () {
          var cameraRotation = _this2.markupsExtension.renderer.getCameraRotation();

          if (Math.abs(cameraRotation) > _MarkupsConstants__WEBPACK_IMPORTED_MODULE_4__.EPSILON) {(function () {
              var eyeDirection = _this2.markupsExtension.renderer.getCameraEyeVector();var

              actionManager = _this2.markupsExtension.markupsManager.actionManager;

              while (!actionManager.isUndoStackEmpty()) {
                var currentAction = actionManager.undoStack[actionManager.undoStack.length - 1];

                if (Array.isArray(currentAction)) {
                  currentAction = currentAction[currentAction.length - 1];
                }

                if (currentAction.markup !== _this2.markup) {
                  break;
                }

                // Modify markup's anchors, so the rotation won't affect the final result, except of the bounding box.
                var _this2$getEditState = _this2.getEditState(),anchors = _this2$getEditState.anchors;
                anchors.forEach(function (anchor) {
                  _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(anchor, cameraRotation, _this2.markup.getWorldCenter(), eyeDirection);
                });

                _this2.prevCenter = _this2.markup.center.clone();

                _this2.markup.setLocked(true);
                _this2.updateEditStateAnchors();
                _this2.updateEditState({ rotation: -cameraRotation });
                _this2.markup.setLocked(false);

                // In order to prevent a jump in the markup's position, we call handleCompensation.
                _this2.handleCompensation();

                // Override history
                var clonedState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(_this2.getEditState());

                currentAction.markup.state = clonedState;
                currentAction.markup.editState = clonedState;

                if (currentAction.newState) {
                  currentAction.newState = clonedState;
                }

                if (!actionManager.isRedoStackEmpty()) {
                  actionManager.redoStack[actionManager.redoStack.length - 1].oldState = clonedState;
                }

                if (actionManager.isGroupOpen) {
                  // Can't undo while group is open, so break to avoid infinite loop
                  // Furthermore, this case will happen when creating a group markup
                  break;
                }
                actionManager.undo();
              }

              while (!actionManager.isRedoStackEmpty()) {
                actionManager.redo();
              }})();
          }})();
      }
    }

    // Use creationEnd when the markup creation / edition is complete.
  }, { key: "creationEnd", value: function creationEnd(point) {
      this.fixInitialRotation();

      if (this.onCreationEndCB) {
        this.onCreationEndCB(point);
      } else {
        this.markup.disableEdit();

        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DRAWING_END, markup: this.markup });
        this.markupsExtension.markupsManager.duringCreationMarkup = null;
        this.editEnd();

        this.markup.complete();
      }
    } }, { key: "creationCancel", value: function creationCancel()

    {
      if (this.markup.anchorHandler) {
        this.markup.anchorHandler.cancelAnchorEditing();
      }

      this.markup.disableEdit();

      this.markup.remove();

      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, markup: this.markup });
      this.markupsExtension.markupsManager.duringCreationMarkup = null;
      this.editEnd();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
          this.creationCancel();
          return true;
        case Autodesk.Viewing.KeyCode.ESCAPE:
          return this.onEscape();
        default:
          break;}


      return false;
    } }, { key: "onEscape", value: function onEscape()

    {
      this.creationCancel();

      return true;
    } }]);return CreationHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrow.js":
/*!*************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrow.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerArrow)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerArrow = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerArrow, _CreationHandler);var _super = _createSuper(CreationHandlerArrow);
  function CreationHandlerArrow(markupsExtension, markup) {var _this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, CreationHandlerArrow);
    _this = _super.call(this, markupsExtension, markup, options);

    _this.tailIndex = options.reverseHead ? 1 : 0;
    _this.headIndex = options.reverseHead ? 0 : 1;return _this;
  }_createClass(CreationHandlerArrow, [{ key: "handleMouseMove", value: function handleMouseMove(

    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;

      if (!anchors[this.headIndex]) {
        anchors[this.headIndex] = anchors[this.tailIndex]; // For the case when creation starts at index 1 (reverseHead=true)
      }

      if (!this.creationStarted) {
        this.creationStart();
      }

      if (anchors[this.tailIndex]) {
        if (this.markupsExtension.markupsTool.shiftDown) {
          this.snapPointToAxis(point, anchors[this.tailIndex], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.ROTATION_SNAP_DEGREES);
        }

        anchors[this.headIndex] = point;
        this.updateEditStateAnchors();
      }

      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {var _this$getEditState2 =
      this.getEditState(),anchors = _this$getEditState2.anchors;

      if (!anchors[this.tailIndex]) {
        anchors[this.tailIndex] = point;
        this.updateEditStateAnchors();
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {var _this$getEditState3 =
      this.getEditState(),anchors = _this$getEditState3.anchors;

      if (!anchors[this.headIndex]) {
        return this.handleMouseMove(point, button);
      } else if (!this.isSamePoint(point, anchors[this.tailIndex])) {
        if (this.markupsExtension.markupsTool.shiftDown) {
          this.snapPointToAxis(point, anchors[this.tailIndex], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.ROTATION_SNAP_DEGREES);
        }

        anchors[this.headIndex] = point;

        this.updateEditStateAnchors();

        this.submitChanges();

        this.creationEnd(point);
      } else {
        this.creationCancel();
        return false;
      }

      return true;
    } }]);return CreationHandlerArrow;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCallout.js":
/*!********************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCallout.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerArrowCallout)
/* harmony export */ });
/* harmony import */ var _CreationHandlerCallout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandlerCallout */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCallout.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerArrowCallout = /*#__PURE__*/function (_CreationHandlerCallo) {_inherits(CreationHandlerArrowCallout, _CreationHandlerCallo);var _super = _createSuper(CreationHandlerArrowCallout);
  function CreationHandlerArrowCallout(markupsExtension, markup, options) {_classCallCheck(this, CreationHandlerArrowCallout);return _super.call(this,
    markupsExtension, markup, options, [
    {
      class: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_ARROW,
      options: { reverseHead: true, tailHandlingNotAllowed: true } },

    {
      class: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_CALLOUT,
      options: { requiresClick: true, rotationNotAllowed: true, frameType: options.calloutFrameType ? options.calloutFrameType : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_RECTANGLE } }]);


  }_createClass(CreationHandlerArrowCallout, [{ key: "getArrowIndex", value: function getArrowIndex()

    {
      return 0;
    } }, { key: "getTextIndex", value: function getTextIndex()

    {
      return 1;
    } }]);return CreationHandlerArrowCallout;}(_CreationHandlerCallout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCloudCallout.js":
/*!*************************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCloudCallout.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerArrowCloudCallout)
/* harmony export */ });
/* harmony import */ var _CreationHandlerCallout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandlerCallout */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCallout.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerArrowCloudCallout = /*#__PURE__*/function (_CreationHandlerCallo) {_inherits(CreationHandlerArrowCloudCallout, _CreationHandlerCallo);var _super = _createSuper(CreationHandlerArrowCloudCallout);
  function CreationHandlerArrowCloudCallout(markupsExtension, markup, options) {_classCallCheck(this, CreationHandlerArrowCloudCallout);return _super.call(this,
    markupsExtension, markup, options, [
    {
      class: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_CLOUD,
      options: { fillNotAllowed: true, rotationNotAllowed: true } },

    {
      class: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_ARROW,
      options: { reverseHead: true, headHandlingNotAllowed: true, tailHandlingNotAllowed: true } },

    {
      class: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_CALLOUT,
      options: { requiresClick: true, rotationNotAllowed: true, frameType: options.calloutFrameType ? options.calloutFrameType : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_RECTANGLE } }]);


  }_createClass(CreationHandlerArrowCloudCallout, [{ key: "getArrowIndex", value: function getArrowIndex()

    {
      return 1;
    } }, { key: "getTextIndex", value: function getTextIndex()

    {
      return 2;
    } }]);return CreationHandlerArrowCloudCallout;}(_CreationHandlerCallout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCallout.js":
/*!***************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCallout.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerCallout)
/* harmony export */ });
/* harmony import */ var _CreationHandlerCompound__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandlerCompound */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCompound.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerCallout = /*#__PURE__*/function (_CreationHandlerCompo) {_inherits(CreationHandlerCallout, _CreationHandlerCompo);var _super = _createSuper(CreationHandlerCallout);
  function CreationHandlerCallout(markupsExtension, markup, options, classes) {_classCallCheck(this, CreationHandlerCallout);return _super.call(this,
    markupsExtension, markup, options, classes);
  }_createClass(CreationHandlerCallout, [{ key: "afterNextMarkupCreated", value: function afterNextMarkupCreated(

    step) {
      if (step !== this.getTextIndex()) {
        return;
      }

      var arrow = this.getArrow();
      var text = this.getText();

      var bbox = text.getWorldBoundingBox(true);
      var halfThickness = text.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.STYLE_PROPERTIES.THICKNESS] / 2;
      var halfHeight = bbox.getSize(new THREE.Vector3()).y / 2 - halfThickness;
      var halfWidth = bbox.getSize(new THREE.Vector3()).x / 2 - halfThickness;

      var arrowHead = arrow.getHead();
      var arrowTail = arrow.getTail();

      var angle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x);

      var translation;
      switch (this.markup.getTextQuadrant(angle)) {
        case 1:
          translation = new THREE.Vector3(0, halfHeight, 0);
          break;
        case 2:
          translation = new THREE.Vector3(-halfWidth, 0, 0);
          break;
        case 3:
          translation = new THREE.Vector3(0, -halfHeight, 0);
          break;
        case 4:
          translation = new THREE.Vector3(halfWidth, 0, 0);
          break;}


      if (text.editState.frameType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_CLOUD) {
        var tailPoint = translation.clone().negate();
        var delta = this.markup.getVectorToClosestPointOnCloud(tailPoint);
        translation.add(delta);
      }

      text.creationHandler.updateEditState({ translation: translation });
      text.creationHandler.submitChanges();
    } }, { key: "getArrowIndex", value: function getArrowIndex()

    {
      throw new Error('getArrowIndex needs implementation');
    } }, { key: "getTextIndex", value: function getTextIndex()

    {
      throw new Error('getTextIndex needs implementation');
    } }, { key: "getArrow", value: function getArrow()

    {
      return this.markup.markups[this.getArrowIndex()];
    } }, { key: "getText", value: function getText()

    {
      return this.markup.markups[this.getTextIndex()];
    } }]);return CreationHandlerCallout;}(_CreationHandlerCompound__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCompound.js":
/*!****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerCompound.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerCompound)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerCompound = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerCompound, _CreationHandler);var _super = _createSuper(CreationHandlerCompound);
  function CreationHandlerCompound(markupsExtension, markup, options) {var _this;var markupClasses = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];_classCallCheck(this, CreationHandlerCompound);
    _this = _super.call(this, markupsExtension, markup, options);

    _this.creationHandlers = [];
    _this.currentStep = 0;
    _this.lastCompleted = -1;

    _this.markup.markups = [];

    var componentsState = [];
    // The uuid is used to connect the group markup with its components
    // They will have this same number saved under groupId
    if (_this.markup.state.uuid) {
      // uuid already exists, so markup is being loaded
      componentsState = _this.markup.state.componentsState.sort(function (a, b) {return a.groupOrder - b.groupOrder;});
    } else {
      _this.markup.state.uuid = _this.markup.editState.uuid = THREE.Math.generateUUID();
    }

    _this.markupClasses = markupClasses;
    _this.numMarkups = markupClasses.length;

    for (var i = 0; i < _this.numMarkups; i++) {
      var markupType = markupClasses[i].class;
      var _options = markupClasses[i].options || {};

      _this._restoreFill(componentsState[i], markupClasses[i], componentsState);

      var isLast = i === markupClasses.length - 1;
      _options.onCreationEnd = function (point) {_this.onCreationEnd(point);};
      _options.onCreationStart = function () {_this.onCreationStart();};

      var componentState = Object.assign({}, componentsState[i], { groupId: _this.markup.state.uuid, groupOrder: i });
      var subMarkup = _this.markupsExtension.markupsManager.createMarkup(markupType, componentState, _options);

      if (!isLast) {
        subMarkup.selectWhenCompleted = function () {return false;};
      }

      subMarkup.markupGroup = _this.markup;

      _this.markup.markups.push(subMarkup);

      _this.creationHandlers.push(subMarkup.creationHandler);
    }

    delete _this.markup.state.componentsState; // Used only for loading
    return _this;}_createClass(CreationHandlerCompound, [{ key: "_restoreFill", value: function _restoreFill(

    currentComponentState, markupClass, componentsState) {
      if (currentComponentState && markupClass.options.fillNotAllowed) {
        // Get the fill values from another markup class. We set it to none only for export purposes
        // To keep things consistent in the UI, all markups should have the same values
        for (var j = 0; j < this.numMarkups; j++) {
          if (markupClass !== this.markupClasses[j] && (!this.markupClasses[j].options || !this.markupClasses[j].options.fillNotAllowed)) {
            currentComponentState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.STYLE_PROPERTIES.FILL_OPACITY] = componentsState[j].style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.STYLE_PROPERTIES.FILL_OPACITY];
            currentComponentState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.STYLE_PROPERTIES.FILL_COLOR] = componentsState[j].style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.STYLE_PROPERTIES.FILL_COLOR];
            break;
          }
        }
      }
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    point) {
      return this.creationHandlers[this.currentStep].handleMouseMove(point);
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      return this.creationHandlers[this.currentStep].handleButtonDown(point, button);
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      return this.creationHandlers[this.currentStep].handleButtonUp(point, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    point, button) {
      return this.creationHandlers[this.currentStep].handleDoubleClick(point, button);
    } }, { key: "creationCancel", value: function creationCancel()

    {
      _get(_getPrototypeOf(CreationHandlerCompound.prototype), "creationCancel", this).call(this);

      this.markupsExtension.markupsManager.closeActionGroup();

      while (this.currentStep-- > 0) {
        this.markupsExtension.markupsManager.actionManager.undo(false);
      }
    } }, { key: "onCreationStart", value: function onCreationStart()

    {
      if (this.currentStep === 0) {
        this.markupsExtension.markupsManager.openActionGroup();
        this.creationStart();
      }
      this.markup.markups[this.currentStep].setVisible(true);
      this.markup.markups[this.currentStep].enableEdit();
    } }, { key: "closeGroup", value: function closeGroup()

    {
      // For the case when the last markup requires a click, the last onCreationEnd will be called 
      // before the previous one finishes. This check assures that Whichever ends last will close the group.
      // (lastCompleted will always lag one step behind currentStep until the end)
      if (this.lastCompleted === this.currentStep) {
        this.markupsExtension.markupsManager.closeActionGroup();
      }
      this.lastCompleted = this.currentStep;
    } }, { key: "onCreationEnd", value: function onCreationEnd(

    point) {
      this.markup.markups[this.currentStep].disableEdit();
      this.markup.markups[this.currentStep].complete();

      if (this.currentStep === this.numMarkups - 1) {
        this.submitChanges();
        this.creationEnd(point);
      } else {
        var nextPoint = this.markup.markups[this.currentStep].getStartPointForNextMarkup();
        this.currentStep += 1;

        if (this.markupClasses[this.currentStep].options.requiresClick) {
          this.creationHandlers[this.currentStep].handleClick(nextPoint);
        } else {
          this.creationHandlers[this.currentStep].handleButtonDown(nextPoint);
        }

        this.afterNextMarkupCreated(this.currentStep);
      }

      this.closeGroup();
    }

    // For optionally locating the markups in the correct position after creating
    // (to take into account constraints)
  }, { key: "afterNextMarkupCreated", value: function afterNextMarkupCreated(step) {

    } }]);return CreationHandlerCompound;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerDimension.js":
/*!*****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerDimension.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerDimension)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerDimension = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerDimension, _CreationHandler);var _super = _createSuper(CreationHandlerDimension);
  function CreationHandlerDimension(markupsExtension, markup, options) {var _this;_classCallCheck(this, CreationHandlerDimension);
    _this = _super.call(this, markupsExtension, markup, options);

    _this.measurement = new Autodesk.Viewing.MeasureCommon.Measurement(Autodesk.Viewing.MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE);

    _this.snapper = _this.markupsExtension.markupsTool.snapper;
    _this.viewer = _this.markupsExtension.viewer;return _this;
  }_createClass(CreationHandlerDimension, [{ key: "getMeasureExtension", value: function getMeasureExtension()

    {
      if (!this.measureExtension) {
        this.measureExtension = this.markupsExtension.viewer.getExtension('Autodesk.Measure');

        if (!this.measureExtension) {
          console.error('Measure extension not available!');
        }
      }

      return this.measureExtension;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;

      if (!this.creationStarted) {
        this.creationStart();
      }

      if (anchors[0]) {
        if (this.markupsExtension.markupsTool.shiftDown && this.viewer.impl.is2d) {
          this.snapPointToAxis(point, anchors[0], 90);
        }

        // No need to update viewportId for each mousemove. Only for the first time.
        if (!anchors[1]) {
          this.updateViewportId(this.measurement.getPick(1).viewportIndex2d);
        }

        this.pickSecondAnchor(point);
      }

      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      var measureExtension = this.getMeasureExtension();

      // If PDF, force calibration
      if ((measureExtension.forceCalibrate || this.viewer.model.isLeaflet() || this.viewer.model.isPdf(true)) && !measureExtension.calibrationTool.isCalibrated()) {
        measureExtension.openCalibrationRequiredDialog('dimension');
        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__.MARKUPS_EVENTS.CALIBRATION_REQUIRED });

        this.creationCancel();
        return true;
      }var _this$getEditState2 =

      this.getEditState(),anchors = _this$getEditState2.anchors;

      if (!anchors[0]) {
        if (this.snapper.isSnapped()) {
          this.snapper.copyResults(this.measurement.getPick(1));
          var p = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(this.snapper.getSnapResult(), this.viewer);

          anchors[0] = this.markupsExtension.renderer.documentCameraToMarkupsCamera(p);

          this.updateEditStateAnchors();
        } else {
          return false;
        }
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {var _this$getEditState3 =
      this.getEditState(),anchors = _this$getEditState3.anchors;

      if (!anchors[1]) {
        return this.handleMouseMove(point, button);
      } else if (!this.isSamePoint(point, anchors[0])) {
        if (this.markupsExtension.markupsTool.shiftDown && this.viewer.impl.is2d) {
          this.snapPointToAxis(point, anchors[0], 90);
        }

        var isSnapped = this.pickSecondAnchor(point);

        if (isSnapped) {
          this.updateViewportId();

          this.submitChanges();
          this.creationEnd(point);

          if (this.markup.dimensionEditHandler) {
            this.markup.dimensionEditHandler.handleButtonDown(point, button);
          }
        } else {
          return false;
        }
      } else {
        this.creationCancel();

        return false;
      }

      return true;
    } }, { key: "pickSecondAnchor", value: function pickSecondAnchor(

    point) {var _this$getEditState4 =
      this.getEditState(),anchors = _this$getEditState4.anchors;

      // After changing the point position with shiftDown, try to snap again.
      if (this.markupsExtension.markupsTool.shiftDown && this.viewer.impl.is2d) {
        var projectedPoint = this.markupsExtension.renderer.worldToClient(point);
        this.snapper.onMouseMove({ x: projectedPoint.x, y: projectedPoint.y });
      }

      var pick = this.measurement.getPick(2);
      var isSnapped = this.snapper.isSnapped();

      if (isSnapped) {
        this.snapper.copyResults(pick);
        anchors[1] = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(this.snapper.getSnapResult(), this.viewer);
      } else {
        anchors[1] = point;
        pick.geomType = Autodesk.Viewing.MeasureCommon.SnapType.SNAP_VERTEX;
        pick.geomVertex = point;
        pick.intersectPoint = point;
      }

      // Correct Perpendicular
      if (Autodesk.Viewing.MeasureCommon.correctPerpendicularPicks(this.measurement.getPick(1), this.measurement.getPick(2), this.viewer, this.snapper)) {
        anchors[1] = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(this.measurement.getPick(2), this.viewer);
        this.snapper.indicator.render();
      }

      if (isSnapped) {
        anchors[1] = this.markupsExtension.renderer.documentCameraToMarkupsCamera(anchors[1]);
      }

      var text = isSnapped || this.viewer.impl.is2d ? this.getDistance() : '';

      this.updateEditState({ text: text, anchors: anchors });

      return isSnapped;
    } }, { key: "creationCancel", value: function creationCancel()

    {
      _get(_getPrototypeOf(CreationHandlerDimension.prototype), "creationCancel", this).call(this);
      this.updateViewportId();
    } }, { key: "updateViewportId", value: function updateViewportId(

    viewportId) {
      if (this.viewer.model && this.viewer.impl.is2d) {
        if (!viewportId) {
          this.viewer.impl.updateViewportId(0);
          this.snapper.setViewportId(null);
        } else {
          // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
          this.viewer.impl.updateViewportId(viewportId);
          this.snapper.setViewportId(viewportId);
        }
      }
    } }, { key: "getDistance", value: function getDistance()

    {
      var distance = null;
      var measureExtension = this.getMeasureExtension();var
      sharedMeasureConfig = measureExtension.sharedMeasureConfig;

      this.measurement.computeResult(this.measurement.picks, this.markupsExtension.viewer);

      if (this.markupsExtension.viewer.model && this.measurement.distanceXYZ) {
        var d = Autodesk.Viewing.Private.convertUnits(this.markupsExtension.viewer.model.getUnitString(), sharedMeasureConfig.units, sharedMeasureConfig.calibrationFactor, this.measurement.distanceXYZ);
        return Autodesk.Viewing.Private.formatValueWithUnits(d, sharedMeasureConfig.units, 3, sharedMeasureConfig.precision);
      }

      return distance;
    } }]);return CreationHandlerDimension;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFactory.js":
/*!***************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFactory.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerFactory)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _CreationHandlerRectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreationHandlerRectangle */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerRectangle.js");
/* harmony import */ var _CreationHandlerPolyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CreationHandlerPolyline */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolyline.js");
/* harmony import */ var _CreationHandlerPolycloud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CreationHandlerPolycloud */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolycloud.js");
/* harmony import */ var _CreationHandlerFreehand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CreationHandlerFreehand */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFreehand.js");
/* harmony import */ var _CreationHandlerArrow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CreationHandlerArrow */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrow.js");
/* harmony import */ var _CreationHandlerText__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CreationHandlerText */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerText.js");
/* harmony import */ var _CreationHandlerDimension__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CreationHandlerDimension */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerDimension.js");
/* harmony import */ var _CreationHandlerArrowCallout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CreationHandlerArrowCallout */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCallout.js");
/* harmony import */ var _CreationHandlerArrowCloudCallout__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CreationHandlerArrowCloudCallout */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerArrowCloudCallout.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}








var

CreationHandlerFactory = /*#__PURE__*/function () {function CreationHandlerFactory() {_classCallCheck(this, CreationHandlerFactory);}_createClass(CreationHandlerFactory, null, [{ key: "getCreationHandler", value: function getCreationHandler(
    type, markupsExtension, markup) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      switch (type) {
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_LINE:
          return new _CreationHandlerArrow__WEBPACK_IMPORTED_MODULE_5__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_RECTANGLE:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CIRCLE:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CLOUD:
          return new _CreationHandlerRectangle__WEBPACK_IMPORTED_MODULE_1__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_FREEHAND:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_HIGHLIGHT:
          return new _CreationHandlerFreehand__WEBPACK_IMPORTED_MODULE_4__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYCLOUD:
          return new _CreationHandlerPolycloud__WEBPACK_IMPORTED_MODULE_3__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYLINE:
          return new _CreationHandlerPolyline__WEBPACK_IMPORTED_MODULE_2__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CALLOUT:
          return new _CreationHandlerText__WEBPACK_IMPORTED_MODULE_6__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_DIMENSION:
          return new _CreationHandlerDimension__WEBPACK_IMPORTED_MODULE_7__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CALLOUT:
          return new _CreationHandlerArrowCallout__WEBPACK_IMPORTED_MODULE_8__["default"](markupsExtension, markup, options);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CLOUD_CALLOUT:
          return new _CreationHandlerArrowCloudCallout__WEBPACK_IMPORTED_MODULE_9__["default"](markupsExtension, markup, options);

        default:}


      throw new Error("".concat(type, " creation handler does not exist"));
    } }]);return CreationHandlerFactory;}();

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFreehand.js":
/*!****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFreehand.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerFreehand)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

CreationHandlerFreehand = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerFreehand, _CreationHandler);var _super = _createSuper(CreationHandlerFreehand);function CreationHandlerFreehand() {_classCallCheck(this, CreationHandlerFreehand);return _super.apply(this, arguments);}_createClass(CreationHandlerFreehand, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;

      if (anchors.length === 1) {
        this.creationStart();
      }

      this.addPoint(point);

      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      this.addPoint(point);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      this.addPoint(point);

      this.submitChanges();
      this.creationEnd(point);

      return true;
    } }, { key: "addPoint", value: function addPoint(

    point) {var _this$getEditState2 =
      this.getEditState(),anchors = _this$getEditState2.anchors;

      if (anchors.length === 0 || !(0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isEqualVectors)(point, anchors[anchors.length - 1], this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MIN_FREEHAND_POINT_DISTANCE))) {
        // WIP for variable width. Needs further tweaking
        // if (anchors.length > 0) {
        //     const VELOCITY_WEIGHT = 0.8;
        //     const MIN_WIDTH = 0.1;
        //     const newStamp = performance.now();
        //     const deltaTime = newStamp - this.prevStamp;
        //     const distance = this.markupsExtension.renderer.sizeFromWorldToClient(point.distanceTo(anchors[anchors.length - 1]));
        //     let speed = distance / deltaTime * 1000; // px per second
        //     if (this.prevSpeed !== null) { // Low pass filter to 
        //         speed = VELOCITY_WEIGHT * speed + (1 - VELOCITY_WEIGHT) * this.prevSpeed;
        //     }
        //     point.width = Math.max(Math.min(1000 / speed, 1), MIN_WIDTH);
        //     this.prevStamp = newStamp;
        //     this.prevSpeed = speed;
        // } else {
        //     point.width = 1.0;
        //     this.prevStamp = performance.now();
        //     this.prevSpeed = null;
        // }

        anchors.push(point);

        anchors = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.simplify)(anchors, this.markupsExtension.renderer.sizeFromClientToWorld(0.5), true);

        this.updateEditStateAnchors(anchors);
      }
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {var _this$getEditState3 =
      this.getEditState(),anchors = _this$getEditState3.anchors;

      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
        case Autodesk.Viewing.KeyCode.ESCAPE:
          if (anchors.length > 0) {
            this.creationCancel();
          }

          return true;
        default:
          break;}


      return false;
    } }]);return CreationHandlerFreehand;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolycloud.js":
/*!*****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolycloud.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerPolycloud)
/* harmony export */ });
/* harmony import */ var _CreationHandlerPolyline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandlerPolyline */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolyline.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

CreationHandlerPolycloud = /*#__PURE__*/function (_CreationHandlerPolyl) {_inherits(CreationHandlerPolycloud, _CreationHandlerPolyl);var _super = _createSuper(CreationHandlerPolycloud);function CreationHandlerPolycloud() {_classCallCheck(this, CreationHandlerPolycloud);return _super.apply(this, arguments);}_createClass(CreationHandlerPolycloud, [{ key: "beforeCreationEnd",
    // CreationHandlerPolycloud is the same as CreationHandlerPolyline.
    value: function beforeCreationEnd()
    {
      this.updateEditState({ closed: true });
      this.submitChanges();
    } }, { key: "getMinimumPoints", value: function getMinimumPoints()

    {
      return 3;
    } }]);return CreationHandlerPolycloud;}(_CreationHandlerPolyline__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolyline.js":
/*!****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerPolyline.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerPolyline)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

CreationHandlerPolyline = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerPolyline, _CreationHandler);var _super = _createSuper(CreationHandlerPolyline);function CreationHandlerPolyline() {_classCallCheck(this, CreationHandlerPolyline);return _super.apply(this, arguments);}_createClass(CreationHandlerPolyline, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;

      if (!this.creationStarted) {
        this.creationStart();
      }

      if (anchors.length > 0) {
        this.popTemporaryPoint();

        if (this.markupsExtension.markupsTool.shiftDown && anchors.length > 0) {
          this.snapPointToAxis(point, anchors[anchors.length - 1], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES);
        }

        var isClosingLoop = this.isClosingLoop(point);
        if (!isClosingLoop) {
          anchors.push(point);
          this.needPop = true;
        }

        this.updateEditState({ anchors: anchors, closed: isClosingLoop });
      }

      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {var _this$getEditState2 =
      this.getEditState(),anchors = _this$getEditState2.anchors;
      if (anchors.length === 0) {
        anchors.push(point);
        this.updateEditStateAnchors();
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {var _this$getEditState3 =
      this.getEditState(),anchors = _this$getEditState3.anchors;

      if (!this.creationStarted) {
        this.creationStart();
      }

      this.popTemporaryPoint();

      var isClosingLoop = this.isClosingLoop(point);

      if (isClosingLoop || this.isNewLocation(point)) {
        if (this.markupsExtension.markupsTool.shiftDown && anchors.length > 0) {
          this.snapPointToAxis(point, anchors[anchors.length - 1], _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES);
        }

        if (!isClosingLoop) {
          anchors.push(point);
        }

        this.updateEditState({ anchors: anchors, closed: isClosingLoop });

        if (anchors.length > 1) {
          this.submitChanges();
        }

        if (isClosingLoop) {
          this.creationEnd(point);
        }
      }

      return true;
    } }, { key: "beforeCreationEnd", value: function beforeCreationEnd()

    {
      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    point, button) {var _this$getEditState4 =
      this.getEditState(),anchors = _this$getEditState4.anchors;

      if (anchors.length >= this.getMinimumPoints()) {
        this.popTemporaryPoint();

        // Got an extra point from handleButtonUp.
        // anchors.pop(); // TODO maybe do this only for mobile

        this.beforeCreationEnd();
        this.creationEnd(point);
      } else if (this.markupsExtension.markupsManager.getMarkupById(this.markup.id)) {
        this.deleteMarkup();
      } else {
        this.creationCancel();
      }

      return true;
    } }, { key: "getMinimumPoints", value: function getMinimumPoints()

    {
      return 2;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:{var _this$getEditState5 =
            this.getEditState(),anchors = _this$getEditState5.anchors;

            if (anchors.length > 0) {
              this.popTemporaryPoint();

              anchors.pop();

              this.updateEditStateAnchors();

              if (anchors.length > 1) {
                this.submitChanges();
              } else if (this.markupsExtension.markupsManager.getMarkupById(this.markup.id)) {
                this.deleteMarkup();
              } else {
                this.creationCancel();
              }
            }

            return true;
          }
        case Autodesk.Viewing.KeyCode.ESCAPE:
          return this.onEscape();
        default:
          break;}


      return false;
    } }, { key: "onEscape", value: function onEscape()

    {var doBeforeCreationEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;var _this$getEditState6 =
      this.getEditState(),anchors = _this$getEditState6.anchors;

      if (anchors.length > 0) {
        this.popTemporaryPoint();

        if (anchors.length >= this.getMinimumPoints()) {
          if (doBeforeCreationEnd) {
            this.beforeCreationEnd();
          }
          this.creationEnd();
        } else if (this.markupsExtension.markupsManager.getMarkupById(this.markup.id)) {
          this.deleteMarkup();
        } else {
          this.creationCancel();
        }

        return true;
      }

      return false;
    } }, { key: "isClosingLoop", value: function isClosingLoop(

    point) {var _this$getEditState7 =
      this.getEditState(),anchors = _this$getEditState7.anchors;
      return anchors.length > 2 && (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isEqualVectors)(point, anchors[0], this.snapDistance());
    } }, { key: "isNewLocation", value: function isNewLocation(

    point) {var _this$getEditState8 =
      this.getEditState(),anchors = _this$getEditState8.anchors;

      if (anchors.length > 0) {
        return !this.isSamePoint(point, anchors[anchors.length - 1]);
      }

      return true;
    } }, { key: "popTemporaryPoint", value: function popTemporaryPoint()

    {
      if (this.needPop) {var _this$getEditState9 =
        this.getEditState(),anchors = _this$getEditState9.anchors;
        anchors.pop();
        this.needPop = false;
        this.updateEditStateAnchors();
      }
    } }]);return CreationHandlerPolyline;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerRectangle.js":
/*!*****************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerRectangle.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerRectangle)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

CreationHandlerRectangle = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerRectangle, _CreationHandler);var _super = _createSuper(CreationHandlerRectangle);function CreationHandlerRectangle() {_classCallCheck(this, CreationHandlerRectangle);return _super.apply(this, arguments);}_createClass(CreationHandlerRectangle, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;

      if (anchors[0]) {
        if (!this.creationStarted) {
          this.creationStart();
        }

        this.updateRectPoints(anchors, point);
      }

      return true;
    } }, { key: "updateRectPoints", value: function updateRectPoints(

    anchors, point) {
      if (this.markupsExtension.markupsTool.shiftDown) {
        this.snapPointToAxis(point, anchors[0], 90, 45);
      }

      var rightVec = this.markupsExtension.renderer.getCameraRightVector();
      var upVec = this.markupsExtension.renderer.getCameraUpVector();

      anchors[2] = point;

      var diagonal = anchors[2].clone().sub(anchors[0]);
      var width = diagonal.dot(rightVec);
      anchors[1] = anchors[0].clone().add(rightVec.multiplyScalar(width));

      var height = diagonal.dot(upVec);
      anchors[3] = anchors[0].clone().add(upVec.multiplyScalar(height));

      this.updateEditStateAnchors();
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {var _this$getEditState2 =
      this.getEditState(),anchors = _this$getEditState2.anchors;

      if (!anchors[0]) {
        anchors[0] = point;
        this.updateEditStateAnchors();
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {var _this$getEditState3 =
      this.getEditState(),anchors = _this$getEditState3.anchors;

      if (!anchors[1]) {
        return this.handleMouseMove(point, button);
      } else if (!this.isSamePoint(point, anchors[0])) {
        this.updateRectPoints(anchors, point);

        this.submitChanges();

        this.creationEnd(point);
      } else {
        this.creationCancel();
        return false;
      }

      return true;
    } }]);return CreationHandlerRectangle;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerText.js":
/*!************************************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerText.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreationHandlerText)
/* harmony export */ });
/* harmony import */ var _CreationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreationHandler */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

CreationHandlerText = /*#__PURE__*/function (_CreationHandler) {_inherits(CreationHandlerText, _CreationHandler);var _super = _createSuper(CreationHandlerText);function CreationHandlerText() {_classCallCheck(this, CreationHandlerText);return _super.apply(this, arguments);}_createClass(CreationHandlerText, [{ key: "calculateAnchorsByCenterPoint", value: function calculateAnchorsByCenterPoint(
    point) {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors,text = _this$getEditState.text;

      var rightVec = this.markupsExtension.renderer.getCameraRightVector();
      var upVec = this.markupsExtension.renderer.getCameraUpVector();

      var style = this.markup.getTextStyle();

      var size = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.getTextSize)(text, style);
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale();
      var width = Math.ceil(size.width) * fontToWorldScale;
      var height = size.height * fontToWorldScale;

      anchors[0] = point.clone().sub(upVec.clone().multiplyScalar(height / 2)).sub(rightVec.clone().multiplyScalar(width / 2));
      anchors[1] = anchors[0].clone().add(rightVec.multiplyScalar(width));
      anchors[2] = anchors[1].clone().add(upVec.clone().multiplyScalar(height));
      anchors[3] = anchors[0].clone().add(upVec.clone().multiplyScalar(height));
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (!this.didMouseMove()) {
        return this.handleClick(point, button);
      }

      return false;
    } }, { key: "handleClick", value: function handleClick(

    point, button) {
      this.calculateAnchorsByCenterPoint(point);
      this.creationStart();
      this.updateEditStateAnchors();
      this.submitChanges();
      this.creationEnd(point);

      // iOS text input can't be focused programatically.
      if (!Autodesk.Viewing.isIOSDevice()) {
        this.markup.textInputHandler.startTextEditing(true);
      }

      return true;
    } }]);return CreationHandlerText;}(_CreationHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/DimensionEditHandler.js":
/*!********************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/DimensionEditHandler.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DimensionEditHandler)
/* harmony export */ });
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

DimensionEditHandler = /*#__PURE__*/function (_EditHandler) {_inherits(DimensionEditHandler, _EditHandler);var _super = _createSuper(DimensionEditHandler);
  function DimensionEditHandler(markupsExtension, markup) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, DimensionEditHandler);return _super.call(this,
    markupsExtension, markup, options);
  }_createClass(DimensionEditHandler, [{ key: "handleMouseMove", value: function handleMouseMove(

    point) {
      if (this.translating) {
        this.handleMouseTranslation(point);
      }

      return this.translating;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.translating) {
        this.translating = this.intersect(point);

        if (this.translating) {
          var anchors = this.markup.getAnchors();

          var direction = anchors[1].clone().sub(anchors[0]).normalize();
          var eyeVec = this.markupsExtension.renderer.getCameraEyeVector();
          this.normal = direction.clone().cross(eyeVec).normalize();

          this.editStart();
        }

        return this.translating;
      }

      return true;
    } }, { key: "getPointOnNormal", value: function getPointOnNormal(

    point) {
      var anchors = this.markup.getAnchors();
      var p2 = anchors[0].clone().add(this.normal);
      var newPoint = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.nearestPointInPointToLine)(point, anchors[0], p2);
      return newPoint;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.translating) {
        var newPoint = this.getPointOnNormal(point);
        if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isEqualVectors)(newPoint, this.lastTranslationPoint, this.getMinChangeDistanceWorld())) {
          this.cancelTransformEditing();
        } else if (this.lastTranslationPoint) {
          this.submitChanges();
          this.editEnd();
        }

        this.translating = false;
        this.lastTranslationPoint = null;

        return true;
      }

      return false;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      return this.translating;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'move';
    } }, { key: "cancelTransformEditing", value: function cancelTransformEditing()

    {
      this.markup.syncEditState();
      this.translating = false;
      this.lastTranslationPoint = null;
      this.editEnd();
    } }, { key: "handleMouseTranslation", value: function handleMouseTranslation(

    point) {
      var newPoint = this.getPointOnNormal(point);

      if (!this.lastTranslationPoint) {
        this.lastTranslationPoint = newPoint;
      }

      var translation = newPoint.clone().sub(this.lastTranslationPoint);
      var translationAbs = translation.clone().add(this.markup.state.translation);

      this.updateEditState({ translation: translationAbs });
    } }, { key: "intersect", value: function intersect(

    point) {
      point = point.clone();
      this.markup.applyInverseRotation(point);
      var p = this.markupsExtension.renderer.worldToClient(point);
      var boundingBox = this.markup.getClientBoundingBox(true);
      return boundingBox.containsPoint(p);
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.translating;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
        case Autodesk.Viewing.KeyCode.ESCAPE:
          if (this.translating) {
            this.cancelTransformEditing();
            return true;
          }
          break;
        default:
          break;}


      return false;
    } }]);return DimensionEditHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/EditHandler.js":
/*!***********************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/EditHandler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EditHandler)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _Actions_AddMarkupAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions/AddMarkupAction */ "./extensions/BimMarkups/Actions/AddMarkupAction.js");
/* harmony import */ var _Actions_UpdateMarkupAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Actions/UpdateMarkupAction */ "./extensions/BimMarkups/Actions/UpdateMarkupAction.js");
/* harmony import */ var _Actions_DeleteMarkupAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Actions/DeleteMarkupAction */ "./extensions/BimMarkups/Actions/DeleteMarkupAction.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}








var av = Autodesk.Viewing;var

EditHandler = /*#__PURE__*/function () {
  function EditHandler(markupsExtension, markup) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, EditHandler);
    this.setGlobalManager(markupsExtension.globalManager);
    this.markupsExtension = markupsExtension;
    this.viewer = markupsExtension.viewer;
    this.markup = markup;
    this.options = options;
  }_createClass(EditHandler, [{ key: "getEditState", value: function getEditState()

    {
      return this.markup.getEditState();
    } }, { key: "setEditState", value: function setEditState(

    editState, changes) {
      this.markup.setEditState(editState, changes, this);
    } }, { key: "getAnchors", value: function getAnchors()

    {
      return this.getEditState().anchors;
    }

    // Use updateEditState whenever there are changes you want to update in the markup's edit state.
  }, { key: "updateEditState", value: function updateEditState(changes) {
      this.setEditState(this.getEditState(), changes);
    }

    // Use updateEditStateAnchors whenever there are changes you want to update in the markup's edit state's anchors.
  }, { key: "updateEditStateAnchors", value: function updateEditStateAnchors() {var anchors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getEditState().anchors;
      this.updateEditState({ anchors: anchors });
    } }, { key: "handleCompensation", value: function handleCompensation()

    {
      if (!this.markup.layer) {
        return;
      }

      // Move anchors so center stays same as before. Add translation to offset to new center
      var anchors = this.markup.getAnchors();

      if (!this.prevCenter) {
        this.prevCenter = this.markup.center.clone();
      }

      var translation = this.markup.center.clone().sub(this.prevCenter);
      anchors.forEach(function (anchor) {
        anchor.sub(translation);
      });

      // Add scale/rotation to new offset
      translation.applyMatrix4(this.markup.scaleMatrix);
      var rotation = this.markup.getRotation();
      if (rotation !== 0) {
        var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(translation, rotation, new THREE.Vector3(), eyeDirection);
      }
      translation.add(this.markup.editState.translation);

      this.updateEditState({ anchors: anchors, translation: translation });

      this.prevCenter.copy(this.markup.center);
    }

    // Use submitChanges to update the markup with the recent changes of the edit handler.
    // Using this will change the history of the markups, and will add an undo / redo actions.
    // Use it only after you committed changes to the editState, using updateEditState.
    // isDuringEdit: set to true when we don't want to update the UI after submitting changes.
    //              Useful when many changes are submitted together which can slow down the UI.
  }, { key: "submitChanges", value: function submitChanges(isDuringEdit) {
      var action;

      var isNewMarkup = !this.markup.layer;

      if (isNewMarkup) {
        var layer = this.markupsExtension.markupsManager.getActiveLayer();

        this.markup.syncState();
        action = new _Actions_AddMarkupAction__WEBPACK_IMPORTED_MODULE_2__["default"](this.markupsExtension.markupsManager, this.markup, layer);
      } else {
        if (this.markup.belongsToGroup()) {
          this.submitGroupUpdate(isDuringEdit);
          return;
        } else {
          action = new _Actions_UpdateMarkupAction__WEBPACK_IMPORTED_MODULE_3__["default"](this.markupsExtension.markupsManager, this.markup, this.getEditState());
        }
      }
      action.isDuringEdit = isDuringEdit;
      action.execute();
    } }, { key: "submitGroupUpdate", value: function submitGroupUpdate(

    isDuringEdit) {var _this = this;
      var markups = this.markup.markupGroup.markups;

      var isGroupOpen = this.markupsExtension.markupsManager.isActionGroupOpen();

      if (!isGroupOpen) {
        this.markupsExtension.markupsManager.openActionGroup();
      }

      markups.forEach(function (markup, i) {
        var action = new _Actions_UpdateMarkupAction__WEBPACK_IMPORTED_MODULE_3__["default"](_this.markupsExtension.markupsManager, markup, markup.getEditState());
        action.isDuringEdit = i < markups.length - 1 ? true : isDuringEdit;
        action.execute();
      });

      if (!isGroupOpen) {
        this.markupsExtension.markupsManager.closeActionGroup();
      }
    } }, { key: "deleteMarkup", value: function deleteMarkup()

    {
      var action = new _Actions_DeleteMarkupAction__WEBPACK_IMPORTED_MODULE_4__["default"](this.markupsExtension.markupsManager, this.markup);
      action.execute();
    } }, { key: "changeStyleProperty", value: function changeStyleProperty(

    key, value, dontSubmit) {
      var editState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.getEditState());
      editState.style[key] = value;

      this.updateEditState({ style: Object.assign({}, editState.style) });

      if (!dontSubmit) {
        this.submitChanges(true);
        this.editEnd(true);
      }
    } }, { key: "snapPointToAxis", value: function snapPointToAxis(

    point, previousPoint, degrees) {var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.isEqualVectors)(point, previousPoint)) {
        return;
      }

      var pointProjected = this.markupsExtension.renderer.worldToClient(point);
      var previousPointProjected = this.markupsExtension.renderer.worldToClient(previousPoint);

      var direction = pointProjected.clone().sub(previousPointProjected).normalize();

      var cameraAngle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].getSignedAngle(this.markupsExtension.renderer.absoluteUpVec, direction, this.markupsExtension.renderer.getCameraEyeVector());
      var angle = cameraAngle + _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(offset);
      var snap = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(degrees);
      var newAngle = Math.ceil((angle - _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(degrees / 2)) / snap) * snap;
      var eyeDirection = new THREE.Vector3(0, 0, -1);
      var rotatedPoint = pointProjected.clone();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(rotatedPoint, newAngle - angle, previousPointProjected, eyeDirection);

      var axis = rotatedPoint.clone().sub(previousPointProjected).normalize();
      var length = pointProjected.clone().sub(previousPointProjected).dot(axis);
      var newPoint = previousPointProjected.add(axis.multiplyScalar(length));

      point.copy(this.markupsExtension.renderer.clientToWorld(newPoint));
    } }, { key: "getSnappedPosition", value: function getSnappedPosition()

    {
      if (this.markupsExtension.markupsTool.isSnappingAllowed()) {
        return this.markupsExtension.markupsTool.getSnappedPosition();
      } else {
        return this.markupsExtension.markupsTool.lastMousePos;
      }
    } }, { key: "didMouseMove", value: function didMouseMove()

    {
      return this.markupsExtension.markupsTool.mouseMoved;
    } }, { key: "getTouchRadiusWorld", value: function getTouchRadiusWorld()

    {
      return this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.TOUCH_RADIUS);
    } }, { key: "getMinChangeDistanceWorld", value: function getMinChangeDistanceWorld()

    {
      return this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.MIN_CHANGE_DISTANCE);
    } }, { key: "snapDistance", value: function snapDistance()

    {
      return this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.SNAP_DISTANCE);
    } }, { key: "intersect", value: function intersect(

    point) {
      return null;
    }

    // Default creation cursor.
  }, { key: "getCursor", value: function getCursor() {
      return 'crosshair';
    } }, { key: "isDragging", value: function isDragging()

    {
      return false;
    } }, { key: "editStart", value: function editStart()

    {
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_START, markup: this.markup, handler: this });
    }

    // See submitChanges above for isDuringEdit usage
  }, { key: "editEnd", value: function editEnd(isDuringEdit) {
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_END, markup: this.markup, isDuringEdit: isDuringEdit, handler: this });
    } }, { key: "isSamePoint", value: function isSamePoint(

    p1, p2) {
      return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.isEqualVectors)(p1, p2, this.getMinChangeDistanceWorld());
    } }, { key: "isSamePointClient", value: function isSamePointClient(

    p1, p2) {
      return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.isEqualVectors)(p1, p2, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.MIN_CHANGE_DISTANCE);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleGesture", value: function handleGesture(

    event) {
    } }, { key: "handleResize", value: function handleResize()

    {
    } }, { key: "destroy", value: function destroy()

    {
      this.markupsExtension = null;
      this.viewer = null;
      this.markup = null;
    } }]);return EditHandler;}();


av.GlobalManagerMixin.call(EditHandler.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/RectSelector.js":
/*!************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/RectSelector.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RectSelector)
/* harmony export */ });
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

RectSelector = /*#__PURE__*/function (_EditHandler) {_inherits(RectSelector, _EditHandler);var _super = _createSuper(RectSelector);
  function RectSelector(markupsExtension) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, RectSelector);
    _this = _super.call(this, markupsExtension, null, options);

    _this.bounds = new THREE.Box3();
    _this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, _this.clean.bind(_assertThisInitialized(_this)));return _this;
  }_createClass(RectSelector, [{ key: "handleMouseMove", value: function handleMouseMove(

    point) {var _this2 = this;
      if (this.buttonDownPoint && this.markupsExtension.markupsTool.dragging && this.didMouseMove()) {
        this.bounds.makeEmpty();

        // Ignore difference in z coordinate.
        this.bounds.expandByVector(new THREE.Vector3(0, 0, Infinity));

        this.bounds.expandByPoint(point);
        this.bounds.expandByPoint(this.buttonDownPoint);

        var selectableMarkups = this.markupsExtension.markupsManager.getEnabledMarkups().filter(function (m) {return !m.isSelected();});

        selectableMarkups.forEach(function (markup) {
          var markupBounds = markup.getWorldBoundingBox(true);

          if (_this2.bounds.intersectsBox(markupBounds)) {
            markup.setHover(true);
          }
        });

        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.RECT_SELECTOR_UPDATED, bounds: this.bounds });
        return true;
      }

      return false;
    } }, { key: "clean", value: function clean()

    {
      this.buttonDownPoint = null;
      this.bounds.makeEmpty();
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.RECT_SELECTOR_UPDATED, bounds: this.bounds });
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      this.clean();
      this.buttonDownPoint = point;
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      var selected = false;

      this.selectMarkups();

      this.clean();

      return selected;
    } }, { key: "selectMarkups", value: function selectMarkups()

    {var _this3 = this;
      if (!this.markupsExtension.markupsTool.shiftDown) {
        this.markupsExtension.markupsManager.deselectAllMarkups();
      }

      var selectableMarkups = this.markupsExtension.markupsManager.getEnabledMarkups().filter(function (m) {return !m.isSelected();});

      selectableMarkups.forEach(function (markup) {
        var markupBounds = markup.getWorldBoundingBox(true);
        if (_this3.bounds.intersectsBox(markupBounds)) {
          markup.select();
        }
      });
    } }]);return RectSelector;}(_EditHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/RotationHandler.js":
/*!***************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/RotationHandler.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RotationHandler)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

RotationHandler = /*#__PURE__*/function (_EditHandler) {_inherits(RotationHandler, _EditHandler);var _super = _createSuper(RotationHandler);function RotationHandler() {_classCallCheck(this, RotationHandler);return _super.apply(this, arguments);}_createClass(RotationHandler, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {
      if (this.rotating) {
        this.handleRotation(point);
      }

      return this.rotating;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.rotating) {
        this.rotating = this.intersect(point);

        if (this.rotating) {
          this.originalRotation = this.markup.getRotation();
          this.handleRotation(point);
          this.editStart();
        }
      }

      return this.rotating;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.rotating) {
        this.rotating = false;

        if (Math.abs(this.originalRotation - this.markup.getRotation()) < _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MIN_ANGLE_CHANGE) {
          this.cancelTransformEditing();
        } else {
          this.submitChanges();
          this.editEnd();
        }

        this.originalRotation = null;

        return true;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
        case Autodesk.Viewing.KeyCode.ESCAPE:
          if (this.rotating) {
            this.cancelTransformEditing();
            return true;
          }
          break;
        default:
          break;}


      return false;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      return false;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      return this.rotating;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIyMHB4IiBoZWlnaHQ9IjIwcHgiIHZpZXdCb3g9IjAgMCAyMCAyMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4gICAgICAgIDx0aXRsZT5tb3VzZSBjdXJzb3Ivcm90YXRlPC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBhdGggZD0iTTMsOCBMMSw4IEw0LDQgTDcsOCBMNSw4IEM1LDEwLjQ4NTI4MTQgNy41MTQ3MTg2MywxMyAxMCwxMyBDMTIuNDg1MjgxNCwxMyAxNSwxMC40ODUyODE0IDE1LDggTDEzLDggTDE2LDQgTDE5LDggTDE3LDggQzE3LDExLjU4OTg1MDkgMTMuNTg5ODUwOSwxNSAxMCwxNSBDNi40MTAxNDkxMywxNSAzLDExLjU4OTg1MDkgMyw4IFoiIGlkPSJwYXRoLTEiPjwvcGF0aD4gICAgICAgIDxmaWx0ZXIgeD0iLTMzLjMlIiB5PSItNjkuNyUiIHdpZHRoPSIxNjYuNyUiIGhlaWdodD0iMTk3LjAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMiI+ICAgICAgICAgICAgPGZlTW9ycGhvbG9neSByYWRpdXM9IjEiIG9wZXJhdG9yPSJkaWxhdGUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dTcHJlYWRPdXRlcjEiPjwvZmVNb3JwaG9sb2d5PiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9Ii0yIiBpbj0ic2hhZG93U3ByZWFkT3V0ZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldE91dGVyMSI+PC9mZU9mZnNldD4gICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxIiBpbj0ic2hhZG93T2Zmc2V0T3V0ZXIxIiByZXN1bHQ9InNoYWRvd0JsdXJPdXRlcjEiPjwvZmVHYXVzc2lhbkJsdXI+ICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dCbHVyT3V0ZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0ib3V0IiByZXN1bHQ9InNoYWRvd0JsdXJPdXRlcjEiPjwvZmVDb21wb3NpdGU+ICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29sb3JNYXRyaXg+ICAgICAgICA8L2ZpbHRlcj4gICAgPC9kZWZzPiAgICA8ZyBpZD0ibW91c2UtY3Vyc29yL3JvdGF0ZSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+ICAgICAgICA8ZyBpZD0iQ29tYmluZWQtU2hhcGUiIGZpbGwtcnVsZT0ibm9uemVybyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAuMDAwMDAwLCA5LjUwMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTEwLjAwMDAwMCwgLTkuNTAwMDAwKSAiPiAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0yKSIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjEiIGQ9Ik0yLjUyMDExNDgzLDguNSBMMy40MjUyNjAwOGUtMTIsOC41IEw0LDMuMTY2NjY2NjcgTDgsOC41IEw1LjUzODA0MjA3LDguNSBDNS44NDQ5MzkyOCwxMC41NDE1MjMyIDcuOTU3NDAyMDYsMTIuNSAxMCwxMi41IEMxMi4wNDI1OTc5LDEyLjUgMTQuMTU1MDYwNywxMC41NDE1MjMyIDE0LjQ2MTk1NzksOC41IEwxMiw4LjUgTDE2LDMuMTY2NjY2NjcgTDIwLDguNSBMMTcuNDc5ODg1Miw4LjUgQzE3LjE4NTI0NywxMi4xNzM1MTU3IDEzLjY5ODgwMSwxNS41IDEwLDE1LjUgQzYuMzAxMTk5MDIsMTUuNSAyLjgxNDc1MzAzLDEyLjE3MzUxNTcgMi41MjAxMTQ4Myw4LjUgWiIgZmlsbD0iIzAwMDAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48L3BhdGg+ICAgICAgICA8L2c+ICAgIDwvZz48L3N2Zz4=) 10 10, auto';
    } }, { key: "cancelTransformEditing", value: function cancelTransformEditing()

    {
      this.markup.syncEditState();

      this.rotating = false;
      this.editEnd();
    } }, { key: "handleRotation", value: function handleRotation(

    point) {
      var p = this.markupsExtension.renderer.worldToClient(point);
      var center = this.markup.getClientCenter();
      var vec = p.clone().sub(center).normalize();

      var angle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].getSignedAngle(vec, this.markupsExtension.renderer.getCameraUpVector(), this.markupsExtension.renderer.getCameraEyeVector());

      if (this.markupsExtension.markupsTool.shiftDown) {
        var snap = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES);
        angle = Math.ceil((angle - _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_SNAP_DEGREES / 2)) / snap) * snap;
      }

      this.updateEditState({ rotation: angle });
    } }, { key: "getRotationAnchor", value: function getRotationAnchor()

    {
      var boundingBox = this.markup.getClientBoundingBox(true);
      var vec = boundingBox.getCenter(new THREE.Vector3()).add(new THREE.Vector3(0, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ROTATION_ANCHOR_DISTANCE + boundingBox.getSize(new THREE.Vector3()).y / 2, 0));
      var pivot = boundingBox.getCenter(new THREE.Vector3());
      var rotation = this.markup.getRotation() + this.markupsExtension.renderer.getCameraRotation();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(vec, rotation, pivot, this.markupsExtension.renderer.absoluteEyeVec);
      return vec;
    } }, { key: "intersect", value: function intersect(

    point) {
      point = point.clone();
      var p = this.markupsExtension.renderer.worldToClient(point);

      var rotationAnchor = this.getRotationAnchor();

      return rotationAnchor.distanceTo(p) <= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.TOUCH_RADIUS;
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.rotating;
    } }]);return RotationHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/ScaleHandler.js":
/*!************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/ScaleHandler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScaleHandler)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var

ScaleHandler = /*#__PURE__*/function (_EditHandler) {_inherits(ScaleHandler, _EditHandler);var _super = _createSuper(ScaleHandler);function ScaleHandler() {_classCallCheck(this, ScaleHandler);return _super.apply(this, arguments);}_createClass(ScaleHandler, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {
      if (this.scaling) {
        var p = point.clone();
        this.markup.applyInverseRotation(p);
        this.markup.applyInverseCameraRotation(p);

        this.handleScaling(p);
      }

      return this.scaling;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.scaling) {
        this.scaleAnchor = this.intersect(point);
        this.scaling = !!this.scaleAnchor;

        if (this.scaling) {
          this.originalPoint = point.clone();
          this.editStart();
        }
      }

      return this.scaling;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.scaling) {
        this.scaleAnchor = null;
        this.scaling = false;

        if (this.isSamePoint(point, this.originalPoint)) {
          this.cancelTransformEditing();
        } else {
          this.submitChanges();
          this.editEnd();
        }

        return true;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
        case Autodesk.Viewing.KeyCode.ESCAPE:
          if (this.scaling) {
            this.cancelTransformEditing();
            return true;
          }
          break;
        default:
          break;}


      return false;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      return this.scaling;
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.cursor && this.scaling) {
        return this.cursor;
      }

      var p = this.markup.getClientCenter();

      var direction = this.lastIntersectPoint.clone().sub(p).normalize();
      var rightVec = new THREE.Vector3(1, 0, 0);
      var sign = this.lastIntersectPoint.y < p.y ? 1 : -1;
      var angle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].radiansToDegrees(direction.angleTo(rightVec)) * sign;
      var newAngle = Math.ceil((angle - 22.5) / 45) * 45;

      this.cursor = null;

      switch (newAngle) {
        case 180:
        case -180:
        case 0:
          this.cursor = 'ew-resize';
          break;
        case 90:
        case -90:
          this.cursor = 'ns-resize';
          break;
        case 135:
        case -45:
          this.cursor = 'nwse-resize';
          break;
        case -135:
        case 45:
          this.cursor = 'nesw-resize';
          break;
        default:}


      return this.cursor;
    } }, { key: "cancelTransformEditing", value: function cancelTransformEditing()

    {
      this.markup.syncEditState();
      this.scaleAnchor = null;
      this.scaling = false;
      this.editEnd();
    } }, { key: "handleScaling", value: function handleScaling(

    point) {var _this = this;
      var pointProjected = this.markupsExtension.renderer.worldToClient(point);

      this.originalBoundingBox = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(this.markup.getWorldBoundingBox().clone());

      this.scaleAnchor.axisList.forEach(function (axis) {
        var currentAnchorPos = _this.getAnchorPosByAxisList([axis], false);
        var pointWithoutMargin = pointProjected.clone().sub(axis.clone().multiplyScalar(_this.markup.getMarginSize()));
        _this.resize(pointWithoutMargin, currentAnchorPos, axis);
      });

      this.updateTranslation();
    } }, { key: "updateTranslation", value: function updateTranslation()

    {
      var axisSummed = this.scaleAnchor.axisList.reduce(function (acc, current) {
        return acc.clone().add(current);
      });

      var newBoundingBox = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(this.markup.getWorldBoundingBox().clone());

      var diffVector = newBoundingBox.getSize(new THREE.Vector3()).sub(this.originalBoundingBox.getSize(new THREE.Vector3())).multiply(axisSummed).multiplyScalar(0.5);
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(diffVector, this.markup.getRotation(), new THREE.Vector3(), eyeDirection);
      var translation = diffVector.add(this.markup.editState.translation);

      this.updateEditState({ translation: translation });

      this.originalBoundingBox = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(this.markup.getWorldBoundingBox().clone());
    } }, { key: "resize", value: function resize(

    point, currentAnchorPos, axis, deep) {
      var p2 = currentAnchorPos.clone().add(axis);
      var newAnchorPos = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__.nearestPointInPointToLine)(point, currentAnchorPos, p2);

      var boundingBox = this.markup.getClientBoundingBox(false);
      var oppositeAnchor = this.getOppositePoint(currentAnchorPos, boundingBox);
      var distanceVector = newAnchorPos.clone().sub(oppositeAnchor);
      var lengthVector = axis.clone().multiply(distanceVector);

      var currentLength = boundingBox.getSize(new THREE.Vector3()).multiply(axis).length();
      var newLength = distanceVector.length();

      // Don't let markup's size be smaller than the bounding box
      if (!deep && newLength < this.markup.getMinimumSize()) {
        return;
      }

      // // Flip to other side.
      if (!deep && lengthVector.x + lengthVector.y < 0) {
        var flipPoint = oppositeAnchor.clone().add(axis);
        this.resize(flipPoint, currentAnchorPos, axis, true);
        this.updateTranslation();
        axis.negate();
        this.applyReflection(axis);
        this.resize(point, flipPoint, axis, true);
        return;
      }

      var scaleRatio = newLength / currentLength - 1;

      var axisMask = this.markupsExtension.markupsTool.shiftDown ? new THREE.Vector3(1, 1, 0) : new THREE.Vector3(Math.abs(axis.x), Math.abs(axis.y), Math.abs(axis.z));
      var scaleVector = axisMask.clone().multiplyScalar(scaleRatio).addScalar(1);

      var scaleAbs = scaleVector.clone().multiply(this.markup.editState.scale);

      this.updateEditState({ scale: scaleAbs });
    } }, { key: "intersect", value: function intersect(

    point) {
      var scaleAnchors = this.getScaleAnchors();
      var p = point.clone();
      this.markup.applyInverseRotation(p);
      this.markup.applyInverseCameraRotation(p);

      var pProjected = this.markupsExtension.renderer.worldToClient(p);
      this.lastIntersectPoint = pProjected;

      return scaleAnchors.find(function (anc) {
        return anc.pos.distanceTo(pProjected) <= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.TOUCH_RADIUS;
      });
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.scaling;
    } }, { key: "getOppositePoint", value: function getOppositePoint(

    point, boundingBox) {
      var center = boundingBox.getCenter(new THREE.Vector3());
      var pointToCenterDistance = point.clone().distanceTo(center);
      var pointToCenterDirection = point.clone().sub(center).normalize();
      return point.clone().sub(pointToCenterDirection.multiplyScalar(pointToCenterDistance * 2));
    } }, { key: "applyReflection", value: function applyReflection(

    axis) {
      var v = new THREE.Vector3(1, 1, 1).sub(axis.clone().multiply(axis).multiplyScalar(2));
      var scale = this.markup.editState.scale.clone();
      scale.multiply(v);
      this.updateEditState({ scale: scale });
    }

    /**
       *
       * Scale Anchors
       *
      */ }, { key: "getScaleAnchors", value: function getScaleAnchors()

    {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors;
      if (anchors.length < 2) {
        return [];
      }

      if (this.options.onlyHorizontal) {
        return [
        this.getEastAnchor(), this.getWestAnchor()];

      } else {
        return [
        this.getEastAnchor(), this.getWestAnchor(), this.getNorthAnchor(), this.getSouthAnchor(),
        this.getNorthWestAnchor(), this.getSouthWestAnchor(), this.getNorthEastAnchor(), this.getSouthEastAnchor()];

      }
    } }, { key: "getAnchorPosByAxisList", value: function getAnchorPosByAxisList(

    axisList, withMargin) {
      var boundingBox = this.markup.getClientBoundingBox(withMargin);
      var pos = boundingBox.getCenter(new THREE.Vector3());
      var tmpSize = new THREE.Vector3();

      axisList.forEach(function (axis) {
        var corner = axis.clone().multiply(boundingBox.getSize(tmpSize).multiplyScalar(0.5));
        pos.add(corner);
      });

      return pos;
    } }, { key: "getAnchor", value: function getAnchor(

    axisList, id) {
      var pos = this.getAnchorPosByAxisList(axisList, !this.markup.belongsToGroup());

      return {
        pos: pos, axisList: axisList, id: id };

    } }, { key: "getNorthAnchor", value: function getNorthAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, 1, 0)], 'n');
    } }, { key: "getSouthAnchor", value: function getSouthAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, -1, 0)], 's');
    } }, { key: "getEastAnchor", value: function getEastAnchor()

    {
      return this.getAnchor([new THREE.Vector3(1, 0, 0)], 'e');
    } }, { key: "getWestAnchor", value: function getWestAnchor()

    {
      return this.getAnchor([new THREE.Vector3(-1, 0, 0)], 'w');
    } }, { key: "getNorthWestAnchor", value: function getNorthWestAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0)], 'nw');
    } }, { key: "getSouthWestAnchor", value: function getSouthWestAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, -1, 0), new THREE.Vector3(-1, 0, 0)], 'sw');
    } }, { key: "getNorthEastAnchor", value: function getNorthEastAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0)], 'ne');
    } }, { key: "getSouthEastAnchor", value: function getSouthEastAnchor()

    {
      return this.getAnchor([new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0)], 'se');
    } }]);return ScaleHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/SelectionHandler.js":
/*!****************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/SelectionHandler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionHandler)
/* harmony export */ });
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

SelectionHandler = /*#__PURE__*/function (_EditHandler) {_inherits(SelectionHandler, _EditHandler);var _super = _createSuper(SelectionHandler);function SelectionHandler() {_classCallCheck(this, SelectionHandler);return _super.apply(this, arguments);}_createClass(SelectionHandler, [{ key: "getCursor", value: function getCursor()
    {
      return 'pointer';
    } }, { key: "intersect", value: function intersect(

    point) {
      return this.markup.intersect(point);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    point) {
      if (this.markupsExtension.markupsTool.dragging || Autodesk.Viewing.isMobileDevice()) {
        return false;
      }

      var intersected = this.markup.intersect(point);

      if (intersected) {
        if (this.markup.layer === this.markupsExtension.markupsManager.getActiveLayer()) {
          this.markup.setHover(true);
        } else {
          this.markup.layer.setHover(true);
        }
      }

      return intersected;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    point, button) {
      if (this.didMouseMove()) {
        return false;
      }

      if (this.markup.intersect(point)) {
        if (!this.markupsExtension.markupsManager.isMarkupSessionOpen() && this.markup.layer !== this.markupsExtension.markupsManager.getActiveLayer()) {
          this.markupsExtension.markupsManager.editLayer(this.markup.layer, false, false, false);
        }

        if (!this.markupsExtension.markupsTool.shiftDown && !this.markupsExtension.markupsTool.ctrlDown) {
          this.markupsExtension.markupsManager.deselectAllMarkups([this.markup]);
        }

        this.markup.select();

        return true;
      }

      return false;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.didMouseMove()) {
        return false;
      }

      if (this.markup.intersect(point)) {
        this.markupsExtension.markupsManager.deselectAllLayers([this.markup.layer]);
        this.markupsExtension.markupsManager.selectLayer(this.markup.layer, false, false);

        if (this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
          if (!this.markupsExtension.markupsTool.shiftDown && !this.markupsExtension.markupsTool.ctrlDown) {
            this.markupsExtension.markupsManager.deselectAllMarkups([this.markup]);
          }

          this.markup.select();
        }

        return true;
      }

      return false;
    } }]);return SelectionHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/TextInputHandler.js":
/*!****************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/TextInputHandler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextInputHandler)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/ActionManager/ActionManager */ "./extensions/BimMarkups/Utils/ActionManager/ActionManager.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _ThirdParty_textarea_caret_textarea_caret__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ThirdParty/textarea-caret/textarea-caret */ "./extensions/BimMarkups/ThirdParty/textarea-caret/textarea-caret.js");
/* harmony import */ var _ThirdParty_textarea_caret_textarea_caret__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ThirdParty_textarea_caret_textarea_caret__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _EditHandlers_RotationHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../EditHandlers/RotationHandler */ "./extensions/BimMarkups/EditHandlers/RotationHandler.js");
/* harmony import */ var mdn_polyfills_MouseEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! mdn-polyfills/MouseEvent */ "./node_modules/mdn-polyfills/MouseEvent.js");
/* harmony import */ var mdn_polyfills_MouseEvent__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(mdn_polyfills_MouseEvent__WEBPACK_IMPORTED_MODULE_9__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}








var


TextInputHandler = /*#__PURE__*/function (_EditHandler) {_inherits(TextInputHandler, _EditHandler);var _super = _createSuper(TextInputHandler);
  function TextInputHandler(markupsExtension, markup, options) {var _this;_classCallCheck(this, TextInputHandler);
    _this = _super.call(this, markupsExtension, markup, options);

    _this.textboxActive = false;
    _this.submitChangesDebounced = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_2__["default"].debounce(_this.options.submitChanges || _this.submitChanges, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.TEXT_DEBOUNCE);

    // Relevent for iOS only. Look at the methods at the end of this file.
    if (Autodesk.Viewing.isIOSDevice()) {
      _this.onMarkupEditEnabledBinded = _this.onMarkupEditEnabled.bind(_assertThisInitialized(_this));
      _this.onMarkupEditDisabledBinded = _this.onMarkupEditDisabled.bind(_assertThisInitialized(_this));
      _this.onMarkupEditStartBinded = _this.onMarkupEditStart.bind(_assertThisInitialized(_this));
      _this.onMarkupEditEndBinded = _this.onMarkupEditEnd.bind(_assertThisInitialized(_this));
      _this.onTouchEndBinded = _this.onTouchEnd.bind(_assertThisInitialized(_this));
      _this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_ENABLE_EDIT, _this.onMarkupEditEnabledBinded);
      _this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_DISABLE_EDIT, _this.onMarkupEditDisabledBinded);
    }return _this;
  }_createClass(TextInputHandler, [{ key: "intersect", value: function intersect(

    point) {
      if (!this.markup.isTextMarkup()) {
        return false;
      }

      point = point.clone();
      this.markup.applyInverseRotation(point);
      this.markup.applyInverseCameraRotation(point);
      var p = this.markupsExtension.renderer.worldToClient(point);
      var boundingBox = this.markup.getClientBoundingBox(true);
      return boundingBox.containsPoint(p);
    } }, { key: "updateCaretPosition", value: function updateCaretPosition()

    {
      var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);
      var pos = this.getUpdatedCaretPosition(label);
      if (pos.start !== 0 || pos.end !== 0) {
        this.lastCaretPosition = pos;
      }
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'pointer';
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    point, button) {
      if (Autodesk.Viewing.isIOSDevice()) {
        return false;
      }

      if (this.intersect(point)) {
        var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);
        this.lastCaretPosition = { start: label.innerText.length, end: label.innerText.length };
        this.startTextEditing();
        return true;
      }
      return false;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point) {
      if (this.textboxActive) {
        this.submitChangesDebounced.flush();
        this.endTextEditing();
        return true;
      }
      return this.isEmpty();
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point) {
      if (this.isEmpty()) {
        this.onEmptyTextMarkup();
        return true;
      }

      return false;
    } }, { key: "isEmpty", value: function isEmpty()

    {
      return this.markup.editState.text.trim() === '';
    } }, { key: "onEmptyTextMarkup", value: function onEmptyTextMarkup()

    {
      if (this.options.onEmptyTextMarkup) {
        this.textboxActive = false;
        this.options.onEmptyTextMarkup();
      } else {
        this.deleteEmptyTextMarkup();
      }
    } }, { key: "deleteEmptyTextMarkup", value: function deleteEmptyTextMarkup()

    {
      this.textboxActive = false;
      this.markupsExtension.markupsManager.actionManager.undo();
      this.markupsExtension.markupsManager.deleteMarkup(this.markup);
    } }, { key: "onCameraChanged", value: function onCameraChanged(

    e) {
      var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);
      label.focus();
    } }, { key: "startTextEditing", value: function startTextEditing(

    markText) {var _this2 = this;

      var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);
      this.label = label;
      if (!label) {
        return;
      }

      this.textboxActive = true;

      // changing position to 'fixed' solves the 'out of screen' text expansion, but cause the text be visible on top of other element.
      label.style.position = 'fixed';

      label.setAttribute('contenteditable', true);
      label.style.webkitUserSelect = 'text';
      label.style.userSelect = 'text';
      label.style.pointerEvents = 'auto';
      label.setAttribute('spellcheck', false);
      this.setCaretPosition(label);

      label.blur();
      label.focus();

      var _document = this.getDocument();
      if (markText) {
        _document.execCommand('selectAll', false, null);
      }

      this.onCameraChanged = function () {
        // When the div is outside of canvas, Safari doesn't fire events unless it's focused.
        label.focus();
      };

      var isSafari = Autodesk.Viewing.isSafari() || Autodesk.Viewing.isIOSDevice();

      this.onCameraChangedDebounced = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_2__["default"].debounce(this.onCameraChanged, 5);

      if (isSafari) {
        this.markupsExtension.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedDebounced);
      }

      this.onKeyDown = function (e) {
        label.focus();

        var labelBounds = label.getBoundingClientRect();
        var canvasBounds = _this2.markupsExtension.viewer.impl.getCanvasBoundingClientRect();
        var style = _this2.markup.getTextStyle();
        var spareSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getTextSize)('AA', style);
        var fontToWorldScale = _this2.markupsExtension.renderer.getFontToWorldScale();
        var fontToClient = _this2.markupsExtension.renderer.sizeFromWorldToClient(fontToWorldScale);
        var canvasMargin = 30;

        var isCaretOverBottomEdge = function isCaretOverBottomEdge() {
          return labelBounds.bottom + spareSize.height * fontToClient > canvasBounds.bottom - canvasMargin;
        };

        var isCaretOverRightEdge = function isCaretOverRightEdge() {
          var caretPosition = _this2.getUpdatedCaretPosition(label);
          var _window = _this2.getWindow();
          var div = _window.getSelection().anchorNode.parentElement;
          div.value = div.innerText;
          var caretRelativeClientPosition = _ThirdParty_textarea_caret_textarea_caret__WEBPACK_IMPORTED_MODULE_3___default()(div, caretPosition.end);

          return labelBounds.left + (caretRelativeClientPosition.left + spareSize.width * fontToClient) > canvasBounds.right - canvasMargin;
        };

        var _window = _this2.getWindow();
        switch (e.keyCode) {
          case Autodesk.Viewing.KeyCode.ESCAPE:
            _this2.submitChangesDebounced.flush();
            _this2.endTextEditing();
            _this2.textboxActive = true;
            break;

          case Autodesk.Viewing.KeyCode.ENTER:
            // Prevent text caret to be out of screen in Safari
            if (isSafari && isCaretOverBottomEdge()) {
              e.preventDefault();
            } else if (_this2.options.singleLine) {
              e.preventDefault();
              // Preventing multiple BRs in a row, because of browser bug that adds extra spaces.
            } else if (_window.getSelection().anchorNode.firstChild && _window.getSelection().anchorNode.firstChild.tagName === 'BR' || _window.getSelection().anchorOffset === 0) {
              e.preventDefault();
              if (Autodesk.Viewing.isIE11) {
                _this2.enterPressed = true; // workaround for double enter click;
              }
            } else {
              _this2.enterPressed = true;
            }
            break;

          case Autodesk.Viewing.KeyCode.BACKSPACE:
            _this2.backspacePressed = true;
            break;

          default:
            if (isSafari) {
              // Prevent text caret to be out of screen in Safari
              if (isCaretOverRightEdge()) {
                if (isCaretOverBottomEdge() || _this2.options.singleLine) {
                  // Reached the bottom edge of the canvas. No more space to write.
                  e.preventDefault();
                } else if (labelBounds.right < canvasBounds.right) {
                  // Add a new line and continue writing.
                  _this2.addNewline = true;
                } else {
                  // Label is already out of canvas. Don't write anything.
                  e.preventDefault();
                }
              } else if (isCaretOverBottomEdge()) {
                // Reached the bottom edge of the canvas. No more space to write.
                e.preventDefault();
              }
            }}


        // Text limitation.
        var caretLength = _this2.lastCaretPosition.end - _this2.lastCaretPosition.start;
        if (!e.metaKey && e.keyCode > 47 && label.innerText.length - caretLength > _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.TEXT_LENGTH_LIMIT) {
          e.preventDefault();
        }

        if (Autodesk.Viewing.isIE11) {
          _this2.onInput(true);
        }
      };

      this.onKeyUp = function () {
        _this2.onInput(true);
      };

      this.onInput = function (isKeyUpEvent) {
        if (!label.innerText) {
          label.innerText = Autodesk.Viewing.isIE11 ? " " : String.fromCharCode(10);
        }

        _this2.lastCaretPosition = _this2.getUpdatedCaretPosition(label);

        var text = label.innerText;

        if (_this2.addNewline) {
          text = text + "\r\n";
        }

        if (Autodesk.Viewing.isIE11 && isKeyUpEvent === true) {
          //IE innerText creates \r\n\r\n after a <p> tag element, replacing it with single break line.
          //also handles case when pressing enter in middle of content - 2+ occurrences 
          text = text.replace(/(\r\n){2,}/g, "\r\n");
          if (_this2.enterPressed) {
            //using keyup event instead of input, event is fired before content
            //is changed with enter key. This way we simulate it enter press.
            text = text + "\r\n\r\n";
          }
        }

        if (!_this2.options.singleLine) {
          _this2.expandBoundingBox(text);
        }

        _this2.updateEditState({ text: text });
        _this2.submitChangesDebounced();

        _this2.enterPressed = false;
        _this2.addNewline = false;
        _this2.backspacePressed = false;
      };

      this.onPaste = function (e) {
        // Paste the text without style.
        e.preventDefault();
        var _window = _this2.getWindow();
        var _document = _this2.getDocument();
        var text = e.clipboardData && e.clipboardData.getData('text') || _window.clipboardData && _window.clipboardData.getData && _window.clipboardData.getData('Text'); // window.clipboardData needed for IE
        if (text) {
          var caretLength = _this2.lastCaretPosition.end - _this2.lastCaretPosition.start;
          var limit = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__.TEXT_LENGTH_LIMIT + caretLength - label.innerText.length;

          if (text.length > limit) {
            // trim text and add ellipsis at the end.
            text = text.substr(0, limit) + "\u2026";
          }

          if (Autodesk.Viewing.isIE11) {
            var sel = _window.getSelection();
            var range = sel.getRangeAt(0);
            var frag = _document.createDocumentFragment();
            frag.appendChild(_document.createElement('br'));
            var span = _document.createElement('span');
            span.innerText = text;
            frag.appendChild(span);
            range.insertNode(frag);
            range.selectNodeContents(span);
            sel.removeAllRanges();
            sel.addRange(range);
            _document.execCommand('ms-endUndoUnit', false, null);
          } else {
            _document.execCommand('insertText', false, text);
          }
        }
      };

      this.onMouseWheel = function (e) {
        var newEvent = new MouseEvent(e.type, e);

        newEvent.wheelDelta = e.wheelDelta;
        newEvent.deltaY = e.deltaY;

        _this2.markupsExtension.viewer.toolController.domElement.dispatchEvent(newEvent);

        if (newEvent.defaultPrevented) {
          e.preventDefault();
        }
      };

      this.onDOMMouseScroll = function (e) {
        var newEvent = new MouseEvent(e.type, e);

        newEvent.wheelDelta = e.wheelDelta;
        newEvent.deltaY = e.deltaY;

        _this2.markupsExtension.viewer.toolController.domElement.dispatchEvent(newEvent);

        if (newEvent.defaultPrevented) {
          e.preventDefault();
        }
      };

      this.onMouseMove = function (e) {
        var newEvent = new MouseEvent(e.type, e);
        _this2.markupsExtension.viewer.toolController.domElement.dispatchEvent(newEvent);

        if (newEvent.defaultPrevented) {
          e.preventDefault();
        }
      };

      label.addEventListener('keydown', this.onKeyDown);
      label.addEventListener('keypress', this.onKeyPress);
      label.addEventListener('input', this.onInput);
      label.addEventListener('paste', this.onPaste);

      if (Autodesk.Viewing.isIE11) {
        label.addEventListener('keyup', this.onKeyUp);
      }

      label.addEventListener('mousewheel', this.onMouseWheel);
      label.addEventListener('DOMMouseScroll', this.onDOMMouseScroll); // Firefox
      label.addEventListener('mousemove', this.onMouseMove);
      label.addEventListener('mouseup', function () {
        setTimeout(function () {
          _this2.lastCaretPosition = _this2.getUpdatedCaretPosition(label);
        }, 25);
      });
      label.addEventListener('touchend', function () {
        setTimeout(function () {
          _this2.lastCaretPosition = _this2.getUpdatedCaretPosition(label);
        }, 25);
      });

      this.onHistoryChangedBinded = this.onHistoryChanged.bind(this);
      this.endTextEditingBinded = this.endTextEditing.bind(this);
      this.onStyleChangedBinded = this.onStyleChanged.bind(this);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_DISABLE_EDIT, this.endTextEditingBinded, { once: true });
      this.markupsExtension.markupsManager.addEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChangedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_STYLE_PROPERTY_CHANGED, this.onStyleChangedBinded);

      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.TEXT_EDITING_STARTED });
    } }, { key: "removeSelection", value: function removeSelection()

    {
      var _window = this.getWindow();
      _window.getSelection().removeAllRanges(); // deselect text.
      this.label.style.position = 'absolute';
      this.label.style.pointerEvents = 'none';
      this.label.setAttribute('contenteditable', false);
      this.label.style.webkitUserSelect = 'none';
      this.label.style.userSelect = 'none';
    } }, { key: "setCaretPosition", value: function setCaretPosition(

    label) {
      if (!this.lastCaretPosition) {
        this.lastCaretPosition = { start: 0, end: label.innerText.length };
      }
      var _window = this.getWindow();
      var _document = this.getDocument();
      var range = _document.createRange();
      var sel = _window.getSelection();
      var start = Math.min(this.lastCaretPosition.start, label.childNodes[0].length); // Clamp values
      var end = Math.min(this.lastCaretPosition.end, label.childNodes[0].length);
      range.setStart(label.childNodes[0], start);
      range.setEnd(label.childNodes[0], end);
      sel.removeAllRanges();
      sel.addRange(range);
    } }, { key: "getUpdatedCaretPosition", value: function getUpdatedCaretPosition(

    label) {
      var caretPos = { start: 0, end: 0 };
      var sel;
      var range;
      var _window = this.getWindow();
      if (_window.getSelection) {
        sel = _window.getSelection();
        if (sel.rangeCount) {
          range = sel.getRangeAt(0);
          if (range.commonAncestorContainer.parentNode === label) {
            caretPos = { start: range.startOffset, end: range.endOffset };
          } else if (range.commonAncestorContainer.parentNode.parentNode === label) {
            caretPos = { start: range.startOffset, end: range.endOffset };
          }
        }
      } else {
        caretPos = { start: label.innerText.length, end: label.innerText.length };
      }
      return caretPos;
    } }, { key: "onHistoryChanged", value: function onHistoryChanged(_ref)

    {var _this3 = this;var actionGroup = _ref.actionGroup;
      actionGroup.forEach(function (action) {
        if (action.trigger === _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].UNDO || action.trigger === _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].REDO) {
          if (_this3.markupsExtension.renderer && _this3.markupsExtension.renderer.textRenderer.getLabel(_this3.markup)) {
            _this3.endTextEditing();
          }
        }
      });
    } }, { key: "endTextEditing", value: function endTextEditing()

    {
      if (!this.textboxActive) {
        return;
      }

      if (!this.markupsExtension.renderer) {
        return;
      }

      var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);

      label.removeEventListener('keydown', this.onKeyDown);
      label.removeEventListener('input', this.onInput);
      label.removeEventListener('paste', this.onPaste);

      if (Autodesk.Viewing.isIE11) {
        label.removeEventListener('keyup', this.onKeyUp);
      }

      label.removeEventListener('mousewheel', this.onMouseWheel);
      label.removeEventListener('DOMMouseScroll', this.onDOMMouseScroll); // Firefox
      label.removeEventListener('mousemove', this.onMouseMove);

      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_DISABLE_EDIT, this.endTextEditingBinded);
      this.markupsExtension.markupsManager.removeEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChangedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_STYLE_PROPERTY_CHANGED, this.onStyleChangedBinded);
      this.markupsExtension.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedDebounced);

      var _window = this.getWindow();
      _window.getSelection().removeAllRanges(); // deselect text.
      label.style.position = 'absolute';
      label.style.pointerEvents = 'none';
      label.blur();
      label.setAttribute('contenteditable', false);
      label.style.webkitUserSelect = 'none';
      label.style.userSelect = 'none';

      this.textboxActive = false;

      if (this.isEmpty()) {
        this.onEmptyTextMarkup();
      } else {
        this.markup.syncEditState();
        this.editEnd();
      }

      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.TEXT_EDITING_ENDED });
    } }, { key: "onStyleChanged", value: function onStyleChanged()

    {
      if (this.textboxActive) {
        this.onCameraChanged();
      }
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (this.textboxActive && event.keyCode === Autodesk.Viewing.KeyCode.ESCAPE) {
        if (this.isEmpty()) {
          this.onEmptyTextMarkup();
        }

        this.textboxActive = false;
        return true;
      }

      return false;
    }

    // When typing text, instead of expanding the textbox height, we want to expand its width.
  }, { key: "expandBoundingBox", value: function expandBoundingBox(text) {var _this$getEditState =
      this.getEditState(),translation = _this$getEditState.translation,scale = _this$getEditState.scale;
      var style = this.markup.getTextStyle();

      var size = this.markup.getWorldBoundingBoxTextOnly().getSize(new THREE.Vector3());
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion
      var _this$markup$getTextW = this.markup.getTextWidthInFontScale(),width = _this$markup$getTextW.width;
      style.width = "".concat(width, "px");

      var oldSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getTextSize)(this.markup.editState.text, style);
      var newSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getTextSize)(text, style);

      if ((this.enterPressed || this.backspacePressed || this.addNewline) && newSize.height !== oldSize.height) {
        var offsetWorld = (newSize.height - oldSize.height) * fontToWorldScale;
        this.translateBoundingBox(offsetWorld);
        return;
      }

      if (newSize.height > oldSize.height) {
        style.width = null;
        var letterSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getTextSize)('A', style).width;
        var offset = letterSize * fontToWorldScale;
        scale.multiply(new THREE.Vector3((size.x + offset) / size.x, 1, 1));

        var rotation = this.markup.getRotation();
        var delta = new THREE.Vector3(offset / 2, 0, 0);
        if (rotation !== 0) {
          var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
          _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(delta, rotation, new THREE.Vector3(), eyeDirection);
        }

        translation.add(delta);
        this.updateEditState({ scale: scale, translation: translation });
      }
    } }, { key: "translateBoundingBox", value: function translateBoundingBox(

    offsetWorld) {var _this$getEditState2 =
      this.getEditState(),translation = _this$getEditState2.translation;
      var delta = this.markup.getBoundingBoxVerticalTranslation(offsetWorld);

      translation.add(delta);
      this.updateEditState({ translation: translation });
    } }, { key: "destroy", value: function destroy()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_ENABLE_EDIT, this.onMarkupEditStartBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.onMarkupEditEndBinded);
    }

    /** 
       * These methods are being used only by iOS devices.
       * The reason is that iOS text input can't be focused programatically.
       * So, in order to select and edit the text area, we have to allow tapping on the div first.
       */ }, { key: "onMarkupEditEnabled", value: function onMarkupEditEnabled(
    event) {var _this4 = this;
      if (event.markup === this.markup) {
        if (!this.markupsExtension.markupsManager.hasEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.onMarkupEditStartBinded)) {
          this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.onMarkupEditStartBinded);
        }
        if (!this.markupsExtension.markupsManager.hasEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.onMarkupEditEndBinded)) {
          this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.onMarkupEditEndBinded);
        }

        setTimeout(function () {
          var label = _this4.markupsExtension.renderer.textRenderer.getLabel(_this4.markup);

          if (label) {
            label.addEventListener('touchend', _this4.onTouchEndBinded);
            label.style.pointerEvents = 'auto';
          }
        }, 10);
      }
    } }, { key: "onTouchEnd", value: function onTouchEnd(

    e) {
      e.preventDefault();
      e.stopPropagation();
      this.startTextEditing();
    } }, { key: "onMarkupEditDisabled", value: function onMarkupEditDisabled(

    event) {
      if (event.markup === this.markup) {
        var label = this.markupsExtension.renderer.textRenderer.getLabel(this.markup);

        if (label) {
          label.removeEventListener('touchend', this.onTouchEndBinded);
          label.style.pointerEvents = 'none';
        }
      }
    } }, { key: "onMarkupEditStart", value: function onMarkupEditStart(

    event) {
      if (this.textboxActive) {
        this.textboxWasActive = true;
      }
      if (event.markup === this.markup && event.handler instanceof _EditHandlers_RotationHandler__WEBPACK_IMPORTED_MODULE_8__["default"]) {
        this.removeSelection();
      }
    } }, { key: "onMarkupEditEnd", value: function onMarkupEditEnd(

    event) {
      if (event.handler instanceof TextInputHandler) {
        return;
      }
      if (event.markup === this.markup && this.textboxWasActive && event.handler instanceof _EditHandlers_RotationHandler__WEBPACK_IMPORTED_MODULE_8__["default"]) {
        this.textboxWasActive = false;
        this.startTextEditing();
      }
    } }]);return TextInputHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_4__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/EditHandlers/TranslationHandler.js":
/*!******************************************************************!*\
  !*** ./extensions/BimMarkups/EditHandlers/TranslationHandler.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TranslationHandler)
/* harmony export */ });
/* harmony import */ var _EditHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditHandler */ "./extensions/BimMarkups/EditHandlers/EditHandler.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

TranslationHandler = /*#__PURE__*/function (_EditHandler) {_inherits(TranslationHandler, _EditHandler);var _super = _createSuper(TranslationHandler);
  function TranslationHandler(markupsExtension, markup) {var _this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, TranslationHandler);
    _this = _super.call(this, markupsExtension, markup, options);

    _this.keyTranslation = new THREE.Vector3();return _this;
  }_createClass(TranslationHandler, [{ key: "handleMouseMove", value: function handleMouseMove(

    point) {
      if (this.translating) {
        this.handleMouseTranslation(point);
      }

      return this.translating;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.translating) {
        this.translating = this.intersect(point);

        if (this.translating) {
          this.lastTranslationPoint = point;
          this.buttonDownPos = point;
          this.editStart();
        }

        return this.translating;
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.translating) {
        var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();

        this.markupsExtension.markupsManager.openActionGroup();
        var consumed;

        if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isEqualVectors)(point, this.lastTranslationPoint, this.getMinChangeDistanceWorld())) {
          this.cancelTransformEditing();
          consumed = false;
        } else {
          // submit translation for all in-edit markups.
          inEditMarkups.forEach(function (markup, i) {
            if (markup.translationHandler) {
              markup.translationHandler.submitChanges(i < inEditMarkups.length - 1);
            }
          });

          this.editEnd();
          consumed = true;
        }

        this.markupsExtension.markupsManager.closeActionGroup();

        this.translating = false;
        this.lastTranslationPoint = null;

        return consumed;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.BACKSPACE:
        case Autodesk.Viewing.KeyCode.DELETE:
        case Autodesk.Viewing.KeyCode.ESCAPE:
          if (this.translating) {
            this.cancelTransformEditing();
            return true;
          }
          break;
        case Autodesk.Viewing.KeyCode.UP:
          this.handleKeyTranslation(this.markupsExtension.renderer.getCameraUpVector());
          return true;
        case Autodesk.Viewing.KeyCode.DOWN:
          this.handleKeyTranslation(this.markupsExtension.renderer.getCameraUpVector().negate());
          return true;
        case Autodesk.Viewing.KeyCode.RIGHT:
          this.handleKeyTranslation(this.markupsExtension.renderer.getCameraRightVector());
          return true;
        case Autodesk.Viewing.KeyCode.LEFT:
          this.handleKeyTranslation(this.markupsExtension.renderer.getCameraRightVector().negate());
          return true;
        default:
          break;}


      return false;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.UP:
        case Autodesk.Viewing.KeyCode.DOWN:
        case Autodesk.Viewing.KeyCode.RIGHT:
        case Autodesk.Viewing.KeyCode.LEFT:
          this.keyTranslation.set(0, 0, 0);
          this.submitChanges(event.isDuringEdit);
          return true;
        default:
          break;}


      return false;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      return this.translating;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'move';
    } }, { key: "cancelTransformEditing", value: function cancelTransformEditing()

    {
      var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();

      inEditMarkups.forEach(function (markup) {
        markup.syncEditState();
      });

      this.translating = false;
      this.lastTranslationPoint = null;
      this.editEnd();
    } }, { key: "handleMouseTranslation", value: function handleMouseTranslation(















    point) {var _this2 = this;
      if (this.markupsExtension.markupsTool.shiftDown) {
        point = point.clone();
        this.snapPointToAxis(point, this.buttonDownPos, 90);
      }

      var translation = point.clone().sub(this.lastTranslationPoint);

      // Apply translation for all in-edit markups.
      var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();

      // Find if we are translating only one group and nothing else    
      if (TranslationHandler.hasOneGroupInEdit(inEditMarkups)) {
        // When translating only one group, apply the translation only to the currently selected markup, and let the other markups move
        // according to the group's constraints
        this.handleTranslation(this.markup, translation);
      } else {
        inEditMarkups.forEach(function (markup) {
          _this2.handleTranslation(markup, translation);
        });
      }
    } }, { key: "handleKeyTranslation", value: function handleKeyTranslation(

    direction) {
      var translation = direction.multiplyScalar(this.markupsExtension.renderer.multiplyByNormaStrokeWidth(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ARROW_MOVE_OFFSET));
      this.keyTranslation.add(translation);
      this.handleTranslation(this.markup, this.keyTranslation);
    } }, { key: "handleTranslation", value: function handleTranslation(

    markup, translation) {
      if (markup.translationHandler) {
        var translationAbs = translation.clone().add(markup.state.translation);
        markup.translationHandler.updateEditState({ translation: translationAbs });
      }
    } }, { key: "intersect", value: function intersect(

    point) {
      return this.markup.intersect(point);
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.translating;
    } }], [{ key: "hasOneGroupInEdit", value: function hasOneGroupInEdit(inEditMarkups) {var numGroups = 0,numNonGroupMarkups = 0;inEditMarkups.forEach(function (markup) {if (markup.isGroupMarkup()) {numGroups++;} else if (!markup.belongsToGroup()) {numNonGroupMarkups++;}});return numGroups === 1 && numNonGroupMarkups === 0;} }]);return TranslationHandler;}(_EditHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/FilterManager.js":
/*!************************************************!*\
  !*** ./extensions/BimMarkups/FilterManager.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilterManager)
/* harmony export */ });
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parseISO/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/endOfDay/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isWithinInterval/index.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var

FilterManager = /*#__PURE__*/function () {
  function FilterManager(markupsExtension, options) {_classCallCheck(this, FilterManager);
    this.markupsExtension = markupsExtension;
    this.options = options;
    this.filters = this.markupsExtension.cache.filters || this.getInitialFilters();
  }_createClass(FilterManager, [{ key: "getInitialFilters", value: function getInitialFilters()

    {
      return {
        createdByFilter: [],
        createdAtStartFilter: null,
        createdAtEndFilter: null,
        showPrivateFilter: true,
        showPublishedFilter: true,
        showArchivedFilter: false,
        toggleMarkupViewFilter: true };

    } }, { key: "updateFilters", value: function updateFilters(

    filters) {
      this.markupsExtension.cache.filters = this.filters = Object.assign({}, this.filters, filters);
      this.markupsExtension.loadLayers();
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.FILTER_CHANGED, filters: this.filters });
    } }, { key: "filterLayers", value: function filterLayers(

    layerList, filterForPanel) {var _this = this;
      if (!filterForPanel && this.filters.hideAllMarkups) {
        return [];
      }

      return layerList.filter(function (layer) {
        return (
          _this.filterByVersion(layer) &&
          _this.filterBySheet(layer, filterForPanel && _this.filters.toggleMarkupViewFilter) &&
          _this.filterByDate(layer) &&
          _this.filterPrivate(layer) &&
          _this.filterPublished(layer) &&
          _this.filterArchived(layer) &&
          _this.filterCreator(layer) &&
          _this.filterDeleted(layer));

      });
    } }, { key: "isDateInRange", value: function isDateInRange(

    dateTime, fromData, toData) {
      // Parse the date with a startOfDay/endOfDay, in order to ignore the exact hour of the creation.
      var dateTimeISO = (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(dateTime);
      var fromDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_4__["default"])(fromData);
      var toDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__["default"])(toData);

      return (0,date_fns__WEBPACK_IMPORTED_MODULE_6__["default"])(dateTimeISO, { start: fromDate, end: toDate });
    } }, { key: "filterByDate", value: function filterByDate(

    layer) {
      if (this.filters.createdAtStartFilter && this.filters.createdAtEndFilter) {
        return this.isDateInRange(layer.metadata.created_at, this.filters.createdAtStartFilter, this.filters.createdAtEndFilter);
      }

      return true;
    } }, { key: "filterBySheet", value: function filterBySheet(

    layer, allSheets) {
      if (allSheets || !this.options.hasMultiSheet) {
        return true;
      }

      var sheetName = layer.metadata.markup_metadata && layer.metadata.markup_metadata.sheetName;

      return this.options.sheetName && sheetName ? (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isSheetNameEqual)(this.options.sheetName, sheetName) : true;
    } }, { key: "filterDeleted", value: function filterDeleted(

    layer) {
      return layer.status !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_STATUS_DELETE_SUCCEED;
    } }, { key: "filterPrivate", value: function filterPrivate(

    layer) {
      return this.filters.showPrivateFilter || layer.metadata.status !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_STATUS_PRIVATE;
    } }, { key: "filterPublished", value: function filterPublished(

    layer) {
      return this.filters.showPublishedFilter || layer.metadata.status !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_STATUS_PUBLISHED;
    } }, { key: "filterArchived", value: function filterArchived(

    layer) {
      return this.filters.showArchivedFilter || layer.metadata.status !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_STATUS_ARCHIVED;
    } }, { key: "filterCreator", value: function filterCreator(

    layer) {
      if (!this.filters.createdByFilter || this.filters.createdByFilter.length === 0) {
        return true;
      }

      return this.filters.createdByFilter.some(function (creator) {
        return layer.metadata.created_by === creator.value;
      });
    } }, { key: "filterByVersion", value: function filterByVersion(

    layer) {
      // Show only layers that were created on the current version or from previous versions.
      // If i'm now watching V1 of a document, I shouldn't see markups that were created on V2 of that document.
      var startVersion = layer.metadata.starting_version;
      return this.options.documentVersion >= startVersion;
    } }, { key: "destroy", value: function destroy()

    {
      this.filters = null;
      this.options = null;
    } }]);return FilterManager;}();

/***/ }),

/***/ "./extensions/BimMarkups/FrameRenderer.js":
/*!************************************************!*\
  !*** ./extensions/BimMarkups/FrameRenderer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FrameRenderer)
/* harmony export */ });
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _FrameRenderer_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FrameRenderer.css */ "./extensions/BimMarkups/FrameRenderer.css");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var av = Autodesk.Viewing;var

FrameRenderer = /*#__PURE__*/function () {
  function FrameRenderer(markupsExtension) {_classCallCheck(this, FrameRenderer);
    this.markupsExtension = markupsExtension;
    this.setGlobalManager(markupsExtension.globalManager);
    this.viewer = this.markupsExtension.viewer;
    this.container = this.viewer.appendOrderedElementToViewer('markup-frames-container');
    this.container.className = 'markup-frames-container';

    this.markupFrames = {};
    this.layerFrames = {};
    this.anchors = {};
    this.segments = {};

    this.rotationAxis = new THREE.Vector3(0, 0, 1);

    this.registerEventListeners();
  }_createClass(FrameRenderer, [{ key: "registerEventListeners", value: function registerEventListeners()

    {
      this.onMarkupDirtyBinded = this.onMarkupDirty.bind(this);
      this.onLayerDirtyBinded = this.onLayerDirty.bind(this);
      this.onLayerDeletedBinded = this.onLayerDeleted.bind(this);
      this.onMarkupRemovedBinded = this.onMarkupRemoved.bind(this);
      this.renderAllBinded = this.renderAll.bind(this);
      this.onRectSelectorUpdatedBinded = this.onRectSelectorUpdated.bind(this);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DIRTY, this.onMarkupDirtyBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DIRTY, this.onLayerDirtyBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_REMOVED, this.onMarkupRemovedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DELETED, this.onLayerDeletedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.renderAllBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.renderAllBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.RECT_SELECTOR_UPDATED, this.onRectSelectorUpdatedBinded);
      this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.renderAllBinded);
    } }, { key: "unregisterEventListeners", value: function unregisterEventListeners()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DIRTY, this.onMarkupDirtyBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DIRTY, this.onLayerDirtyBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_REMOVED, this.onMarkupRemovedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DELETED, this.onLayerDeletedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.renderAllBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.renderAllBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.RECT_SELECTOR_UPDATED, this.onRectSelectorUpdatedBinded);
      this.viewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.renderAllBinded);
    } }, { key: "renderAll", value: function renderAll()

    {
      var markups = this.markupsExtension.markupsManager.getAllMarkups();
      this.renderMarkups(markups);

      var layers = this.markupsExtension.markupsManager.getLayersAsList();
      this.renderLayers(layers);
    } }, { key: "onMarkupDirty", value: function onMarkupDirty(_ref)

    {var markup = _ref.markup;
      this.renderMarkups([markup]);
    } }, { key: "onLayerDirty", value: function onLayerDirty(_ref2)

    {var layer = _ref2.layer;
      this.renderLayerSelectionFrame(layer);
    } }, { key: "renderLayers", value: function renderLayers(

    layers) {var _this = this;
      layers.forEach(function (layer) {
        _this.renderLayerSelectionFrame(layer);
      });
    } }, { key: "renderMarkups", value: function renderMarkups(

    markups) {var _this2 = this;
      markups.forEach(function (markup) {
        if (!markup.belongsToGroup()) {
          _this2.renderMarkupSelectionFrame(markup);
        }
        _this2.renderTransformAnchors(markup);

        if (markup.layer) {
          _this2.renderLayerSelectionFrame(markup.layer);
        }
      });
    } }, { key: "renderFrame", value: function renderFrame(

    frame, entity, withFill) {
      var _document = this.getDocument();
      if (!frame) {
        frame = _document.createElement('div');
        frame.className = 'markup-selection-frame-container';
        this.container.appendChild(frame);

        var frameFill = _document.createElement('div');
        frameFill.className = 'markup-selection-frame fill';
        frameFill.style.width = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");
        frameFill.style.height = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");

        if (Autodesk.Viewing.isIOSDevice()) {
          frameFill.className += ' ios';
        }

        frame.appendChild(frameFill);
        frame.fillElement = frameFill;

        for (var i = 0; i < 4; i++) {
          var frameBorder = _document.createElement('div');
          frameBorder.className = 'markup-selection-frame border';
          frameBorder.style.width = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");
          frameBorder.style.height = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");

          if (Autodesk.Viewing.isIOSDevice()) {
            frameBorder.className += ' ios';
          }

          frame.appendChild(frameBorder);
          frame["border_".concat(i)] = frameBorder;
        }
      }

      if (!frame.classList.contains('visible')) {
        frame.classList.add('visible');
        frame.offsetHeight; // Force update DOM.
      }

      if (withFill && !frame.fillElement.classList.contains('visible')) {
        frame.fillElement.classList.add('visible');
        frame.fillElement.offsetHeight; // Force update DOM.
      } else if (!withFill && frame.fillElement.classList.contains('visible')) {
        frame.fillElement.classList.remove('visible');
        frame.fillElement.offsetHeight; // Force update DOM.
      }

      var boundingBox = entity.getClientBoundingBox(true);
      var center = boundingBox.getCenter(new THREE.Vector3());
      center.x -= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE / 2;
      center.y -= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE / 2;
      var size = boundingBox.getSize(new THREE.Vector3());

      var rotate = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].radiansToDegrees(entity.getRotation() + this.markupsExtension.renderer.getCameraRotation()) || 0;

      if (withFill) {
        frame.fillElement.style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(rotate, "deg) scale(").concat(size.x / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(size.y / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");
      }

      frame['border_0'].style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(rotate, "deg) translate(0px, ").concat(size.y / 2, "px) scale(").concat(size.x / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(1 / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");
      frame['border_1'].style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(rotate, "deg) translate(0px, ").concat(-size.y / 2, "px) scale(").concat(size.x / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(1 / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");
      frame['border_2'].style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(rotate, "deg) translate(").concat(size.x / 2, "px, 0px) scale(").concat(1 / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(size.y / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");
      frame['border_3'].style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(rotate, "deg) translate(").concat(-size.x / 2, "px, 0px) scale(").concat(1 / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(size.y / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");

      return frame;
    } }, { key: "renderMarkupSelectionFrame", value: function renderMarkupSelectionFrame(

    markup) {
      var frame = this.markupFrames[markup.id];

      var hovered = markup.isHovered();
      var selected = markup.isSelected();

      if ((selected || hovered) && markup.layer) {
        this.markupFrames[markup.id] = this.renderFrame(frame, markup, selected);
      } else if (frame && frame.classList.contains('visible')) {
        frame.classList.remove('visible');
        frame.offsetHeight; // Force update DOM.
      }
    } }, { key: "renderLayerSelectionFrame", value: function renderLayerSelectionFrame(

    layer) {
      var frame = this.layerFrames[layer.id];

      var hovered = layer.isHovered();
      var selected = layer.isSelected();
      var visible = layer.isVisible();

      if ((selected || hovered) && visible && !this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
        this.layerFrames[layer.id] = this.renderFrame(frame, layer, false);
      } else if (frame && frame.classList.contains('visible')) {
        this.container.removeChild(frame);
        delete this.layerFrames[layer.id]; // Need to delete layer element because of Safari bug where it doesn't get updated.
      }
    } }, { key: "_renderScaleAnchors", value: function _renderScaleAnchors(

    markup) {var _this3 = this;
      if (!markup.scaleHandler) {
        return;
      }

      if (markup.isInEdit()) {
        var scaleAnchors = markup.scaleHandler.getScaleAnchors();
        var pivot = markup.getClientCenter();
        scaleAnchors.forEach(function (anchor, i) {
          var name = "".concat(markup.id, "_scale_").concat(i);

          var rotation = markup.getRotation() + _this3.markupsExtension.renderer.getCameraRotation();
          _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].applyRotation(anchor.pos, rotation, pivot, _this3.rotationAxis);
          var isActive = markup.scaleHandler.isDragging() && anchor.id === markup.scaleHandler.scaleAnchor.id;
          _this3.createAnchorElement(name, anchor.pos, isActive, rotation, 'rectangle');
        });
      } else {
        for (var i = 0; i < 8; i++) {
          var name = "".concat(markup.id, "_scale_").concat(i);

          if (this.anchors[name] && this.anchors[name].classList.contains('visible')) {
            this.anchors[name].classList.remove('visible');
          }
        }
      }
    } }, { key: "_renderRotationAnchor", value: function _renderRotationAnchor(

    markup) {
      if (!markup.rotationHandler) {
        return;
      }

      var name = "".concat(markup.id, "_rotation_anchor");

      if (markup.isInEdit()) {
        var rotationAnchorPos = markup.rotationHandler.getRotationAnchor();
        var isActive = markup.rotationHandler.isDragging();
        this.createAnchorElement(name, rotationAnchorPos, isActive);

        var boundingBox = markup.getClientBoundingBox(true);
        var p = boundingBox.getCenter(new THREE.Vector3()).add(new THREE.Vector3(0, boundingBox.getSize(new THREE.Vector3()).y / 2, 0));
        var pivot = boundingBox.getCenter(new THREE.Vector3());
        var rotation = markup.getRotation() + this.markupsExtension.renderer.getCameraRotation();

        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].applyRotation(p, rotation, pivot, this.rotationAxis);

        this.createSegment(name, p, rotationAnchorPos);
      } else if (this.anchors[name] && this.anchors[name].classList.contains('visible')) {
        this.anchors[name].classList.remove('visible');
        this.segments[name].classList.remove('visible');
      }
    } }, { key: "_renderAnchors", value: function _renderAnchors(

    markup) {var _this4 = this;
      if (!markup.anchorHandler) {
        return;
      }

      var getExistingAnchors = function getExistingAnchors(nameStart) {return Object.keys(_this4.anchors).filter(function (k) {return k.indexOf(nameStart) === 0;});};
      var getExistingSegments = function getExistingSegments(nameStart) {return Object.keys(_this4.segments).filter(function (k) {return k.indexOf(nameStart) === 0;});};

      var removeAnchorVisibility = function removeAnchorVisibility(name) {
        var anchor = _this4.anchors[name];
        if (anchor && anchor.classList.contains('visible')) {
          anchor.classList.remove('visible');
        }
      };

      var removeSegmentVisibility = function removeSegmentVisibility(name) {
        var segment = _this4.segments[name];
        if (segment && segment.classList.contains('visible')) {
          segment.classList.remove('visible');
        }

      };

      var baseName = "".concat(markup.id, "_anchor");
      var anchors = markup.anchorHandler.getAnchors();
      if (markup.isInEdit()) {
        var pivot = markup.getClientCenter();

        var applyTransform = function applyTransform(anchor) {
          markup.applyScaleAndTranslation(anchor);
          anchor = _this4.markupsExtension.renderer.worldToClient(anchor);
          _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].applyRotation(anchor, markup.getRotation(), pivot, _this4.rotationAxis);

          return anchor;
        };

        var prevAnchor = null,anchor = null;

        for (var i = 0; i < anchors.length; i++) {
          var name = "".concat(baseName, "_").concat(i);
          anchor = applyTransform(anchors[i].clone());
          var isActive = anchors[i] === markup.anchorHandler.activeAnchor;
          if (markup.isAnchorHandlingAllowed(anchors[i])) {
            this.createAnchorElement(name, anchor, isActive);
          }

          if (markup.showPath() && i > 0) {
            this.createSegment(name, prevAnchor, anchor);
          }

          prevAnchor = anchor;
        }

        if (markup.showPath() && markup.editState.closed) {// Add last segment
          var _name = "".concat(baseName, "_").concat(anchors.length);
          var firstAnchor = applyTransform(anchors[0].clone());
          this.createSegment(_name, anchor, firstAnchor);
        }

        // Remove anchors and segments no longer in use (can happen during undo)
        var existingAnchors = getExistingAnchors(baseName);
        var existingSegments = getExistingSegments(baseName);

        for (var _i = anchors.length; _i < existingAnchors.length; _i++) {
          removeAnchorVisibility("".concat(baseName, "_").concat(_i));
        }

        var end = markup.editState.closed ? existingSegments.length : existingSegments.length + 1;
        for (var _i2 = anchors.length; _i2 < end; _i2++) {
          removeSegmentVisibility("".concat(baseName, "_").concat(_i2));
        }
      } else {
        for (var _i3 = 0; _i3 <= anchors.length; _i3++) {// Include length to remove last segment when closed
          var _name2 = "".concat(baseName, "_").concat(_i3);
          removeAnchorVisibility(_name2);
          removeSegmentVisibility(_name2);
        }
      }
    } }, { key: "renderTransformAnchors", value: function renderTransformAnchors(

    markup) {
      if (!markup.isCompleted()) {
        return;
      }

      this._renderScaleAnchors(markup);

      this._renderRotationAnchor(markup);

      this._renderAnchors(markup);
    } }, { key: "createAnchorElement", value: function createAnchorElement(

    name, position, isActive) {var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var className = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
      var anchorElement = this.anchors[name];

      var _document = this.getDocument();
      if (!anchorElement) {
        anchorElement = _document.createElement('div');
        anchorElement.className = 'markup-anchor ' + className;
        var diameter = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ANCHOR_RADIUS * 2, "px");
        anchorElement.style.width = diameter;
        anchorElement.style.height = diameter;
        this.container.appendChild(anchorElement);
        this.anchors[name] = anchorElement;

        var anchorFill = _document.createElement('div');
        anchorFill.className = 'markup-anchor-fill ' + className;
        anchorElement.appendChild(anchorFill);
        anchorElement.anchorFill = anchorFill;
      }

      if (!anchorElement.classList.contains('visible')) {
        anchorElement.classList.add('visible');
      }

      if (isActive && !anchorElement.anchorFill.classList.contains('visible')) {
        anchorElement.anchorFill.classList.add('visible');
      } else if (!isActive && anchorElement.anchorFill.classList.contains('visible')) {
        anchorElement.anchorFill.classList.remove('visible');
      }

      var rotate = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].radiansToDegrees(rotation);

      anchorElement.style.transform = "translate(".concat(position.x - _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ANCHOR_RADIUS, "px, ").concat(position.y - _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ANCHOR_RADIUS, "px) rotate(").concat(rotate, "deg)");
    } }, { key: "createSegment", value: function createSegment(

    name, p1, p2) {
      var segmentElement = this.segments[name];

      var _document = this.getDocument();
      if (!segmentElement) {
        segmentElement = _document.createElement('div');
        segmentElement.className = 'markup-selection-frame segment border';
        segmentElement.style.width = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");
        segmentElement.style.height = "".concat(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, "px");
        this.container.appendChild(segmentElement);
        this.segments[name] = segmentElement;
      }

      if (!segmentElement.classList.contains('visible')) {
        segmentElement.classList.add('visible');
      }

      var center = p1.clone().add(p2).multiplyScalar(0.5);
      center.x -= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE / 2;
      center.y -= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE / 2;
      var length = p1.distanceTo(p2);

      var rotate = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].getSignedAngle(p2.clone().sub(p1), this.markupsExtension.renderer.getCameraUpVector(), this.markupsExtension.renderer.getCameraEyeVector());

      segmentElement.style.transform = "translate(".concat(center.x, "px, ").concat(center.y, "px) rotate(").concat(_Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_1__["default"].radiansToDegrees(rotate + this.markupsExtension.renderer.getCameraRotation()), "deg) scale(").concat(1 / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ", ").concat(length / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.FRAME_SIZE_SCALE, ")");
    } }, { key: "onLayerDeleted", value: function onLayerDeleted(_ref3)

    {var layer = _ref3.layer;
      var name = layer.id;
      var layerElement = this.layerFrames[name];

      if (layerElement) {
        this.container.removeChild(layerElement);
      }

      delete this.layerFrames[name];
    } }, { key: "onMarkupRemoved", value: function onMarkupRemoved(_ref4)

    {var markup = _ref4.markup;
      var name = markup.id;
      var markupElement = this.markupFrames[name];

      if (markupElement) {
        this.container.removeChild(markupElement);
      }

      delete this.markupFrames[name];

      if (markup.layer && markup.layer.isEmpty()) {
        this.onLayerDeleted(markup);
      }
    } }, { key: "onRectSelectorUpdated", value: function onRectSelectorUpdated(_ref5)

    {var bounds = _ref5.bounds;
      var _document = this.getDocument();
      if (!this.rectSelectorFrame) {
        this.rectSelectorFrame = _document.createElement('div');
        this.rectSelectorFrame.className = 'rect-selector-frame';
        this.container.appendChild(this.rectSelectorFrame);
      }

      var visible = !bounds.isEmpty();

      if (visible && !this.rectSelectorFrame.classList.contains('visible')) {
        this.rectSelectorFrame.classList.add('visible');
        this.rectSelectorFrame.offsetHeight; // Force update DOM.
      } else if (!visible && this.rectSelectorFrame.classList.contains('visible')) {
        this.rectSelectorFrame.classList.remove('visible');
        this.rectSelectorFrame.offsetHeight; // Force update DOM.
      }

      var boundsProjected = bounds.clone();

      boundsProjected.min = this.markupsExtension.renderer.worldToClient(boundsProjected.min);
      boundsProjected.max = this.markupsExtension.renderer.worldToClient(boundsProjected.max);
      var size = boundsProjected.getSize(new THREE.Vector3());

      this.rectSelectorFrame.style.width = "".concat(Math.abs(size.x), "px");
      this.rectSelectorFrame.style.height = "".concat(Math.abs(size.y), "px");

      this.rectSelectorFrame.style.transformOrigin = 'top left';
      this.rectSelectorFrame.style.transform = "translate(".concat(boundsProjected.min.x, "px, ").concat(boundsProjected.min.y, "px) scale(").concat(Math.sign(size.x), ", ").concat(Math.sign(size.y), ")");
    } }, { key: "destroy", value: function destroy()

    {var _this5 = this;
      this.unregisterEventListeners();

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_3__.forAll)(this.markupFrames, function (frame) {
        _this5.container.removeChild(frame);
      });
      this.markupFrames = null;

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_3__.forAll)(this.layerFrames, function (frame) {
        _this5.container.removeChild(frame);
      });
      this.layerFrames = null;

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_3__.forAll)(this.anchors, function (anchor) {
        _this5.container.removeChild(anchor);
      });
      this.anchors = null;

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_3__.forAll)(this.segments, function (segment) {
        _this5.container.removeChild(segment);
      });
      this.segments = null;

      this.markupsExtension = null;
      this.viewer = null;
    } }]);return FrameRenderer;}();


av.GlobalManagerMixin.call(FrameRenderer.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/Links/Link.js":
/*!*********************************************!*\
  !*** ./extensions/BimMarkups/Links/Link.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Link)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _LinkAnchorHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinkAnchorHandler */ "./extensions/BimMarkups/Links/LinkAnchorHandler.js");
/* harmony import */ var _LinkSelectionHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LinkSelectionHandler */ "./extensions/BimMarkups/Links/LinkSelectionHandler.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var

Link = /*#__PURE__*/function () {
  function Link(markupsExtension, id, guid, layer, type, state) {_classCallCheck(this, Link);
    this.id = id;
    this.guid = guid;
    this.layer = layer;
    this.type = type;
    this.markupsExtension = markupsExtension;

    // Whether the link is visible.
    this.visible = true;

    // Whether the link is selected.
    this.selected = false;

    this.hover = false;

    // Whether the link has changed recently and needs to be re-rendered.
    this.dirty = false;

    if (state) {
      this.state = state;
    } else {
      this.state = this.getDefaultState();
      this.state.style = this.getDefaultStyle();
    }

    this.editState = {};

    this.registerSelectionHandler();
    this.registerAnchorHandler();
  }_createClass(Link, [{ key: "getDefaultState", value: function getDefaultState()

    {
      return {};
    } }, { key: "getDefaultStyle", value: function getDefaultStyle()

    {
      return {};
    } }, { key: "getState", value: function getState()

    {
      return this.state;
    } }, { key: "setState", value: function setState(

    state) {
      this.state = state;
    } }, { key: "getEditState", value: function getEditState()

    {
      return this.editState;
    } }, { key: "setEditState", value: function setEditState(

    editState) {
      this.editState = editState;
      this.setDirty(true);
    } }, { key: "syncEditState", value: function syncEditState()

    {
      this.setEditState(_Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.getState()));
    } }, { key: "setDirty", value: function setDirty(

    dirty) {
      this.dirty = dirty;

      if (dirty) {
        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.LINK_DIRTY, link: this });
      }
    } }, { key: "isDirty", value: function isDirty()

    {
      return this.dirty;
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.layer.isVisible();
    } }, { key: "getLinkBasePosition", value: function getLinkBasePosition()

    {
      var layerBoundingBox = this.layer.getClientBoundingBox(true);
      var posProjected = layerBoundingBox.max.clone().setY(layerBoundingBox.min.y);
      var upVec = this.markupsExtension.renderer.getCameraUpVector();
      var rightVec = this.markupsExtension.renderer.getCameraRightVector();

      var linkBoundingBox = this.getClientBoundingBox();
      var linkSize = linkBoundingBox.getSize(new THREE.Vector3());
      var verticalOffset = upVec.multiplyScalar(this.markupsExtension.renderer.multiplyByNormaStrokeWidth(linkSize.y / 2));
      var horizontalOffset = rightVec.multiplyScalar(this.markupsExtension.renderer.multiplyByNormaStrokeWidth(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.LINK_POSITION_OFFSET + linkSize.x / 2));

      // Apply camera rotation.
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(posProjected, -cameraRotation, layerBoundingBox.getCenter(new THREE.Vector3()), eyeDirection);

      var pos = this.markupsExtension.renderer.clientToWorld(posProjected).sub(verticalOffset).add(horizontalOffset);
      return pos;
    } }, { key: "getClientBoundingBox", value: function getClientBoundingBox()

    {
      return this.markupsExtension.renderer.linksRenderer.getLinkBoundingBox(this);
    } }, { key: "getPosition", value: function getPosition()

    {
      if (this.editState.position) {
        return this.editState.position;
      } else {
        return this.getLinkBasePosition();
      }
    } }, { key: "select", value: function select()

    {
      this.selected = true;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.LINK_SELECTED, link: this });
      this.setDirty(true);
    } }, { key: "deselect", value: function deselect()

    {
      this.selected = false;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.LINK_DESELECTED, link: this });
      this.setDirty(true);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.selected;
    } }, { key: "setHover", value: function setHover(

    hover) {
      if (this.hover !== hover) {
        this.hover = hover;
        this.setDirty(true);
      }
    } }, { key: "isHovered", value: function isHovered()

    {
      return this.hover;
    } }, { key: "isCompleted", value: function isCompleted()

    {
      return true;
    } }, { key: "registerSelectionHandler", value: function registerSelectionHandler()

    {
      this.selectionHandler = new _LinkSelectionHandler__WEBPACK_IMPORTED_MODULE_5__["default"](this.markupsExtension, this);
    } }, { key: "registerAnchorHandler", value: function registerAnchorHandler()

    {
      this.anchorHandler = new _LinkAnchorHandler__WEBPACK_IMPORTED_MODULE_4__["default"](this.markupsExtension, this);
    } }, { key: "destroy", value: function destroy()

    {
      if (this.translationHandler) {
        this.translationHandler.destroy();
        this.translationHandler = null;
      }

      this.markupsExtension = null;
      this.state = null;
      this.editState = null;
    } }]);return Link;}();

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinkAnchorHandler.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinkAnchorHandler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnchorHandler)
/* harmony export */ });
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _LinkEditHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LinkEditHandler */ "./extensions/BimMarkups/Links/LinkEditHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

AnchorHandler = /*#__PURE__*/function (_LinkEditHandler) {_inherits(AnchorHandler, _LinkEditHandler);var _super = _createSuper(AnchorHandler);function AnchorHandler() {_classCallCheck(this, AnchorHandler);return _super.apply(this, arguments);}_createClass(AnchorHandler, [{ key: "handleMouseMove", value: function handleMouseMove(
    point) {
      var hovered = this.grabbing || this.intersect(point);
      this.link.setHover(hovered);

      if (this.grabbing) {
        this.updatePosition(point);

        return true;
      }

      return false;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    point, button) {
      if (!this.grabbing) {
        this.grabbing = this.intersect(point);

        if (this.grabbing) {
          this.originalPosition = point.clone();
          this.lastTranslationPoint = point;
        }

        return !!this.grabbing;
      }

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (this.grabbing) {
        this.updatePosition(point);

        if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__.isEqualVectors)(point, this.originalPosition, this.getMinChangeDistanceWorld())) {
          this.cancelAnchorEditing();
          return false;
        } else {
          this.submitChanges();
        }

        this.grabbing = false;
        this.lastTranslationPoint = null;

        return true;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (this.grabbing) {
        switch (keyCode) {
          case Autodesk.Viewing.KeyCode.BACKSPACE:
          case Autodesk.Viewing.KeyCode.DELETE:
          case Autodesk.Viewing.KeyCode.ESCAPE:
            this.cancelAnchorEditing();
            return true;
          default:
            break;}

      }

      return false;
    } }, { key: "updateEditStatePosition", value: function updateEditStatePosition()

    {
      this.updateEditState({ position: this.getEditState().position });
    } }, { key: "updatePosition", value: function updatePosition(

    point) {
      var translation = point.clone().sub(this.lastTranslationPoint);

      if (!this.link.editState.position) {
        this.link.editState.position = this.link.getLinkBasePosition();
      }

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__.applyTranslation)(this.link.editState.position, translation);

      this.lastTranslationPoint = point;
      this.updateEditStatePosition();
    } }, { key: "cancelAnchorEditing", value: function cancelAnchorEditing()

    {
      this.grabbing = false;
      this.link.syncEditState();
      this.updateEditStatePosition();
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.grabbing;
    } }, { key: "intersect", value: function intersect(

    point) {
      var p = this.markupsExtension.renderer.worldToClient(point);
      var boundingBox = this.link.getClientBoundingBox();

      return boundingBox.containsPoint(p);
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.grabbing) {
        return 'grabbing';
      } else {
        return 'grab';
      }
    } }]);return AnchorHandler;}(_LinkEditHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinkAttachment.js":
/*!*******************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinkAttachment.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinkAttachment)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Link */ "./extensions/BimMarkups/Links/Link.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

LinkAttachment = /*#__PURE__*/function (_Link) {_inherits(LinkAttachment, _Link);var _super = _createSuper(LinkAttachment);
  function LinkAttachment(markupsExtension, id, guid, layer, state) {_classCallCheck(this, LinkAttachment);return _super.call(this,
    markupsExtension, id, guid, layer, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.LINK_TYPE_DOCUMENT_ATTACHMENT, state);
  }return LinkAttachment;}(_Link__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinkEditHandler.js":
/*!********************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinkEditHandler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EditHandler)
/* harmony export */ });
/* harmony import */ var _Actions_UpdateMarkupAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions/UpdateMarkupAction */ "./extensions/BimMarkups/Actions/UpdateMarkupAction.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

EditHandler = /*#__PURE__*/function () {
  function EditHandler(markupsExtension, link) {_classCallCheck(this, EditHandler);
    this.markupsExtension = markupsExtension;
    this.viewer = markupsExtension.viewer;
    this.link = link;

    this.link.syncEditState();
  }_createClass(EditHandler, [{ key: "getEditState", value: function getEditState()

    {
      return this.link.getEditState();
    } }, { key: "setEditState", value: function setEditState(

    editState) {
      this.link.setEditState(editState);
    }

    // Use updateEditState whenever there are changes you want to update in the markup's edit state.
  }, { key: "updateEditState", value: function updateEditState(changes) {
      this.setEditState(Object.assign({}, this.getEditState(), changes));
    }

    // Use submitChanges to update the markup with the recent changes of the edit handler.
    // Using this will change the history of the markups, and will add an undo / redo actions.
    // Use it only after you committed changes to the editState, using updateEditState.
  }, { key: "submitChanges", value: function submitChanges() {
      var action = new _Actions_UpdateMarkupAction__WEBPACK_IMPORTED_MODULE_0__["default"](this.markupsExtension.markupsManager, this.link, this.getEditState());
      action.execute();
    } }, { key: "isDragging", value: function isDragging()

    {
      return false;
    } }, { key: "getTouchRadiusWorld", value: function getTouchRadiusWorld()

    {
      return this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.TOUCH_RADIUS);
    } }, { key: "getMinChangeDistanceWorld", value: function getMinChangeDistanceWorld()

    {
      return this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MIN_CHANGE_DISTANCE);
    } }, { key: "didMouseMove", value: function didMouseMove()

    {
      return this.markupsExtension.markupsTool.mouseMoved;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleGesture", value: function handleGesture(

    event) {
    } }, { key: "handleResize", value: function handleResize()

    {
    } }, { key: "destroy", value: function destroy()

    {
      this.markupsExtension = null;
      this.viewer = null;
      this.link = null;
    } }]);return EditHandler;}();

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinkSelectionHandler.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinkSelectionHandler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionHandler)
/* harmony export */ });
/* harmony import */ var _LinkEditHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LinkEditHandler */ "./extensions/BimMarkups/Links/LinkEditHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

SelectionHandler = /*#__PURE__*/function (_LinkEditHandler) {_inherits(SelectionHandler, _LinkEditHandler);var _super = _createSuper(SelectionHandler);function SelectionHandler() {_classCallCheck(this, SelectionHandler);return _super.apply(this, arguments);}_createClass(SelectionHandler, [{ key: "intersect", value: function intersect(
    point) {
      var p = this.markupsExtension.renderer.worldToClient(point);
      var boundingBox = this.link.getClientBoundingBox();

      return boundingBox.containsPoint(p);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    point) {
      if (this.markupsExtension.markupsTool.dragging || Autodesk.Viewing.isMobileDevice()) {
        return false;
      }

      var intersected = this.intersect(point);

      this.link.setHover(intersected);

      if (intersected) {
        this.link.layer.setHover(true);
      }

      return intersected;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'pointer';
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    point, button) {
      if (!this.didMouseMove() && this.intersect(point)) {
        this.markupsExtension.markupsManager.deselectAllLinks();
        this.markupsExtension.markupsManager.selectLink(this.link);

        return true;
      }

      return false;
    } }]);return SelectionHandler;}(_LinkEditHandler__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinkTypesDictionary.js":
/*!************************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinkTypesDictionary.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linkTypesDictionary": () => (/* binding */ linkTypesDictionary)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _LinkAttachment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LinkAttachment */ "./extensions/BimMarkups/Links/LinkAttachment.js");
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}


var linkTypesDictionary = _defineProperty({},
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.LINK_TYPE_DOCUMENT_ATTACHMENT, _LinkAttachment__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Links/LinksRenderer.js":
/*!******************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinksRenderer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinksRenderer)
/* harmony export */ });
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _LinksRenderer_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LinksRenderer.css */ "./extensions/BimMarkups/Links/LinksRenderer.css");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var av = Autodesk.Viewing;var

LinksRenderer = /*#__PURE__*/function () {
  function LinksRenderer(markupsExtension) {_classCallCheck(this, LinksRenderer);
    this.markupsExtension = markupsExtension;
    this.setGlobalManager(markupsExtension.globalManager);
    this.viewer = this.markupsExtension.viewer;
    this.container = this.viewer.appendOrderedElementToViewer('markup-links-container');
    this.container.className = 'markup-links-container';

    this.links = {};
    this.linksSizeCache = {};

    this.registerEventListeners();
  }_createClass(LinksRenderer, [{ key: "registerEventListeners", value: function registerEventListeners()

    {
      this.onLinkDirtyBinded = this.onLinkDirty.bind(this);
      this.onMarkupDirtyBinded = this.onMarkupDirty.bind(this);
      this.renderAllLinksBinded = this.renderAllLinks.bind(this);
      this.onLinkDeletedBinded = this.onLinkDeleted.bind(this);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_DIRTY, this.onLinkDirtyBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DIRTY, this.onMarkupDirtyBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_SYNCED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_REMOVED, this.onLinkDeletedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_SELECTED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DESELECTED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_VIEW_EXITED, this.renderAllLinksBinded);

      this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.renderAllLinksBinded);
    } }, { key: "unregisterEventListeners", value: function unregisterEventListeners()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_DIRTY, this.onLinkDirtyBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DIRTY, this.onMarkupDirtyBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_SYNCED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_REMOVED, this.onLinkDeletedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_SELECTED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DESELECTED, this.renderAllLinksBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_VIEW_EXITED, this.renderAllLinksBinded);

      this.viewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.renderAllLinksBinded);
    } }, { key: "onMarkupDirty", value: function onMarkupDirty(_ref)

    {var _this = this;var markup = _ref.markup;
      if (markup.layer) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.forAll)(markup.layer.links, function (link) {
          _this.renderLink(link);
        });
      }
    } }, { key: "onLinkDirty", value: function onLinkDirty(_ref2)

    {var link = _ref2.link;
      this.renderLink(link);
    } }, { key: "renderLink", value: function renderLink(

    link) {
      if (link.layer.isEmpty()) {
        return;
      }

      var name = "".concat(link.layer.id, "_link_").concat(link.id);

      if (link.isVisible()) {
        var isSelected = link.isSelected();
        var isHovered = link.isHovered();
        var isActiveLayer = this.markupsExtension.markupsManager.getActiveLayer() === link.layer;
        var count = link.layer.layerData.attachments.length;
        var transparent = this.markupsExtension.markupsManager.isMarkupSessionOpen() && !isActiveLayer ||
        this.markupsExtension.markupsManager.getSelectedLayers().length > 0 && !link.layer.isSelected() ||
        !this.markupsExtension.isToolEnabled();
        this.createLinkElement(name, link, isSelected, isActiveLayer, isHovered, count, transparent);
      } else if (this.links[name]) {
        this.links[name].classList.remove('visible');
      }

      link.setDirty(false);
    } }, { key: "renderAllLinks", value: function renderAllLinks()

    {var _this2 = this;var
      layers = this.markupsExtension.markupsManager.layers;

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.forAll)(layers, function (layer) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.forAll)(layer.links, function (link) {
          _this2.renderLink(link);
        });
      });

      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LINK_RENDERED });
    } }, { key: "createLinkElement", value: function createLinkElement(

    name, link, isSelected, isActiveLayer, isHovered, count, transparent) {
      var anchorElement = this.links[name];

      var _document = this.getDocument();
      if (!anchorElement) {
        anchorElement = _document.createElement('div');
        anchorElement.className = 'link';

        var icon = _document.createElement('div');
        icon.className = 'link-document-attachment';
        anchorElement.appendChild(icon);

        this.container.appendChild(anchorElement);
        this.links[name] = anchorElement;
      }

      if (!anchorElement.classList.contains('visible')) {
        anchorElement.classList.add('visible');
      }

      if (transparent && !anchorElement.classList.contains('transparent')) {
        anchorElement.classList.add('transparent');
      } else if (!transparent && anchorElement.classList.contains('transparent')) {
        anchorElement.classList.remove('transparent');
      }

      if (isSelected && !anchorElement.classList.contains('selected')) {
        anchorElement.classList.add('selected');
      } else if (!isSelected && anchorElement.classList.contains('selected')) {
        anchorElement.classList.remove('selected');
      }

      if (isHovered && !anchorElement.classList.contains('hover')) {
        anchorElement.classList.add('hover');
      } else if (!isHovered && anchorElement.classList.contains('hover')) {
        anchorElement.classList.remove('hover');
      }

      if (isActiveLayer && !anchorElement.classList.contains('editable')) {
        anchorElement.classList.add('editable');
      } else if (!isActiveLayer && anchorElement.classList.contains('editable')) {
        anchorElement.classList.remove('editable');
      }

      var text = count > 99 ? '99+' : count;
      anchorElement.firstChild.innerText = text;

      if (!this.linksSizeCache[text]) {
        this.linksSizeCache[text] = anchorElement.firstChild.getBoundingClientRect();
      }

      // Calculate link's icon bounding box.
      // First we calculate the boundingBox just for the size, without the correct position. It's necessary for link.getPosition().
      var boundingBox = new THREE.Box3();
      var linkHalfSize = new THREE.Vector3(this.linksSizeCache[text].width / 2, this.linksSizeCache[text].height / 2, 0);
      boundingBox.expandByPoint(new THREE.Vector3());
      boundingBox.expandByVector(linkHalfSize);
      anchorElement.boundingBox = boundingBox;
      var pos = link.getPosition();

      var position = this.markupsExtension.renderer.worldToClient(pos);

      anchorElement.style.transform = "translate(".concat(Math.round(position.x - this.linksSizeCache[text].width / 2), "px, ").concat(Math.round(position.y - this.linksSizeCache[text].height / 2), "px)");

      // Now, after we got the right position, we can update the bounding box with the true position.
      boundingBox.makeEmpty();
      boundingBox.expandByPoint(position);
      boundingBox.expandByVector(linkHalfSize);
    } }, { key: "getLinkBoundingBox", value: function getLinkBoundingBox(

    link) {
      var name = "".concat(link.layer.id, "_link_").concat(link.id);
      var anchorElement = this.links[name];
      if (!anchorElement) {
        return new THREE.Box3();
      }

      return anchorElement.boundingBox;
    } }, { key: "onLinkDeleted", value: function onLinkDeleted(_ref3)

    {var link = _ref3.link;
      var name = "".concat(link.layer.id, "_link_").concat(link.id);
      var linkElement = this.links[name];

      if (linkElement) {
        this.container.removeChild(linkElement);
      }

      delete this.links[name];
    } }, { key: "destroy", value: function destroy()

    {var _this3 = this;
      this.unregisterEventListeners();

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.forAll)(this.links, function (link) {
        _this3.container.removeChild(link);
      });
      this.links = null;

      this.markupsExtension = null;
      this.viewer = null;
    } }]);return LinksRenderer;}();


av.GlobalManagerMixin.call(LinksRenderer.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/Markup.js":
/*!*****************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/Markup.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Markup)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _EditHandlers_SelectionHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EditHandlers/SelectionHandler */ "./extensions/BimMarkups/EditHandlers/SelectionHandler.js");
/* harmony import */ var _EditHandlers_TranslationHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../EditHandlers/TranslationHandler */ "./extensions/BimMarkups/EditHandlers/TranslationHandler.js");
/* harmony import */ var _EditHandlers_AnchorHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../EditHandlers/AnchorHandler */ "./extensions/BimMarkups/EditHandlers/AnchorHandler.js");
/* harmony import */ var _EditHandlers_RotationHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../EditHandlers/RotationHandler */ "./extensions/BimMarkups/EditHandlers/RotationHandler.js");
/* harmony import */ var _EditHandlers_ScaleHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../EditHandlers/ScaleHandler */ "./extensions/BimMarkups/EditHandlers/ScaleHandler.js");
/* harmony import */ var _EditHandlers_TextInputHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../EditHandlers/TextInputHandler */ "./extensions/BimMarkups/EditHandlers/TextInputHandler.js");
/* harmony import */ var _EditHandlers_DimensionEditHandler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../EditHandlers/DimensionEditHandler */ "./extensions/BimMarkups/EditHandlers/DimensionEditHandler.js");
/* harmony import */ var _EditHandlers_CreationHandlers_CreationHandlerFactory__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../EditHandlers/CreationHandlers/CreationHandlerFactory */ "./extensions/BimMarkups/EditHandlers/CreationHandlers/CreationHandlerFactory.js");
/* harmony import */ var _RendererHelpers_MarkupsGeometryManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../RendererHelpers/MarkupsGeometryManager */ "./extensions/BimMarkups/RendererHelpers/MarkupsGeometryManager.js");
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}













var av = Autodesk.Viewing;var

Markup = /*#__PURE__*/function () {
  function Markup(markupsExtension, id, type, state) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, Markup);
    this.setGlobalManager(markupsExtension.globalManager);
    this.id = id;
    this.type = type;
    this.options = options;
    this.markupsExtension = markupsExtension;
    this.materialManager = this.markupsExtension.renderer.materialManager;

    this.layer = null;

    this.meshContainer = null;
    this.strokeMaterial = null;
    this.fillMaterial = null;
    this.center = new THREE.Vector3();

    this.matrix = new THREE.Matrix4();
    this.invMatrix = new THREE.Matrix4();
    this.scaleMatrix = new THREE.Matrix4();
    this.invScaleMatrix = new THREE.Matrix4();

    // Whether the markup creation has been ended successfully.
    this.completed = false;

    // Whether the markup is selected.
    this.selected = false;

    // Whether the markup is in edit mode.
    this.inEdit = false;

    // Whether the markup is enabled for touch.
    this.enabled = true;

    // Whether the markup is transparent.
    this.transparent = false;

    // Whether the markup is visible.
    this.visible = false;

    // Whether the markup is being hovered or not.
    this.hover = false;

    // To prevent infinite recursion when changing group's edit state
    this.locked = false;

    this.state = this.getDefaultState();
    this.state.anchors = this.getDefaultAnchors();
    this.state.style = this.getDefaultStyle();

    if (state) {
      Object.assign(this.state, state);
    }

    this.state.translation = this.state.translation || new THREE.Vector3();
    this.state.rotation = this.state.rotation || 0;
    this.state.scale = this.state.scale || new THREE.Vector3(1.0, 1.0, 1.0);

    this.editState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.state);
    this.updateMatrix();

    this.registerSelectionHandler();

    this.creationHandler = _EditHandlers_CreationHandlers_CreationHandlerFactory__WEBPACK_IMPORTED_MODULE_11__["default"].getCreationHandler(this.type, this.markupsExtension, this, options);
  }_createClass(Markup, [{ key: "updateMatrix", value: function updateMatrix()

    {
      this.scaleMatrix.makeScale(this.editState.scale.x, this.editState.scale.y, this.editState.scale.z);

      this.matrix.copy(this.scaleMatrix);
      this.matrix.setPosition(this.editState.translation);
      this.invMatrix.copy(this.matrix).invert();
      this.invScaleMatrix.copy(this.scaleMatrix).invert();
      this.updateCenter();
    } }, { key: "updateCenter", value: function updateCenter()

    {
      if (this.editState.anchors.length === 0) {return;}

      var max = new THREE.Vector3().set(-Infinity, -Infinity, -Infinity);
      var min = new THREE.Vector3().set(Infinity, Infinity, Infinity);
      this.editState.anchors.forEach(function (anchor) {
        max = max.max(anchor);
        min = min.min(anchor);
      });

      this.center.x = (max.x + min.x) / 2;
      this.center.y = (max.y + min.y) / 2;
    } }, { key: "getDefaultState", value: function getDefaultState()

    {
      return {};
    } }, { key: "getDefaultAnchors", value: function getDefaultAnchors()

    {
      return [];
    } }, { key: "getDefaultStyle", value: function getDefaultStyle()

    {var _ref;
      return _ref = {}, _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.LAST_COLOR)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_WEIGHT, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_WEIGHT)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_FAMILY, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_FAMILY)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_STYLE, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_STYLE)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR)), _defineProperty(_ref,
      _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY, this.markupsExtension.getStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY)), _ref;

    } }, { key: "getState", value: function getState()

    {
      return this.state;
    } }, { key: "setState", value: function setState(

    state) {
      this.state = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(state);

      this.rotatedBoundingBox = null;
      this.boundingBox = null;
    } }, { key: "getEditState", value: function getEditState()

    {
      return this.editState;
    } }, { key: "setEditState", value: function setEditState(

    editState, changes, source) {
      var prevState = this.editState;

      if (changes) {
        this.editState = Object.assign({}, editState, changes);
      } else {
        this.editState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(editState);
      }

      this.updateMatrix();

      this.rotatedBoundingBox = null;
      this.boundingBox = null;

      if (this.visible && this.markupsExtension.renderer) {
        this.render(changes);
      }

      if (this.belongsToGroup() && !this.isLocked()) {
        this.syncGroup(prevState, this.editState, changes, source);
      }
    } }, { key: "isLocked", value: function isLocked()

    {
      return this.locked;
    } }, { key: "setLocked", value: function setLocked(

    isLocked) {
      this.locked = isLocked;
    } }, { key: "render", value: function render(

    state) {
      if (!this.meshContainer) {
        this.meshContainer = new THREE.Group();
        this.markupsExtension.renderer.addToScene(this);
      }
    } }, { key: "syncEditState", value: function syncEditState()

    {
      this.setEditState(this.getState());
    } }, { key: "syncState", value: function syncState()

    {
      this.setState(this.getEditState());
    } }, { key: "syncGroup", value: function syncGroup(

    prevState, newState, changes, source) {
      this.markupGroup.rotatedBoundingBox = null;
      this.markupGroup.boundingBox = null;
      if (changes) {
        this.markupGroup.syncGroupMarkups(this, prevState, newState, changes, source);
      }
    } }, { key: "select", value: function select()

    {
      if (this.layer && !this.markupsExtension.permissionManager.canEditMarkup(this.layer.layerData)) {
        return;
      }

      this.selected = true;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_SELECTED, markup: this });

      this.enableEdit();

      if (this.belongsToGroup() && !this.markupGroup.locked) {
        this.markupGroup.select(this);
      }
    } }, { key: "deselect", value: function deselect()

    {
      this.selected = false;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DESELECTED, markup: this });

      this.disableEdit();
    } }, { key: "setVisible", value: function setVisible(

    isVisible, forceSet) {
      if (this.visible !== isVisible || forceSet) {
        this.visible = isVisible;

        if (this.meshContainer) {
          this.meshContainer.visible = isVisible;
        }

        if (this.markupsExtension.renderer) {
          if (this.visible) {
            this.render();
          } else {
            this.markupsExtension.renderer.invalidate();
          }
        }

        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_VISIBILITY_CHANGED, markup: this, visible: isVisible });
      }
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.visible;
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.selected;
    } }, { key: "enableEdit", value: function enableEdit()

    {
      this.inEdit = true;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_ENABLE_EDIT, markup: this });
      this.setDirty();
    } }, { key: "disableEdit", value: function disableEdit()

    {
      this.inEdit = false;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DISABLE_EDIT, markup: this });
      this.setDirty();
    } }, { key: "enable", value: function enable()

    {
      this.enabled = true;

      this.changeTransparency(false);
    } }, { key: "disable", value: function disable()

    {
      this.enabled = false;

      this.changeTransparency(true);
    } }, { key: "isEnabled", value: function isEnabled()

    {
      return this.enabled;
    } }, { key: "changeTransparency", value: function changeTransparency(

    transparent) {
      if (this.transparent !== transparent) {
        this.transparent = transparent;

        if (this.visible && this.markupsExtension.renderer) {
          this.render({ style: {} });
        }

        this.setDirty();
      }
    } }, { key: "isTransparent", value: function isTransparent()

    {
      return this.transparent;
    } }, { key: "setHover", value: function setHover(

    hover) {
      if (this.hover !== hover) {
        this.hover = hover;

        if (this.belongsToGroup() && !this.markupGroup.locked) {
          this.markupGroup.setHover(hover, this);
        }
        this.setDirty();
      }
    } }, { key: "isHovered", value: function isHovered()

    {
      return this.hover;
    } }, { key: "isInEdit", value: function isInEdit()

    {
      return this.inEdit;
    } }, { key: "setDirty", value: function setDirty()

    {
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_DIRTY, markup: this });
    } }, { key: "isCompleted", value: function isCompleted()

    {
      return this.completed;
    } }, { key: "complete", value: function complete()

    {
      this.completed = true;

      if (this.selectWhenCompleted()) {
        this.select();
      } else {
        this.setDirty();
      }

      if (this.visible && this.markupsExtension.renderer) {
        this.render();
      }

      this.markupsExtension.markupsManager.selectLayer(this.layer, false, false);
    } }, { key: "selectWhenCompleted", value: function selectWhenCompleted()

    {
      return true;
    } }, { key: "registerAnchorHandler", value: function registerAnchorHandler(

    options) {
      this.anchorHandler = new _EditHandlers_AnchorHandler__WEBPACK_IMPORTED_MODULE_6__["default"](this.markupsExtension, this, options);
    } }, { key: "registerTranslationHandler", value: function registerTranslationHandler(

    options) {
      this.translationHandler = new _EditHandlers_TranslationHandler__WEBPACK_IMPORTED_MODULE_5__["default"](this.markupsExtension, this, options);
    } }, { key: "registerRotationHandler", value: function registerRotationHandler(

    options) {
      this.rotationHandler = new _EditHandlers_RotationHandler__WEBPACK_IMPORTED_MODULE_7__["default"](this.markupsExtension, this, options);
    } }, { key: "registerScaleHandler", value: function registerScaleHandler(

    options) {
      this.scaleHandler = new _EditHandlers_ScaleHandler__WEBPACK_IMPORTED_MODULE_8__["default"](this.markupsExtension, this, options);
    } }, { key: "registerSelectionHandler", value: function registerSelectionHandler(

    options) {
      this.selectionHandler = new _EditHandlers_SelectionHandler__WEBPACK_IMPORTED_MODULE_4__["default"](this.markupsExtension, this, options);
    } }, { key: "registerTextInputHandler", value: function registerTextInputHandler(

    options) {
      this.textInputHandler = new _EditHandlers_TextInputHandler__WEBPACK_IMPORTED_MODULE_9__["default"](this.markupsExtension, this, options);
    } }, { key: "registerDimensionEditHandler", value: function registerDimensionEditHandler(

    options) {
      this.dimensionEditHandler = new _EditHandlers_DimensionEditHandler__WEBPACK_IMPORTED_MODULE_10__["default"](this.markupsExtension, this, options);
    } }, { key: "applyCameraRotation", value: function applyCameraRotation(

    point) {
      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(point, cameraRotation, this.getWorldCenter(), eyeDirection);
    } }, { key: "applyInverseCameraRotation", value: function applyInverseCameraRotation(

    point) {
      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(point, -cameraRotation, this.getWorldCenter(), eyeDirection);
    } }, { key: "applyInverseRotation", value: function applyInverseRotation(

    point) {
      var rotation = this.getRotation();
      if (rotation === 0) {
        return;
      }

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(point, -rotation, this.getWorldCenter(), eyeDirection);
    } }, { key: "applyRotation", value: function applyRotation(

    point) {
      var rotation = this.getRotation();
      if (rotation === 0) {
        return;
      }

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(point, rotation, this.getWorldCenter(), eyeDirection);
    } }, { key: "applyRotationForAnchors", value: function applyRotationForAnchors(

    anchors) {
      var rotation = this.getRotation();
      if (rotation === 0) {
        return;
      }

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var center = this.getWorldCenter();
      anchors.forEach(function (anchor) {
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(anchor, rotation, center, eyeDirection);
      });
    } }, { key: "applyScaleAndTranslation", value: function applyScaleAndTranslation(

    point) {
      point.sub(this.center);
      point.applyMatrix4(this.matrix);
      point.add(this.center);
    } }, { key: "applyInverseScaleAndTranslation", value: function applyInverseScaleAndTranslation(

    point) {
      point.sub(this.center);
      point.applyMatrix4(this.invMatrix);
      point.add(this.center);
    } }, { key: "calculateWorldBoundingBox", value: function calculateWorldBoundingBox(

    rotate) {var _this = this;
      var boundingBox = new THREE.Box3();
      var anchors;
      if (this.meshLine && this.meshLine.boundingPoints) {
        anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.meshLine.boundingPoints);
      } else {
        anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.editState.anchors);
      }

      anchors.forEach(function (anchor) {
        _this.applyScaleAndTranslation(anchor);
      });

      if (rotate) {
        this.applyRotationForAnchors(anchors);
      }

      anchors.forEach(function (anchor) {
        boundingBox.expandByPoint(anchor);
      });

      var halfThickness = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] / 2;
      boundingBox.expandByVector(new THREE.Vector3(halfThickness, halfThickness, 0));

      return boundingBox;
    }

    // If you need to change the bounding box after getting it, make sure to clone it first!
  }, { key: "getWorldBoundingBox", value: function getWorldBoundingBox(rotate) {
      if (rotate) {
        if (!this.rotatedBoundingBox) {
          this.rotatedBoundingBox = this.calculateWorldBoundingBox(rotate);
        }
        return this.rotatedBoundingBox;
      } else {
        if (!this.boundingBox) {
          this.boundingBox = this.calculateWorldBoundingBox(rotate);
        }
        return this.boundingBox;
      }
    } }, { key: "getClientBoundingBox", value: function getClientBoundingBox(

    withMargin, rotate) {
      var boundingBox = this.getWorldBoundingBox(rotate).clone();

      boundingBox.min = this.markupsExtension.renderer.worldToClient(boundingBox.min);
      boundingBox.max = this.markupsExtension.renderer.worldToClient(boundingBox.max);

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var center = boundingBox.getCenter(new THREE.Vector3());

      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();

      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(boundingBox.min, cameraRotation, center, eyeDirection);
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(boundingBox.max, cameraRotation, center, eyeDirection);

      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(boundingBox);

      if (withMargin) {
        var margin = this.getMarginSize();
        boundingBox.expandByVector(new THREE.Vector3(margin, margin, 0));
      }

      boundingBox.min.z = 0;
      boundingBox.max.z = 0;

      return boundingBox;
    } }, { key: "getMarginSize", value: function getMarginSize()

    {
      return _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.BOUNDING_BOX_MARGIN;
    }

    // Returns minimum size in client coordinates
  }, { key: "getMinimumSize", value: function getMinimumSize() {
      return Math.max(this.markupsExtension.renderer.sizeFromWorldToClient(this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS]), this.getMarginSize());
    } }, { key: "getCenter", value: function getCenter()

    {
      return this.center;
    } }, { key: "setPosition", value: function setPosition()

    {
      var translation = this.center.clone().add(this.editState.translation);
      this.meshContainer.position.copy(translation);
    } }, { key: "setRotation", value: function setRotation()

    {
      this.meshContainer.rotation.z = this.editState.rotation * this.markupsExtension.renderer.getCameraEyeVector().z;
    } }, { key: "getWorldCenter", value: function getWorldCenter()

    {
      return this.center.clone().add(this.editState.translation);
    } }, { key: "getClientCenter", value: function getClientCenter()

    {
      return this.markupsExtension.renderer.worldToClient(this.getWorldCenter());
    } }, { key: "getRotation", value: function getRotation()

    {
      return this.editState.rotation;
    } }, { key: "getScale", value: function getScale()

    {
      return this.editState.scale;
    } }, { key: "getAnchors", value: function getAnchors()

    {
      return this.editState.anchors;
    } }, { key: "isAnchorHandlingAllowed", value: function isAnchorHandlingAllowed(

    anchor) {
      return true;
    } }, { key: "getTail", value: function getTail()

    {
      return this.editState.anchors[this.editState.anchors.length - 1];
    } }, { key: "getHead", value: function getHead()

    {
      return this.editState.anchors[0];
    }

    // For group markups, returns a points suitable to place the next markup
  }, { key: "getStartPointForNextMarkup", value: function getStartPointForNextMarkup() {
      return new THREE.Vector3();
    } }, { key: "intersect", value: function intersect(

    _point) {
      var point = _point.clone();
      this.applyInverseRotation(point);
      var p = this.markupsExtension.renderer.worldToClient(point);

      var boundingBox = this.getClientBoundingBox(true);

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(p, cameraRotation, boundingBox.getCenter(new THREE.Vector3()), eyeDirection);
      p.z = 0;

      var inBoundingBox = boundingBox.containsPoint(p);

      if (!inBoundingBox || this.isTextMarkup()) {
        return inBoundingBox;
      }

      if (this.hasFill() && this.fillMesh) {
        var intersects = this.markupsExtension.renderer.raycaster.intersectObject(this.fillMesh);
        if (intersects.length > 0) {
          return true;
        }
      }

      var halfWidth = this.strokeMaterial.uniforms.lineWidth.value / 2;

      halfWidth += this.markupsExtension.renderer.sizeFromClientToWorld(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.HIT_AREA_MARGIN);

      return this.meshLine.isPointNear(_point, halfWidth * halfWidth, this.meshContainer.matrixWorld);
    } }, { key: "isGroupMarkup", value: function isGroupMarkup()

    {
      return false;
    } }, { key: "belongsToGroup", value: function belongsToGroup()

    {
      return !!this.markupGroup;
    }

    // A text markup
  }, { key: "isTextMarkup", value: function isTextMarkup() {
      return false;
    }

    // A geometric shape with thickness
  }, { key: "isGeometricMarkup", value: function isGeometricMarkup() {
      return true;
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return false;
    } }, { key: "isPoint", value: function isPoint()

    {
      return this.editState.anchors.length < 2 || _RendererHelpers_MarkupsGeometryManager__WEBPACK_IMPORTED_MODULE_12__["default"].areAllAnchorsEqual(this.editState.anchors);
    } }, { key: "hasFill", value: function hasFill()

    {
      return this.isWithFillMarkup() && !this.options.fillNotAllowed &&
      this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY] > 0 &&
      this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR] !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.COLORS.NO_COLOR;
    } }, { key: "needsMiter", value: function needsMiter()

    {
      return true;
    } }, { key: "showPath", value: function showPath()

    {
      return false;
    } }, { key: "hasThicknessChanged", value: function hasThicknessChanged()

    {
      return this.strokeMaterial && this.strokeMaterial.uniforms.lineWidth.value !== this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS];
    } }, { key: "removeFill", value: function removeFill()

    {
      if (this.fillMaterial) {
        this.materialManager.removeMaterial(this.fillMaterial);
        this.fillMaterial = null;
      }

      if (this.fillMesh) {
        this.meshContainer.remove(this.fillMesh);
        this.fillMesh = null;
      }
    } }, { key: "remove", value: function remove()

    {var doDispatchEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.markupsExtension.renderer) {
        return;
      }

      if (this.strokeMaterial) {
        this.materialManager.removeMaterial(this.strokeMaterial);
        this.strokeMaterial = null;
      }

      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
        this.strokeMesh = null;
      }

      if (this.meshLine && !this.markupsExtension.renderer.geometryManager.isCachedGeometry(this.meshLine)) {
        this.meshLine.dispose();
        this.meshLine = null;
      }

      if (this.fillMaterial) {
        this.materialManager.removeMaterial(this.fillMaterial);
        this.fillMaterial = null;
      }

      if (this.fillMesh) {
        if (!this.markupsExtension.renderer.geometryManager.isCachedGeometry(this.fillMesh.geometry)) {
          this.fillMesh.traverse(function (child) {if (child.geometry) child.geometry.dispose();});
        }
        this.meshContainer.remove(this.fillMesh);
        this.fillMesh = null;
      }

      if (this.meshContainer) {
        this.markupsExtension.renderer.removeFromScene(this);
        this.meshContainer = null;
      }

      if (doDispatchEvent) {
        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_3__.MARKUPS_EVENTS.MARKUP_REMOVED, markup: this });
      }
    } }, { key: "destroy", value: function destroy()

    {
      if (this.anchorHandler) {
        this.anchorHandler.destroy();
        this.anchorHandler = null;
      }

      if (this.translationHandler) {
        this.translationHandler.destroy();
        this.translationHandler = null;
      }

      if (this.rotationHandler) {
        this.rotationHandler.destroy();
        this.rotationHandler = null;
      }

      if (this.scaleHandler) {
        this.scaleHandler.destroy();
        this.scaleHandler = null;
      }

      if (this.selectionHandler) {
        this.selectionHandler.destroy();
        this.selectionHandler = null;
      }

      if (this.textInputHandler) {
        this.textInputHandler.destroy();
        this.textInputHandler = null;
      }

      this.markupsExtension = null;
      this.state = null;
      this.editState = null;
      this.layer = null;
    } }], [{ key: "createMesh", value: function createMesh(

    geometry, material) {
      var mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false; // We do our own culling in MarkupsRenderer

      return mesh;
    } }]);return Markup;}();


av.GlobalManagerMixin.call(Markup.prototype);

Markup.singleClickMarkup = false;
Markup.withSnappingMarkup = false;
Markup.useTimerBeforeSelection = false;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupArrow.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupArrow.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupArrow)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupLines__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupLines */ "./extensions/BimMarkups/MarkupTypes/MarkupLines.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupArrow = /*#__PURE__*/function (_MarkupLines) {_inherits(MarkupArrow, _MarkupLines);var _super = _createSuper(MarkupArrow);
  function MarkupArrow(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupArrow);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW, state, options);
  }_createClass(MarkupArrow, [{ key: "getTail", value: function getTail()

    {
      return this.editState.anchors[0];
    } }, { key: "getHead", value: function getHead()

    {
      return this.editState.anchors[1];
    } }, { key: "getStartPointForNextMarkup", value: function getStartPointForNextMarkup()

    {
      return this.getTail().clone();
    } }, { key: "isAnchorHandlingAllowed", value: function isAnchorHandlingAllowed(

    anchor) {
      if (this.options.headHandlingNotAllowed && anchor === this.getHead() ||
      this.options.tailHandlingNotAllowed && anchor === this.getTail()) {
        return false;
      }

      return true;
    } }]);return MarkupArrow;}(_MarkupLines__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupArrowCallout.js":
/*!*****************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupArrowCallout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupArrowCallout)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupCallout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupCallout */ "./extensions/BimMarkups/MarkupTypes/MarkupCallout.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupArrowCallout = /*#__PURE__*/function (_MarkupCallout) {_inherits(MarkupArrowCallout, _MarkupCallout);var _super = _createSuper(MarkupArrowCallout);
  function MarkupArrowCallout(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupArrowCallout);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CALLOUT, state, options);
  }_createClass(MarkupArrowCallout, [{ key: "getTextMarkup", value: function getTextMarkup()

    {
      return this.markups[1];
    } }, { key: "getArrowMarkup", value: function getArrowMarkup()

    {
      return this.markups[0];
    } }, { key: "applyArrowConstraints", value: function applyArrowConstraints(

    state) {
      this.applyArrowTextConstraint(state);
    } }, { key: "applyConstraints", value: function applyConstraints(

    sourceMarkup, prevState, newState) {var _this = this;
      this.markups.forEach(function (markup) {
        if (markup === sourceMarkup || !markup.isCompleted()) {
          return;
        }

        if (sourceMarkup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW && sourceMarkup.anchorHandler.activeAnchor === sourceMarkup.getHead()) {
          sourceMarkup.setLocked(true);
          _this.applyArrowConstraints(newState);
          sourceMarkup.setLocked(false);
        }
      });
    } }]);return MarkupArrowCallout;}(_MarkupCallout__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupArrowCloudCallout.js":
/*!**********************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupArrowCloudCallout.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupArrowCloudCallout)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupCallout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupCallout */ "./extensions/BimMarkups/MarkupTypes/MarkupCallout.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupArrowCloudCallout = /*#__PURE__*/function (_MarkupCallout) {_inherits(MarkupArrowCloudCallout, _MarkupCallout);var _super = _createSuper(MarkupArrowCloudCallout);
  function MarkupArrowCloudCallout(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupArrowCloudCallout);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CLOUD_CALLOUT, state, options);
  }_createClass(MarkupArrowCloudCallout, [{ key: "getTextMarkup", value: function getTextMarkup()

    {
      return this.markups[2];
    } }, { key: "getArrowMarkup", value: function getArrowMarkup()

    {
      return this.markups[1];
    } }, { key: "getShapeMarkup", value: function getShapeMarkup()

    {
      return this.markups[0];
    } }, { key: "applyArrowConstraints", value: function applyArrowConstraints(


    state) {
      this.applyArrowTextConstraint(state);
      this.applyShapeArrowConstraint(state);
    } }, { key: "applyConstraints", value: function applyConstraints(

    sourceMarkup, prevState, newState) {var _this = this;
      this.markups.forEach(function (markup) {
        if (markup === sourceMarkup || !markup.isCompleted()) {
          return;
        }

        if (sourceMarkup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW) {
          sourceMarkup.setLocked(true);
          if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CLOUD) {
            _this.applyShapeArrowConstraint(newState);
          } else {
            _this.applyArrowTextConstraint(newState);
          }
          sourceMarkup.setLocked(false);
        }
      });
    } }]);return MarkupArrowCloudCallout;}(_MarkupCallout__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupCallout.js":
/*!************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupCallout.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupCallout)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupGroup */ "./extensions/BimMarkups/MarkupTypes/MarkupGroup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupCallout = /*#__PURE__*/function (_MarkupGroup) {_inherits(MarkupCallout, _MarkupGroup);var _super = _createSuper(MarkupCallout);
  function MarkupCallout(markupsExtension, id, type, state) {var _this;var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, MarkupCallout);
    _this = _super.call(this, markupsExtension, id, type, state, options);

    var textMarkup = _this.getTextMarkup();
    textMarkup.textInputHandler.onEmptyTextMarkup = _this.onEmptyTextMarkup.bind(_assertThisInitialized(_this));return _this;
  }_createClass(MarkupCallout, [{ key: "getArrowMarkup", value: function getArrowMarkup()

    {
      throw new Error('getArrowMarkup should be implemented');
    } }, { key: "getTextMarkup", value: function getTextMarkup()

    {
      throw new Error('getTextMarkup should be implemented');
    } }, { key: "getShapeMarkup", value: function getShapeMarkup()

    {
      throw new Error('getShapeMarkup should be implemented');
    } }, { key: "getQuadrant", value: function getQuadrant(

    markup, angle) {
      var bbox = markup.getWorldBoundingBox(true);
      var limitAngle = Math.atan2(bbox.getSize(new THREE.Vector3()).y, bbox.getSize(new THREE.Vector3()).x);

      // Quadrant locations:
      //
      //       \   3   /
      //        \     /
      //         \   /
      //     4    \ /     2
      //          / \
      //         /   \
      //        /  1  \
      //       /       \
      if (angle >= -(Math.PI - limitAngle) && angle < -limitAngle) {
        return 1;
      } else if (angle >= -limitAngle && angle < limitAngle) {
        return 2;
      } else if (angle >= limitAngle && angle < Math.PI - limitAngle) {
        return 3;
      } else {
        return 4;
      }
    } }, { key: "getTextQuadrant", value: function getTextQuadrant(

    angle) {
      return this.getQuadrant(this.getTextMarkup(), angle);
    } }, { key: "getShapeQuadrant", value: function getShapeQuadrant(

    angle) {
      return this.getQuadrant(this.getShapeMarkup(), angle);
    }

    // Returns a vector from closest vertex to the passed point
  }, { key: "getVectorToClosestPointOnCloud", value: function getVectorToClosestPointOnCloud(point) {
      var text = this.getTextMarkup();
      var geo = text.frameMarkup.meshLine.sourceGeo;
      var closestDistance = Infinity;
      var closestVertex = null;

      // Find closest point on cloud (brute force approach)
      geo.forEach(function (vertex) {
        var distance = point.distanceToSquared(vertex);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestVertex = vertex;
        }
      });

      return point.clone().sub(closestVertex);
    } }, { key: "applyArrowTextConstraint", value: function applyArrowTextConstraint(

    state) {
      var arrow = this.getArrowMarkup();
      var text = this.getTextMarkup();
      state = state || arrow.getEditState();
      if (!state.anchors[0] || !state.anchors[1]) {
        return;
      }

      var bbox = text.getWorldBoundingBox(true);
      var center = bbox.getCenter(new THREE.Vector3());
      var halfThickness = text.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.THICKNESS] / 2;
      var halfHeight = bbox.getSize(new THREE.Vector3()).y / 2 - halfThickness;
      var halfWidth = bbox.getSize(new THREE.Vector3()).x / 2 - halfThickness;

      var origArrowTail = state.anchors[0];
      var arrowHead = state.anchors[1].clone();
      arrow.applyScaleAndTranslation(arrowHead);

      var angle = Math.atan2(arrowHead.y - center.y, arrowHead.x - center.x);

      switch (this.getTextQuadrant(angle)) {
        case 1:
          origArrowTail.set(center.x, center.y - halfHeight, 0);
          break;
        case 2:
          origArrowTail.set(center.x + halfWidth, center.y, 0);
          break;
        case 3:
          origArrowTail.set(center.x, center.y + halfHeight, 0);
          break;
        case 4:
          origArrowTail.set(center.x - halfWidth, center.y, 0);
          break;}


      if (text.editState.frameType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CLOUD) {
        var tailPoint = origArrowTail.clone().sub(center);
        var delta = this.getVectorToClosestPointOnCloud(tailPoint).negate();
        origArrowTail.add(delta);
      }
      arrow.applyInverseScaleAndTranslation(origArrowTail);
      arrow.creationHandler.updateEditStateAnchors();
    } }, { key: "applyShapeArrowConstraint", value: function applyShapeArrowConstraint(

    state) {
      var arrow = this.getArrowMarkup();
      var shape = this.getShapeMarkup();
      state = state || arrow.getEditState();
      if (!state.anchors[0] || !state.anchors[1]) {
        return;
      }

      var bbox = shape.getWorldBoundingBox(true);
      var center = bbox.getCenter(new THREE.Vector3());
      var bboxSize = bbox.getSize(new THREE.Vector3());
      var halfHeight = bboxSize.y / 2;
      var halfWidth = bboxSize.x / 2;

      var origArrowHead = state.anchors[1];
      var arrowTail = state.anchors[0].clone();
      arrow.applyScaleAndTranslation(arrowTail);

      var dx = arrowTail.x - center.x;
      var dy = arrowTail.y - center.y;
      var angle = Math.atan2(dy, dx);
      var delta;

      var sign = function sign(d) {return d > 0 ? 1 : -1;};

      switch (this.getShapeQuadrant(angle)) {
        case 1:
          delta = sign(dx) * halfWidth / 3;
          origArrowHead.set(center.x + delta, center.y - halfHeight, 0);
          break;
        case 2:
          delta = sign(dy) * halfHeight / 3;
          origArrowHead.set(center.x + halfWidth, center.y + delta, 0);
          break;
        case 3:
          delta = sign(dx) * halfWidth / 3;
          origArrowHead.set(center.x + delta, center.y + halfHeight, 0);
          break;
        case 4:
          delta = sign(dy) * halfHeight / 3;
          origArrowHead.set(center.x - halfWidth, center.y + delta, 0);
          break;}


      arrow.applyInverseScaleAndTranslation(origArrowHead);
      arrow.creationHandler.updateEditStateAnchors();
    } }, { key: "applyArrowConstraints", value: function applyArrowConstraints(

    state) {
      throw new Error('applyArrowTextConstraint must be implemented');
    } }, { key: "applyConstraints", value: function applyConstraints(

    sourceMarkup, prevState, newState) {
      throw new Error('applyConstraints must be implemented');
    } }, { key: "applyTranslation", value: function applyTranslation(

    sourceMarkup, prevState, newState) {var _this2 = this;
      this.markups.forEach(function (markup) {
        if (markup === sourceMarkup || !markup.isCompleted()) {
          return;
        }

        markup.setLocked(true);
        if (sourceMarkup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW) {
          // For shape and text, apply the same translation
          var translation = newState.translation.clone().sub(prevState.translation);
          translation = markup.editState.translation.clone().add(translation);
          markup.creationHandler.updateEditState({ translation: translation });
        } else {// markup is arrow
          _this2.applyArrowConstraints();
        }
        markup.setLocked(false);
      });
    } }, { key: "applyStyle", value: function applyStyle(

    sourceMarkup, prevState, newState, changes) {var _this3 = this;
      this.markups.forEach(function (markup) {
        if (markup === sourceMarkup || !markup.isCompleted()) {
          return;
        }

        markup.setLocked(true);
        markup.creationHandler.updateEditState({ style: changes.style });
        _this3.applyArrowConstraints();
        markup.setLocked(false);
      });
    } }, { key: "applyScale", value: function applyScale(

    sourceMarkup, prevState, newState) {var _this4 = this;
      this.markups.forEach(function (markup) {
        if (markup === sourceMarkup || !markup.isCompleted()) {
          return;
        }

        if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW) {
          markup.setLocked(true);
          _this4.applyArrowConstraints();
          markup.setLocked(false);
        }
      });
    } }, { key: "applyTextChange", value: function applyTextChange(

    sourceMarkup, prevState, newState) {
      this.applyArrowConstraints();
    } }, { key: "onEmptyTextMarkup", value: function onEmptyTextMarkup()

    {
      this.markupsExtension.markupsManager.actionManager.undo();

      var textMarkup = this.getTextMarkup();
      textMarkup.creationHandler.updateEditState({ text: textMarkup.getDefaultState().text });
      textMarkup.creationHandler.submitChanges();
    } }]);return MarkupCallout;}(_MarkupGroup__WEBPACK_IMPORTED_MODULE_1__["default"]);


MarkupCallout.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupCircle.js":
/*!***********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupCircle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupCircle)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupScalableShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupScalableShape */ "./extensions/BimMarkups/MarkupTypes/MarkupScalableShape.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupCircle = /*#__PURE__*/function (_MarkupScalableShape) {_inherits(MarkupCircle, _MarkupScalableShape);var _super = _createSuper(MarkupCircle);
  function MarkupCircle(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupCircle);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CIRCLE, state, options);
  }_createClass(MarkupCircle, [{ key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }, { key: "needsMiter", value: function needsMiter()

    {
      return false;
    } }]);return MarkupCircle;}(_MarkupScalableShape__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupCloud.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupCloud.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupCloud)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupCloud = /*#__PURE__*/function (_Markup) {_inherits(MarkupCloud, _Markup);var _super = _createSuper(MarkupCloud);
  function MarkupCloud(markupsExtension, id, state) {var _this;var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupCloud);
    _this = _super.call(this, markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CLOUD, state, options);

    _this.registerTranslationHandler();
    if (!options.rotationNotAllowed) {
      _this.registerRotationHandler();
    }
    _this.registerScaleHandler();return _this;
  }_createClass(MarkupCloud, [{ key: "createCloud", value: function createCloud()

    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }
      if (this.fillMesh) {
        this.meshContainer.remove(this.fillMesh);
        this.fillMesh = null;
      }

      // stroke mesh
      if (!this.strokeMaterial) {
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);
      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_1__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      // fill mesh
      if (this.hasFill() && !this.isPoint()) {
        this.createFillMesh();
      }

      this.meshContainer.add(this.strokeMesh);

      if (this.meshLine.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CIRCLE) {
        var width = this.editState.anchors[0].distanceTo(this.editState.anchors[1]);
        var height = this.editState.anchors[2].distanceTo(this.editState.anchors[1]);
        var minSize = this.markupsExtension.renderer.getNormaStrokeWidth();
        this.meshContainer.scale.x = Math.max(Math.abs(width * this.editState.scale.x), minSize) * Math.sign(this.editState.scale.x);
        this.meshContainer.scale.y = Math.max(Math.abs(height * this.editState.scale.y), minSize) * Math.sign(this.editState.scale.y);

        // Set the initial rotation to be according to camera rotation.
        if (this.isCompleted()) {
          this.setRotation();
        } else {
          this.meshContainer.rotation.z = -this.markupsExtension.renderer.getCameraRotation() * this.markupsExtension.renderer.getCameraEyeVector().z;
        }
      } else {
        this.meshContainer.scale.x = 1.0;
        this.meshContainer.scale.y = 1.0;
        this.setRotation();
      }

      this.setPosition();
    } }, { key: "createFillMesh", value: function createFillMesh()

    {var _this2 = this;
      var fill = this.markupsExtension.renderer.geometryManager.getFillGeometry(this);
      if (!fill.innerGeometry) {
        return;
      }
      if (!this.fillMaterial) {
        this.fillMaterial = this.materialManager.addMaterial(this, true);
      }

      this.fillMesh = _Markup__WEBPACK_IMPORTED_MODULE_1__["default"].createMesh(fill.innerGeometry, this.fillMaterial);
      this.meshContainer.add(this.fillMesh);

      if (fill.arcGeometry) {
        this.meshLine.arcs.forEach(function (arc) {
          var mesh = _Markup__WEBPACK_IMPORTED_MODULE_1__["default"].createMesh(fill.arcGeometry, _this2.fillMaterial);
          _this2.fillMesh.add(mesh);
          mesh.position.x = arc.x;
          mesh.position.y = arc.y;
        });
      }
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupCloud.prototype), "render", this).call(this);

      var anchors = changes.anchors;
      if (anchors && anchors.length > 1 || this.editState.anchors.length > 1 && changes.scale) {// Scale recreates the mesh as well
        this.createCloud();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var recreateCloud = this.hasThicknessChanged();

        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
        }

        if (this.hasFill()) {
          if (this.fillMesh) {
            var newFillMaterial = this.materialManager.editMaterial(this.fillMaterial, this, true);

            if (newFillMaterial) {
              this.fillMaterial = newFillMaterial;
              this.fillMesh.traverse(function (child) {return child.material = newFillMaterial;});
            }
          } else {
            recreateCloud = true;
          }
        } else {
          this.removeFill();
        }

        if (recreateCloud) {
          this.createCloud();
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      if (changes.rotation !== undefined) {
        this.setRotation();
      }

      this.markupsExtension.renderer.invalidate();
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }, { key: "needsMiter", value: function needsMiter()

    {
      return false;
    } }]);return MarkupCloud;}(_Markup__WEBPACK_IMPORTED_MODULE_1__["default"]);


MarkupCloud.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupDimension.js":
/*!**************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupDimension.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupDimension)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
/* harmony import */ var _MarkupText__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MarkupText */ "./extensions/BimMarkups/MarkupTypes/MarkupText.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var

MarkupDimension = /*#__PURE__*/function (_Markup) {_inherits(MarkupDimension, _Markup);var _super = _createSuper(MarkupDimension);
  function MarkupDimension(markupsExtension, id, state) {var _this;var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupDimension);
    _this = _super.call(this, markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_DIMENSION, state, options);

    if (_this.markupsExtension.viewer.impl.is2d) {
      _this.registerDimensionEditHandler();
    }

    _this.textMarkup = new _MarkupText__WEBPACK_IMPORTED_MODULE_4__["default"](markupsExtension, id);
    _this.textMarkup.editState.isFrameUsed = false;

    _this.registerTextInputHandler({ singleLine: true, onEmptyTextMarkup: _this.onEmptyTextMarkup.bind(_assertThisInitialized(_this)), submitChanges: _this.onSubmitChanges.bind(_assertThisInitialized(_this)) });

    _this.getTextStyle = _this.textMarkup.getTextStyle.bind(_this.textMarkup);

    var originalEditStart = _this.textInputHandler.editStart;
    _this.textInputHandler.editStart = function () {
      originalEditStart.bind(_this.textInputHandler)();
      _this.onTextMarkupEditStart();
    };

    var originalEditEnd = _this.textInputHandler.editEnd;
    _this.textInputHandler.editEnd = function () {
      originalEditEnd.bind(_this.textInputHandler)();
      _this.onTextMarkupEditEnd();
    };

    _this.textMarkup.textInputHandler = _this.textInputHandler;return _this;
  }_createClass(MarkupDimension, [{ key: "setVisible", value: function setVisible(

    isVisible, forceSet) {
      _get(_getPrototypeOf(MarkupDimension.prototype), "setVisible", this).call(this, isVisible, forceSet);

      this.textMarkup.setVisible(isVisible, forceSet);
    } }, { key: "setState", value: function setState(

    state) {
      _get(_getPrototypeOf(MarkupDimension.prototype), "setState", this).call(this, state);

      this.textMarkup.rotatedBoundingBox = null;
      this.textMarkup.boundingBox = null;
      this.textMarkup.resetFrameBoundingBox();
    } }, { key: "setEditState", value: function setEditState(

    editState, changes, source) {
      this.textMarkup.rotatedBoundingBox = null;
      this.textMarkup.boundingBox = null;
      this.textMarkup.resetFrameBoundingBox();

      _get(_getPrototypeOf(MarkupDimension.prototype), "setEditState", this).call(this, editState, changes, source);
    } }, { key: "createDimension", value: function createDimension()

    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }

      if (!this.strokeMaterial) {
        this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] *= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
        this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] /= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);

      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_3__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      this.meshContainer.add(this.strokeMesh);

      this.setPosition();
    } }, { key: "calculateWorldBoundingBox", value: function calculateWorldBoundingBox(

    rotate) {
      var boundingBox = _get(_getPrototypeOf(MarkupDimension.prototype), "calculateWorldBoundingBox", this).call(this, rotate);

      var textBoundingBox = this.textMarkup.calculateWorldBoundingBox(true);
      return boundingBox.union(textBoundingBox);
    } }, { key: "renderText", value: function renderText()

    {var _this$getEditState =
      this.getEditState(),anchors = _this$getEditState.anchors,text = _this$getEditState.text,style = _this$getEditState.style;
      var textStyle = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(style);
      textStyle[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE] *= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_FONT_SIZE_FACTOR;
      this.textMarkup.enabled = this.enabled;
      this.textMarkup.transparent = this.isTransparent();
      this.textMarkup.editState.style = textStyle;
      this.textMarkup.editState.text = text;
      this.textMarkup.editState.isSingleLine = true;

      var pos = anchors[0].clone().add(anchors[1]).multiplyScalar(0.5);
      this.applyScaleAndTranslation(pos);
      this.textMarkup.creationHandler.calculateAnchorsByCenterPoint(pos);

      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();

      // Modify markup's anchors, so the rotation won't affect the final result, except of the bounding box.
      var textAnchors = this.textMarkup.editState.anchors;
      textAnchors.forEach(function (anchor) {
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(anchor, cameraRotation, pos, eyeDirection);
      });

      var angle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].getSignedAngle(this.markupsExtension.renderer.getCameraRightVector(), anchors[1].clone().sub(anchors[0]), this.markupsExtension.renderer.getCameraEyeVector());
      // Text should always be readable - flip it if it's upside down.
      if (Math.abs(angle) > Math.PI / 2) {
        angle += Math.PI;
      }

      this.textMarkup.editState.rotation = angle - cameraRotation;

      var p1 = textAnchors[1].clone();
      var p2 = textAnchors[2].clone();

      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation([p1, p2], this.textMarkup.editState.rotation, pos, eyeDirection);

      var thickness = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;
      var tipLength = thickness * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_TIP_LENGTH;

      var dir = p2.clone().sub(p1);
      var textTranslation = dir.clone().normalize().multiplyScalar(tipLength).add(dir.multiplyScalar(0.5));

      textAnchors.forEach(function (anchor) {
        anchor.add(textTranslation);
      });

      this.textMarkup.render();
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupDimension.prototype), "render", this).call(this);var

      anchors = changes.anchors;

      if (anchors && anchors.length > 1) {
        this.createDimension();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] *= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;
        var recreateDimension = this.hasThicknessChanged();
        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);
        this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] /= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
          if (recreateDimension) {
            this.createDimension();
          }
        }
      }

      if (changes.translation) {
        this.createDimension(); // Due to change in translation, need to update dimension geometry too.
        this.setPosition();
      }

      this.renderText();

      this.markupsExtension.renderer.invalidate();
    } }, { key: "isTextMarkup", value: function isTextMarkup()

    {
      return true;
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }, { key: "onEmptyTextMarkup", value: function onEmptyTextMarkup()

    {
      this.markupsExtension.markupsManager.actionManager.undo();

      var text = this.creationHandler.getDistance();
      this.creationHandler.updateEditState({ text: text });
      this.creationHandler.submitChanges();
    } }, { key: "onSubmitChanges", value: function onSubmitChanges()

    {
      this.textInputHandler.submitChanges();
      this.hasChanges = true;
    } }, { key: "remove", value: function remove()

    {var doDispatchEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.textMarkup.remove(false);
      _get(_getPrototypeOf(MarkupDimension.prototype), "remove", this).call(this, doDispatchEvent);
    } }, { key: "onTextMarkupEditStart", value: function onTextMarkupEditStart()

    {var
      text = this.textMarkup.editState.text;

      if (text[0] === '(' && text[text.length - 1] === ')') {
        text = text.slice(1, text.length - 1);
      }

      this.hasChanges = false;

      this.creationHandler.updateEditState({ text: text });
    } }, { key: "onTextMarkupEditEnd", value: function onTextMarkupEditEnd()

    {var
      text = this.textMarkup.editState.text;

      if (text[0] === '(' && text[text.length - 1] === ')') {
        text = text.slice(1, text.length - 1);
      }
      if (text !== '') {
        if (this.hasChanges) {
          this.markupsExtension.markupsManager.actionManager.undo();

          this.creationHandler.updateEditState({ text: "(".concat(text, ")") });
          this.creationHandler.submitChanges();
        } else if (text !== this.creationHandler.getDistance()) {
          this.creationHandler.updateEditState({ text: "(".concat(text, ")") });
        }
      }
    } }]);return MarkupDimension;}(_Markup__WEBPACK_IMPORTED_MODULE_3__["default"]);


MarkupDimension.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupFreehand.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupFreehand.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupFreehand)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupPen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupPen */ "./extensions/BimMarkups/MarkupTypes/MarkupPen.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupFreehand = /*#__PURE__*/function (_MarkupPen) {_inherits(MarkupFreehand, _MarkupPen);var _super = _createSuper(MarkupFreehand);
  function MarkupFreehand(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupFreehand);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_FREEHAND, state, options);
  }return MarkupFreehand;}(_MarkupPen__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupGroup.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupGroup.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupGroup)
/* harmony export */ });
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
/* harmony import */ var _EditHandlers_TranslationHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EditHandlers/TranslationHandler */ "./extensions/BimMarkups/EditHandlers/TranslationHandler.js");
/* harmony import */ var _EditHandlers_ScaleHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditHandlers/ScaleHandler */ "./extensions/BimMarkups/EditHandlers/ScaleHandler.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

MarkupGroup = /*#__PURE__*/function (_Markup) {_inherits(MarkupGroup, _Markup);var _super = _createSuper(MarkupGroup);
  function MarkupGroup(markupsExtension, id, type, state, options) {_classCallCheck(this, MarkupGroup);return _super.call(this,
    markupsExtension, id, type, state, options);
  }_createClass(MarkupGroup, [{ key: "render", value: function render()

    {
      // Group is only a container markup - doesn't do any rendering itself
      var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;} }, { key: "intersect", value: function intersect(

    _point) {
      return false;
    } }, { key: "isGroupMarkup", value: function isGroupMarkup()

    {
      return true;
    } }, { key: "select", value: function select(

    selectedMarkup) {
      this.selected = true;
      this.enableEdit();

      if (selectedMarkup) {
        this.setLocked(true);
        this.markups.forEach(function (markup) {return markup !== selectedMarkup && !markup.isSelected() && markup.select();});
        this.setLocked(false);
      }

      this.setDirty();
    } }, { key: "setHover", value: function setHover(

    hover, hoveredMarkup) {
      if (this.hover === hover) return;

      this.hover = hover;

      if (hoveredMarkup) {
        this.setLocked(true);
        this.markups.forEach(function (markup) {return markup !== hoveredMarkup && markup.isHovered() !== hover && markup.setHover(hover);});
        this.setLocked(false);
      }

      this.setDirty();
    } }, { key: "calculateWorldBoundingBox", value: function calculateWorldBoundingBox()

    {
      var boundingBox = new THREE.Box3();

      this.markups.forEach(function (markup) {
        var bbox = markup.getWorldBoundingBox(true);
        boundingBox.union(bbox);
      });

      return boundingBox;
    } }, { key: "remove", value: function remove()

    {var doDispatchEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.markups.forEach(function (markup) {return markup.remove(doDispatchEvent);});

      _get(_getPrototypeOf(MarkupGroup.prototype), "remove", this).call(this, doDispatchEvent);
    } }, { key: "syncGroupMarkups", value: function syncGroupMarkups(

    sourceMarkup, prevState, newState, changes, source) {
      if (changes.anchors) {
        this.applyConstraints(sourceMarkup, prevState, newState);
      }

      // Translation constraints are only applied when it comes from a mouse movement in the translation handler
      // This allows creating specific interactions depending on which component of the group was moved
      if (changes.translation && source instanceof _EditHandlers_TranslationHandler__WEBPACK_IMPORTED_MODULE_1__["default"] && source.keyTranslation.length() === 0) {
        this.applyTranslation(sourceMarkup, prevState, newState);
      }

      if (changes.scale && source instanceof _EditHandlers_ScaleHandler__WEBPACK_IMPORTED_MODULE_2__["default"]) {
        this.applyScale(sourceMarkup, prevState, newState);
      }

      if (changes.style) {
        this.applyStyle(sourceMarkup, prevState, newState, changes);
      }

      if (changes.text) {
        this.applyTextChange(sourceMarkup, prevState, newState);
      }
    } }, { key: "applyConstraints", value: function applyConstraints(

    sourceMarkup, prevState, newState) {

    } }, { key: "applyTranslation", value: function applyTranslation(

    sourceMarkup, prevState, newState) {

    } }, { key: "applyStyle", value: function applyStyle(

    sourceMarkup, prevState, newState, changes) {

    } }, { key: "applyScale", value: function applyScale(

    sourceMarkup, prevState, newState) {

    } }, { key: "applyTextChange", value: function applyTextChange(

    sourceMarkup, prevState, newState) {

    } }]);return MarkupGroup;}(_Markup__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupHighlight.js":
/*!**************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupHighlight.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupHighlight)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupPen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupPen */ "./extensions/BimMarkups/MarkupTypes/MarkupPen.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupHighlight = /*#__PURE__*/function (_MarkupPen) {_inherits(MarkupHighlight, _MarkupPen);var _super = _createSuper(MarkupHighlight);
  function MarkupHighlight(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupHighlight);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_HIGHLIGHT, state, options);
  }_createClass(MarkupHighlight, [{ key: "getDefaultStyle", value: function getDefaultStyle()

    {
      var style = _get(_getPrototypeOf(MarkupHighlight.prototype), "getDefaultStyle", this).call(this);
      style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.OPACITY] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HIGHLIGHT_OPACITY;

      return style;
    } }]);return MarkupHighlight;}(_MarkupPen__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupLine.js":
/*!*********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupLine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupLine)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupLines__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupLines */ "./extensions/BimMarkups/MarkupTypes/MarkupLines.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupLine = /*#__PURE__*/function (_MarkupLines) {_inherits(MarkupLine, _MarkupLines);var _super = _createSuper(MarkupLine);
  function MarkupLine(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupLine);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_LINE, state, options);
  }return MarkupLine;}(_MarkupLines__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupLines.js":
/*!**********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupLines.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupLines)
/* harmony export */ });
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

MarkupLines = /*#__PURE__*/function (_Markup) {_inherits(MarkupLines, _Markup);var _super = _createSuper(MarkupLines);
  function MarkupLines(markupsExtension, id, type, state) {var _this;var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, MarkupLines);
    _this = _super.call(this, markupsExtension, id, type, state, options);

    _this.registerTranslationHandler();
    _this.registerAnchorHandler();return _this;
  }_createClass(MarkupLines, [{ key: "createLine", value: function createLine()


    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }

      if (!this.strokeMaterial) {
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);

      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_0__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      this.setPosition();

      this.meshContainer.add(this.strokeMesh);
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupLines.prototype), "render", this).call(this);

      var anchors = changes.anchors;
      if (anchors && anchors.length > 1) {
        this.createLine();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var recreateLines = this.hasThicknessChanged();

        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
          if (recreateLines) {
            this.createLine();
          }
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      this.markupsExtension.renderer.invalidate();
    } }]);return MarkupLines;}(_Markup__WEBPACK_IMPORTED_MODULE_0__["default"]);


MarkupLines.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupPen.js":
/*!********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupPen.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupPen)
/* harmony export */ });
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

MarkupPen = /*#__PURE__*/function (_Markup) {_inherits(MarkupPen, _Markup);var _super = _createSuper(MarkupPen);
  function MarkupPen(markupsExtension, id, type, state) {var _this;var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, MarkupPen);
    _this = _super.call(this, markupsExtension, id, type, state, options);

    _this.registerTranslationHandler();
    _this.registerRotationHandler();
    _this.registerScaleHandler();return _this;
  }_createClass(MarkupPen, [{ key: "selectWhenCompleted", value: function selectWhenCompleted()

    {
      return false;
    } }, { key: "needsMiter", value: function needsMiter()

    {
      return true;
    } }, { key: "createPen", value: function createPen()

    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }

      if (!this.strokeMaterial) {
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);

      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_0__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      this.meshContainer.add(this.strokeMesh);

      this.setPosition();
      this.setRotation();
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupPen.prototype), "render", this).call(this);

      var anchors = changes.anchors;
      if (anchors && anchors.length > 0 || this.editState.anchors.length > 0 && changes.scale) {// Scale recreates the mesh as well
        this.createPen();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      if (changes.rotation !== undefined) {
        this.setRotation();
      }

      this.markupsExtension.renderer.invalidate();
    } }]);return MarkupPen;}(_Markup__WEBPACK_IMPORTED_MODULE_0__["default"]);


MarkupPen.singleClickMarkup = true;
MarkupPen.useTimerBeforeSelection = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupPolycloud.js":
/*!**************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupPolycloud.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupPolycloud)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

MarkupPolycloud = /*#__PURE__*/function (_Markup) {_inherits(MarkupPolycloud, _Markup);var _super = _createSuper(MarkupPolycloud);
  function MarkupPolycloud(markupsExtension, id, state) {var _this;var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupPolycloud);
    _this = _super.call(this, markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYCLOUD, state, options);

    _this.registerTranslationHandler();
    _this.registerAnchorHandler();
    _this.registerRotationHandler();
    _this.registerScaleHandler();return _this;
  }_createClass(MarkupPolycloud, [{ key: "getDefaultState", value: function getDefaultState()

    {
      return {
        closed: false };

    } }, { key: "needsMiter", value: function needsMiter()

    {
      return false;
    } }, { key: "createCloud", value: function createCloud()

    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }
      if (this.fillMesh) {
        this.meshContainer.remove(this.fillMesh);
        this.fillMesh = null;
      }

      // stroke mesh
      if (!this.strokeMaterial) {
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);
      if (this.meshLine.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CIRCLE) {
        var minSize = this.markupsExtension.renderer.getNormaStrokeWidth();
        this.meshContainer.scale.x = minSize;
        this.meshContainer.scale.y = minSize;
      } else {
        this.meshContainer.scale.x = 1.0;
        this.meshContainer.scale.y = 1.0;
      }

      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      if (this.hasFill() && !this.isPoint() && (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isPolygonSimple)(this.editState.anchors)) {
        this.createFillMesh();
      }
      this.meshContainer.add(this.strokeMesh);

      this.setPosition();
      this.setRotation();
    } }, { key: "createFillMesh", value: function createFillMesh()

    {var _this2 = this;
      var fill = this.markupsExtension.renderer.geometryManager.getFillGeometry(this);
      if (!fill.innerGeometry) {
        return;
      }

      if (!this.fillMaterial) {
        this.fillMaterial = this.materialManager.addMaterial(this, true);
      }

      this.fillMesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(fill.innerGeometry, this.fillMaterial);
      this.meshContainer.add(this.fillMesh);

      if (fill.arcGeometry) {
        this.meshLine.arcs.forEach(function (arc) {
          var mesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(fill.arcGeometry, _this2.fillMaterial);
          _this2.fillMesh.add(mesh);
          mesh.position.x = arc.x;
          mesh.position.y = arc.y;
        });
      }

      if (fill.fillGapGeometries) {
        fill.fillGapGeometries.forEach(function (shape) {
          var mesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(shape, _this2.fillMaterial);
          _this2.fillMesh.add(mesh);
        });
      }
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupPolycloud.prototype), "render", this).call(this);

      var anchors = changes.anchors;
      if (anchors && anchors.length > 0 || this.editState.anchors.length > 0 && changes.scale) {// Scale recreates the mesh as well
        this.createCloud();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var recreateCloud = this.hasThicknessChanged();

        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
        }

        if (this.hasFill()) {
          if (this.fillMesh) {
            var newFillMaterial = this.materialManager.editMaterial(this.fillMaterial, this, true);

            if (newFillMaterial) {
              this.fillMaterial = newFillMaterial;
              this.fillMesh.traverse(function (child) {return child.material = newFillMaterial;});
            }
          } else {
            recreateCloud = true; // To trigger re-creation
          }
        } else {
          this.removeFill();
        }

        if (recreateCloud) {
          this.createCloud();
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      if (changes.rotation !== undefined) {
        this.setRotation();
      }

      this.markupsExtension.renderer.invalidate();
    } }, { key: "showPath", value: function showPath()

    {
      return true;
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return this.editState.closed;
    } }]);return MarkupPolycloud;}(_Markup__WEBPACK_IMPORTED_MODULE_2__["default"]);


MarkupPolycloud.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupPolyline.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupPolyline.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupPolyline)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var

MarkupPolyline = /*#__PURE__*/function (_Markup) {_inherits(MarkupPolyline, _Markup);var _super = _createSuper(MarkupPolyline);
  function MarkupPolyline(markupsExtension, id, state) {var _this;var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupPolyline);
    _this = _super.call(this, markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYLINE, state, options);

    _this.registerTranslationHandler();
    _this.registerAnchorHandler();
    _this.registerRotationHandler();
    _this.registerScaleHandler();return _this;
  }_createClass(MarkupPolyline, [{ key: "getDefaultState", value: function getDefaultState()

    {
      return {
        closed: false };

    } }, { key: "createPolyline", value: function createPolyline()

    {
      if (this.strokeMesh) {
        this.meshContainer.remove(this.strokeMesh);
      }
      if (this.fillMesh) {
        this.meshContainer.remove(this.fillMesh);
        this.fillMesh = null;
      }

      // stroke mesh
      if (!this.strokeMaterial) {
        this.strokeMaterial = this.materialManager.addMaterial(this, false);
      }

      this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);
      this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

      // fill mesh
      if (this.hasFill() && !this.isPoint() && (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.isPolygonSimple)(this.editState.anchors)) {
        if (!this.fillMaterial) {
          this.fillMaterial = this.materialManager.addMaterial(this, true);
        }

        var fillGeometry = this.markupsExtension.renderer.geometryManager.getFillGeometry(this);
        if (fillGeometry) {
          this.fillMesh = _Markup__WEBPACK_IMPORTED_MODULE_2__["default"].createMesh(fillGeometry, this.fillMaterial);
          this.meshContainer.add(this.fillMesh);
        }
      }

      this.meshContainer.add(this.strokeMesh);

      this.setPosition();
      this.setRotation();
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupPolyline.prototype), "render", this).call(this);


      var anchors = changes.anchors;
      if (anchors && anchors.length > 0 || this.editState.anchors.length > 0 && changes.scale) {// Scale recreates the mesh as well
        this.createPolyline();
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
        }

        var recreate = false;
        if (this.hasFill()) {
          if (this.fillMesh) {
            var newFillMaterial = this.materialManager.editMaterial(this.fillMaterial, this, true);

            if (newFillMaterial) {
              this.fillMaterial = newFillMaterial;
              this.fillMesh.material = newFillMaterial;
            }
          } else {
            recreate = true; // To trigger re-creation
          }
        } else {
          this.removeFill();
        }

        if (recreate) {
          this.createPolyline();
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      if (changes.rotation !== undefined) {
        this.setRotation();
      }

      this.markupsExtension.renderer.invalidate();
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return this.editState.closed;
    } }, { key: "showPath", value: function showPath()

    {
      return true;
    } }]);return MarkupPolyline;}(_Markup__WEBPACK_IMPORTED_MODULE_2__["default"]);


MarkupPolyline.withSnappingMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupRectangle.js":
/*!**************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupRectangle.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupRectangle)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupScalableShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupScalableShape */ "./extensions/BimMarkups/MarkupTypes/MarkupScalableShape.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupRectangle = /*#__PURE__*/function (_MarkupScalableShape) {_inherits(MarkupRectangle, _MarkupScalableShape);var _super = _createSuper(MarkupRectangle);
  function MarkupRectangle(markupsExtension, id, state) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupRectangle);return _super.call(this,
    markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_RECTANGLE, state, options);
  }_createClass(MarkupRectangle, [{ key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }]);return MarkupRectangle;}(_MarkupScalableShape__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupScalableShape.js":
/*!******************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupScalableShape.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupScalableShape)
/* harmony export */ });
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var

MarkupScalableShape = /*#__PURE__*/function (_Markup) {_inherits(MarkupScalableShape, _Markup);var _super = _createSuper(MarkupScalableShape);
  function MarkupScalableShape(markupsExtension, id, type, state) {var _this;var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, MarkupScalableShape);
    _this = _super.call(this, markupsExtension, id, type, state, options);

    _this.width = 0;
    _this.height = 0;

    _this.registerTranslationHandler();
    _this.registerRotationHandler();
    _this.registerScaleHandler();return _this;
  }_createClass(MarkupScalableShape, [{ key: "setSize", value: function setSize()

    {
      var minSize = this.markupsExtension.renderer.getNormaStrokeWidth();
      this.meshContainer.scale.x = Math.max(Math.abs(this.width * this.editState.scale.x), minSize) * Math.sign(this.editState.scale.x);
      this.meshContainer.scale.y = Math.max(Math.abs(this.height * this.editState.scale.y), minSize) * Math.sign(this.editState.scale.y);
    } }, { key: "createShape", value: function createShape(

    anchors) {
      if (!this.strokeMesh) {
        if (!this.strokeMaterial) {
          this.strokeMaterial = this.materialManager.addMaterial(this, false);
        }

        // stroke mesh
        this.meshLine = this.markupsExtension.renderer.geometryManager.getStrokeGeometry(this);
        this.strokeMesh = _Markup__WEBPACK_IMPORTED_MODULE_0__["default"].createMesh(this.meshLine.geometry, this.strokeMaterial);

        this.meshContainer.add(this.strokeMesh);

        // Set the initial rotation to be according to camera rotation.
        this.meshContainer.rotation.z = -this.markupsExtension.renderer.getCameraRotation() * this.markupsExtension.renderer.getCameraEyeVector().z;
      }

      if (!this.fillMesh && this.hasFill()) {
        this.createFill();
      }

      this.width = anchors[0].distanceTo(anchors[1]);
      this.height = anchors[2].distanceTo(anchors[1]);

      this.setPosition();
      this.setSize();
    } }, { key: "createFill", value: function createFill()

    {
      this.fillGeometry = this.markupsExtension.renderer.geometryManager.getFillGeometry(this);

      if (this.fillGeometry) {
        if (!this.fillMaterial) {
          this.fillMaterial = this.materialManager.addMaterial(this, true);
        }

        this.fillMesh = _Markup__WEBPACK_IMPORTED_MODULE_0__["default"].createMesh(this.fillGeometry, this.fillMaterial);

        // Make sure fill is first in order
        this.meshContainer.add(this.fillMesh);
        this.meshContainer.add(this.strokeMesh);
      }
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      _get(_getPrototypeOf(MarkupScalableShape.prototype), "render", this).call(this);

      var anchors = changes.anchors;
      if (anchors && anchors.length > 1) {
        this.createShape(anchors);
      }

      if (!this.strokeMesh) {
        return;
      }

      if (changes.style) {
        var newStrokeMaterial = this.materialManager.editMaterial(this.strokeMaterial, this, false);

        if (newStrokeMaterial) {
          this.strokeMaterial = newStrokeMaterial;
          this.strokeMesh.material = newStrokeMaterial;
        }

        if (this.hasFill()) {
          if (this.fillMesh) {
            var newFillMaterial = this.materialManager.editMaterial(this.fillMaterial, this, true);

            if (newFillMaterial) {
              this.fillMaterial = newFillMaterial;
              this.fillMesh.material = newFillMaterial;
            }
          } else {
            this.createFill();
          }
        } else {
          this.removeFill();
        }
      }

      if (changes.translation) {
        this.setPosition();
      }

      if (changes.rotation !== undefined) {
        this.setRotation();
      }

      if (changes.scale) {
        this.setSize();
      }

      this.markupsExtension.renderer.invalidate();
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }]);return MarkupScalableShape;}(_Markup__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupText.js":
/*!*********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupText.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupText)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _Markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MarkupsTypesDictionary */ "./extensions/BimMarkups/MarkupTypes/MarkupsTypesDictionary.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var

MarkupText = /*#__PURE__*/function (_Markup) {_inherits(MarkupText, _Markup);var _super = _createSuper(MarkupText);
  function MarkupText(markupsExtension, id, state) {var _this;var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};_classCallCheck(this, MarkupText);
    _this = _super.call(this, markupsExtension, id, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CALLOUT, state, options);

    _this.registerTranslationHandler();
    _this.registerScaleHandler({ onlyHorizontal: true });
    _this.registerTextInputHandler();
    if (!options.rotationNotAllowed) {
      _this.registerRotationHandler();
    }return _this;
  }_createClass(MarkupText, [{ key: "getDefaultState", value: function getDefaultState()

    {
      return {
        text: 'Default Text',
        isFrameUsed: true,
        frameType: this.options.frameType ? this.options.frameType : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE };

    } }, { key: "shouldRenderFrame", value: function shouldRenderFrame()

    {
      return this.editState.isFrameUsed || this.hasFill();
    } }, { key: "setVisible", value: function setVisible(

    isVisible, forceSet) {
      _get(_getPrototypeOf(MarkupText.prototype), "setVisible", this).call(this, isVisible, forceSet);

      if (this.frameMarkup) {
        this.frameMarkup.setVisible(isVisible, forceSet);
      } else if (this.shouldRenderFrame() && isVisible) {
        this.renderFrame();
      }
    } }, { key: "render", value: function render()

    {var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editState;
      this.markupsExtension.renderer.textRenderer.renderMarkup(this);
      if (this.shouldRenderFrame()) {
        this.renderFrame();
      } else {
        this.removeFrame();

        // Since there is no geometry changes in this case, we need to trigger the bounding box rendering using setDirty.
        this.setDirty();
      }
    } }, { key: "renderFrame", value: function renderFrame()

    {
      if (!this.frameMarkup) {
        this.frameMarkup = new _MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_5__.markupsTypesDictionary[this.editState.frameType](this.markupsExtension, this.id);
        this.frameMarkup.layer = this.layer;
        this.frameMarkup.transparent = this.isTransparent();
        this.frameMarkup.editState.anchors = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
      }

      var state = this.frameMarkup.editState;
      // Copy style
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS];
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY];
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR];
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY];

      if (!this.editState.isFrameUsed) {
        state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR];
        state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY];
      } else {
        state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR] = this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR];
        state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY] = 1.0;
      }


      // Set anchors
      var bbox = this.getWorldBoundingBox();
      var t = state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] / 2;
      this.frameMarkup.editState.anchors[0].set(bbox.min.x + t, bbox.min.y + t, 0);
      this.frameMarkup.editState.anchors[1].set(bbox.max.x - t, bbox.min.y + t, 0);
      this.frameMarkup.editState.anchors[2].set(bbox.max.x - t, bbox.max.y - t, 0);
      this.frameMarkup.editState.anchors[3].set(bbox.min.x + t, bbox.max.y - t, 0);

      // Copy rotation (translate and scale not needed since they are already included in the bounding box)
      state.rotation = this.editState.rotation;

      this.frameMarkup.updateMatrix();

      this.frameMarkup.render();
    } }, { key: "removeFrame", value: function removeFrame()

    {
      if (this.frameMarkup) {
        this.frameMarkup.remove(false);
        this.frameMarkup = null;
      }
    } }, { key: "remove", value: function remove()

    {var doDispatchEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.removeFrame();
      _get(_getPrototypeOf(MarkupText.prototype), "remove", this).call(this, doDispatchEvent);
    } }, { key: "changeTransparency", value: function changeTransparency(

    transparent) {
      if (this.frameMarkup) {
        this.frameMarkup.transparent = transparent;
      }
      _get(_getPrototypeOf(MarkupText.prototype), "changeTransparency", this).call(this, transparent);
    } }, { key: "resetFrameBoundingBox", value: function resetFrameBoundingBox()

    {
      if (this.frameMarkup) {
        this.frameMarkup.rotatedBoundingBox = null;
        this.frameMarkup.boundingBox = null;
      }
    } }, { key: "setState", value: function setState(

    state) {
      this.resetFrameBoundingBox();

      _get(_getPrototypeOf(MarkupText.prototype), "setState", this).call(this, state);
    } }, { key: "setEditState", value: function setEditState(

    editState, changes, source) {
      if (changes && changes.style) {
        var newState = Object.assign({}, editState, changes);
        // When changing font-size, we want it to grow down, instead of from the middle.
        var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion
        var _this$getTextWidthInF = this.getTextWidthInFontScale(),width = _this$getTextWidthInF.width;

        var oldStyle = this.getTextStyle(this.editState);
        var newStyle = this.getTextStyle(newState);
        oldStyle.width = "".concat(width, "px");
        newStyle.width = "".concat(width, "px");
        var oldSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getTextSize)(this.editState.text, oldStyle);
        var newSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getTextSize)(newState.text, newStyle);

        if (newSize.height !== oldSize.height) {
          var offsetWorld = (newSize.height - oldSize.height) * fontToWorldScale;
          var delta = this.getBoundingBoxVerticalTranslation(offsetWorld);

          if (this.shouldRenderFrame()) {
            var oldFrameSize = this.calculateFrameSize(this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE]);
            var newFrameSize = this.calculateFrameSize(newState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE]);
            var deltaFrameSize = newFrameSize - oldFrameSize;
            var deltaFrameVec = new THREE.Vector3(deltaFrameSize, -deltaFrameSize, 0);

            this._rotateTranslationVector(deltaFrameVec);
            delta.add(deltaFrameVec);
          }

          if (!changes.translation) {var _this$getEditState =
            this.getEditState(),translation = _this$getEditState.translation;
            translation.add(delta);
            changes.translation = translation;
          } else {
            changes.translation.add(delta);
          }
        }

        changes.isFrameUsed = newState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR] !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.COLORS.NO_COLOR;
      }

      this.resetFrameBoundingBox();

      _get(_getPrototypeOf(MarkupText.prototype), "setEditState", this).call(this, editState, changes, source);
    } }, { key: "getTextWidthInFontScale", value: function getTextWidthInFontScale()

    {
      var isSafari = Autodesk.Viewing.isSafari() || Autodesk.Viewing.isIOSDevice();

      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion
      var preciseWidth = this.getWorldBoundingBoxTextOnly().getSize(new THREE.Vector3()).x / fontToWorldScale;
      var width = isSafari ? preciseWidth : Math.ceil(preciseWidth) || 1; // Safari doesn't need rounded width

      return { preciseWidth: preciseWidth, width: width };
    } }, { key: "getBoundingBoxVerticalTranslation", value: function getBoundingBoxVerticalTranslation(

    offsetWorld) {
      var delta = new THREE.Vector3(0, -offsetWorld / 2, 0);

      this._rotateTranslationVector(delta);

      return delta;
    } }, { key: "_rotateTranslationVector", value: function _rotateTranslationVector(

    vec) {
      var rotation = this.getRotation();
      if (rotation !== 0) {
        var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(vec, rotation, new THREE.Vector3(), eyeDirection);
      }
    } }, { key: "_rotateBoundingBox", value: function _rotateBoundingBox(

    boundingBox) {
      var rotation = this.getRotation();
      if (rotation === 0) {
        return boundingBox;
      }

      var center = boundingBox.getCenter(new THREE.Vector3());
      var size = boundingBox.getSize(new THREE.Vector3());
      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var rotatedBoundingBox = new THREE.Box3();
      var points = [boundingBox.min, boundingBox.min.clone().add(new THREE.Vector3(size.x, 0, 0)), boundingBox.max, boundingBox.min.clone().add(new THREE.Vector3(0, size.y, 0))];
      points.forEach(function (point) {
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(point, rotation, center, eyeDirection);
        rotatedBoundingBox.expandByPoint(point);
      });

      return rotatedBoundingBox;
    } }, { key: "_calculateWorldBoundingBoxText", value: function _calculateWorldBoundingBoxText()

    {var _this2 = this;
      var boundingBox = new THREE.Box3();
      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(this.editState.anchors);

      anchors.forEach(function (anchor) {
        _this2.applyScaleAndTranslation(anchor);
      });

      anchors.forEach(function (anchor) {
        boundingBox.expandByPoint(anchor);
      });

      // Now, make some text adjustments, so the bounding box will fit exactly to the text.
      var center = boundingBox.getCenter(new THREE.Vector3());
      var style = this.getTextStyle();
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion

      // If the width of the bounding box is smaller than a single letter width, change the bounding box width to be in the size of a single letter.
      var textBounds = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getTextSize)('A', style);
      if (boundingBox.getSize(new THREE.Vector3()).x < textBounds.width * fontToWorldScale) {
        boundingBox.min.x = center.x;
        boundingBox.max.x = center.x;
        boundingBox.expandByVector(new THREE.Vector3(textBounds.width * fontToWorldScale / 2, 0, 0));
      }

      var unscaledWidth = Math.ceil(boundingBox.getSize(new THREE.Vector3()).x / fontToWorldScale);
      style.width = "".concat(unscaledWidth, "px");

      // Set the height of the bounding box according to the text measurement.
      textBounds = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getTextSize)(this.editState.text, style);
      boundingBox.min.y = center.y;
      boundingBox.max.y = center.y;
      boundingBox.expandByVector(new THREE.Vector3(0, textBounds.height * fontToWorldScale / 2, 0));

      return boundingBox;
    } }, { key: "calculateWorldBoundingBox", value: function calculateWorldBoundingBox(

    rotate) {
      var boundingBox = this._calculateWorldBoundingBoxText();

      if (this.shouldRenderFrame()) {
        var frameSize = this.getWorldFrameSize();
        boundingBox.expandByVector(new THREE.Vector3(frameSize, frameSize, 0));
      }

      if (rotate) {
        return this._rotateBoundingBox(boundingBox);
      }

      return boundingBox;
    } }, { key: "calculateFrameSize", value: function calculateFrameSize(

    fontSize) {var thickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS];
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion
      var padding = fontSize * fontToWorldScale / 2;

      if (!this.editState.isFrameUsed) {
        thickness = 0;
      } else {
        if (this.editState.frameType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD) {
          thickness += this.markupsExtension.renderer.geometryManager.getCloudMinimumRadius(thickness) / 2;
        }
      }

      return padding + thickness;
    } }, { key: "getWorldFrameSize", value: function getWorldFrameSize()

    {
      return this.calculateFrameSize(this.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE]);
    } }, { key: "getClientFrameSize", value: function getClientFrameSize()

    {
      var frameSize = this.getWorldFrameSize();

      return this.markupsExtension.renderer.sizeFromWorldToClient(frameSize);
    } }, { key: "getWorldBoundingBoxTextOnly", value: function getWorldBoundingBoxTextOnly(

    rotate) {
      if (!this.shouldRenderFrame()) {
        return this.getWorldBoundingBox(rotate).clone();
      }

      var boundingBox = this.getWorldBoundingBox(false).clone();

      var frameSize = this.getWorldFrameSize();
      boundingBox.expandByVector(new THREE.Vector3(-frameSize, -frameSize, 0));

      if (rotate) {
        return this._rotateBoundingBox(boundingBox);
      }

      return boundingBox;
    } }, { key: "getClientBoundingBoxTextOnly", value: function getClientBoundingBoxTextOnly(

    rotate) {var normalizeY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var boundingBox = this.getWorldBoundingBoxTextOnly(rotate);

      boundingBox.min = this.markupsExtension.renderer.worldToClient(boundingBox.min);
      boundingBox.max = this.markupsExtension.renderer.worldToClient(boundingBox.max);

      if (normalizeY) {
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(boundingBox);
      }

      return boundingBox;
    } }, { key: "getTextStyle", value: function getTextStyle()

    {var editState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getEditState();var
      style = editState.style;

      var textStyle = {};
      textStyle.color = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR];
      textStyle.fontFamily = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_FAMILY];
      textStyle.opacity = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY] * (this.isTransparent() ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DISABLED_OPACITY : 1.0);
      textStyle.fontSize = "".concat(style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE], "px");
      textStyle.fontWeight = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_WEIGHT];
      textStyle.fontStyle = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_STYLE];
      textStyle.whiteSpace = editState.isSingleLine ? 'nowrap' : 'pre-wrap';
      textStyle.lineHeight = 1;
      textStyle.backgroundColor = null;

      return textStyle;
    }

    // Returns minimum size in client coordinates
  }, { key: "getMinimumSize", value: function getMinimumSize() {
      var minSize = _get(_getPrototypeOf(MarkupText.prototype), "getMinimumSize", this).call(this);

      var style = this.getTextStyle();
      // If the width of the bounding box is smaller than a single letter width, change the bounding box width to be in the size of a single letter.
      var textBounds = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getTextSize)('A', style);
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale(); // Font to World conversion

      return Math.max(this.markupsExtension.renderer.sizeFromWorldToClient(textBounds.width * fontToWorldScale + 2 * this.getWorldFrameSize()), minSize);
    } }, { key: "isTextMarkup", value: function isTextMarkup()

    {
      return true;
    } }, { key: "isGeometricMarkup", value: function isGeometricMarkup()

    {
      return false;
    } }, { key: "isWithFillMarkup", value: function isWithFillMarkup()

    {
      return true;
    } }, { key: "getStartPointForNextMarkup", value: function getStartPointForNextMarkup()

    {
      return this.getWorldBoundingBox().getCenter(new THREE.Vector3());
    } }]);return MarkupText;}(_Markup__WEBPACK_IMPORTED_MODULE_3__["default"]);


MarkupText.singleClickMarkup = true;

/***/ }),

/***/ "./extensions/BimMarkups/MarkupTypes/MarkupsTypesDictionary.js":
/*!*********************************************************************!*\
  !*** ./extensions/BimMarkups/MarkupTypes/MarkupsTypesDictionary.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "markupsTypesDictionary": () => (/* binding */ markupsTypesDictionary)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupArrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupArrow */ "./extensions/BimMarkups/MarkupTypes/MarkupArrow.js");
/* harmony import */ var _MarkupPolyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupPolyline */ "./extensions/BimMarkups/MarkupTypes/MarkupPolyline.js");
/* harmony import */ var _MarkupPolycloud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupPolycloud */ "./extensions/BimMarkups/MarkupTypes/MarkupPolycloud.js");
/* harmony import */ var _MarkupRectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MarkupRectangle */ "./extensions/BimMarkups/MarkupTypes/MarkupRectangle.js");
/* harmony import */ var _MarkupCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MarkupCircle */ "./extensions/BimMarkups/MarkupTypes/MarkupCircle.js");
/* harmony import */ var _MarkupCloud__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MarkupCloud */ "./extensions/BimMarkups/MarkupTypes/MarkupCloud.js");
/* harmony import */ var _MarkupFreehand__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MarkupFreehand */ "./extensions/BimMarkups/MarkupTypes/MarkupFreehand.js");
/* harmony import */ var _MarkupHighlight__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MarkupHighlight */ "./extensions/BimMarkups/MarkupTypes/MarkupHighlight.js");
/* harmony import */ var _MarkupText__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MarkupText */ "./extensions/BimMarkups/MarkupTypes/MarkupText.js");
/* harmony import */ var _MarkupDimension__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MarkupDimension */ "./extensions/BimMarkups/MarkupTypes/MarkupDimension.js");
/* harmony import */ var _MarkupLine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MarkupLine */ "./extensions/BimMarkups/MarkupTypes/MarkupLine.js");
/* harmony import */ var _MarkupArrowCallout__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./MarkupArrowCallout */ "./extensions/BimMarkups/MarkupTypes/MarkupArrowCallout.js");
/* harmony import */ var _MarkupArrowCloudCallout__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MarkupArrowCloudCallout */ "./extensions/BimMarkups/MarkupTypes/MarkupArrowCloudCallout.js");
var _markupsTypesDictiona;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}














var markupsTypesDictionary = (_markupsTypesDictiona = {}, _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW, _MarkupArrow__WEBPACK_IMPORTED_MODULE_1__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYLINE, _MarkupPolyline__WEBPACK_IMPORTED_MODULE_2__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_POLYCLOUD, _MarkupPolycloud__WEBPACK_IMPORTED_MODULE_3__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_RECTANGLE, _MarkupRectangle__WEBPACK_IMPORTED_MODULE_4__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CIRCLE, _MarkupCircle__WEBPACK_IMPORTED_MODULE_5__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CLOUD, _MarkupCloud__WEBPACK_IMPORTED_MODULE_6__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_FREEHAND, _MarkupFreehand__WEBPACK_IMPORTED_MODULE_7__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_HIGHLIGHT, _MarkupHighlight__WEBPACK_IMPORTED_MODULE_8__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CALLOUT, _MarkupArrowCallout__WEBPACK_IMPORTED_MODULE_12__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_ARROW_CLOUD_CALLOUT, _MarkupArrowCloudCallout__WEBPACK_IMPORTED_MODULE_13__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_CALLOUT, _MarkupText__WEBPACK_IMPORTED_MODULE_9__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_TEXT, _MarkupText__WEBPACK_IMPORTED_MODULE_9__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_DIMENSION, _MarkupDimension__WEBPACK_IMPORTED_MODULE_10__["default"]), _defineProperty(_markupsTypesDictiona,
_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_TYPE_LINE, _MarkupLine__WEBPACK_IMPORTED_MODULE_11__["default"]), _markupsTypesDictiona);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsCommon.js":
/*!************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsCommon.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forAll": () => (/* binding */ forAll),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "isEqualVectors": () => (/* binding */ isEqualVectors),
/* harmony export */   "getObjectAsList": () => (/* binding */ getObjectAsList),
/* harmony export */   "nearestPointInPointToLine": () => (/* binding */ nearestPointInPointToLine),
/* harmony export */   "applyTranslation": () => (/* binding */ applyTranslation),
/* harmony export */   "convertHexToRGBA": () => (/* binding */ convertHexToRGBA),
/* harmony export */   "getTextSize": () => (/* binding */ getTextSize),
/* harmony export */   "createArc": () => (/* binding */ createArc),
/* harmony export */   "createCloud": () => (/* binding */ createCloud),
/* harmony export */   "isClockwise": () => (/* binding */ isClockwise),
/* harmony export */   "isTrueValue": () => (/* binding */ isTrueValue),
/* harmony export */   "getArcAngleSize": () => (/* binding */ getArcAngleSize),
/* harmony export */   "insertInSortedArray": () => (/* binding */ insertInSortedArray),
/* harmony export */   "checkLineIntersection": () => (/* binding */ checkLineIntersection),
/* harmony export */   "handleIntersection": () => (/* binding */ handleIntersection),
/* harmony export */   "markupsOverlayRenderer": () => (/* binding */ markupsOverlayRenderer),
/* harmony export */   "getScreenShotOfMarkup": () => (/* binding */ getScreenShotOfMarkup),
/* harmony export */   "setCustomGestureValues": () => (/* binding */ setCustomGestureValues),
/* harmony export */   "restoreGestureValues": () => (/* binding */ restoreGestureValues),
/* harmony export */   "simplify": () => (/* binding */ simplify),
/* harmony export */   "isPolygonSimple": () => (/* binding */ isPolygonSimple),
/* harmony export */   "executeAfterTransitionEnded": () => (/* binding */ executeAfterTransitionEnded),
/* harmony export */   "isSheetNameEqual": () => (/* binding */ isSheetNameEqual)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");



var av = Autodesk.Viewing;

var forAll = function forAll(obj, func) {
  if (obj) {
    Object.keys(obj).forEach(function (key) {
      var m = obj[key];
      if (m) {
        func(m);
      }
    });
  }
};

// Converts a deep array to a flat array
var flatten = function flatten(list) {return list.reduce(function (a, b) {return a.concat(Array.isArray(b) ? flatten(b) : b);}, []);};

var isEqualVectors = function isEqualVectors(v1, v2, precision) {
  if (!v1 || !v2) {
    return false;
  }

  precision = precision || _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.EPSILON;

  if (v1.distanceTo(v2) <= precision) {
    return true;
  }
  return false;
};

// Converts the object into a flat list, keeping the same pointers for all items (shallow copy).
var getObjectAsList = function getObjectAsList(object) {
  var list = [];

  forAll(object, function (item) {
    if (Array.isArray(item)) {
      item.forEach(function (i) {
        list.push(i);
      });
    } else {
      list.push(item);
    }
  });

  return list;
};

var nearestPointInPointToLine = function nearestPointInPointToLine(point, lineStart, lineEnd) {
  var X0 = new THREE.Vector3();
  var X1 = new THREE.Vector3();
  var nearestPoint;
  var param;

  X0.subVectors(lineStart, point);
  X1.subVectors(lineEnd, lineStart);
  param = X0.dot(X1);
  X0.subVectors(lineEnd, lineStart);
  param = -param / X0.dot(X0);

  X0.subVectors(lineEnd, lineStart);
  X0.multiplyScalar(param);
  nearestPoint = X0.add(lineStart);

  return nearestPoint;
};

var applyTranslation = function applyTranslation(points, translation) {
  if (!(points instanceof Array)) {
    points = [points];
  }

  points.forEach(function (point) {
    point.x += translation.x;
    point.y += translation.y;
    point.z += translation.z;
  });
};

var convertHexToRGBA = function convertHexToRGBA(hex, opacity) {
  if (!hex || hex === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.COLORS.NO_COLOR || !opacity) {
    return null;
  }

  hex = hex.replace('#', '');
  var r = parseInt(hex.substring(0, 2), 16);
  var g = parseInt(hex.substring(2, 4), 16);
  var b = parseInt(hex.substring(4, 6), 16);
  return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
};

var getTextSize = function () {
  var _document = av.getGlobal().document;
  var measureDiv = _document.createElement('div');
  measureDiv.id = 'text-markup-measure-div';
  measureDiv.style.position = 'absolute';
  measureDiv.style.visibility = 'hidden';
  measureDiv.style.pointerEvents = 'none';
  measureDiv.style.textRendering = 'geometricPrecision';

  _document.body.appendChild(measureDiv);
  var cache = {};

  return function (text, style) {
    var hash = "".concat(text, "_").concat(style.fontWeight, "_").concat(style.fontSize, "_").concat(style.fontFamily, "_").concat(style.fontStyle, "_").concat(style.width);

    if (cache[hash]) {
      return cache[hash];
    }

    measureDiv.innerText = text;
    measureDiv.style.fontWeight = style.fontWeight;
    measureDiv.style.fontSize = style.fontSize;
    measureDiv.style.fontFamily = style.fontFamily;
    measureDiv.style.fontStyle = style.fontStyle;
    measureDiv.style.overflowWrap = style.overflowWrap || 'break-word';
    measureDiv.style.wordWrap = style.wordWrap || 'break-word'; //IE11 
    measureDiv.style.whiteSpace = style.whiteSpace || 'pre-wrap';
    measureDiv.style.width = style.width || (Autodesk.Viewing.isIE11 ? 'auto' : 'unset');
    measureDiv.style.lineHeight = style.lineHeight || 1;var _measureDiv$getBoundi =

    measureDiv.getBoundingClientRect(),width = _measureDiv$getBoundi.width,height = _measureDiv$getBoundi.height;

    cache[hash] = { width: width, height: height };

    return cache[hash];
  };
}();

var createArc = function createArc(x, y, radius, start, end, clockwise, steps, path) {var radiusInMM = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;var bbox = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
  if (!path)
  path = [];

  x = x || 0;
  y = y || 0;
  radius = radius || 0;
  start = start || 0;
  end = end || 0;

  var dist = Math.abs(start - end);
  if (dist > 2 * Math.PI) dist -= 2 * Math.PI;
  if (!clockwise && start > end)
  dist = 2 * Math.PI - dist;else
  if (clockwise && end > start)
  dist = 2 * Math.PI - dist;

  //approximate the # of steps using the cube root of the radius
  if (typeof steps !== 'number') {
    radiusInMM = radiusInMM || radius;
    steps = Math.max(6, 2 * Math.floor(6 * Math.pow(radiusInMM, 1 / 3) * (dist / Math.PI)));
  }

  //ensure we have at least 3 steps
  steps = Math.max(steps, 3);

  var f = dist / steps,
  t = start;

  //modify direction
  f *= clockwise ? -1 : 1;

  for (var i = 0; i < steps + 1; i++) {
    var nx = x + Math.cos(t) * radius;
    var ny = y + Math.sin(t) * radius;

    path.push({ x: nx, y: ny, z: 0 });

    if (bbox) {
      bbox.min.x = Math.min(bbox.min.x, nx);
      bbox.min.y = Math.min(bbox.min.y, ny);
      bbox.max.x = Math.max(bbox.max.x, nx);
      bbox.max.y = Math.max(bbox.max.y, ny);
    }

    t += f;
  }

  return path;
};

var _addFillingCircle = function _addFillingCircle(circles, radius, begin, end) {
  var beginPoint = new THREE.Vector2(circles[begin].x + Math.cos(circles[begin].end) * radius, circles[begin].y + Math.sin(circles[begin].end) * radius);
  var endPoint = new THREE.Vector2(circles[end].x + Math.cos(circles[end].begin) * radius, circles[end].y + Math.sin(circles[end].begin) * radius);

  var difVec = beginPoint.clone().sub(endPoint);

  var vecLength = difVec.length();

  var mid = beginPoint.clone().add(endPoint).divideScalar(2);

  difVec.normalize();
  var perpenLength = Math.sqrt(Math.max(0, radius * radius - vecLength / 2 * (vecLength / 2)));
  var perpenVec = new THREE.Vector2(difVec.y, -difVec.x);
  perpenVec.multiplyScalar(perpenLength);

  var newPoint = mid.clone().add(perpenVec);

  var beginAng = Math.atan2(beginPoint.y - newPoint.y, beginPoint.x - newPoint.x);
  var endAng = Math.atan2(endPoint.y - newPoint.y, endPoint.x - newPoint.x);

  var newCircle = {
    x: newPoint.x,
    y: newPoint.y,
    begin: beginAng,
    end: endAng };


  circles.splice(begin + 1, 0, newCircle);

  return { newCircle: newCircle, beginPoint: beginPoint, endPoint: endPoint };
};

var _hideIntersectionCircles = function _hideIntersectionCircles(circles, radius, intersectionObjects) {
  for (var t = 0; t < intersectionObjects.length; t++) {
    var begin = null;
    var end = 0;
    for (var k = 0; k < circles.length; k++) {
      if (circles[k]['isCurrentIntersection' + t]) {
        for (var j = 0; j < circles.length; j++) {
          if (circles[j]['isNextIntersection' + t]) {
            var dist = Math.sqrt((circles[k].x - circles[j].x) * (circles[k].x - circles[j].x) + (circles[k].y - circles[j].y) * (circles[k].y - circles[j].y));
            if (dist < 2 * radius) {
              circles[k].hide = true;
              if (begin === null) begin = k - 1;
              circles[j].hide = true;
              if (end < j + 1) end = j + 1;
            }
          }
        }
      }
    }
    intersectionObjects[t].begin = begin;
    intersectionObjects[t].end = end;
  }
};

var createCloud = function createCloud(poly, radius) {var isClosed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;var intersectionObjects = arguments.length > 3 ? arguments[3] : undefined;var overlap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4 / 5;var incise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 20;var stretch = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      Global intersection angles of two circles of the same radius
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
  function intersect(p, q, r) {
    var dx = q.x - p.x;
    var dy = q.y - p.y;

    var len = Math.sqrt(dx * dx + dy * dy);
    var a = 0.5 * len / r;

    if (a < -1) a = -1;
    if (a > 1) a = 1;

    var phi = Math.atan2(dy, dx);
    var gamma = Math.acos(a);

    return [phi - gamma, Math.PI + phi + gamma];
  }

  // Create a list of circles
  var circles = [];
  var delta = 2 * radius * overlap;
  var prev = isClosed ? poly[poly.length - 1] : poly[0];
  stretch = stretch || !isClosed;

  for (var i = isClosed ? 0 : 1; i < poly.length; i++) {
    var curr = poly[i];

    var dx = curr.x - prev.x;
    var dy = curr.y - prev.y;

    var len = Math.sqrt(dx * dx + dy * dy);

    dx /= len;
    dy /= len;

    var firstAngle = 0;
    var lastAngle = 0;
    if (!isClosed) {
      if (i === 1) {// Start point
        len -= radius;
        prev.x += dx * radius;
        prev.y += dy * radius;
        firstAngle = Math.atan2(dy, dx) + Math.PI;
      } else if (i === poly.length - 1) {// End point
        lastAngle = Math.atan2(dy, dx);
      }
    }

    var d = delta;

    if (stretch) {
      var n = len / delta + 0.5 | 0;

      if (n < 1) {
        n = 1;
      }

      d = len / n;
    }

    for (var a = 0; a + 0.1 * d < len; a += d) {
      circles.push({
        x: prev.x + a * dx,
        y: prev.y + a * dy,
        begin: firstAngle,
        end: lastAngle,
        isAnchor: a === 0 });


      for (var j = 0; j < intersectionObjects.length; j++) {
        circles[circles.length - 1]['isNextIntersection' + j] = curr['isNextIntersection' + j];
        circles[circles.length - 1]['isCurrentIntersection' + j] = curr['isCurrentIntersection' + j];
        if (curr['isNextIntersection' + j] && a === 0) {
          intersectionObjects[j].anchorPoint = circles[circles.length - 1];
        }
      }
    }

    prev = curr;
  }

  // Determine intersection angles of circles

  var inciseInRadians = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(incise);

  prev = circles[circles.length - 1];
  for (var _i = 0; _i < circles.length; _i++) {
    var _curr = circles[_i];
    var angle = intersect(prev, _curr, radius);

    if (isClosed || _i !== 0) {// For open clouds, first and last angles were calculated in previous loop
      prev.end = angle[0] + inciseInRadians;
      _curr.begin = angle[1];
    }

    prev = _curr;
  }

  // Hide all circles that appear between the intersection point and the intersection anchor.
  _hideIntersectionCircles(circles, radius, intersectionObjects);

  // In case there is an intersection and arcs are hidden, insert a new arc to fill the gap that was created
  for (var k = intersectionObjects.length - 1; k > -1; k--) {
    if (circles[intersectionObjects[k].begin] && circles[intersectionObjects[k].end]) {
      intersectionObjects[k].beginCircle = circles[intersectionObjects[k].begin];
      intersectionObjects[k].endCircle = circles[intersectionObjects[k].end];var _addFillingCircle2 =
      _addFillingCircle(circles, radius, intersectionObjects[k].begin, intersectionObjects[k].end),newCircle = _addFillingCircle2.newCircle,beginPoint = _addFillingCircle2.beginPoint,endPoint = _addFillingCircle2.endPoint;
      intersectionObjects[k].newCircle = newCircle;
      intersectionObjects[k].beginPoint = beginPoint;
      intersectionObjects[k].endPoint = endPoint;
    }
  }

  // Remove all hidden arcs
  circles = circles.filter(function (cir) {return !cir.hide;});

  return circles;
};

var isClockwise = function isClockwise(anchors, markup) {
  var sum = 0;
  for (var i = 0; i < anchors.length; i++) {
    var p1 = anchors[i];
    var p2 = anchors[(i + 1) % anchors.length];
    sum += (p2.x - p1.x) * (p2.y + p1.y);
  }
  return sum * markup.scaleMatrix.elements[0] * markup.scaleMatrix.elements[5] > 0;
};

var isTrueValue = function isTrueValue(value) {
  return value === 'true' || value === true || value === 1;
};

var locationInArray = function locationInArray(element, array, comparer) {
  if (array.length === 0) return -1;

  var start = 0;
  var end = array.length;
  var pivot = Math.floor(end / 2);

  while (end - start > 1) {
    var comp = comparer(array[pivot], element);
    if (comp === 0) return pivot;

    if (comp > 0) {
      end = pivot;
    } else {
      start = pivot;
    }

    pivot = Math.floor(start + (end - start) / 2);
  }

  return comparer(array[pivot], element) > 0 ? pivot - 1 : pivot;
};

var getArcAngleSize = function getArcAngleSize(arc, clockwise) {
  var dist = Math.abs(arc.begin - arc.end);
  if (dist > 2 * Math.PI) dist -= 2 * Math.PI;
  if (!clockwise && arc.begin > arc.end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && arc.end > arc.begin) {
    dist = 2 * Math.PI - dist;
  }
  return dist;
};

var insertInSortedArray = function insertInSortedArray(element, array, comparer) {
  array.splice(locationInArray(element, array, comparer) + 1, 0, element);
  return array;
};

// if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
var checkLineIntersection = function checkLineIntersection(line1Start, line1End, line2Start, line2End) {
  var result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false,
    onBothLines: false };

  var denominator = (line2End.y - line2Start.y) * (line1End.x - line1Start.x) - (line2End.x - line2Start.x) * (line1End.y - line1Start.y);

  if (denominator === 0) {
    return result;
  }

  var a = line1Start.y - line2Start.y;
  var b = line1Start.x - line2Start.x;
  var numerator1 = (line2End.x - line2Start.x) * a - (line2End.y - line2Start.y) * b;
  var numerator2 = (line1End.x - line1Start.x) * a - (line1End.y - line1Start.y) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;

  // if we cast these lines infinitely in both directions, they intersect here:
  result.x = line1Start.x + a * (line1End.x - line1Start.x);
  result.y = line1Start.y + a * (line1End.y - line1Start.y);

  // if line1 is a segment and line2 is infinite, they intersect if:
  if (a > 0 && a < 1) {
    result.onLine1 = true;
  }
  // if line2 is a segment and line1 is infinite, they intersect if:
  if (b > 0 && b < 1) {
    result.onLine2 = true;
  }

  result.onBothLines = result.onLine1 && result.onLine2;

  // if line1 and line2 are segments, they intersect if both of the above are true
  return result;
};

var handleIntersection = function handleIntersection(anchors, radius, markup) {
  var leng = anchors.length;
  var intersects = [];
  for (var i = 0; i < leng; i++) {
    var ind = i === 0 ? leng - 1 : i - 1;
    var prevAnchor = anchors[ind];
    var currentAnchor = anchors[i];
    var nextAnchor = anchors[(i + 1) % leng];

    if (!currentAnchor || !nextAnchor) {
      break;
    }

    var angA = Math.atan2(currentAnchor.y - prevAnchor.y, currentAnchor.x - prevAnchor.x);

    var tangentA2 = {};
    tangentA2.p1 = new THREE.Vector3(prevAnchor.x + Math.cos(angA - Math.PI / 2) * radius, prevAnchor.y + Math.sin(angA - Math.PI / 2) * radius, 1);
    tangentA2.p2 = new THREE.Vector3(currentAnchor.x + Math.cos(angA - Math.PI / 2) * radius, currentAnchor.y + Math.sin(angA - Math.PI / 2) * radius, 1);

    var angB = Math.atan2(nextAnchor.y - currentAnchor.y, nextAnchor.x - currentAnchor.x);

    var tangentB2 = {};
    tangentB2.p1 = new THREE.Vector3(currentAnchor.x + Math.cos(angB - Math.PI / 2) * radius, currentAnchor.y + Math.sin(angB - Math.PI / 2) * radius, 1);
    tangentB2.p2 = new THREE.Vector3(nextAnchor.x + Math.cos(angB - Math.PI / 2) * radius, nextAnchor.y + Math.sin(angB - Math.PI / 2) * radius, 1);

    var intersect = checkLineIntersection(tangentA2.p1, tangentA2.p2, tangentB2.p1, tangentB2.p2);

    // if there is an intersection point on the lines
    if (intersect.onBothLines) {
      var vec1 = new THREE.Vector3(currentAnchor.x - prevAnchor.x, currentAnchor.y - prevAnchor.y, 0);
      var vec2 = new THREE.Vector3(nextAnchor.x - currentAnchor.x, nextAnchor.y - currentAnchor.y, 0);
      vec1.normalize();
      vec2.normalize();
      vec1.multiplyScalar(-1);

      var cross = new THREE.Vector3().crossVectors(vec1, vec2);

      var asin = Math.asin(cross.z);

      var acos = vec1.dot(vec2);

      var diff = Math.atan2(asin, acos);

      if (diff < Math.PI / 2) {
        currentAnchor['isCurrentIntersection' + intersects.length] = true;
        nextAnchor['isNextIntersection' + intersects.length] = true;

        currentAnchor.intersects = intersects;
        nextAnchor.intersects = intersects;

        intersects.push(intersect);
      }
    }
  }
  return intersects;
};

var markupsOverlayRenderer = function markupsOverlayRenderer(viewer, options) {var overlayRendererExtraOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var
  width = options.width,height = options.height,ctx = options.ctx,target = options.target,screenshotCamera = options.screenshotCamera,onRenderDone = options.onRenderDone;var
  markupLayer = overlayRendererExtraOptions.markupLayer;

  var markupsExtension = viewer.getExtension('Autodesk.BIM360.Markups');

  if (!markupsExtension) {
    onRenderDone(ctx.targetToCanvas(target).canvas);
    return;
  }

  var canvasBounds = viewer.impl.getCanvasBoundingClientRect();
  var originalWidth = canvasBounds.width;
  var originalHeight = canvasBounds.height;

  var webglRenderer = viewer.impl.glrenderer();
  webglRenderer.pushViewport();
  webglRenderer.setPixelRatio(1.0);
  webglRenderer.setViewport(0, 0, width, height);
  markupsExtension.renderer.onResize({ width: width, height: height });

  var cam = viewer.impl.is2d ? screenshotCamera : markupsExtension.renderer.markupsCamera;
  var visibleLayers = markupsExtension.markupsManager.getVisibleLayers();

  if (markupLayer) {
    visibleLayers.forEach(function (layer) {return layer !== markupLayer && layer.setVisible(false);});
  }

  var wasVisible;
  var wasTransparent;

  // Make sure the current layer is fully visible before rendering.
  var beforeRender = function beforeRender() {
    if (markupLayer) {
      wasVisible = markupLayer.isVisible();
      wasTransparent = markupLayer.isTransparent();

      markupLayer.setVisible(true);
      markupLayer.changeTransparency(false);
    }
  };

  var afterRender = function afterRender() {
    if (markupLayer) {
      markupLayer.setVisible(wasVisible);
      markupLayer.changeTransparency(!wasTransparent);
    }
  };

  beforeRender();

  markupsExtension.renderer.render(target, cam);

  afterRender();

  // Restore previous state
  webglRenderer.popViewport();
  webglRenderer.setPixelRatio();
  markupsExtension.renderer.onResize({ width: originalWidth, height: originalHeight });var _ctx$targetToCanvas =

  ctx.targetToCanvas(target),canvas = _ctx$targetToCanvas.canvas;
  var scaleRatio = width / originalWidth;

  markupsExtension.renderer.textRenderer.renderTextToCanvas(canvas, cam, scaleRatio, beforeRender, afterRender, onRenderDone);

  if (markupLayer) {
    visibleLayers.forEach(function (layer) {return layer !== markupLayer && layer.setVisible(true);});
  }
};

var getScreenShotOfMarkup = function getScreenShotOfMarkup(viewer, callback, markupLayer) {
  var markupsExtension = viewer.getExtension('Autodesk.BIM360.Markups');
  var bounds;

  if (markupLayer && viewer.impl.is2d) {
    bounds = markupLayer.getWorldBoundingBox();
    Autodesk.Viewing.ScreenShot.makeBoundsSquare(bounds);
  }

  var getCropBounds = function getCropBounds(viewer, camera) {
    bounds = markupLayer.getWorldBoundingBox();
    Autodesk.Viewing.ScreenShot.makeBoundsSquare(bounds);

    var markupsCameraBackup = markupsExtension.renderer.markupsCamera;

    if (viewer.impl.is2d) {
      markupsExtension.renderer.markupsCamera = camera;
    }

    var min = markupsExtension.renderer.worldToClient(bounds.min);
    var max = markupsExtension.renderer.worldToClient(bounds.max);

    markupsExtension.renderer.markupsCamera = markupsCameraBackup;

    var clientBounds = new THREE.Box3().setFromPoints([min, max]);
    Autodesk.Viewing.ScreenShot.makeBoundsSquare(clientBounds, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MINIMUM_THUMBNAIL_SIZE);

    var size = clientBounds.getSize(new THREE.Vector3()).x;
    clientBounds.expandByVector(new THREE.Vector3(size * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.SELECTION_ZOOM_MARGIN, size * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.SELECTION_ZOOM_MARGIN, 0));

    return clientBounds;
  };

  var options = {
    bounds: bounds,
    margin: markupLayer ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.SELECTION_ZOOM_MARGIN : 0,
    overlayRenderer: markupsOverlayRenderer,
    overlayRendererExtraOptions: { markupLayer: markupLayer },
    getCropBounds: markupLayer && getCropBounds };


  Autodesk.Viewing.ScreenShot.getScreenShotAtScreenSize(viewer, callback, options);
};

var setCustomGestureValues = function setCustomGestureValues(viewer) {
  var gestureHandler = viewer.toolController.getTool('gestures');
  if (gestureHandler) {
    gestureHandler.setGestureParameter('singletap', 'time', 250);
    gestureHandler.setGestureParameter('drag', 'threshold', 0);
  }
};

var restoreGestureValues = function restoreGestureValues(viewer) {
  var gestureHandler = viewer.toolController.getTool('gestures');
  if (gestureHandler) {
    gestureHandler.restoreGestureParameterDefault('singletap', 'time');
    gestureHandler.restoreGestureParameterDefault('drag', 'threshold');
  }
};
/*
    * Taken from Simplify.js, a high-performance JS polyline simplification library
    * (c) 2013, Vladimir Agafonkin
    * mourner.github.io/simplify-js
    */
var simplify = function simplify(points, tolerance, highestQuality) {

  if (points.length <= 2) return points;

  // square distance between 2 points
  function getSqDist(p1, p2) {
    var dx = p1.x - p2.x,
    dy = p1.y - p2.y;

    return dx * dx + dy * dy;
  }

  // square distance from a point to a segment
  function getSqSegDist(p, p1, p2) {
    var x = p1.x,
    y = p1.y,
    dx = p2.x - x,
    dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {
      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

      if (t > 1) {
        x = p2.x;
        y = p2.y;

      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
  }

  // basic distance-based simplification
  function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
    newPoints = [prevPoint],
    point;

    for (var i = 1, len = points.length; i < len; i++) {
      point = points[i];

      if (getSqDist(point, prevPoint) > sqTolerance) {
        newPoints.push(point);
        prevPoint = point;
      }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
  }

  function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
    index;

    for (var i = first + 1; i < last; i++) {
      var sqDist = getSqSegDist(points[i], points[first], points[last]);

      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }

    if (maxSqDist > sqTolerance) {
      if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
      simplified.push(points[index]);
      if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
  }

  // simplification using Ramer-Douglas-Peucker algorithm
  function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
  }

  // both algorithms combined for awesome performance
  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  points = simplifyDouglasPeucker(points, sqTolerance);

  return points;
};

// A polygon is a simple polygon if there are no intersection between its edges.	
function isPolygonSimple(points) {
  var n = points.length;

  if (n === 3) {
    return true;
  }

  for (var i = 0; i < n; i++) {

    var p1 = points[i];
    var p2 = points[(i + 1) % n];

    for (var j = i + 2; j < n; j++) {

      var q1 = points[j % n];
      var q2 = points[(j + 1) % n];

      if (q2 === p1) {
        break;
      }

      var intersect = checkLineIntersection(p1, p2, q1, q2);

      // if there is an intersection point on the lines
      if (intersect.onBothLines) {
        return false;
      }
    }
  }

  return true;
}

var executeAfterTransitionEnded = function executeAfterTransitionEnded(viewer, callback) {
  if (!viewer.navigation.getRequestTransition() && !viewer.navigation.getTransitionActive()) {
    callback();
  } else {
    // Try again in case there is a requestTransition, but CAMERA_TRANSITION_COMPLETED won't get fired.
    // It can happen in case there is a requestTransition to the same camera position exactly.
    setTimeout(function () {
      if (!viewer.navigation.getRequestTransition() && !viewer.navigation.getTransitionActive()) {
        callback();
      } else {
        viewer.addEventListener(Autodesk.Viewing.CAMERA_TRANSITION_COMPLETED, function () {
          callback();
        }, { once: true });
      }
    }, 1);
  }
};

var isSheetNameEqual = function isSheetNameEqual(nameA, nameB) {
  if (nameA === nameB) {
    return true;
  }

  // Same length but not equal - nothing more to check...
  if (!nameA || !nameB || nameA.length === nameB.length) {
    return false;
  }

  // In some cases, PDF sheets are being exported with/without parentheses.
  if (nameA.startsWith('(')) {
    return nameA === "(".concat(nameB, ")");
  } else {
    return nameB === "(".concat(nameA, ")");
  }
};

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsConstants.js":
/*!***************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsConstants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "COLORS": () => (/* binding */ COLORS),
/* harmony export */   "DEFAULT_COLORS": () => (/* binding */ DEFAULT_COLORS),
/* harmony export */   "DEFAULT_FILL_COLORS": () => (/* binding */ DEFAULT_FILL_COLORS),
/* harmony export */   "STYLE_PROPERTIES": () => (/* binding */ STYLE_PROPERTIES),
/* harmony export */   "FONT_SIZES": () => (/* binding */ FONT_SIZES),
/* harmony export */   "MESHLINE_PATH_START": () => (/* binding */ MESHLINE_PATH_START),
/* harmony export */   "MESHLINE_PATH_END": () => (/* binding */ MESHLINE_PATH_END),
/* harmony export */   "MESHLINE_PATH_DEFAULT": () => (/* binding */ MESHLINE_PATH_DEFAULT),
/* harmony export */   "MESHLINE_PATH_ROUND_CAP": () => (/* binding */ MESHLINE_PATH_ROUND_CAP),
/* harmony export */   "MESHLINE_PATH_FLAT_CAP": () => (/* binding */ MESHLINE_PATH_FLAT_CAP),
/* harmony export */   "MARKUP_TYPE_ARROW": () => (/* binding */ MARKUP_TYPE_ARROW),
/* harmony export */   "MARKUP_TYPE_RECTANGLE": () => (/* binding */ MARKUP_TYPE_RECTANGLE),
/* harmony export */   "MARKUP_TYPE_CIRCLE": () => (/* binding */ MARKUP_TYPE_CIRCLE),
/* harmony export */   "MARKUP_TYPE_CLOUD": () => (/* binding */ MARKUP_TYPE_CLOUD),
/* harmony export */   "MARKUP_TYPE_FREEHAND": () => (/* binding */ MARKUP_TYPE_FREEHAND),
/* harmony export */   "MARKUP_TYPE_HIGHLIGHT": () => (/* binding */ MARKUP_TYPE_HIGHLIGHT),
/* harmony export */   "MARKUP_TYPE_POLYLINE": () => (/* binding */ MARKUP_TYPE_POLYLINE),
/* harmony export */   "MARKUP_TYPE_POLYCLOUD": () => (/* binding */ MARKUP_TYPE_POLYCLOUD),
/* harmony export */   "MARKUP_TYPE_TEXT": () => (/* binding */ MARKUP_TYPE_TEXT),
/* harmony export */   "MARKUP_TYPE_CALLOUT": () => (/* binding */ MARKUP_TYPE_CALLOUT),
/* harmony export */   "MARKUP_TYPE_ARROW_CALLOUT": () => (/* binding */ MARKUP_TYPE_ARROW_CALLOUT),
/* harmony export */   "MARKUP_TYPE_ARROW_CLOUD_CALLOUT": () => (/* binding */ MARKUP_TYPE_ARROW_CLOUD_CALLOUT),
/* harmony export */   "MARKUP_TYPE_DIMENSION": () => (/* binding */ MARKUP_TYPE_DIMENSION),
/* harmony export */   "MARKUP_TYPE_LINE": () => (/* binding */ MARKUP_TYPE_LINE),
/* harmony export */   "RECT_SELECTOR": () => (/* binding */ RECT_SELECTOR),
/* harmony export */   "MARKUP_STATUS_SAVE_FAILED": () => (/* binding */ MARKUP_STATUS_SAVE_FAILED),
/* harmony export */   "MARKUP_STATUS_SAVE_SUCCEED": () => (/* binding */ MARKUP_STATUS_SAVE_SUCCEED),
/* harmony export */   "MARKUP_STATUS_SAVING": () => (/* binding */ MARKUP_STATUS_SAVING),
/* harmony export */   "MARKUP_STATUS_DELETING": () => (/* binding */ MARKUP_STATUS_DELETING),
/* harmony export */   "MARKUP_STATUS_DELETE_SUCCEED": () => (/* binding */ MARKUP_STATUS_DELETE_SUCCEED),
/* harmony export */   "MARKUP_STATUS_DELETE_FAILED": () => (/* binding */ MARKUP_STATUS_DELETE_FAILED),
/* harmony export */   "MARKUP_STATUS_CREATED": () => (/* binding */ MARKUP_STATUS_CREATED),
/* harmony export */   "MARKUP_STATUS_OPEN": () => (/* binding */ MARKUP_STATUS_OPEN),
/* harmony export */   "MARKUP_STATUS_PRIVATE": () => (/* binding */ MARKUP_STATUS_PRIVATE),
/* harmony export */   "MARKUP_STATUS_PUBLISHED": () => (/* binding */ MARKUP_STATUS_PUBLISHED),
/* harmony export */   "MARKUP_STATUS_PUBLISHING": () => (/* binding */ MARKUP_STATUS_PUBLISHING),
/* harmony export */   "MARKUP_STATUS_CLOSED": () => (/* binding */ MARKUP_STATUS_CLOSED),
/* harmony export */   "MARKUP_STATUS_ARCHIVED": () => (/* binding */ MARKUP_STATUS_ARCHIVED),
/* harmony export */   "MARKUP_STATUS_ARCHIVING": () => (/* binding */ MARKUP_STATUS_ARCHIVING),
/* harmony export */   "MARKUP_ATTACHMENT_LOADING": () => (/* binding */ MARKUP_ATTACHMENT_LOADING),
/* harmony export */   "MARKUP_ATTACHMENT_SAVING": () => (/* binding */ MARKUP_ATTACHMENT_SAVING),
/* harmony export */   "MARKUP_ATTACHMENT_SAVE_SUCCEED": () => (/* binding */ MARKUP_ATTACHMENT_SAVE_SUCCEED),
/* harmony export */   "MARKUP_ATTACHMENT_SAVE_FAILED": () => (/* binding */ MARKUP_ATTACHMENT_SAVE_FAILED),
/* harmony export */   "MARKUP_ATTACHMENT_RENAMING": () => (/* binding */ MARKUP_ATTACHMENT_RENAMING),
/* harmony export */   "MARKUP_ATTACHMENT_DELETEING": () => (/* binding */ MARKUP_ATTACHMENT_DELETEING),
/* harmony export */   "ATTACHMENT_DATA_TYPE_BINARY": () => (/* binding */ ATTACHMENT_DATA_TYPE_BINARY),
/* harmony export */   "ATTACHMENT_DATA_TYPE_TEXT": () => (/* binding */ ATTACHMENT_DATA_TYPE_TEXT),
/* harmony export */   "MARKUP_RESOURCE_TYPE_SVG": () => (/* binding */ MARKUP_RESOURCE_TYPE_SVG),
/* harmony export */   "MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE": () => (/* binding */ MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE),
/* harmony export */   "DEFAULT_STATUSES_TO_LOAD": () => (/* binding */ DEFAULT_STATUSES_TO_LOAD),
/* harmony export */   "LINK_TYPE_ATTACHMENTS": () => (/* binding */ LINK_TYPE_ATTACHMENTS),
/* harmony export */   "LINK_TYPE_DOCUMENT_ATTACHMENT": () => (/* binding */ LINK_TYPE_DOCUMENT_ATTACHMENT),
/* harmony export */   "DEFAULT_MARKUP": () => (/* binding */ DEFAULT_MARKUP),
/* harmony export */   "DEFAULT_COLOR": () => (/* binding */ DEFAULT_COLOR),
/* harmony export */   "DEFAULT_FONT_COLOR": () => (/* binding */ DEFAULT_FONT_COLOR),
/* harmony export */   "DEFAULT_FILL_COLOR": () => (/* binding */ DEFAULT_FILL_COLOR),
/* harmony export */   "DEFAULT_THICKNESS": () => (/* binding */ DEFAULT_THICKNESS),
/* harmony export */   "DEFAULT_OPACITY": () => (/* binding */ DEFAULT_OPACITY),
/* harmony export */   "DEFAULT_HIGHLIGHT_OPACITY": () => (/* binding */ DEFAULT_HIGHLIGHT_OPACITY),
/* harmony export */   "DEFAULT_FILL_OPACITY": () => (/* binding */ DEFAULT_FILL_OPACITY),
/* harmony export */   "DEFAULT_STROKE_IN_MM": () => (/* binding */ DEFAULT_STROKE_IN_MM),
/* harmony export */   "DEFAULT_FONT_SIZE_IN_PIXELS": () => (/* binding */ DEFAULT_FONT_SIZE_IN_PIXELS),
/* harmony export */   "DEFAULT_FONT_SIZE_IN_MM": () => (/* binding */ DEFAULT_FONT_SIZE_IN_MM),
/* harmony export */   "DEFAULT_FONT_WEIGHT": () => (/* binding */ DEFAULT_FONT_WEIGHT),
/* harmony export */   "DEFAULT_FONT_FAMILY": () => (/* binding */ DEFAULT_FONT_FAMILY),
/* harmony export */   "DEFAULT_FONT_STYLE": () => (/* binding */ DEFAULT_FONT_STYLE),
/* harmony export */   "SUB_MENU_VISIBLE_CLASS": () => (/* binding */ SUB_MENU_VISIBLE_CLASS),
/* harmony export */   "ARROW_TIP_LENGTH": () => (/* binding */ ARROW_TIP_LENGTH),
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "TOUCH_RADIUS": () => (/* binding */ TOUCH_RADIUS),
/* harmony export */   "ANCHOR_RADIUS": () => (/* binding */ ANCHOR_RADIUS),
/* harmony export */   "MIN_CHANGE_DISTANCE": () => (/* binding */ MIN_CHANGE_DISTANCE),
/* harmony export */   "SNAP_DISTANCE": () => (/* binding */ SNAP_DISTANCE),
/* harmony export */   "MIN_FREEHAND_POINT_DISTANCE": () => (/* binding */ MIN_FREEHAND_POINT_DISTANCE),
/* harmony export */   "MIN_ANGLE_CHANGE": () => (/* binding */ MIN_ANGLE_CHANGE),
/* harmony export */   "ROTATION_ANCHOR_DISTANCE": () => (/* binding */ ROTATION_ANCHOR_DISTANCE),
/* harmony export */   "ROTATION_SNAP_DEGREES": () => (/* binding */ ROTATION_SNAP_DEGREES),
/* harmony export */   "PASTE_OFFSET": () => (/* binding */ PASTE_OFFSET),
/* harmony export */   "ARROW_MOVE_OFFSET": () => (/* binding */ ARROW_MOVE_OFFSET),
/* harmony export */   "CONTEXTUAL_MENU_OFFSET": () => (/* binding */ CONTEXTUAL_MENU_OFFSET),
/* harmony export */   "LINK_POSITION_OFFSET": () => (/* binding */ LINK_POSITION_OFFSET),
/* harmony export */   "LINK_ICON_SIZE": () => (/* binding */ LINK_ICON_SIZE),
/* harmony export */   "SELECTION_ZOOM_MARGIN": () => (/* binding */ SELECTION_ZOOM_MARGIN),
/* harmony export */   "MAX_THICKNESS": () => (/* binding */ MAX_THICKNESS),
/* harmony export */   "PERSPECTIVE_MODE_SCALE": () => (/* binding */ PERSPECTIVE_MODE_SCALE),
/* harmony export */   "FRAME_SIZE_SCALE": () => (/* binding */ FRAME_SIZE_SCALE),
/* harmony export */   "BOUNDING_BOX_MARGIN": () => (/* binding */ BOUNDING_BOX_MARGIN),
/* harmony export */   "HIT_AREA_MARGIN": () => (/* binding */ HIT_AREA_MARGIN),
/* harmony export */   "TEXT_DEBOUNCE": () => (/* binding */ TEXT_DEBOUNCE),
/* harmony export */   "DIMENSION_TIP_LENGTH": () => (/* binding */ DIMENSION_TIP_LENGTH),
/* harmony export */   "DIMENSION_THICKNESS_FACTOR": () => (/* binding */ DIMENSION_THICKNESS_FACTOR),
/* harmony export */   "DIMENSION_FONT_SIZE_FACTOR": () => (/* binding */ DIMENSION_FONT_SIZE_FACTOR),
/* harmony export */   "DISABLED_OPACITY": () => (/* binding */ DISABLED_OPACITY),
/* harmony export */   "MOBILE_GESTURES_MIN_THRESHOLD_TIME": () => (/* binding */ MOBILE_GESTURES_MIN_THRESHOLD_TIME),
/* harmony export */   "SCREEN_MARGIN": () => (/* binding */ SCREEN_MARGIN),
/* harmony export */   "TEXT_LENGTH_LIMIT": () => (/* binding */ TEXT_LENGTH_LIMIT),
/* harmony export */   "MINIMUM_THUMBNAIL_SIZE": () => (/* binding */ MINIMUM_THUMBNAIL_SIZE),
/* harmony export */   "WORLD_3D_SIZE": () => (/* binding */ WORLD_3D_SIZE),
/* harmony export */   "MAX_NORMA_PERCENTAGE": () => (/* binding */ MAX_NORMA_PERCENTAGE),
/* harmony export */   "MAX_NORMA_TEXT_PERCENTAGE": () => (/* binding */ MAX_NORMA_TEXT_PERCENTAGE),
/* harmony export */   "NORMA_3D": () => (/* binding */ NORMA_3D),
/* harmony export */   "NORMA_TEXT_3D": () => (/* binding */ NORMA_TEXT_3D),
/* harmony export */   "POINT_SIZE_IN_MM": () => (/* binding */ POINT_SIZE_IN_MM),
/* harmony export */   "TIMEOUT_TO_SELECT_AFTER_DRAWEND": () => (/* binding */ TIMEOUT_TO_SELECT_AFTER_DRAWEND),
/* harmony export */   "MARKUP_CREATION_CURSORS": () => (/* binding */ MARKUP_CREATION_CURSORS),
/* harmony export */   "MARKUP_ERRORS": () => (/* binding */ MARKUP_ERRORS)
/* harmony export */ });
var _MARKUP_CREATION_CURS;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}var COLORS = {
  RED: '#FF0000',
  GREEN: '#00F72C',
  BLUE: '#103FFB',
  ORANGE: '#FF9224',
  YELLOW: '#FEF935',
  CYAN: '#03FCFE',
  WHITE: '#FFFFFF',
  BLACK: '#000000',
  PINK: '#FF4CFC',
  PURPLE: '#922890',
  NO_COLOR: '-1' };


var DEFAULT_COLORS = [
{
  color: COLORS.RED,
  label: 'Red' },

{
  color: COLORS.BLUE,
  label: 'Blue' },

{
  color: COLORS.PURPLE,
  label: 'Purple' },

{
  color: COLORS.YELLOW,
  label: 'Yellow' },

{
  color: COLORS.ORANGE,
  label: 'Orange' },

{
  color: COLORS.CYAN,
  label: 'Cyan' },

{
  color: COLORS.PINK,
  label: 'Pink' },

{
  color: COLORS.GREEN,
  label: 'Green' },

{
  color: COLORS.BLACK,
  label: 'Black' },

{
  color: COLORS.WHITE,
  label: 'White' }];



var DEFAULT_FILL_COLORS = [
{
  color: COLORS.RED,
  label: 'Red' },

{
  color: COLORS.BLUE,
  label: 'Blue' },

{
  color: COLORS.PURPLE,
  label: 'Purple' },

{
  color: COLORS.YELLOW,
  label: 'Yellow' },

{
  color: COLORS.ORANGE,
  label: 'Orange' },

{
  color: COLORS.CYAN,
  label: 'Cyan' },

{
  color: COLORS.PINK,
  label: 'Pink' },

{
  color: COLORS.GREEN,
  label: 'Green' },

{
  color: COLORS.NO_COLOR,
  label: 'No Fill' },

{
  color: COLORS.BLACK,
  label: 'Black' },

{
  color: COLORS.WHITE,
  label: 'White' }];



var STYLE_PROPERTIES = {
  COLOR: 'stroke-color',
  FILL_COLOR: 'fill-color',
  THICKNESS: 'stroke-width',
  OPACITY: 'stroke-opacity',
  FILL_OPACITY: 'fill-opacity',
  FONT_SIZE: 'font-size',
  FONT_WEIGHT: 'font-weight',
  FONT_FAMILY: 'font-family',
  FONT_STYLE: 'font-style',
  FONT_COLOR: 'font-color',
  STROKE_LINEJOIN: 'stroke-linejoin' };


var FONT_SIZES = [10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 40, 44, 48, 52, 58, 64, 70, 76, 82, 88, 94, 100];

var MESHLINE_PATH_START = 1;
var MESHLINE_PATH_END = 2;

var MESHLINE_PATH_DEFAULT = 1;
var MESHLINE_PATH_ROUND_CAP = 2;
var MESHLINE_PATH_FLAT_CAP = 3;

// Markup types
var MARKUP_TYPE_ARROW = 'arrow';
var MARKUP_TYPE_RECTANGLE = 'rectangle';
var MARKUP_TYPE_CIRCLE = 'ellipse';
var MARKUP_TYPE_CLOUD = 'cloud';
var MARKUP_TYPE_FREEHAND = 'freehand';
var MARKUP_TYPE_HIGHLIGHT = 'highlight';
var MARKUP_TYPE_POLYLINE = 'polyline';
var MARKUP_TYPE_POLYCLOUD = 'polycloud';
var MARKUP_TYPE_TEXT = 'label';
var MARKUP_TYPE_CALLOUT = 'callout';
var MARKUP_TYPE_ARROW_CALLOUT = 'simple-arrow-callout';
var MARKUP_TYPE_ARROW_CLOUD_CALLOUT = 'arrow-cloud-callout';
var MARKUP_TYPE_DIMENSION = 'dimension';
var MARKUP_TYPE_LINE = 'line';

var RECT_SELECTOR = 'selector';

// Statuses
var MARKUP_STATUS_SAVE_FAILED = 'save_failed';
var MARKUP_STATUS_SAVE_SUCCEED = 'save_success';
var MARKUP_STATUS_SAVING = 'markup_saving';
var MARKUP_STATUS_DELETING = 'deleting';
var MARKUP_STATUS_DELETE_SUCCEED = 'delete_success';
var MARKUP_STATUS_DELETE_FAILED = 'delete_failed';
var MARKUP_STATUS_CREATED = 'created';
var MARKUP_STATUS_OPEN = 'open';
var MARKUP_STATUS_PRIVATE = 'private';
var MARKUP_STATUS_PUBLISHED = 'published';
var MARKUP_STATUS_PUBLISHING = 'publishing';
var MARKUP_STATUS_CLOSED = 'closed';
var MARKUP_STATUS_ARCHIVED = 'archived';
var MARKUP_STATUS_ARCHIVING = 'archiving';
var MARKUP_ATTACHMENT_LOADING = 'attachment_loading';
var MARKUP_ATTACHMENT_SAVING = 'attachment_saving';
var MARKUP_ATTACHMENT_SAVE_SUCCEED = 'attachment_save_success';
var MARKUP_ATTACHMENT_SAVE_FAILED = 'attachment_save_failed';
var MARKUP_ATTACHMENT_RENAMING = 'attachment_renaming';
var MARKUP_ATTACHMENT_DELETEING = 'attachment_deleting';

// Metadata
var ATTACHMENT_DATA_TYPE_BINARY = 'binary';
var ATTACHMENT_DATA_TYPE_TEXT = 'text';
var MARKUP_RESOURCE_TYPE_SVG = 'svg';
var MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE = 'screencapture';
var DEFAULT_STATUSES_TO_LOAD = [MARKUP_STATUS_PRIVATE, MARKUP_STATUS_PUBLISHED, MARKUP_STATUS_ARCHIVED].join(',');

// Link types
var LINK_TYPE_ATTACHMENTS = 'attachments';
var LINK_TYPE_DOCUMENT_ATTACHMENT = 'document';

// Default Properties values
var DEFAULT_MARKUP = MARKUP_TYPE_FREEHAND;
var DEFAULT_COLOR = COLORS.RED;
var DEFAULT_FONT_COLOR = COLORS.RED;
var DEFAULT_FILL_COLOR = COLORS.NO_COLOR;
var DEFAULT_THICKNESS = 10.0;
var DEFAULT_OPACITY = 1.0;
var DEFAULT_HIGHLIGHT_OPACITY = 0.5;
var DEFAULT_FILL_OPACITY = 0.5;
var DEFAULT_STROKE_IN_MM = 0.1;
var DEFAULT_FONT_SIZE_IN_PIXELS = 36.0;
var DEFAULT_FONT_SIZE_IN_MM = 10.0;
var DEFAULT_FONT_WEIGHT = 'normal';
var DEFAULT_FONT_FAMILY = 'Artifakt Element, Arial';
var DEFAULT_FONT_STYLE = 'normal';

var SUB_MENU_VISIBLE_CLASS = 'subMenuVisible';


var isTouchDevice = typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);

// Other constants
var ARROW_TIP_LENGTH = 5;
var EPSILON = 0.0001;
var TOUCH_RADIUS = isTouchDevice ? 34 : 4;
var ANCHOR_RADIUS = 4;
var MIN_CHANGE_DISTANCE = 5;
var SNAP_DISTANCE = 20;
var MIN_FREEHAND_POINT_DISTANCE = 1;
var MIN_ANGLE_CHANGE = 0.05;
var ROTATION_ANCHOR_DISTANCE = isTouchDevice ? 30 : 20;
var ROTATION_SNAP_DEGREES = 45;
var PASTE_OFFSET = 20;
var ARROW_MOVE_OFFSET = 20;
var CONTEXTUAL_MENU_OFFSET = 60;
var LINK_POSITION_OFFSET = 10;
var LINK_ICON_SIZE = 20;
var SELECTION_ZOOM_MARGIN = 0.05;
var MAX_THICKNESS = 100;
var PERSPECTIVE_MODE_SCALE = 1000; // Legacy constant - Don't change!
var FRAME_SIZE_SCALE = 20; // Used in order to prevent render errors when changing browser's zoom.
var BOUNDING_BOX_MARGIN = window.devicePixelRatio * 4 + 10;
var HIT_AREA_MARGIN = TOUCH_RADIUS + 10;
var TEXT_DEBOUNCE = 200;
var DIMENSION_TIP_LENGTH = 8;
var DIMENSION_THICKNESS_FACTOR = 2 / 5;
var DIMENSION_FONT_SIZE_FACTOR = 3 / 5;
var DISABLED_OPACITY = 0.3;
var MOBILE_GESTURES_MIN_THRESHOLD_TIME = 100;
var SCREEN_MARGIN = 10;
var TEXT_LENGTH_LIMIT = 3000;
var MINIMUM_THUMBNAIL_SIZE = 92; // According to the markup's panel.

var WORLD_3D_SIZE = 1000; // This needs to be constant so that markups appear consistently in the same place

var MAX_NORMA_PERCENTAGE = 0.05 / 100; // Percentage of document diagonal. A boundary for the norma
var MAX_NORMA_TEXT_PERCENTAGE = 20 * MAX_NORMA_PERCENTAGE;
var NORMA_3D = 1; // We chose a 3D world size (WORLD_3D_SIZE) such that 1 is the norma size there
var NORMA_TEXT_3D = 20 * NORMA_3D;

var POINT_SIZE_IN_MM = 0.005; // A point is created by drawing a minimal meshline with round caps. This is the distance between the points.
var TIMEOUT_TO_SELECT_AFTER_DRAWEND = 700;

var MARKUP_CREATION_CURSORS = (_MARKUP_CREATION_CURS = {}, _defineProperty(_MARKUP_CREATION_CURS,
RECT_SELECTOR, 'cell'), _defineProperty(_MARKUP_CREATION_CURS,
MARKUP_TYPE_TEXT, 'text'), _defineProperty(_MARKUP_CREATION_CURS,
MARKUP_TYPE_CALLOUT, 'text'), _MARKUP_CREATION_CURS);


var MARKUP_ERRORS = {
  MARKUP_SAVE_FAILED: 'MARKUP_SAVE_FAILED',
  MARKUP_DELETE_FAILED: 'MARKUP_DELETE_FAILED',
  MARKUP_PUBLISH_FAILED: 'MARKUP_PUBLISH_FAILED',
  MARKUP_ARCHIVE_FAILED: 'MARKUP_ARCHIVE_FAILED',
  MARKUP_ATTACHMENT_CREATE_FAILED: 'MARKUP_ATTACHMENT_CREATE_FAILED',
  MARKUP_ATTACHMENT_DELETE_FAILED: 'MARKUP_ATTACHMENT_DELETE_FAILED',
  MARKUP_ATTACHMENT_RENAME_FAILED: 'MARKUP_ATTACHMENT_RENAME_FAILED',
  MARKUP_ATTACHMENT_UPDATE_FAILED: 'MARKUP_ATTACHMENT_UPDATE_FAILED' };

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsDeserializer.js":
/*!******************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsDeserializer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringToSvgNode": () => (/* binding */ stringToSvgNode),
/* harmony export */   "parseMetadata": () => (/* binding */ parseMetadata),
/* harmony export */   "getLayerDataModelVersion": () => (/* binding */ getLayerDataModelVersion),
/* harmony export */   "parseMarkupLayer": () => (/* binding */ parseMarkupLayer)
/* harmony export */ });
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsSceneState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsSceneState */ "./extensions/BimMarkups/MarkupsSceneState.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");




var stringToSvgNode = function stringToSvgNode(markupString) {
  var node;

  try {
    var domParser = new DOMParser();
    var doc = domParser.parseFromString(markupString, 'text/xml');
    node = doc.firstChild;
  } catch (err) {
    console.warn('stringToSvgNode failed to generate an HTMLElement from its string representation.');
  }

  return node;
};

// Converts a point from legacy markups coordinates to current ones. Relevant for 3D and PDF files
var markupsToWorld = function markupsToWorld(point, viewer, renderer, layerData) {
  var isPdf = viewer.model.isPdf(true);

  if (viewer.model.isLeaflet() || isPdf) {
    var loadOptions;
    var bounds;

    if (isPdf) {
      loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);
      bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);
    } else {
      var modelData = viewer.model.getData();
      loadOptions = modelData.loadOptions.loadOptions;
      bounds = modelData.bbox;
    }var _loadOptions =

    loadOptions,texWidth = _loadOptions.texWidth,texHeight = _loadOptions.texHeight;

    // https://jira.autodesk.com/browse/BLMV-2853
    // In case that the DPI of the current document is different than the DPI of the document where the markup has originally created (or edited)
    // We need to scale the ratio back in order that the markup will appear in the same place.
    var originalDocumentWidth = layerData.metadata.markup_metadata &&
    layerData.metadata.markup_metadata.originalDocumentResolution &&
    layerData.metadata.markup_metadata.originalDocumentResolution[0] || texWidth;
    var dpiCorrection = texWidth / originalDocumentWidth;
    var boundsSize = bounds.getSize(new THREE.Vector3());
    var wx = point.x / (texWidth / dpiCorrection) * boundsSize.x;
    var wy = point.y / (texHeight / dpiCorrection) * boundsSize.y;

    var worldPos = new THREE.Vector3(wx, wy, 0);
    var worldTopLeft = new THREE.Vector3(bounds.min.x, bounds.max.y, 0);
    worldPos.add(worldTopLeft);

    if (isPdf) {
      Autodesk.Viewing.PDFUtils.leafletToPdfWorld(viewer, worldPos);
    }

    return worldPos;
  }

  // 3D document
  if (renderer.documentCamera.isPerspective) {
    var bb = viewer.impl.getCanvasBoundingClientRect();

    // Factor by PERSPECTIVE_MODE_SCALE because Firefox on Windows machines have problems dealing with very small paths (SVG legacy factor)
    point.x = point.x / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.width * 0.5;
    point.y = -point.y / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.height * 0.5;

    point = renderer.clientToWorld(point);
  } else {// Orthographic
    point.applyMatrix4(renderer.documentCamera.matrixWorld);
    point.sub(renderer.documentCamera.position);

    // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so
    // exported markups don't have the offset.
    var globalOffset = viewer.model && viewer.model.getData().globalOffset;
    if (globalOffset) {
      point.sub(globalOffset);
    }

    point = renderer.documentCameraToMarkupsCamera(point);
  }

  return point;
};

var sizeFromMarkupsToWorld = function sizeFromMarkupsToWorld(size, viewer, renderer, layerData) {
  var a = markupsToWorld(new THREE.Vector3(), viewer, renderer, layerData);
  var b = markupsToWorld(new THREE.Vector3(size, 0, 0), viewer, renderer, layerData);

  return a.distanceTo(b);
};

var parseMetadata = function parseMetadata(svgNode, layerData, viewer, renderer, dataModelVersion) {
  var meta = svgNode.childNodes[0].childNodes[0];

  var getMetaAttribute = function getMetaAttribute(attribute) {
    return meta.getAttribute(attribute) || meta.getAttribute(attribute.toLowerCase());
  };

  var type = getMetaAttribute('type') || '';

  var isLegacyMarkup = dataModelVersion < 5;
  var isLeaflet = viewer.model.isLeaflet();
  var isPdf = viewer.model.isPdf(true);

  var state = {
    style: {},
    anchors: [] };


  var output = {
    type: type,
    state: state };


  var getStyle = function getStyle(styleObj) {
    var source = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__.getObjectAsList)(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES);
    var style = {};

    for (var i = 0; i < source.length; i++) {
      var value = styleObj.getAttribute(source[i]);

      if (value) {
        switch (source[i]) {
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS:
            style[source[i]] = parseFloat(value);
            break;
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.OPACITY:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY:
            style[source[i]] = parseFloat(value);
            break;
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.STROKE_LINEJOIN:
            break;
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_FAMILY:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_STYLE:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_WEIGHT:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR:
          case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR:
            style[source[i]] = value;
            break;
          default:
            break;}

      }
    }

    if (!style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR]) {
      style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_COLOR] = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.COLOR];
    }

    if (!style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR]) {
      style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.COLORS.NO_COLOR;
    }

    // Support legacy markup extension - BLMV-3054.
    if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_COLOR] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.COLORS.NO_COLOR) {
      style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FILL_OPACITY;
    }

    return style;
  };

  var isClosed = function isClosed() {
    var path = svgNode.childNodes[1] || '';
    var closed = false;

    if (typeof path !== 'string') {
      var d = path.getAttribute('d').split(' ');
      if (d[d.length - 1].toLowerCase() === 'z') {
        closed = true;
      }
    }
    return closed;
  };

  var getLocations = function getLocations() {
    var locations = [];
    var attribute = getMetaAttribute('locations');
    var locStr = attribute && attribute.split(' ') || '';

    for (var i = 0; i < locStr.length; i += 2) {
      var point = new THREE.Vector3(parseFloat(locStr[i]), parseFloat(locStr[i + 1]), 0);
      locations.push(point);
    }

    return locations;
  };

  var getAttributeVector = function getAttributeVector(attribute) {
    var posVec = new THREE.Vector3();
    var value = getMetaAttribute(attribute);

    if (value) {
      var strPos = value.split(' ');

      posVec.x = strPos[0] && parseFloat(strPos[0]) || 0;
      posVec.y = strPos[1] && parseFloat(strPos[1]) || 0;
      posVec.z = strPos[2] && parseFloat(strPos[2]) || 0;
    }

    return posVec;
  };

  var getPosition = function getPosition() {
    return getAttributeVector('position');
  };

  var getSize = function getSize() {
    return getAttributeVector('size');
  };

  var getRotation = function getRotation() {
    var strRot = getMetaAttribute('rotation');
    return strRot && parseFloat(strRot) || 0;
  };

  var getText = function getText() {
    return getMetaAttribute('text') || '';
  };

  var getIsFrameUsed = function getIsFrameUsed() {
    return !!parseInt(getMetaAttribute('isFrameUsed'), 10);
  };

  var fixScalableShapeAnchors = function fixScalableShapeAnchors() {
    var halfThickness = state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] / 2;
    state.anchors[0].add(new THREE.Vector3(halfThickness, halfThickness, 0));
    state.anchors[1].add(new THREE.Vector3(-halfThickness, halfThickness, 0));
    state.anchors[2].add(new THREE.Vector3(-halfThickness, -halfThickness, 0));
    state.anchors[3].add(new THREE.Vector3(halfThickness, -halfThickness, 0));
  };

  var fixLegacyFontSize = function fixLegacyFontSize() {
    if (Object.prototype.hasOwnProperty.call(state.style, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE)) {
      // Fix font size for older markups by converting from world to font
      var scale = renderer.getFontToWorldScale();
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE] /= scale;
    }
  };

  var fixLegacyFill = function fixLegacyFill() {
    if (!state.isFrameUsed) {
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FILL_OPACITY] = 0;
    }
  };

  // Check if belongs to group
  var groupId = getMetaAttribute('groupId');
  if (groupId) {
    state.groupId = groupId;
    state.groupOrder = parseFloat(getMetaAttribute('groupOrder'));
  }
  // Check if it's a group
  var uuid = getMetaAttribute('uuid');
  if (uuid) {
    state.uuid = uuid;
  }

  state.style = getStyle(meta);
  state.position = getPosition();
  state.rotation = getRotation();
  state.size = getSize();

  if (!viewer.impl.is2d) {
    (0,_MarkupsSceneState__WEBPACK_IMPORTED_MODULE_1__.restoreMarkupViewState)(viewer, layerData, true);
  }

  var offset;

  switch (type) {
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE:
      state.anchors[0] = new THREE.Vector3(-state.size.x / 2, -state.size.y / 2, 0);
      state.anchors[1] = new THREE.Vector3(state.size.x / 2, -state.size.y / 2, 0);
      state.anchors[2] = new THREE.Vector3(state.size.x / 2, state.size.y / 2, 0);
      state.anchors[3] = new THREE.Vector3(-state.size.x / 2, state.size.y / 2, 0);
      if (isLegacyMarkup && type !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD) {
        fixScalableShapeAnchors(); // Legacy circle/rectangle markups grow inwards
      }
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_ARROW:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_LINE:
      state.anchors[0] = getAttributeVector('tail');
      state.anchors[1] = getAttributeVector('head');
      if (isLegacyMarkup) {
        state.rotation = 0;
      }
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_TEXT:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CALLOUT:
      state.text = getText();
      state.isFrameUsed = getIsFrameUsed();
      state.frameType = getMetaAttribute('frameType') || _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE;

      if (isLegacyMarkup) {
        fixLegacyFill();
      }

      state.anchors[0] = new THREE.Vector3(-state.size.x / 2, -state.size.y / 2, 0);
      state.anchors[1] = new THREE.Vector3(state.size.x / 2, -state.size.y / 2, 0);
      state.anchors[2] = new THREE.Vector3(state.size.x / 2, state.size.y / 2, 0);
      state.anchors[3] = new THREE.Vector3(-state.size.x / 2, state.size.y / 2, 0);
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_ARROW_CALLOUT:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_ARROW_CLOUD_CALLOUT:
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_HIGHLIGHT:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_FREEHAND:
      state.anchors = getLocations();
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYCLOUD:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYLINE:
      state.anchors = getLocations();
      state.closed = isClosed();
      break;

    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_DIMENSION:
      state.anchors[0] = getAttributeVector('firstAnchor');
      state.anchors[1] = getAttributeVector('secondAnchor');

      offset = getAttributeVector('offset');
      state.position.sub(offset);
      state.translation = markupsToWorld(offset, viewer, renderer, layerData).sub(markupsToWorld(new THREE.Vector3(), viewer, renderer, layerData));

      state.text = getText();

      if (isLegacyMarkup) {
        // Legacy dimension used half the thickness
        state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] /= 2;
      }

      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE] /= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_FONT_SIZE_FACTOR;
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] /= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;
      break;

    default:
      break;}


  if (isLegacyMarkup || isLeaflet || isPdf) {// For Leaflet we do it for new markups as well
    fixLegacyFontSize();
  }

  // Translate to position.
  (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_0__.applyTranslation)(state.anchors, state.position);

  // Conversion for legacy markups
  // For Leaflet we do it for new markups as well, to support exporting to PDF with markups included
  // Also, for Leaflet we have to make sure we support different DPIs from old versions.
  if (isLegacyMarkup && viewer.model.is3d() || isLeaflet || isPdf) {
    // Get the world position from the legacy markups coordinate system.
    state.anchors.forEach(function (anchor) {
      anchor.copy(markupsToWorld(anchor, viewer, renderer, layerData));
    });

    // Convert font and thickness sizes
    state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] = sizeFromMarkupsToWorld(state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS], viewer, renderer, layerData);
    state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE] = sizeFromMarkupsToWorld(state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.FONT_SIZE], viewer, renderer, layerData);
  }

  return output;
};

var getLayerDataModelVersion = function getLayerDataModelVersion(layerMetadata) {
  var versionAttr = layerMetadata.getAttribute('data-model-version');
  return typeof versionAttr === 'string' ? parseFloat(versionAttr) : 0;
};

var parseMarkupLayer = function parseMarkupLayer(svgString, layerData, viewer, renderer) {
  try {
    // data-model-version 6 and up saved as JSON.
    var metadata = JSON.parse(svgString);
    return metadata;
  } catch (e) {
    // data-model-version 5 and lower saved as SVG.
    var parentSvgNode = stringToSvgNode(svgString);
    var children = parentSvgNode.childNodes;

    var markups = [];

    var layerMetadata = children[0].childNodes[0];
    var dataModelVersion = getLayerDataModelVersion(layerMetadata);

    var viewerStateBackup = !viewer.impl.is2d ? viewer.getState() : null;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      var _metadata = child.childNodes[0].childNodes[0];
      if (_metadata) {
        var markup = parseMetadata(child, layerData, viewer, renderer, dataModelVersion);
        markups.push(markup);
      }
    }

    if (viewerStateBackup) {
      viewer.restoreState(viewerStateBackup, null, true);
    }

    return markups;
  }
};

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsEvents.js":
/*!************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsEvents.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MARKUPS_EVENTS": () => (/* binding */ MARKUPS_EVENTS)
/* harmony export */ });
var MARKUPS_EVENTS = {
  MARKUP_SESSION_START: 'markup.session.start', // Triggered when a markup session starts. Can be creation or edition of existing markup.
  MARKUP_SESSION_END: 'markup.session.end', // Triggered when a markup session ends. Can be creation or edition of existing markup.
  MARKUP_TOOL_ENABLED_CHANGED: 'markup.tool.enabled.changed', // Triggered when tool enabled / disabled. When disabled, all user interactions disabled.
  MARKUP_REMOVED: 'markup.removed', // Triggered when markup has been removed from the canvas.
  MARKUP_DRAWING_START: 'markup.drawing.start', // Triggered when markup drawing starts - The drawing itself.
  MARKUP_DRAWING_END: 'markup.drawing.end', // Triggered when markup drawing ends - When the user stops drawing.
  MARKUP_DRAWING_CANCEL: 'markup.drawing.cancel', // Triggered when markup drawing has been canceled.
  MARKUP_EDIT_START: 'markup.edit.start', // Triggered when a markup edit has started.
  MARKUP_EDIT_END: 'markup.edit.end', // Triggered when a markup edit has ended.
  MARKUP_SELECTED: 'markup.selected', // Triggered when a markup has been selected.
  MARKUP_DESELECTED: 'markup.deselected', // Triggered when a markup has been deselected.
  MARKUP_ENABLE_EDIT: 'markup.enable.edit', // Triggered when a markup edit is enabled. Used for user interactions.
  MARKUP_DISABLE_EDIT: 'markup.disable.edit', // Triggered when a markup edit is disabled.
  MARKUP_DIRTY: 'markup.dirty', // Triggered when a markup is dirty. Used for rendering.
  MARKUP_VISIBILITY_CHANGED: 'markup.visibility.changed', // Triggered when markup visibility changed. Invisible markups won't be rendered.
  MARKUP_VIEW_ENTERED: 'markup.view.entered', // Triggered when entering markup view (3D only). locks camera & navigation.
  MARKUP_VIEW_EXITED: 'markup.view.exited', // Triggered when exiting markup view (3D only). makes visible layers invisible, and unlock camera & navigation.
  TEXT_EDITING_STARTED: 'text.editing.started', // Triggered when text editing has been enabled. Used to notify when mobile keyboard turns on.
  TEXT_EDITING_ENDED: 'text.editing.ended', // Triggered when text editing has been disabled. Used to notify when mobile keyboard turns off.

  LAYER_DIRTY: 'layer.dirty', // Triggered when a layer is dirty. Used for rendering.
  LAYER_SELECTED: 'layer.selected', // Triggered when a layer has been selected.
  LAYER_DESELECTED: 'layer.deselected', // Triggered when a layer has been deselected.
  LAYER_SELECTED_FROM_DIFFERENT_SHEET: 'layer.selected.from.different.sheet', // Triggered when a layer has been selected, but it's not from the current sheet. Used to let the viewer observer to switch sheet and then select the layer.
  LAYER_EDITED_FROM_DIFFERENT_SHEET: 'layer.edited.from.different.sheet', // Triggered when a layer has been selected for editing, but it's not from the current sheet. Used to let the viewer observer to switch sheet and then edit the layer.
  LAYER_DELETE: 'layer.delete', // Triggered in order to signal the service operator to start deleting a layer.
  LAYER_DELETED: 'layer.deleted', // Triggered when a layer has been deleted from the backend.
  LAYER_PUBLISH: 'layer.publish', // Triggered in order to signal the service operator to start publishing a layer.
  LAYER_ARCHIVE: 'layer.archive', // Triggered in order to signal the service operator to start archiving a layer.
  LAYER_SYNCING: 'layer.syncing', // Triggered when a layer syncing with the backend has been started. Could be saving, editing, deleting or updating status.
  LAYER_SYNCED: 'layer.synced', // Triggered when a layer sync with the backend has been completed.
  LAYER_READY_TO_SAVE: 'layer.ready.to.save', // Triggered when a layer is ready for being saved. Used to enable / disable save button.
  LAYER_CREATED: 'layer.created', // Triggered when a layer is created.

  DOCUMENT_ATTACHMENT_CREATION_START: 'document.attachment.creation.start', // Triggered in order to signal the service operator to start create a new document attachment.
  DOCUMENT_ATTACHMENT_RENAME: 'document.attachment.rename', // Triggered in order to signal the service operator to start renaming a document attachment.
  DOCUMENT_ATTACHMENT_DELETE: 'document.attachment.delete', // Triggered in order to signal the service operator to start deleting a document attachment.

  LAYER_FETCHED: 'layer.fetched', // Triggered when a layer has been downloaded from the backend.
  LAYER_RESOURCE_FETCHED: 'layer.resource.fetched', // Triggered when a layer's resource has been downloaded from the backend.
  LAYER_THUMBNAIL_FETCHED: 'layer.thumbnail.fetched', // Triggered when a layer's thumbnail has been downloaded from the backend.
  LAYER_METADATA_FETCHED: 'layer.metadata.fetched', // Triggered when a layer's metadata has been downloaded from the backend.
  ATTACHMENT_THUMBNAIL_LOADED: 'attachment.thumbnail.loaded', // Triggered when an attachment thumbnail has been downloaded from the backend.
  ALL_MARKUPS_LOADED: 'all.markups.loaded', // Triggered when all markups have been loaded from the backend.
  PROJECT_USERS_FETCHED: 'project.users.fetched', // Triggered when the users' array has been fetched from the backend.

  LINK_DIRTY: 'link.dirty', // Triggered when a link icon is dirty. Used for rendering.
  LINK_SELECTED: 'link.selected', // Triggered when a link has been selected.
  LINK_DESELECTED: 'link.deselected', // Triggered when a link has been deselected.
  LINK_SYNCED: 'link.synced', // Triggered when a link sync with the backend has been completed.
  LINK_SYNCING: 'link.syncing', // Triggered when a link syncing with the backend has been started. Could be saving, editing, deleting or updating status.
  LINK_REMOVED: 'link.removed', // Triggered when link has been removed from the canvas.
  LINK_RENDERED: 'link.rendered', // Triggered after a link icon has been rendered.

  FILTER_CHANGED: 'filter.changed', // Triggered when a filter has been changed.
  BUTTON_DOWN: 'button.down', // Triggered when the user clicked somewhere on the canvas. Used to notify menus to close submenus.
  MARKUP_CREATION_TYPE_CHANGED: 'markup.creation.type.changed', // Triggered when the selected markup tool has changed. (i.e. polyline, arrow).
  MARKUP_STYLE_PROPERTY_CHANGED: 'markup.style.property.changed', // Triggered when style property has been changed. Affect the toolbar and contextual menu style buttons.

  LAYER_DISCARD_PRESSED: 'layer.discard.pressed', // Triggered when 'discard markup' has been selected by the user.
  LAYER_PUBLISH_PRESSED: 'layer.publish.pressed', // Triggered when 'publish markup' has been selected by the user.
  LAYER_ARCHIVE_PRESSED: 'layer.archive.pressed', // Triggered when 'archive markup' has been selected by the user.
  LAYER_DELETE_PRESSED: 'layer.delete.pressed', // Triggered when 'delete markup' has been selected by the user.
  LAYER_DELETE_EMPTY_PRESSED: 'layer.delete.empty.pressed', // Triggered when 'save markup' has been selected by the user, while the layer is empty.
  EXIT_VIEWER_PRESSED: 'exit.viewer.pressed', // Triggered when exiting the viewer, while the layer is still in saving process.

  RECT_SELECTOR_UPDATED: 'rect.selector.updated', // Triggered when a rect selector frame changed.
  CALIBRATION_REQUIRED: 'calibration.required' // Triggered when trying to create a measure markup, and the document requires calibration first
};

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsLayer.js":
/*!***********************************************!*\
  !*** ./extensions/BimMarkups/MarkupsLayer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsLayer)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupTypes/Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsLayerData */ "./extensions/BimMarkups/MarkupsLayerData.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _Links_Link__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Links/Link */ "./extensions/BimMarkups/Links/Link.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var

MarkupsLayer = /*#__PURE__*/function () {
  function MarkupsLayer(markupsExtension, id, layerData) {_classCallCheck(this, MarkupsLayer);
    this.markupsExtension = markupsExtension;
    this.id = id;
    this.layerData = !layerData || layerData instanceof _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_3__["default"] ? layerData : new _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_3__["default"](layerData.guid, layerData.resources, layerData.attachments, layerData.status, layerData.metadata);

    this.markups = {};
    this.links = {};

    this.selected = false;
    this.visible = false;
    this.transparent = false;
    this.hover = false;
  }_createClass(MarkupsLayer, [{ key: "addMarkup", value: function addMarkup(

    markup) {
      this.markups[markup.id] = markup;
      markup.layer = this;

      markup.setVisible(this.visible, true);
    } }, { key: "deleteMarkup", value: function deleteMarkup(

    markup) {
      var markupId = markup instanceof _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_1__["default"] ? markup.id : markup;

      if (this.markups[markupId]) {
        markup.deselect();

        delete this.markups[markupId];
        markup.remove();
        markup.layer = null;

        this.setDirty();
      } else {
        console.warn('deleteMarkup - markup does not exist');
      }
    } }, { key: "deleteAllMarkups", value: function deleteAllMarkups()

    {var _this = this;
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.forAll)(this.markups, function (markup) {
        _this.deleteMarkup(markup);
      });
    } }, { key: "getMarkupById", value: function getMarkupById(

    markupId) {
      return this.markups[markupId];
    } }, { key: "isEmpty", value: function isEmpty()

    {
      return Object.keys(this.markups).length === 0;
    } }, { key: "addLink", value: function addLink(

    link) {
      this.links[link.id] = link;
    } }, { key: "deleteLink", value: function deleteLink(

    link) {
      var linkId = link instanceof _Links_Link__WEBPACK_IMPORTED_MODULE_6__["default"] ? link.id : link;

      if (this.links[linkId]) {
        this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_4__.MARKUPS_EVENTS.LINK_REMOVED, link: link });
        delete this.links[linkId];
      } else {
        console.warn('deleteLink - markup does not exist');
      }
    } }, { key: "deleteAllLinks", value: function deleteAllLinks()

    {var _this2 = this;
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.forAll)(this.links, function (link) {
        _this2.deleteLink(link);
      });
    } }, { key: "getLinkById", value: function getLinkById(

    linkId) {
      return this.links[linkId];
    } }, { key: "getClientBoundingBox", value: function getClientBoundingBox(

    withMargin) {
      var boundingBox = this.getWorldBoundingBox();

      boundingBox.min = this.markupsExtension.renderer.worldToClient(boundingBox.min);
      boundingBox.max = this.markupsExtension.renderer.worldToClient(boundingBox.max);

      var eyeDirection = this.markupsExtension.renderer.getCameraEyeVector();
      var center = boundingBox.getCenter(new THREE.Vector3());

      var cameraRotation = this.markupsExtension.renderer.getCameraRotation();

      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(boundingBox.min, cameraRotation, center, eyeDirection);
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(boundingBox.max, cameraRotation, center, eyeDirection);

      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].swapBoundingBoxY(boundingBox);

      if (withMargin) {
        var margin = this.getMarginSize();
        boundingBox.expandByVector(new THREE.Vector3(margin, margin, 0));
      }

      boundingBox.min.z = 0;
      boundingBox.max.z = 0;

      return boundingBox;
    } }, { key: "getMarginSize", value: function getMarginSize()

    {
      return _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.BOUNDING_BOX_MARGIN;
    } }, { key: "getWorldBoundingBox", value: function getWorldBoundingBox()

    {
      var boundingBox = new THREE.Box3();

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.forAll)(this.markups, function (markup) {
        var bbox = markup.getWorldBoundingBox(true);
        boundingBox.union(bbox);
      });

      return boundingBox;
    } }, { key: "getRotation", value: function getRotation()

    {
      return 0;
    } }, { key: "getAllMarkups", value: function getAllMarkups()

    {
      return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.getObjectAsList)(this.markups);
    } }, { key: "getAllLinks", value: function getAllLinks()

    {
      return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.getObjectAsList)(this.links);
    } }, { key: "hasSingleMarkup", value: function hasSingleMarkup()

    {
      return this.getAllMarkups().length === 1;
    } }, { key: "select", value: function select()

    {
      this.selected = true;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_4__.MARKUPS_EVENTS.LAYER_SELECTED, layer: this });
      this.setDirty();
    } }, { key: "deselect", value: function deselect()

    {
      this.selected = false;
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_4__.MARKUPS_EVENTS.LAYER_DESELECTED, layer: this });
      this.setDirty();
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.selected;
    } }, { key: "setHover", value: function setHover(

    hover) {
      if (this.hover !== hover) {
        this.hover = hover;

        this.getAllLinks().forEach(function (link) {
          link.setHover(hover);
        });

        this.setDirty();
      }
    } }, { key: "isHovered", value: function isHovered()

    {
      return this.hover;
    } }, { key: "unhoverAllMarkups", value: function unhoverAllMarkups()

    {
      var markups = this.getAllMarkups();
      markups.forEach(function (markup) {
        markup.setHover(false);
      });
    } }, { key: "setVisible", value: function setVisible(

    isVisible) {
      this.visible = isVisible;
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_5__.forAll)(this.markups, function (markup) {
        markup.setVisible(isVisible);
      });
      this.setDirty();
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.visible;
    } }, { key: "setDirty", value: function setDirty()

    {
      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_4__.MARKUPS_EVENTS.LAYER_DIRTY, layer: this });
    } }, { key: "getGuid", value: function getGuid()

    {
      return this.layerData && this.layerData.guid;
    } }, { key: "selectAllMarkups", value: function selectAllMarkups()

    {
      this.getAllMarkups().forEach(function (markup) {
        markup.select();
      });
    } }, { key: "changeTransparency", value: function changeTransparency(

    transparent) {
      this.transparent = transparent;

      this.getAllMarkups().forEach(function (markup) {
        markup.changeTransparency(transparent);
      });
    } }, { key: "isTransparent", value: function isTransparent()

    {
      return this.transparent;
    } }, { key: "enable", value: function enable()

    {
      this.getAllMarkups().forEach(function (markup) {
        markup.enable();
      });
    } }, { key: "disable", value: function disable()

    {
      this.getAllMarkups().forEach(function (markup) {
        markup.disable();
      });
    } }]);return MarkupsLayer;}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsLayerData.js":
/*!***************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsLayerData.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsLayerData)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var MarkupsLayerData = /*#__PURE__*/function () {
  function MarkupsLayerData(guid, resources, attachments, status, metadata) {_classCallCheck(this, MarkupsLayerData);
    this.guid = guid;
    this.resources = resources || [];
    this.attachments = attachments || [];
    this.status = status;
    this.metadata = metadata || {};
  }_createClass(MarkupsLayerData, [{ key: "getSvgResource", value: function getSvgResource()

    {
      return this.resources[0] && this.resources[0].data;
    } }, { key: "getScreenCaptureResource", value: function getScreenCaptureResource()

    {
      return this.resources[1] && this.resources[1].data;
    } }, { key: "getLinksMetadata", value: function getLinksMetadata()

    {
      return this.metadata && this.metadata.markup_metadata && this.metadata.markup_metadata.links;
    } }, { key: "getMetadata", value: function getMetadata()

    {
      return this.metadata;
    } }]);return MarkupsLayerData;}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsManager.js":
/*!*************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsManager.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsManager)
/* harmony export */ });
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/ActionManager/ActionManager */ "./extensions/BimMarkups/Utils/ActionManager/ActionManager.js");
/* harmony import */ var _MarkupsLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsLayer */ "./extensions/BimMarkups/MarkupsLayer.js");
/* harmony import */ var _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupTypes/Markup */ "./extensions/BimMarkups/MarkupTypes/Markup.js");
/* harmony import */ var _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MarkupTypes/MarkupsTypesDictionary */ "./extensions/BimMarkups/MarkupTypes/MarkupsTypesDictionary.js");
/* harmony import */ var _Links_LinkTypesDictionary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Links/LinkTypesDictionary */ "./extensions/BimMarkups/Links/LinkTypesDictionary.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsDeserializer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MarkupsDeserializer */ "./extensions/BimMarkups/MarkupsDeserializer.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _Actions_AddMarkupAction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Actions/AddMarkupAction */ "./extensions/BimMarkups/Actions/AddMarkupAction.js");
/* harmony import */ var _MarkupsSceneState__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MarkupsSceneState */ "./extensions/BimMarkups/MarkupsSceneState.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}










var

MarkupsManager = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(MarkupsManager, _Autodesk$Viewing$Eve);var _super = _createSuper(MarkupsManager);
  function MarkupsManager(markupsExtension) {var _this;_classCallCheck(this, MarkupsManager);
    _this = _super.call(this);

    _this.markupsExtension = markupsExtension;
    _this.actionManager = new _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"]();

    _this.registerEvents();
    _this.reset();return _this;
  }_createClass(MarkupsManager, [{ key: "registerEvents", value: function registerEvents()

    {
      this.onHistoryChangedBinded = this.onHistoryChanged.bind(this);
      this.actionManager.addEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChangedBinded);

      this.onAllMarkupsLoadedBinded = this.onAllMarkupsLoaded.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.ALL_MARKUPS_LOADED, this.onAllMarkupsLoadedBinded);

      this.onMarkupLayerFetchedBinded = this.onMarkupLayerFetched.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_FETCHED, this.onMarkupLayerFetchedBinded);

      this.onMarkupResourceFetchedBinded = this.onMarkupResourceFetched.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_RESOURCE_FETCHED, this.onMarkupResourceFetchedBinded);

      this.onMarkupLinkSyncedBinded = this.onMarkupLinkSynced.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LINK_SYNCED, this.onMarkupLinkSyncedBinded);

      this.onLayerSyncedBinded = this.onLayerSynced.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SYNCED, this.onLayerSyncedBinded);

      this.onLayerSyncingBinded = this.onLayerSyncing.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SYNCING, this.onLayerSyncingBinded);

      this.onLayerSelectedBinded = this.onLayerSelected.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SELECTED, this.onLayerSelectedBinded);

      this.onLayerDeselectedBinded = this.onLayerDeselected.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_DESELECTED, this.onLayerDeselectedBinded);

      this.onCalibrationEndedBinded = this.onCalibrationEnded.bind(this);
      this.markupsExtension.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.FINISHED_CALIBRATION_FOR_DIMENSION_EVENT, this.onCalibrationEndedBinded);

      this.onDrawingStartBinded = this.onDrawingStart.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_START, this.onDrawingStartBinded);

      this.onDrawingEndBinded = this.onDrawingEnd.bind(this);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onDrawingEndBinded);
      this.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.onDrawingEndBinded);
    } }, { key: "unregisterEvents", value: function unregisterEvents()

    {
      this.actionManager.removeEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChangedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.ALL_MARKUPS_LOADED, this.onAllMarkupsLoadedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_FETCHED, this.onMarkupLayerFetchedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_RESOURCE_FETCHED, this.onMarkupResourceFetchedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LINK_SYNCED, this.onMarkupLinkSyncedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SYNCED, this.onLayerSyncedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SYNCING, this.onLayerSyncingBinded);
      this.markupsExtension.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.FINISHED_CALIBRATION_FOR_DIMENSION_EVENT, this.onCalibrationEndedBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_START, this.onDrawingStartBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onDrawingEndBinded);
      this.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.onDrawingEndBinded);
    } }, { key: "createLayer", value: function createLayer(

    layerJson) {
      var layer = new _MarkupsLayer__WEBPACK_IMPORTED_MODULE_2__["default"](this.markupsExtension, this.nextLayerId, layerJson);
      this.layers[layer.id] = layer;

      this.nextLayerId += 1;

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_CREATED });
      return layer;
    } }, { key: "loadLayers", value: function loadLayers(

    layersJson, ignoreFilters, removeExistingLayers) {var _this2 = this;
      if (removeExistingLayers) {
        this.removeAllLayers([this.getActiveLayer()]);

        if (this.markupsExtension.markupsCache) {
          this.markupsExtension.markupsCache.cleanCache();
        }
      }

      layersJson = layersJson instanceof Array ? layersJson : [layersJson];

      layersJson.forEach(function (layerJson) {
        // Add layer to cache if it's not there
        if (_this2.markupsExtension.markupsCache && layerJson.guid && !_this2.markupsExtension.markupsCache.get(layerJson.guid)) {
          _this2.markupsExtension.markupsCache.add(layerJson.guid, layerJson);
        }
      });

      var layersFiltered = ignoreFilters ? layersJson : this.markupsExtension.filterManager.filterLayers(layersJson);

      // Remove filtered out layers that currently on canvas.
      this.getLayersAsList().forEach(function (layer) {
        if (layer !== _this2.getActiveLayer() && layersFiltered.findIndex(function (l) {return l.guid === layer.getGuid();}) === -1) {
          _this2.removeLayer(layer);
        }
      });

      // Add new layers that was added to canvas.
      layersFiltered.forEach(function (layerJson) {
        if (!_this2.getLayerByGuid(layerJson.guid)) {
          var layer = _this2.createLayer(layerJson);

          if (_this2.markupsExtension.viewer.impl.is2d) {
            layer.setVisible(true);
            _this2.loadMarkupsToLayer(layer);
          }

          _this2.loadLinksToLayer(layer);
        }
      });
    } }, { key: "removeLayer", value: function removeLayer(

    layer) {
      var layerId = layer.id;
      var layerToDelete = this.layers[layerId];

      if (layerToDelete) {
        if (this.isMarkupSessionOpen() && layerToDelete === this.getActiveLayer()) {
          this.endMarkupSession(false);
        } else if (this.markupsExtension.viewer.model && this.markupsExtension.viewer.model.is3d() && this.isInMarkupView() && this.getVisibleLayers()[0] === layerToDelete) {
          this.exitMarkupView();
        }

        this.deselectLayer(layer);
        layer.deleteAllMarkups();
        layer.deleteAllLinks();
        layer.setVisible(false);

        this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_DELETED, layer: layer });
        delete this.layers[layerId];
      } else {
        console.warn('deleteLayer - layer does not exist');
      }
    } }, { key: "removeAllLayers", value: function removeAllLayers(

    exclude) {var _this3 = this;
      this.getLayersAsList().forEach(function (layer) {
        if (!exclude || exclude.indexOf(layer) === -1) {
          _this3.removeLayer(layer);
        }
      });
    } }, { key: "deleteLayer", value: function deleteLayer(

    layer) {
      // Delete the layer from backend.
      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_DELETE, layerData: layer.layerData });
    } }, { key: "getLayerById", value: function getLayerById(

    layerId) {
      return this.layers[layerId];
    } }, { key: "getLayerByGuid", value: function getLayerByGuid(

    layerGuid) {
      if (layerGuid === null || layerGuid === undefined) {
        return null;
      }

      return this.getLayersAsList().find(function (layer) {return layer.getGuid() === layerGuid;});
    } }, { key: "addMarkupToLayer", value: function addMarkupToLayer(

    markup, layer) {
      if (!this.getLayerById(layer.id)) {
        this.layers[layer.id] = layer;
      }

      // If other layer is selected, make new markup transparent.
      if (this.getSelectedLayers().length > 0 && !layer.isSelected()) {
        markup.changeTransparency(true);
      }

      // If other layer is under edit session, make new markup transparent.
      if (this.isMarkupSessionOpen() && layer !== this.getActiveLayer() || !this.isToolEnabled()) {
        markup.disable();
      }

      layer.addMarkup(markup);
      return true;
    } }, { key: "addLinkToLayer", value: function addLinkToLayer(

    link, layer) {
      if (!this.getLayerById(layer.id)) {
        this.layers[layer.id] = layer;
      }

      layer.addLink(link);
      return true;
    } }, { key: "createMarkup", value: function createMarkup(

    type, optionalState, options) {
      var MarkupClass = _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_4__.markupsTypesDictionary[type];

      if (MarkupClass) {
        return new MarkupClass(this.markupsExtension, this.nextMarkupId++, optionalState, options);
      }

      return null;
    } }, { key: "createLink", value: function createLink(

    layer, linkMetadata) {
      var position = linkMetadata.position ? new THREE.Vector3().copy(linkMetadata.position) : null;

      if (position && this.markupsExtension.viewer.model.isPdf(true)) {
        Autodesk.Viewing.PDFUtils.leafletToPdfWorld(this.markupsExtension.viewer, position);
      }

      var link = new _Links_LinkTypesDictionary__WEBPACK_IMPORTED_MODULE_5__.linkTypesDictionary[linkMetadata.type](this.markupsExtension, this.nextLinkId, linkMetadata.id, layer, { position: position });
      this.nextLinkId += 1;
      return link;
    } }, { key: "onAllMarkupsLoaded", value: function onAllMarkupsLoaded(_ref)

    {var amount = _ref.amount;
      console.log('All markups have been loaded. Amount: ' + amount);
    } }, { key: "onMarkupLayerFetched", value: function onMarkupLayerFetched(_ref2)

    {var _this4 = this;var layerData = _ref2.layerData;
      this.markupsExtension.filterManager.filterLayers([layerData]).forEach(function (data) {
        var layer = _this4.createLayer(data);

        if (_this4.markupsExtension.viewer.impl.is2d) {
          layer.setVisible(true);
        }
      });
    } }, { key: "onMarkupResourceFetched", value: function onMarkupResourceFetched(_ref3)

    {var layerData = _ref3.layerData;
      if (this.markupsExtension.viewer.impl.is2d) {
        var layer = this.getLayerByGuid(layerData.guid);

        if (layer) {
          this.loadMarkupsToLayer(layer);
        }
      }
    } }, { key: "onMarkupLinkSynced", value: function onMarkupLinkSynced(_ref4)

    {var documentAttachment = _ref4.documentAttachment,layerData = _ref4.layerData;
      var layer = this.getLayerByGuid(layerData.guid);

      if (layer) {
        if (documentAttachment && documentAttachment.status === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.MARKUP_ATTACHMENT_DELETEING &&
        layerData.attachments.length === 0) {
          layer.deleteAllLinks();
        }
        this.loadLinksToLayer(layer);
      }
    } }, { key: "onDrawingStart", value: function onDrawingStart()

    {
      var duringCreationMarkup = this.getDuringCreationMarkup(false);
      this.polySaveDisabled = duringCreationMarkup && duringCreationMarkup.inEdit && (
      duringCreationMarkup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.MARKUP_TYPE_POLYLINE ||
      duringCreationMarkup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.MARKUP_TYPE_POLYCLOUD);

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_READY_TO_SAVE, readyToSave: this.getReadyToSave() });
    } }, { key: "onDrawingEnd", value: function onDrawingEnd()

    {
      this.polySaveDisabled = false;

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_READY_TO_SAVE, readyToSave: this.getReadyToSave() });
    } }, { key: "getReadyToSave", value: function getReadyToSave()

    {
      var activeLayer = this.getActiveLayer();
      var isEmpty;
      var hasEmptyText;

      if (activeLayer) {
        isEmpty = activeLayer.isEmpty();

        if (!isEmpty) {
          // Don't allow saving empty text.
          hasEmptyText = activeLayer.getAllMarkups().some(function (markup) {
            return markup.isTextMarkup() && markup.textInputHandler.isEmpty();
          });
        }
      }

      // For mobile, disable save button if the layer is empty.
      // For web, enable the save button in case of an empty layer, what will trigger a deletion of the layer (in case the user has permissions)
      var emptynessCondition = this.markupsExtension.options.isMobileApp ?
      !isEmpty :
      !isEmpty || isEmpty && this.markupsExtension.permissionManager.canDeleteMarkup(activeLayer.layerData);
      var ready = activeLayer && emptynessCondition && !this.polySaveDisabled && !hasEmptyText;

      return !!ready;
    } }, { key: "removeMarkupFromLayer", value: function removeMarkupFromLayer(

    markup) {
      var layer = markup.layer;

      if (layer) {
        this.duringCreationMarkup = null;

        markup.deselect();
        markup.disableEdit();
        layer.deleteMarkup(markup);

        return true;
      } else {
        console.warn('removeMarkupFromLayer - markup does not exist');
        return false;
      }
    } }, { key: "getMarkupById", value: function getMarkupById(

    markupId) {
      var markup = null;

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(this.layers, function (l) {
        var m = l.getMarkupById(markupId);

        if (m) {
          markup = m;
        }
      });

      return markup;
    } }, { key: "getSelectedMarkups", value: function getSelectedMarkups()

    {
      return this.getMarkupsByProperty('selected', true);
    } }, { key: "getUnselectedMarkups", value: function getUnselectedMarkups()

    {
      return this.getMarkupsByProperty('selected', false);
    } }, { key: "getSelectedLayers", value: function getSelectedLayers()

    {
      return this.getLayersByProperty('selected', true);
    } }, { key: "getUnselectedLayers", value: function getUnselectedLayers()

    {
      return this.getLayersByProperty('selected', false);
    } }, { key: "getSelectedLayer", value: function getSelectedLayer()

    {
      return this.getSelectedLayers()[0];
    } }, { key: "getVisibleLayers", value: function getVisibleLayers()

    {
      return this.getLayersByProperty('visible', true);
    } }, { key: "getVisibleMarkups", value: function getVisibleMarkups()

    {
      return this.getMarkupsByProperty('visible', true);
    } }, { key: "getEnabledMarkups", value: function getEnabledMarkups()

    {
      return this.getMarkupsByProperty('enabled', true).filter(function (markup) {return !markup.layer || markup.layer.isVisible();});
    } }, { key: "getDisabledMarkups", value: function getDisabledMarkups()

    {
      return this.getMarkupsByProperty('enabled', false);
    } }, { key: "getVisibleLinks", value: function getVisibleLinks()

    {
      var visibleLayers = this.getVisibleLayers();
      var res = [];
      visibleLayers.forEach(function (layer) {
        var links = layer.getAllLinks();
        links.forEach(function (link) {
          res.push(link);
        });
      });

      return res;
    } }, { key: "getDirtyLinks", value: function getDirtyLinks()

    {
      return this.getLinksByProperty('dirty', true);
    } }, { key: "getSelectedLinks", value: function getSelectedLinks()

    {
      return this.getLinksByProperty('selected', true);
    } }, { key: "getInEditMarkups", value: function getInEditMarkups()

    {
      var inEditMarkups = this.getMarkupsByProperty('inEdit', true);

      if (this.duringCreationMarkup && inEditMarkups.indexOf(this.duringCreationMarkup) === -1) {
        inEditMarkups.push(this.duringCreationMarkup);
      }

      return inEditMarkups;
    } }, { key: "getMarkupsByProperty", value: function getMarkupsByProperty(

    key, value) {
      var markups = [];

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(this.layers, function (l) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(l.markups, function (m) {
          if (m[key] === value) {
            markups.push(m);
          }
        });
      });

      return markups;
    } }, { key: "getLayersByProperty", value: function getLayersByProperty(

    key, value) {
      var layers = [];

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(this.layers, function (l) {
        if (l[key] === value) {
          layers.push(l);
        }
      });

      return layers;
    } }, { key: "getLinksByProperty", value: function getLinksByProperty(

    key, value) {
      var links = [];

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(this.layers, function (l) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(l.links, function (m) {
          if (m[key] === value) {
            links.push(m);
          }
        });
      });

      return links;
    } }, { key: "selectMarkup", value: function selectMarkup(

    markup) {
      markup = markup instanceof _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_3__["default"] ? markup : this.getMarkupById(markup);

      if (markup) {
        markup.select();
      } else {
        console.warn('selectMarkup - markup does not exist');
      }
    } }, { key: "deselectMarkup", value: function deselectMarkup(

    markup) {
      markup = markup instanceof _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_3__["default"] ? markup : this.getMarkupById(markup);

      if (markup) {
        markup.deselect();
      } else {
        console.warn('selectMarkup - markup does not exist');
      }
    } }, { key: "deselectAllMarkups", value: function deselectAllMarkups(

    exclude) {
      var selectedMarkups = this.getSelectedMarkups();
      selectedMarkups.forEach(function (markup) {
        if ((!exclude || exclude.indexOf(markup) === -1) && markup.isSelected()) {
          markup.deselect();
        }
      });
    } }, { key: "unhoverAllLayers", value: function unhoverAllLayers()

    {
      var layers = this.getLayersAsList();
      layers.forEach(function (layer) {
        layer.setHover(false);
      });
    } }, { key: "unhoverAllMarkups", value: function unhoverAllMarkups()

    {
      var markups = this.getAllMarkups();
      markups.forEach(function (markup) {
        markup.setHover(false);
      });
    } }, { key: "enableAllMarkups", value: function enableAllMarkups()

    {
      this.getAllMarkups().forEach(function (markup) {
        markup.enable();
      });
    } }, { key: "disableAllMarkups", value: function disableAllMarkups()

    {
      this.getAllMarkups().forEach(function (markup) {
        markup.disable();
      });
    } }, { key: "lockNavigation", value: function lockNavigation()

    {
      if (!this.lockSettings) {
        this.lockSettings = this.markupsExtension.viewer.getNavigationLockSettings();
        this.markupsExtension.viewer.setNavigationLockSettings({
          orbit: false, pan: false, zoom: false, roll: false, fov: false, gotoview: false, walk: false });

        this.markupsExtension.viewer.navigation.setIsLocked(true);
      }

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_VIEW_ENTERED });
    } }, { key: "unlockNavigation", value: function unlockNavigation()

    {
      if (this.lockSettings) {
        this.markupsExtension.viewer.setNavigationLockSettings(this.lockSettings);
        this.markupsExtension.viewer.setNavigationLock(false);
        this.markupsExtension.viewer.toolController.setIsLocked(false);
        this.lockSettings = null;
      }
    } }, { key: "loadLayerIfHidden", value: function loadLayerIfHidden(

    layerGuid) {
      var layer = layerGuid instanceof _MarkupsLayer__WEBPACK_IMPORTED_MODULE_2__["default"] ? layerGuid : this.getLayerByGuid(layerGuid);

      // In case the layer is hidden because of a filter, load it and then select it.
      if (!layer && this.markupsExtension.markupsCache) {
        var layerData = this.markupsExtension.markupsCache.get(layerGuid);

        if (layerData) {
          var sheetNameInMarkup = layerData.metadata.markup_metadata.sheetName;

          // Different sheet - don't load layer here.
          if (!(0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.isSheetNameEqual)(this.markupsExtension.options.sheetName, sheetNameInMarkup)) {
            layerData = null;
          }
        }

        if (layerData) {
          this.loadLayers([layerData], true);
          layer = this.getLayerByGuid(layerGuid);
        }
      }

      return layer;
    } }, { key: "selectLayer", value: function selectLayer(

    layerGuid, focus, immediate) {var _this5 = this;var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
      var layer = this.loadLayerIfHidden(layerGuid);
      var onSelectionDone = cb.bind(this);

      if (layer) {
        var wasSelected = layer.isSelected();
        this.deselectAllLayers([layer]);
        this.exitMarkupView([layer]);

        if (this.markupsExtension.viewer.impl.is2d) {
          layer.select();

          if (focus) {
            var marginBackup = {
              horizontal: this.markupsExtension.viewer.navigation.FIT_TO_VIEW_HORIZONTAL_MARGIN,
              vertical: this.markupsExtension.viewer.navigation.FIT_TO_VIEW_VERTICAL_MARGIN };


            // Change global bounds margins.
            this.markupsExtension.viewer.navigation.FIT_TO_VIEW_HORIZONTAL_MARGIN = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.SELECTION_ZOOM_MARGIN;
            this.markupsExtension.viewer.navigation.FIT_TO_VIEW_VERTICAL_MARGIN = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.SELECTION_ZOOM_MARGIN;

            var boundingBox = layer.getWorldBoundingBox();
            this.markupsExtension.viewer.navigation.fitBounds(immediate, boundingBox);

            // Restore global bounds margins.
            this.markupsExtension.viewer.navigation.FIT_TO_VIEW_HORIZONTAL_MARGIN = marginBackup.horizontal;
            this.markupsExtension.viewer.navigation.FIT_TO_VIEW_VERTICAL_MARGIN = marginBackup.vertical;
          }

          onSelectionDone();
        } else {
          this.loadMarkupsToLayer(layer);
          layer.select();
          this.navigationToolBackup = this.markupsExtension.viewer.getActiveNavigationTool();
          this.markupsExtension.viewer.setActiveNavigationTool(this.markupsExtension.markupsTool.getName());

          (0,_MarkupsSceneState__WEBPACK_IMPORTED_MODULE_10__.restoreMarkupViewState)(this.markupsExtension.viewer, layer.layerData, immediate || wasSelected, function () {
            if (layer.isSelected()) {
              layer.setVisible(true);
              _this5.lockNavigation();
            }

            onSelectionDone();
          });
        }
      } else {
        this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_SELECTED_FROM_DIFFERENT_SHEET, layerGuid: layerGuid });
        var cache = this.markupsExtension.cache; // Must get the cache because when loading sheet, extension will be gone
        cache.layerToSelect = this.loadRelevantSheet(layerGuid);
      }
    } }, { key: "deselectLayer", value: function deselectLayer(

    layer) {
      layer = layer instanceof _MarkupsLayer__WEBPACK_IMPORTED_MODULE_2__["default"] ? layer : this.getLayerByGuid(layer);

      if (layer) {
        if (layer.isSelected()) {
          layer.deselect();

          if (layer.layerData) {
            // In case layer was hidden before selection, hide it.
            if (this.markupsExtension.filterManager.filterLayers([layer.layerData]).length === 0) {
              this.removeLayer(layer);
            }
          }
        }
      } else {
        console.warn('deselectLayer - layer does not exist');
      }
    } }, { key: "deselectAllLayers", value: function deselectAllLayers(

    exclude) {var _this6 = this;
      var selectedLayers = this.getSelectedLayers();
      selectedLayers.forEach(function (layer) {
        if ((!exclude || exclude.indexOf(layer) === -1) && layer.isSelected()) {
          _this6.deselectLayer(layer);
        }
      });
    } }, { key: "loadRelevantSheet", value: function loadRelevantSheet(

    layerGuid) {var _this7 = this;
      var doLoadSheet = function doLoadSheet(key, value) {
        for (var i = 0; i < _this7.markupsExtension.sheetList.length; i++) {
          var s = _this7.markupsExtension.sheetList[i];
          var sheet = s.search(_defineProperty({}, key, value))[0];

          if (sheet) {
            if (_this7.markupsExtension.options.loadDocumentCallback) {
              _this7.markupsExtension.options.loadDocumentCallback(sheet);
            } else {
              _this7.markupsExtension.viewer.loadDocumentNode(_this7.markupsExtension.viewer.model.getDocumentNode().getDocument(),
              sheet,
              { loadAsHidden: false, applyRefPoint: false, keepCurrentModels: false });
            }

            return layerGuid;
          }
        }

        console.warn("loadRelevantSheet - Sheet not found (by ".concat(key, ")"));
        return null;
      };

      var doLoadSheetByName = function doLoadSheetByName() {
        var sheetNameInMarkup = layer.metadata.markup_metadata.sheetName;

        // Same sheet.
        if (!sheetNameInMarkup || (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.isSheetNameEqual)(_this7.sheetName, sheetNameInMarkup)) {
          return;
        }

        // Different name - switch sheet.
        return doLoadSheet('name', sheetNameInMarkup);
      };

      var layer = this.markupsExtension.markupsCache.get(layerGuid);

      if (!layer) {
        console.warn('loadRelevantSheet - Cant find selected layer.');
        return null;
      }

      if (!this.markupsExtension.options.hasMultiSheet) {
        console.warn('loadRelevantSheet - Something weird just happened. This method shouldnt be called on Plans folder.');
        return;
      }

      return doLoadSheetByName();
    } }, { key: "isInMarkupView", value: function isInMarkupView()

    {
      var visibleLayers = this.getVisibleLayers();
      return !this.isMarkupSessionOpen() && visibleLayers.length > 0;
    } }, { key: "exitMarkupView", value: function exitMarkupView(

    exclude) {var _this8 = this;
      if (this.markupsExtension.viewer.impl.is2d || !this.isInMarkupView()) {
        return;
      }

      var visibleLayers = this.getVisibleLayers();
      if (exclude) {
        visibleLayers = visibleLayers.filter(function (layer) {return exclude.indexOf(layer) === -1;});
      }

      if (visibleLayers.length === 0) {
        return;
      }

      visibleLayers.forEach(function (layer) {
        _this8.deselectLayer(layer);
        layer.setVisible(false);
      });

      this.unlockNavigation();
      this.markupsExtension.viewer.setActiveNavigationTool(this.navigationToolBackup);

      var sectionExt = this.markupsExtension.viewer.getExtension('Autodesk.Section');

      if (sectionExt && sectionExt.getSectionPlanes().length === 1) {
        sectionExt.setSectionFromPlane(null);
      } else {
        this.markupsExtension.viewer.impl.setCutPlaneSet('__set_view', undefined);
      }

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_VIEW_EXITED });
    } }, { key: "changeAllLayersTransparency", value: function changeAllLayersTransparency(

    isTransparent, exclude) {
      if (this.markupsExtension.isToolEnabled()) {
        var layers = this.getLayersAsList();
        layers.forEach(function (layer) {
          if (!exclude || exclude.indexOf(layer) === -1) {
            layer.changeTransparency(isTransparent);
          }
        });
      }
    } }, { key: "onLayerSynced", value: function onLayerSynced(_ref5)

    {var layerData = _ref5.layerData,layer = _ref5.layer;
      layer = layer || this.getLayerByGuid(layerData.guid);

      if (layer) {
        // Verify there is no markup session active currently, before enabling the layer.
        if (!this.isMarkupSessionOpen()) {
          layer.enable();

          var selectedLayer = this.getSelectedLayer();

          if (selectedLayer && selectedLayer !== layer || !this.markupsExtension.isToolEnabled()) {
            layer.changeTransparency(true);
          }
        }

        if (this.markupsExtension.filterManager.filterLayers([layerData]).length === 0) {
          this.removeLayer(layer);
        }
      }

      if (this.markupsExtension.options.onMarkupsSyncCallback) {
        this.markupsExtension.options.onMarkupsSyncCallback({ count: this.markupsExtension.markupsCache.length() });
      }
    } }, { key: "onLayerSyncing", value: function onLayerSyncing(_ref6)

    {var layerData = _ref6.layerData,layer = _ref6.layer;
      layer = layer || this.getLayerByGuid(layerData.guid);

      if (layer) {
        if (this.markupsExtension.viewer.impl.is2d) {
          layer.deselect();
        }

        layer.disable();
      }
    } }, { key: "selectLink", value: function selectLink(

    link) {
      if (link) {
        link.select();
      } else {
        console.warn('selectLink - link does not exist');
      }
    } }, { key: "deselectLink", value: function deselectLink(

    link) {
      if (link) {
        link.deselect();
      } else {
        console.warn('deselectLink - link does not exist');
      }
    } }, { key: "deselectAllLinks", value: function deselectAllLinks()

    {var _this9 = this;
      var selectedLinks = this.getSelectedLinks();
      selectedLinks.forEach(function (link) {
        _this9.deselectLink(link);
      });
    } }, { key: "getDuringCreationMarkup", value: function getDuringCreationMarkup(

    create) {
      if (!this.duringCreationMarkup && create) {
        var type = this.getMarkupCreationType();
        var markup = this.createMarkup(type);

        if (markup) {
          markup.setVisible(true);
          markup.enableEdit();
          this.duringCreationMarkup = markup;
        }
      }

      return this.duringCreationMarkup;
    } }, { key: "getActiveLayer", value: function getActiveLayer()

    {
      return this.activeLayer;
    } }, { key: "setActiveLayer", value: function setActiveLayer(

    layer) {
      layer = layer instanceof _MarkupsLayer__WEBPACK_IMPORTED_MODULE_2__["default"] ? layer : this.getLayerById(layer);
      this.activeLayer = layer;
    } }, { key: "isMarkupSessionOpen", value: function isMarkupSessionOpen()

    {
      return this.sessionOpen;
    } }, { key: "changeMarkupCreationType", value: function changeMarkupCreationType()

    {var _this10 = this;var creationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_MARKUP;
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.executeAfterTransitionEnded)(this.markupsExtension.viewer, function () {
        var duringCreationMarkup = _this10.getDuringCreationMarkup(false);

        if (duringCreationMarkup) {
          duringCreationMarkup.creationHandler.onEscape();
        }

        _this10.markupCreationType = creationType;
        _this10.markupsExtension.viewer.setActiveNavigationTool(creationType ? _this10.markupsExtension.markupsTool.getName() : _this10.navigationToolBackup);

        _this10.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_CREATION_TYPE_CHANGED, creationType: creationType });

        if (creationType && !_this10.isMarkupSessionOpen() && creationType !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.RECT_SELECTOR) {
          _this10.startMarkupSession();
        }
      });
    } }, { key: "getMarkupCreationType", value: function getMarkupCreationType()

    {
      return this.markupCreationType;
    } }, { key: "setToolEnabled", value: function setToolEnabled(

    enable) {var _this11 = this;
      this.toolEnabled = enable;

      if (!enable) {
        this.deselectAllLayers();
        this.deselectAllLinks();
        this.disableAllMarkups();
      } else {
        this.enableAllMarkups();
      }

      // Solving a bug that happens in Safari and Edge. 
      // In those browsers, Rendering the MarkupsToolbar just after creating a new issue
      // Causing the markups toolbar to render without it's buttons:
      // https://jira.autodesk.com/browse/BLMV-3152
      // Another render of the toolbar solves the problem.
      if (Autodesk.Viewing.isSafari() || Autodesk.Viewing.isIE11) {
        setTimeout(function () {
          if (_this11.markupsExtension.markupsUI) {
            _this11.markupsExtension.markupsUI.toolbar.renderToolbar();
          }
        }, 1);
      }

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_TOOL_ENABLED_CHANGED, enable: enable });
    } }, { key: "isToolEnabled", value: function isToolEnabled()

    {
      return this.toolEnabled;
    } }, { key: "startMarkupSession", value: function startMarkupSession(

    creationType, layer) {
      if (!this.isToolEnabled()) {
        return false;
      }

      this.deselectAllLayers(layer && [layer]);
      this.exitMarkupView([layer]);
      this.deselectAllLinks();

      this.sessionOpen = true;

      this.markupsExtension.markupsTool.updateToolPriority();

      layer = layer || this.createLayer();
      layer.setVisible(true);
      this.setActiveLayer(layer);

      this.navigationToolBackup = this.markupsExtension.viewer.getActiveNavigationTool();
      this.markupsExtension.viewer.setActiveNavigationTool(this.markupsExtension.markupsTool.getName());

      if (!this.markupsExtension.viewer.impl.is2d) {
        this.lockNavigation();
      }

      if (creationType || !this.getMarkupCreationType()) {
        this.changeMarkupCreationType(creationType);
      }

      this.getAllMarkups().forEach(function (markup) {
        if (markup.layer !== layer) {
          markup.disable();
        }
      });

      this.creationStatusType = this.markupsExtension.options.defaultMarkupStatus || _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.MARKUP_STATUS_PRIVATE;

      this.contextMenu = this.markupsExtension.viewer.contextMenu;
      this.markupsExtension.viewer.setContextMenu(null);

      this.markupsExtension.viewer.impl.pauseHighlight(true);
      this.markupsExtension.viewer.impl.disableSelection(true);

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.setCustomGestureValues)(this.markupsExtension.viewer);

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_SESSION_START, layer: layer });

      return true;
    } }, { key: "endMarkupSession", value: function endMarkupSession(

    save) {var _this12 = this;
      if (!this.isMarkupSessionOpen()) {
        return;
      }

      var layer = this.getActiveLayer();
      var deleteLayer = false;

      if (save && layer.isEmpty()) {
        if (layer.layerData) {
          // In case the layer already saved in the backend, trying to save it when it's empty is prohibited.
          // So the options are to delete it, or undo the changes.
          this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_DELETE_EMPTY_PRESSED, onConfirmCB: function onConfirmCB() {return _this12.deleteLayer(layer);} });
          return;
        } else {
          deleteLayer = true;
        }

        // Don't allow saving an empty layer.
        save = false;
      }

      this.sessionOpen = false;

      if (!save) {
        this.exitMarkupView();
      }

      if (this.markupsExtension.markupsTool) this.markupsExtension.markupsTool.updateToolPriority();
      this.changeMarkupCreationType(null);
      this.setActiveLayer(null);

      if (this.duringCreationMarkup) {
        this.duringCreationMarkup.creationHandler.creationCancel();
      }

      this.deselectAllMarkups();

      this.enableAllMarkups();
      this.unhoverAllMarkups();

      if (!save) {
        while (!this.actionManager.isUndoStackEmpty()) {
          this.undo();
        }
      }

      this.actionManager.clear();

      // If the layer is empty - remove it.
      // If the layer is new, and the user wants to discard it - just remove the layer.
      var removeLayer = layer.isEmpty() || !save && !layer.getGuid();

      if (deleteLayer) {
        this.deleteLayer(layer);
      } else if (removeLayer) {
        this.removeLayer(layer);
      }

      layer.deselect();

      this.markupsExtension.viewer.setContextMenu(this.contextMenu);

      this.markupsExtension.viewer.impl.pauseHighlight(false);
      this.markupsExtension.viewer.impl.disableSelection(false);

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.restoreGestureValues)(this.markupsExtension.viewer);

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_SESSION_END, layer: layer, save: save });
    } }, { key: "editLayer", value: function editLayer(

    layerGuid, focus, selectAllMarkups, immediate) {var _this13 = this;
      if (!this.isToolEnabled()) {
        return;
      }

      var layer = this.loadLayerIfHidden(layerGuid);

      if (layer) {
        if (this.markupsExtension.permissionManager.canEditMarkup(layer.layerData)) {
          this.selectLayer(layer, focus, immediate, function () {
            _this13.startMarkupSession(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_MARKUP, layer);
            if (selectAllMarkups) {
              // Currently, mobile devices don't support multi selection of markups.
              if (!Autodesk.Viewing.isMobileDevice()) {
                layer.selectAllMarkups();
              }
            }
          });
        } else {
          console.warn('editLayer - Cant edit layer, permissions not valid.');
        }
      } else {
        this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_EDITED_FROM_DIFFERENT_SHEET, layerGuid: layerGuid });
        var cache = this.markupsExtension.cache; // Must get the cache because when loading sheet, extension will be gone
        cache.layerToEdit = this.loadRelevantSheet(layerGuid);
      }
    } }, { key: "onLayerSelected", value: function onLayerSelected(_ref7)

    {var layer = _ref7.layer;
      this.changeAllLayersTransparency(true, [layer]);
    } }, { key: "onLayerDeselected", value: function onLayerDeselected()

    {
      if (!this.getSelectedLayer()) {
        this.changeAllLayersTransparency(false);
      }
    } }, { key: "deleteMarkup", value: function deleteMarkup(

    markup) {
      markup = markup instanceof _MarkupTypes_Markup__WEBPACK_IMPORTED_MODULE_3__["default"] ? markup : this.getMarkupById(markup);

      if (markup) {
        markup.creationHandler.deleteMarkup();
      } else {
        console.warn('deleteMarkup - markup does not exist');
      }
    } }, { key: "deleteInEditMarkups", value: function deleteInEditMarkups()

    {var _this14 = this;
      this.markupsToDelete = this.getInEditMarkups();

      this.openActionGroup();

      this.markupsToDelete.forEach(function (markup) {
        _this14.deleteMarkup(markup);
      });

      this.closeActionGroup();
    } }, { key: "undo", value: function undo()

    {
      if (this.duringCreationMarkup) {
        this.duringCreationMarkup.creationHandler.onEscape(false);
      } else {
        this.actionManager.undo();
      }
    } }, { key: "redo", value: function redo()

    {
      this.actionManager.redo();
    } }, { key: "isActionGroupOpen", value: function isActionGroupOpen()

    {
      return this.actionManager.isGroupOpen;
    } }, { key: "openActionGroup", value: function openActionGroup()

    {
      this.actionManager.openActionGroup();
    } }, { key: "closeActionGroup", value: function closeActionGroup()

    {
      this.actionManager.closeActionGroup();
    } }, { key: "copy", value: function copy()

    {
      this.markupsToCopy = this.getSelectedMarkups();
      this.pasteOffset = 1;
    } }, { key: "paste", value: function paste()

    {var _this15 = this;
      this.deselectAllMarkups();

      this.openActionGroup();

      this.markupsToCopy.forEach(function (markup) {
        _this15.duplicateMarkup(markup);
      });

      this.closeActionGroup();

      this.pasteOffset += 1;
    } }, { key: "cut", value: function cut()

    {
      this.copy();
      this.deleteInEditMarkups();
    } }, { key: "duplicateMarkup", value: function duplicateMarkup(

    markup) {var _this16 = this;
      var getTranslationVector = function getTranslationVector() {
        var rightVec = _this16.markupsExtension.renderer.getCameraRightVector();
        var upVec = _this16.markupsExtension.renderer.getCameraUpVector();
        var translationSize = _this16.markupsExtension.renderer.multiplyByNormaStrokeWidth(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.PASTE_OFFSET * _this16.pasteOffset);
        return rightVec.sub(upVec).normalize().multiplyScalar(translationSize);
      };

      var addToLayer = function addToLayer(markup) {
        markup.completed = true;
        var layer = _this16.activeLayer ? _this16.activeLayer : _this16.createLayer();
        var action = new _Actions_AddMarkupAction__WEBPACK_IMPORTED_MODULE_9__["default"](_this16, markup, layer);
        action.execute();
      };

      // Markups without translationHandler can't be duplicated. aka dimension markup.
      // Also, group components will be added by the group parent.
      if (markup.translationHandler && !markup.belongsToGroup()) {
        var newState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(markup.getState());
        // Translate
        var translationVec = getTranslationVector();
        newState.translation.add(translationVec);

        var newMarkup = this.createMarkup(markup.type, newState);

        addToLayer(newMarkup);
        newMarkup.select();
      } else if (markup.isGroupMarkup()) {
        var _newState = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(markup.getState());
        // Translate
        var _translationVec = getTranslationVector();

        _newState.uuid = THREE.Math.generateUUID(); // Can't use same id for different group
        _newState.componentsState = markup.markups.map(function (component) {
          var state = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(component.getState());
          state.translation.add(_translationVec);
          return state;
        });

        var _newMarkup = this.createMarkup(markup.type, _newState);

        addToLayer(_newMarkup);
        _newMarkup.markups.forEach(function (markup) {return addToLayer(markup);});
        _newMarkup.select();
      }
    } }, { key: "loadMarkupsToLayer", value: function loadMarkupsToLayer(

    layer) {var _this17 = this;
      var svgString = layer.layerData && layer.layerData.getSvgResource();

      if (!svgString || !layer.isEmpty()) {
        return;
      }

      var addToLayer = function addToLayer(markup) {
        markup.completed = true;
        _this17.addMarkupToLayer(markup, layer);
        markup.setDirty();
      };

      var svgMetadata = (0,_MarkupsDeserializer__WEBPACK_IMPORTED_MODULE_7__.parseMarkupLayer)(svgString, layer.layerData, this.markupsExtension.viewer, this.markupsExtension.renderer);

      svgMetadata.forEach(function (markupMetadata) {
        if (markupMetadata.state.groupId) {
          return; // Group components will be added by the group parent
        }
        if (markupMetadata.state.uuid) {
          // It's a group, find its corresponding components
          markupMetadata.state.componentsState = svgMetadata.filter(function (metadata) {return markupMetadata.state.uuid === metadata.state.groupId;}).map(function (metadata) {return metadata.state;});
        }

        var newMarkup = _this17.createMarkup(markupMetadata.type, markupMetadata.state);

        if (newMarkup) {
          addToLayer(newMarkup);

          if (newMarkup.isGroupMarkup()) {
            newMarkup.markups.forEach(function (markup) {return addToLayer(markup);});
          }
        }
      });
    } }, { key: "createLinkMetadata", value: function createLinkMetadata(

    layerData) {var
      metadata = layerData.metadata;
      metadata.markup_metadata = metadata.markup_metadata || {};
      metadata.markup_metadata.links = metadata.markup_metadata.links || [];

      layerData.attachments.forEach(function (docAttachment) {
        // Only one link per attachment type.
        if (!metadata.markup_metadata.links.some(function (link) {return link.id === docAttachment.attributes.issue_id && link.type === docAttachment.attributes.attachment_type;})) {
          metadata.markup_metadata.links.push({
            id: docAttachment.attributes.issue_id,
            type: docAttachment.attributes.attachment_type,
            position: null });

        }
      });
    } }, { key: "loadLinksToLayer", value: function loadLinksToLayer(

    layer) {var _this18 = this;
      this.createLinkMetadata(layer.layerData);
      var links = layer.layerData.getLinksMetadata();

      if (!links) {
        return;
      }

      links.forEach(function (linkMetadata) {
        // Checks if a link is already loaded to the layer, Will not recreate it in this case.
        if (layer.getAllLinks().find(function (link) {return link.guid === linkMetadata.id;})) {
          return;
        }

        if (layer.layerData.attachments.some(function (attachment) {return attachment.attributes.issue_id === linkMetadata.id;})) {
          var newLink = _this18.createLink(layer, linkMetadata);
          _this18.addLinkToLayer(newLink, layer);
          newLink.setDirty(true);
        }
      });
    } }, { key: "changeStyleProperty", value: function changeStyleProperty(

    key, value, dontSubmit) {
      // Transform color to its true value if needed.
      if (typeof value === 'string') {
        value = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.COLORS[value.toUpperCase()] || value;
      }

      if (key === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.THICKNESS) {
        value *= this.markupsExtension.renderer.getNormaStrokeWidth(); // The input thickness is just a factor, so multiply by the norma.
      }

      this.creationStyleProperties[key] = value;

      if (key === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.COLOR && value !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.COLORS.NO_COLOR) {
        this.creationStyleProperties[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.LAST_COLOR] = value;
      }

      if (this.isMarkupSessionOpen()) {
        this.openActionGroup();

        this.getSelectedMarkups().forEach(function (markup) {
          markup.creationHandler.changeStyleProperty(key, value, dontSubmit);
        });

        this.closeActionGroup();
      }

      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.MARKUP_STYLE_PROPERTY_CHANGED, styleProperty: key, value: value });
    } }, { key: "getStyleProperty", value: function getStyleProperty(

    key) {
      return this.creationStyleProperties[key];
    } }, { key: "onCalibrationEnded", value: function onCalibrationEnded()

    {
      this.markupsExtension.setToolEnabled(true);
      this.startMarkupSession(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.MARKUP_TYPE_DIMENSION);
    } }, { key: "onHistoryChanged", value: function onHistoryChanged(

    event) {var
      actionGroup = event.actionGroup;

      actionGroup.forEach(function (a) {
        a.markup.setDirty();
      });

      // In order to centralize all the events in one place, the events from actionManager will pass threw markupsManager's event dispatcher.
      this.dispatchEvent(event);
      this.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS.LAYER_READY_TO_SAVE, readyToSave: this.getReadyToSave() });
    } }, { key: "getLayersAsList", value: function getLayersAsList()

    {
      return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getObjectAsList)(this.layers);
    } }, { key: "getAllMarkups", value: function getAllMarkups()

    {
      var markups = [];

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.forAll)(this.layers, function (layer) {
        markups.push.apply(markups, _toConsumableArray((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getObjectAsList)(layer.markups)));
      });

      return markups;
    } }, { key: "generateScreenCapture", value: function generateScreenCapture(

    layer) {var _this19 = this;
      return new Promise(function (resolve) {
        setTimeout(function () {
          (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_6__.getScreenShotOfMarkup)(_this19.markupsExtension.viewer, function (img) {
            resolve(img);
          }, layer);
        }, 100);
      });
    } }, { key: "changeCreationStatusType", value: function changeCreationStatusType(

    status) {
      this.creationStatusType = status;
    } }, { key: "getCreationStatusType", value: function getCreationStatusType()

    {
      return this.creationStatusType;
    } }, { key: "setDefaultCreationStyleProperties", value: function setDefaultCreationStyleProperties()

    {
      this.creationStyleProperties = {};
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.LAST_COLOR, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_COLOR);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.COLOR, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_COLOR);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FILL_COLOR, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FILL_COLOR);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.THICKNESS, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_THICKNESS);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.OPACITY, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OPACITY);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FILL_OPACITY, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FILL_OPACITY);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FONT_SIZE, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FONT_SIZE_IN_PIXELS);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FONT_WEIGHT, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FONT_WEIGHT);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FONT_FAMILY, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FONT_FAMILY);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FONT_STYLE, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FONT_STYLE);
      this.changeStyleProperty(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.STYLE_PROPERTIES.FONT_COLOR, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_FONT_COLOR);
    } }, { key: "reset", value: function reset()

    {
      this.nextMarkupId = 0;
      this.nextLinkId = 0;
      this.nextLayerId = 0;
      this.sessionOpen = false;
      this.layers = {};
      this.selectedLayers = [];
      this.duringCreationMarkup = null;
      this.activeLayer = null;
      this.markupCreationType = null;
      this.markupsToCopy = [];
      this.pasteOffset = 1;
      this.toolEnabled = true;
      this.contextMenu = null;
      this.actionManager.clear();
      this.creationStyleProperties = {};
    } }, { key: "destroy", value: function destroy()

    {
      this.removeAllLayers();
      this.unlockNavigation();
      this.unregisterEvents();
      this.reset();
      this.clearListeners();
      this.markupsExtension = null;
      this.actionManager = null;
    } }]);return MarkupsManager;}(Autodesk.Viewing.EventDispatcher);

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsMobileCallbacks.js":
/*!*********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsMobileCallbacks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupMobileCallbacks)
/* harmony export */ });
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/ActionManager/ActionManager */ "./extensions/BimMarkups/Utils/ActionManager/ActionManager.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var av = Autodesk.Viewing;
var _window = av.getGlobal();var

MarkupMobileCallbacks = /*#__PURE__*/function () {
  function MarkupMobileCallbacks(markupsExtension) {_classCallCheck(this, MarkupMobileCallbacks);
    this.markupsExtension = markupsExtension;
    this.registerEventListeners();
  }_createClass(MarkupMobileCallbacks, [{ key: "registerEventListeners", value: function registerEventListeners()








































    {
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DESELECTED, this.onLayerDeselected);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DESELECTED, this.onMarkupDeselected);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SELECTED_FROM_DIFFERENT_SHEET, this.onLayerSelectedDifferentSheet);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_EDITED_FROM_DIFFERENT_SHEET, this.onLayerEditDifferentSheet);

      this.markupsExtension.markupsManager.addEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChanged);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.onMarkupSessionStart);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.onMarkupSessionEnd);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_START, this.onMarkupDrawingStart);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onMarkupDrawingEnd);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.onMarkupDrawingCancel);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LINK_SELECTED, this.onLinkSelected);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LINK_DESELECTED, this.onLinkDeselected);

      this.onLayerReadyToSaveChangedBinded = this.onLayerReadyToSaveChanged.bind(this);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_READY_TO_SAVE, this.onLayerReadyToSaveChangedBinded);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_VIEW_ENTERED, this.onMarkupViewEntered);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_VIEW_EXITED, this.onMarkupViewExited);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.TEXT_EDITING_STARTED, this.onTextEditingStarted);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.TEXT_EDITING_ENDED, this.onTextEditingEnded);

      // Contextual menu
      this.updateContextualMenuBinded = this.updateContextualMenu.bind(this);
      this.hideContextualMenuBinded = this.hideContextualMenu.bind(this);

      this.updateContextualMenuDebouncedShort = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].debounce(this.updateContextualMenuBinded, 10);
      this.updateContextualMenuDebouncedLong = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].debounce(this.updateContextualMenuBinded, 200);

      this.markupsExtension.markupsManager.addEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DIRTY, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SYNCED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_TOOL_ENABLED_CHANGED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DESELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DESELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.hideContextualMenuBinded);

      this.markupsExtension.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.updateContextualMenuDebouncedLong);
    } }, { key: "unregisterEventListeners", value: function unregisterEventListeners()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DESELECTED, this.onLayerDeselected);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DESELECTED, this.onMarkupDeselected);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SELECTED_FROM_DIFFERENT_SHEET, this.onLayerSelectedDifferentSheet);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_EDITED_FROM_DIFFERENT_SHEET, this.onLayerEditDifferentSheet);

      this.markupsExtension.markupsManager.removeEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.onHistoryChanged);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.onMarkupSessionStart);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.onMarkupSessionEnd);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_START, this.onMarkupDrawingStart);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onMarkupDrawingEnd);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.onMarkupDrawingCancel);

      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LINK_SELECTED, this.onLinkSelected);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LINK_DESELECTED, this.onLinkDeselected);

      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_READY_TO_SAVE, this.onLayerReadyToSaveChangedBinded);

      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_VIEW_ENTERED, this.onMarkupViewEntered);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_VIEW_EXITED, this.onMarkupViewExited);

      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.TEXT_EDITING_STARTED, this.onTextEditingStarted);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.TEXT_EDITING_ENDED, this.onTextEditingEnded);

      this.markupsExtension.markupsManager.removeEventListener(_Utils_ActionManager_ActionManager__WEBPACK_IMPORTED_MODULE_1__["default"].HISTORY_CHANGED_EVENT, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_SELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DIRTY, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SYNCED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_SELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_TOOL_ENABLED_CHANGED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.LAYER_DESELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DESELECTED, this.updateContextualMenuDebouncedShort);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.hideContextualMenuBinded);

      this.markupsExtension.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.updateContextualMenuDebouncedLong);

      this.updateContextualMenuDebouncedShort.cancel();
      this.updateContextualMenuDebouncedLong.cancel();
    }

    // Callbacks //
  }, { key: "markupToolLoaded", value: function markupToolLoaded()
    {
      MarkupMobileCallbacks.send('onMarkupToolLoaded');
    } }, { key: "onMarkupSessionStart", value: function onMarkupSessionStart()

    {
      MarkupMobileCallbacks.send('onMarkupSessionStart');
    } }, { key: "onMarkupSessionEnd", value: function onMarkupSessionEnd()

    {
      MarkupMobileCallbacks.send('onMarkupSessionEnd');
    } }, { key: "onMarkupDrawingStart", value: function onMarkupDrawingStart(_ref)

    {var markup = _ref.markup;
      MarkupMobileCallbacks.send('onMarkupDrawingStart', markup.type);
    } }, { key: "onMarkupDrawingEnd", value: function onMarkupDrawingEnd(_ref2)

    {var markup = _ref2.markup;
      MarkupMobileCallbacks.send('onMarkupDrawingEnd', markup.type);
    } }, { key: "onMarkupDrawingCancel", value: function onMarkupDrawingCancel(_ref3)

    {var markup = _ref3.markup;
      MarkupMobileCallbacks.send('onMarkupDrawingCancel', markup.type);
    } }, { key: "onLayerSelectedDifferentSheet", value: function onLayerSelectedDifferentSheet(_ref4)

    {var layerGuid = _ref4.layerGuid;
      MarkupMobileCallbacks.send('onLayerSelectedDifferentSheet', layerGuid);
    } }, { key: "onLayerEditDifferentSheet", value: function onLayerEditDifferentSheet(_ref5)

    {var layerGuid = _ref5.layerGuid;
      MarkupMobileCallbacks.send('onLayerEditDifferentSheet', layerGuid);
    } }, { key: "onLayerSelected", value: function onLayerSelected(_ref6)

    {var layer = _ref6.layer;
      var guid = layer.getGuid();

      if (guid) {
        var dataObj = {
          guid: guid,
          boundingBox: MarkupMobileCallbacks.correctPixelRatio(layer.getClientBoundingBox(true)) };


        MarkupMobileCallbacks.send('onLayerSelected', dataObj);
      }
    } }, { key: "onLayerDeselected", value: function onLayerDeselected(_ref7)

    {var layer = _ref7.layer;
      var guid = layer.getGuid();

      if (guid) {
        MarkupMobileCallbacks.send('onLayerDeselected', guid);
      }
    } }, { key: "onMarkupSelected", value: function onMarkupSelected(_ref8)

    {var markup = _ref8.markup;
      var dataObj = {
        id: markup.id,
        layerGuid: markup.layer && markup.layer.getGuid() || '', // Needed for Android ugly fix.
        type: markup.type,
        style: markup.editState.style,
        boundingBox: MarkupMobileCallbacks.correctPixelRatio(markup.getClientBoundingBox(true, true)) };


      MarkupMobileCallbacks.send('onMarkupSelected', dataObj);
    } }, { key: "onMarkupDeselected", value: function onMarkupDeselected(_ref9)

    {var markup = _ref9.markup;
      MarkupMobileCallbacks.send('onMarkupDeselected', markup.id);
    } }, { key: "onHistoryChanged", value: function onHistoryChanged(_ref10)

    {var hasUndo = _ref10.hasUndo,hasRedo = _ref10.hasRedo;
      var dataObj = {
        enableUndo: hasUndo,
        enableRedo: hasRedo };


      MarkupMobileCallbacks.send('onMarkupHistoryChanged', dataObj);
    } }, { key: "onLayerReadyToSaveChanged", value: function onLayerReadyToSaveChanged(_ref11)

    {var readyToSave = _ref11.readyToSave;
      MarkupMobileCallbacks.send('onLayerReadyToSaveChanged', readyToSave);
    } }, { key: "postLayer", value: function postLayer(

    metadata, resources, requestId) {var _resources;
      var dataObj = {
        metadata: metadata,
        resources: (_resources = {}, _defineProperty(_resources,
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SVG, resources[0]), _defineProperty(_resources,
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE, resources[1]), _resources),

        requestId: requestId };


      MarkupMobileCallbacks.send('onPostLayer', dataObj);
    } }, { key: "updateLayer", value: function updateLayer(

    originalGuid, metadata, resources, requestId) {var _resources2;
      var dataObj = {
        originalGuid: originalGuid,
        metadata: metadata,
        resources: (_resources2 = {}, _defineProperty(_resources2,
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SVG, resources[0]), _defineProperty(_resources2,
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE, resources[1]), _resources2),

        requestId: requestId };


      MarkupMobileCallbacks.send('onUpdateLayer', dataObj);
    } }, { key: "deleteLayer", value: function deleteLayer(

    guid, requestId) {
      var dataObj = {
        guid: guid,
        requestId: requestId };


      MarkupMobileCallbacks.send('onDeleteLayer', dataObj);
    } }, { key: "publishLayer", value: function publishLayer(

    guid, requestId) {
      var dataObj = {
        guid: guid,
        requestId: requestId };


      MarkupMobileCallbacks.send('onPublishLayer', dataObj);
    } }, { key: "archiveLayer", value: function archiveLayer(

    guid, closeVersion, requestId) {
      var dataObj = {
        guid: guid,
        closeVersion: closeVersion,
        requestId: requestId };


      MarkupMobileCallbacks.send('onArchiveLayer', dataObj);
    } }, { key: "onLinkSelected", value: function onLinkSelected(_ref12)

    {var link = _ref12.link;
      var dataObj = {
        type: link.type,
        layerGuid: link.layer.layerData.guid,
        boundingBox: link.getClientBoundingBox() };


      MarkupMobileCallbacks.send('onLinkSelected', dataObj);
    } }, { key: "onLinkDeselected", value: function onLinkDeselected(_ref13)

    {var link = _ref13.link;
      var dataObj = {
        type: link.type,
        layerGuid: link.layer.layerData.guid };


      MarkupMobileCallbacks.send('onLinkDeselected', dataObj);
    }

    // Used to update contextual menu position.
  }, { key: "updateContextualMenu", value: function updateContextualMenu() {
      var duringCreation = this.markupsExtension.markupsManager.getDuringCreationMarkup();

      if (!duringCreation) {
        var markup = this.markupsExtension.markupsManager.getSelectedMarkups()[0];

        if (markup) {
          this.onMarkupSelected({ markup: markup });
          return;
        } else if (!this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
          var layer = this.markupsExtension.markupsManager.getSelectedLayer();

          if (layer) {
            this.onLayerSelected({ layer: layer });
            return;
          }
        }
      }

      this.hideContextualMenu();
    } }, { key: "hideContextualMenu", value: function hideContextualMenu()

    {
      MarkupMobileCallbacks.send('onHideContextualMenu');
    } }, { key: "onMarkupViewExited", value: function onMarkupViewExited()

    {
      MarkupMobileCallbacks.send('onMarkupViewExited');
    } }, { key: "onMarkupViewEntered", value: function onMarkupViewEntered()

    {
      MarkupMobileCallbacks.send('onMarkupViewEntered');
    } }, { key: "onTextEditingStarted", value: function onTextEditingStarted()

    {
      MarkupMobileCallbacks.send('onTextEditingStarted');
    } }, { key: "onTextEditingEnded", value: function onTextEditingEnded()

    {
      MarkupMobileCallbacks.send('onTextEditingEnded');
    } }, { key: "destroy", value: function destroy()

    {
      this.unregisterEventListeners();

      this.iosSend = null;
      this.androidSend = null;
      this.send = null;
    } }], [{ key: "send", value: function send(callbackName, dataObj) {var iosBridge = _window.webkit && _window.webkit.messageHandlers.callbackHandler;var iosSend = iosBridge ? function (messageName, data) {iosBridge.postMessage({ command: messageName, data: data });} : null;var androidSend = _window.JSINTERFACE;var dataAsString = _typeof(dataObj) === 'object' ? JSON.stringify(dataObj) : dataObj;if (iosSend) {if (dataAsString !== undefined) {iosSend(callbackName, dataAsString);} else {iosSend(callbackName);}} else if (androidSend) {if (androidSend[callbackName]) {if (dataAsString !== undefined) {androidSend[callbackName](dataAsString);} else {androidSend[callbackName]();}}}} }, { key: "correctPixelRatio", value: function correctPixelRatio(boundingBox) {// iOS gets their coordinates in points, while Android in pixels.
      // Android need to fix the result according to devicePixelRatio.
      if (Autodesk.Viewing.isAndroidDevice()) {boundingBox.min.multiplyScalar(window.devicePixelRatio);boundingBox.max.multiplyScalar(window.devicePixelRatio);}return boundingBox;} }]);return MarkupMobileCallbacks;}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsPermissionManager.js":
/*!***********************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsPermissionManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsPermissionManager)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var

MarkupsPermissionManager = /*#__PURE__*/function () {
  function MarkupsPermissionManager() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, MarkupsPermissionManager);
    this.options = options;
  }_createClass(MarkupsPermissionManager, [{ key: "canPublishMarkup", value: function canPublishMarkup(

    layerData) {
      // Layer hasn't been saved yet.
      if (!layerData || !layerData.guid) {
        return false;
      }

      // Already published.
      if (!layerData.metadata.status === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PUBLISHED) {
        return false;
      }

      return !(!this.options.userId ||
      !layerData.metadata.permitted_statuses ||
      layerData.metadata.permitted_statuses.indexOf(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PUBLISHED) === -1);
    } }, { key: "canArchiveMarkup", value: function canArchiveMarkup(

    layerData) {
      // Layer hasn't been saved yet.
      if (!layerData || !layerData.guid) {
        return false;
      }

      // Already published.
      if (!layerData.metadata.status === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_ARCHIVED) {
        return false;
      }

      return !(!this.options.userId ||
      !layerData.metadata.permitted_statuses ||
      layerData.metadata.permitted_statuses.indexOf(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_ARCHIVED) === -1);
    } }, { key: "canEditMarkup", value: function canEditMarkup(

    layerData) {
      // During initial creation - allow editing.
      if (!layerData) {
        return true;
      }

      // Layer hasn't been saved yet.
      if (!layerData.guid) {
        return false;
      }

      var editableStatuses = [_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PRIVATE, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PUBLISHED];

      if (!this.options.userId || editableStatuses.indexOf(layerData.metadata.status) === -1) {
        return false;
      }

      // Can't edit markup when viewing a previous document version
      if (this.options.documentVersion < this.options.currentRawDocumentVersion) {
        return false;
      }

      // Admin or creator can delete any markups
      return this.options.isAdmin || this.options.userId === layerData.metadata.created_by;
    } }, { key: "canDeleteMarkup", value: function canDeleteMarkup(

    layerData) {
      // Layer hasn't been saved yet.
      if (!layerData || !layerData.guid) {
        return false;
      }

      var deletableStatuses = [_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_OPEN, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PRIVATE];

      if (!this.options.userId || deletableStatuses.indexOf(layerData.metadata.status) === -1) {
        return false;
      }

      // Admin or creator can delete any markups
      return this.options.isAdmin || this.options.userId === layerData.metadata.created_by;
    } }, { key: "canEditMarkupAttachment", value: function canEditMarkupAttachment(

    layerData, docAttachment) {
      // Layer hasn't been saved yet.
      if (!layerData || !layerData.guid) {
        return false;
      }

      // Cannot edit any attachments of closed markup.
      if (layerData.metadata.status === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_CLOSED || layerData.metadata.status === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_ARCHIVED) {
        return false;
      }

      if (this.options.documentVersion !== this.options.currentRawDocumentVersion) {
        return false;
      }

      if (!this.options.userId) {
        // No userId, won't allow to edit a markup at all.
        return false;
      }

      // Rule number 1, admin can edit any attachments.
      if (this.options.isAdmin) {
        return true;
      }

      // Rule number 2, only attachment author can edit the attachment.
      return !docAttachment || docAttachment && this.options.userId === docAttachment.attributes.created_by;
    } }, { key: "canCreateMarkup", value: function canCreateMarkup()

    {
      if (this.options.documentVersion !== this.options.currentRawDocumentVersion) {
        return false;
      }

      return true;
    } }, { key: "destroy", value: function destroy()

    {
      this.options = null;
    } }]);return MarkupsPermissionManager;}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsRenderer.js":
/*!**************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsRenderer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsRenderer)
/* harmony export */ });
/* harmony import */ var _FrameRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FrameRenderer */ "./extensions/BimMarkups/FrameRenderer.js");
/* harmony import */ var _Links_LinksRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Links/LinksRenderer */ "./extensions/BimMarkups/Links/LinksRenderer.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _RendererHelpers_MarkupsMaterialManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RendererHelpers/MarkupsMaterialManager */ "./extensions/BimMarkups/RendererHelpers/MarkupsMaterialManager.js");
/* harmony import */ var _RendererHelpers_MarkupsGeometryManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RendererHelpers/MarkupsGeometryManager */ "./extensions/BimMarkups/RendererHelpers/MarkupsGeometryManager.js");
/* harmony import */ var _RendererHelpers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RendererHelpers/TextRenderer */ "./extensions/BimMarkups/RendererHelpers/TextRenderer.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _Utils_CameraUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Utils/CameraUtils */ "./extensions/BimMarkups/Utils/CameraUtils.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}










var avp = Autodesk.Viewing.Private;
var ShaderPass = avp.ShaderPass;
var CopyShader = avp.CopyShader;var

MarkupsRenderer = /*#__PURE__*/function () {
  function MarkupsRenderer(markupsExtension) {_classCallCheck(this, MarkupsRenderer);
    this.markupsExtension = markupsExtension;
    this.viewer = this.markupsExtension.viewer;
    this.viewer.impl.updateCameraMatrices();

    this.viewer.navigation.updateCamera();
    this.documentCamera = this.viewer.navigation.getCamera();
    this.documentCamera.updateMatrixWorld();

    this.textRenderer = new _RendererHelpers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__["default"](this.markupsExtension);
    this.frameRenderer = new _FrameRenderer__WEBPACK_IMPORTED_MODULE_0__["default"](this.markupsExtension);
    this.linksRenderer = new _Links_LinksRenderer__WEBPACK_IMPORTED_MODULE_1__["default"](this.markupsExtension);
    this.materialManager = new _RendererHelpers_MarkupsMaterialManager__WEBPACK_IMPORTED_MODULE_4__["default"](this.markupsExtension);
    this.geometryManager = new _RendererHelpers_MarkupsGeometryManager__WEBPACK_IMPORTED_MODULE_5__["default"](this.markupsExtension);

    this.is3d = this.viewer.model.is3d();

    this.raycaster = new THREE.Raycaster();

    this.size = {
      width: this.viewer.canvas.clientWidth,
      height: this.viewer.canvas.clientHeight };


    if (this.is3d) {
      this.viewSize = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.WORLD_3D_SIZE;
      this.markupsCamera = new THREE.OrthographicCamera(0, this.viewSize, this.viewSize, 0, 0, 1);
      this.markupsCamera.position.set(0, 0, 1);
      this.markupsCamera.target = new THREE.Vector3(0, 0, 0);
    } else {
      this.markupsCamera = this.viewer.navigation.getCamera();
    }

    this.markups = [];

    this.renderer = this.viewer.impl.renderer();
    this.glrenderer = this.viewer.impl.glrenderer();
    this.copyPass = new ShaderPass(CopyShader);
    this.copyPass.material.depthWrite = false;
    this.copyPass.material.depthTest = false;
    this.copyPass.material.transparent = true;

    this._tmpScene = new THREE.Scene();
    this._black = new THREE.Color(0, 0, 0);

    this.absoluteRightVec = new THREE.Vector3(1, 0, 0);
    this.absoluteUpVec = new THREE.Vector3(0, 1, 0);
    this.absoluteEyeVec = new THREE.Vector3(0, 0, 1);

    this.tmpMatrix = new THREE.Matrix4();
    this.frustum = new THREE.Frustum();

    this.setMMtoUnitConversion();
    this.setNormaStrokeWidth();
    this.setNormaTextSize();

    this.registerEventListeners();
    this.updateCameraAndMaterialParameters();
  }_createClass(MarkupsRenderer, [{ key: "registerEventListeners", value: function registerEventListeners()

    {
      this.onRenderBinded = this.onRender.bind(this);
      this.onResizeBinded = this.onResize.bind(this);
      this.invalidateBinded = this.invalidate.bind(this);
      this.onCameraChangedBinded = this.onCameraChanged.bind(this);
      this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.onRenderBinded);
      this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_REMOVED, this.invalidateBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.invalidateBinded);
    } }, { key: "removeEventListeners", value: function removeEventListeners()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.onRenderBinded);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_REMOVED, this.invalidateBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_2__.MARKUPS_EVENTS.MARKUP_DRAWING_CANCEL, this.invalidateBinded);
    } }, { key: "onCameraChanged", value: function onCameraChanged()

    {
      this.eyeVector = null;
      this.upVector = null;
      this.rightVector = null;
    } }, { key: "getResolution", value: function getResolution()

    {
      var pixelRatio = this.glrenderer.getPixelRatio();

      return {
        width: this.size.width * pixelRatio,
        height: this.size.height * pixelRatio };

    } }, { key: "supportsInt32Index", value: function supportsInt32Index()

    {
      return !!this.glrenderer.supportsElementIndexUint();
    } }, { key: "disposeTmpTarget", value: function disposeTmpTarget()

    {
      if (this._tmpTarget) {
        this._tmpTarget.dispose();
        this._tmpTarget = null;
      }
    } }, { key: "createTempRenderTarget", value: function createTempRenderTarget()

    {var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getResolution();
      this.disposeTmpTarget();

      if (resolution.width === 0 || resolution.height === 0) {
        return false;
      }

      this._tmpTarget = new THREE.WebGLRenderTarget(resolution.width, resolution.height,
      {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false,
        depthBuffer: false });

      this._tmpTarget.texture.generateMipmaps = false;

      return true;
    } }, { key: "onRender", value: function onRender()

    {
      this.render();
    } }, { key: "onResize", value: function onResize(

    e) {
      this.size.width = e.width;
      this.size.height = e.height;

      this.updateCameraAndMaterialParameters();
    } }, { key: "updateCameraAndMaterialParameters", value: function updateCameraAndMaterialParameters()

    {
      if (this.is3d) {
        var aspect = this.size.width / (this.size.height || 1); // In case height is 0.
        var newRight = this.viewSize * aspect;
        var delta = this.markupsCamera.right - newRight;

        this.markupsCamera.position.x += delta / 2;
        this.markupsCamera.target.x += delta / 2;
        this.markupsCamera.right = newRight;

        this.markupsCamera.updateProjectionMatrix();
        this.markupsCamera.updateMatrixWorld();
      }

      var resolution = this.getResolution();

      if (this._tmpTarget) {// Resize only if it already exists
        this.createTempRenderTarget(resolution);
      }

      this.materialManager.updateScreenSize(resolution);
    }

    // A null target means render to screen
  }, { key: "render", value: function render() {var _this = this;var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.renderer.getFinalTarget();var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.markupsCamera;
      //
      // Markups can have a combination of fill and stroke, each one with a different opacity. To avoid the overlapping parts
      // of a transparent markup having darker areas (because of the alpha values being blended) we render them to a 
      // temporary target first, with blending off. Afterwards the result is blended with the final image.
      // In order to render correctly we must take into account the following:
      // 
      //          Fill            Stroke          How to render
      //      ----------------------------------------------------
      //         Opaque          Opaque           Normally
      //         Transparent     Opaque           Fill with temp target, stroke normally
      //         Transparent     Transparent      Both with temp target
      //         None            Opaque           Normally
      //         None            Transparent      With temp target
      //

      // TODO: Improve performance by simplifying the check in isInsideCamera.
      this.tmpMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this.frustum.setFromProjectionMatrix(this.tmpMatrix);

      var isInsideCamera = function isInsideCamera(box) {
        var topRight = box.max;
        var topLeft = box.max.clone().setX(box.min.x);
        var bottomLeft = box.min;
        var bottomRight = box.min.clone().setX(box.max.x);
        return _this.frustum.containsPoint(topRight) || _this.frustum.containsPoint(topLeft) || _this.frustum.containsPoint(bottomLeft) || _this.frustum.containsPoint(bottomRight) || _this.frustum.intersectsBox(box);
      };

      var is2DBoxIntersection = function is2DBoxIntersection(box1, box2) {
        return !(box2.max.x < box1.min.x || box2.min.x > box1.max.x ||
        box2.max.y < box1.min.y || box2.min.y > box1.max.y);
      };

      var normalMeshes = [];
      var transparentMeshes = [],transparentProperties = [];

      var flushNormalMeshes = function flushNormalMeshes() {var _this$_tmpScene;
        if (normalMeshes.length === 0) return;

        (_this$_tmpScene = _this._tmpScene).add.apply(_this$_tmpScene, normalMeshes);

        _this.glrenderer.render(_this._tmpScene, camera, target);

        _this._tmpScene.children.length = 0;
        normalMeshes.length = 0;
      };

      var flushTransparentMeshes = function flushTransparentMeshes() {var _this$_tmpScene2;
        if (transparentMeshes.length === 0) return;

        (_this$_tmpScene2 = _this._tmpScene).add.apply(_this$_tmpScene2, transparentMeshes);

        _this.glrenderer.setClearColor(_this._black, 0.0);
        _this.glrenderer.clearTarget(_this._tmpTarget, true, false, false);

        _this.glrenderer.render(_this._tmpScene, camera, _this._tmpTarget);
        _this.copyPass.render(_this.glrenderer, target, _this._tmpTarget);

        _this._tmpScene.children.length = 0;
        transparentMeshes.length = 0;
        transparentProperties.length = 0;
      };

      this.markups.forEach(function (markup) {
        var meshContainer = markup.meshContainer;
        if (!meshContainer.visible || meshContainer.children.length === 0) {
          return;
        }

        if (!_this.is3d) {// No point in checking in 3D since the camera is fixed
          var bbox = markup.getWorldBoundingBox(true);
          if (!isInsideCamera(bbox)) {
            return;
          }
        }

        var fillMesh = markup.fillMesh;
        var strokeMesh = markup.strokeMesh;
        var hasTransparentFill = fillMesh && fillMesh.material.opacity < 1;
        var hasTransparentStroke = strokeMesh.material.uniforms.opacity.value < 1;

        var normalRender = !hasTransparentFill && !hasTransparentStroke;
        if (normalRender) {
          flushTransparentMeshes();
          normalMeshes.push(meshContainer);
        } else {
          if (!_this._tmpTarget) {// Create only if needed
            if (!_this.createTempRenderTarget()) {
              return;
            }
          }

          flushNormalMeshes();

          if ((hasTransparentFill || !fillMesh) && hasTransparentStroke) {
            var currentBBox = markup.getWorldBoundingBox(true);
            if (transparentProperties.some(function (prop) {
              if (markup.isTransparent() && prop.isTransparent) {
                return false;
              }

              return is2DBoxIntersection(currentBBox, prop.bbox);
            })) {
              flushTransparentMeshes();
            }

            transparentMeshes.push(meshContainer);
            transparentProperties.push({
              bbox: currentBBox,
              isTransparent: markup.isTransparent() });

          } else {
            flushTransparentMeshes();

            _this._tmpScene.add(meshContainer);

            // Fill to tmpTarget                   
            meshContainer.remove(strokeMesh);

            _this.glrenderer.setClearColor(_this._black, 0.0);
            _this.glrenderer.clearTarget(_this._tmpTarget, true, false, false);

            _this.glrenderer.render(_this._tmpScene, camera, _this._tmpTarget);
            _this.copyPass.render(_this.glrenderer, target, _this._tmpTarget);

            // Stroke as normal
            meshContainer.remove(fillMesh);
            meshContainer.add(strokeMesh);

            _this.glrenderer.render(_this._tmpScene, camera, target);

            // Restore mesh container (adding back in the correct order)
            meshContainer.add(fillMesh);
            meshContainer.add(strokeMesh);

            _this._tmpScene.remove(meshContainer);
          }
        }
      });

      flushNormalMeshes();
      flushTransparentMeshes();
    } }, { key: "getCameraEyeVector", value: function getCameraEyeVector()

    {
      if (!this.eyeVector) {
        this.eyeVector = _Utils_CameraUtils__WEBPACK_IMPORTED_MODULE_9__["default"].getCameraEyeVector(this.markupsCamera);
      }

      return this.eyeVector.clone();
    } }, { key: "getCameraRightVector", value: function getCameraRightVector()

    {
      if (!this.rightVector) {
        this.rightVector = _Utils_CameraUtils__WEBPACK_IMPORTED_MODULE_9__["default"].getCameraRightVector(this.markupsCamera);
      }

      return this.rightVector.clone();
    } }, { key: "getCameraUpVector", value: function getCameraUpVector()

    {
      if (!this.upVector) {
        this.upVector = _Utils_CameraUtils__WEBPACK_IMPORTED_MODULE_9__["default"].getCameraUpVector(this.markupsCamera);
      }

      return this.upVector.clone();
    } }, { key: "getCameraRotation", value: function getCameraRotation()

    {
      return _Utils_CameraUtils__WEBPACK_IMPORTED_MODULE_9__["default"].getCameraRotation(this.markupsCamera);
    } }, { key: "worldToClient", value: function worldToClient(

    point) {var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.markupsCamera;
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = point.clone().project(camera);

      return new THREE.Vector3((p.x + 1) / 2 * containerBounds.width, (-p.y + 1) / 2 * containerBounds.height, 0);
    } }, { key: "clientToWorld", value: function clientToWorld(

    point) {var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.markupsCamera;
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3();

      p.x = point.x / containerBounds.width * 2 - 1;
      p.y = -(point.y / containerBounds.height * 2 - 1);

      var result = p.unproject(camera);
      result.z = 0;
      return result;
    } }, { key: "sizeFromWorldToClient", value: function sizeFromWorldToClient(

    size) {
      var a = this.worldToClient(new THREE.Vector3());
      var b = this.worldToClient(new THREE.Vector3(size, 0, 0));

      return a.distanceTo(b);
    } }, { key: "sizeFromClientToWorld", value: function sizeFromClientToWorld(

    size) {
      var a = this.clientToWorld(new THREE.Vector3());
      var b = this.clientToWorld(new THREE.Vector3(size, 0, 0));

      return a.distanceTo(b);
    } }, { key: "multiplyByNormaStrokeWidth", value: function multiplyByNormaStrokeWidth(

    size) {
      return this.normaStrokeWidth * size;
    } }, { key: "documentCameraToMarkupsCamera", value: function documentCameraToMarkupsCamera(

    point) {
      if (!this.is3d) {
        point.z = 0;
        return point; // in 2D, both cameras are the same.
      }

      var p = this.worldToClient(point, this.documentCamera);
      return this.clientToWorld(p);
    } }, { key: "_fromMMtoWorldUnits", value: function _fromMMtoWorldUnits(

    value) {
      if (this.is3d) {
        return 1;
      }

      var model = this.viewer.model;

      // Prefer page units (model might be in meters while the page units are in inches or mm). If not available take model units
      // If that is also not available (i.e. raster image) use a default of mm for a 1 to 1 conversion
      var units = model.getMetadata('page_dimensions', 'page_units', null) || model.getMetadata('page_dimensions', 'model_units', 'mm');

      var worldUnits = Autodesk.Viewing.Private.convertUnits('mm', units, 1, value);

      if (model.isLeaflet()) {
        var bounds = this.viewer.impl.getFitBounds(true);
        var worldWidth = bounds.getSize(new THREE.Vector3()).x;
        var pageWidth = model.getMetadata('page_dimensions', 'page_width');
        worldUnits *= worldWidth / pageWidth;
      }

      return worldUnits;
    } }, { key: "_calcNormaSize", value: function _calcNormaSize(

    defaultValue, maxSizePercentange) {
      var norma = this.mmToWorldUnitFactor * defaultValue;

      var bounds = this.viewer.impl.getFitBounds(true);
      var boundsSize = bounds.getSize(new THREE.Vector3());
      var worldWidth = boundsSize.x;
      var worldHeight = boundsSize.y;

      var diagonal = Math.sqrt(worldWidth * worldWidth + worldHeight * worldHeight);
      norma = Math.min(norma, diagonal * maxSizePercentange);

      return norma;
    } }, { key: "setMMtoUnitConversion", value: function setMMtoUnitConversion()

    {
      this.mmToWorldUnitFactor = this._fromMMtoWorldUnits(1);
    } }, { key: "setNormaStrokeWidth", value: function setNormaStrokeWidth()

    {
      if (this.is3d) {
        this.normaStrokeWidth = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.NORMA_3D;
      } else {
        this.normaStrokeWidth = this._calcNormaSize(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_STROKE_IN_MM, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MAX_NORMA_PERCENTAGE);
      }
    } }, { key: "setNormaTextSize", value: function setNormaTextSize()

    {
      if (this.is3d) {
        this.normaTextSize = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.NORMA_TEXT_3D;
      } else {
        this.normaTextSize = this._calcNormaSize(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_FONT_SIZE_IN_MM, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MAX_NORMA_TEXT_PERCENTAGE);
      }
    } }, { key: "getNormaStrokeWidth", value: function getNormaStrokeWidth()

    {
      return this.normaStrokeWidth;
    }

    // We defined the baseline font size in px, and what it's value should be in mm, so that we can perform this
    // conversion, and have a consistent experience among documents with different scales
  }, { key: "getFontToWorldScale", value: function getFontToWorldScale() {
      return this.normaTextSize / _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_FONT_SIZE_IN_PIXELS;
    } }, { key: "addToScene", value: function addToScene(

    markup) {
      var hasCreationDate = function hasCreationDate(m) {return m.layer && m.layer.layerData && m.layer.layerData.metadata && m.layer.layerData.metadata.created_at;};

      var comparer = function comparer(a, b) {
        if (!hasCreationDate(a)) return 1; // It's a markup we just added by pushing to the array and should be left untouched at the end 

        var dateA = Date.parse(a.layer.layerData.metadata.created_at); // The array element
        var dateB = Date.parse(b.layer.layerData.metadata.created_at); // The element being inserted

        // First priority - oldest first
        if (dateA > dateB) return 1;
        if (dateA < dateB) return -1;

        // Second priority - id
        if (a.id > b.id) return 1;
        if (a.id < b.id) return -1;

        return 0;
      };

      if (hasCreationDate(markup)) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_8__.insertInSortedArray)(markup, this.markups, comparer);
      } else {// Newly created markups don't have a layer yet
        this.markups.push(markup);
      }
    } }, { key: "removeFromScene", value: function removeFromScene(

    markup) {
      _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_7__["default"].remove(this.markups, function (m) {return m === markup;});
    } }, { key: "invalidate", value: function invalidate()

    {
      this.markupsExtension.viewer.impl.invalidate(false, false, true);
    } }, { key: "updateRaycaster", value: function updateRaycaster(

    mouse) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var x = mouse.x / containerBounds.width * 2 - 1;
      var y = -(mouse.y / containerBounds.height) * 2 + 1;

      this.raycaster.ray.origin.set(x, y, (this.markupsCamera.near + this.markupsCamera.far) / (this.markupsCamera.near - this.markupsCamera.far)).unproject(this.markupsCamera);
      this.raycaster.ray.direction.set(0, 0, -1);
    } }, { key: "destroy", value: function destroy()

    {
      this.removeEventListeners();

      if (this.frameRenderer) {
        this.frameRenderer.destroy();
        this.frameRenderer = null;
      }

      if (this.linksRenderer) {
        this.linksRenderer.destroy();
        this.linksRenderer = null;
      }

      if (this.textRenderer) {
        this.textRenderer.destroy();
        this.textRenderer = null;
      }

      if (this.materialManager) {
        this.materialManager.destroy();
        this.materialManager = null;
      }

      if (this.geometryManager) {
        this.geometryManager.destroy();
        this.geometryManager = null;
      }

      this.disposeTmpTarget();

      this.invalidate();

      this.markupsExtension = null;
      this.viewer = null;
    } }]);return MarkupsRenderer;}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsSceneState.js":
/*!****************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsSceneState.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateSceneMetadata": () => (/* binding */ generateSceneMetadata),
/* harmony export */   "getViewportData": () => (/* binding */ getViewportData),
/* harmony export */   "restoreMarkupViewState": () => (/* binding */ restoreMarkupViewState)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}var applyOffsetToCamera = function applyOffsetToCamera(viewport, offset) {
  if (!viewport || !offset) {
    return;
  }

  if ('eye' in viewport) {
    viewport.eye[0] = (Number(viewport.eye[0]) + offset.x).toString();
    viewport.eye[1] = (Number(viewport.eye[1]) + offset.y).toString();
    viewport.eye[2] = (Number(viewport.eye[2]) + offset.z).toString();
  }

  if ('target' in viewport) {
    viewport.target[0] = (Number(viewport.target[0]) + offset.x).toString();
    viewport.target[1] = (Number(viewport.target[1]) + offset.y).toString();
    viewport.target[2] = (Number(viewport.target[2]) + offset.z).toString();
  }

  if ('pivotPoint' in viewport) {
    viewport.pivotPoint[0] = (Number(viewport.pivotPoint[0]) + offset.x).toString();
    viewport.pivotPoint[1] = (Number(viewport.pivotPoint[1]) + offset.y).toString();
    viewport.pivotPoint[2] = (Number(viewport.pivotPoint[2]) + offset.z).toString();
  }
};

var generateSceneMetadata = function generateSceneMetadata(viewerState, globalOffset, options) {
  var state = JSON.parse(JSON.stringify(viewerState));

  if (globalOffset) {
    applyOffsetToCamera(state.viewport, globalOffset);
  }

  state.sheetGUID = options.sheetGUID;
  state.sheetName = options.sheetName;
  return state;
};

var getViewportData = function getViewportData(viewer, layerData) {var
  model = viewer.model;
  var globalOffset = model ? model.getData().globalOffset : null;

  var metadata = layerData.metadata.markup_metadata;

  if (globalOffset) {
    var clonedMarkupData = JSON.parse(JSON.stringify(metadata));var

    viewport = clonedMarkupData.viewport;

    var invGlobalOffset = { x: -globalOffset.x, y: -globalOffset.y, z: -globalOffset.z };
    applyOffsetToCamera(viewport, invGlobalOffset);

    return clonedMarkupData;
  }

  return metadata;
};

var restoreMarkupViewState = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(viewer, layerData, immediate) {var cb,amendedData,doTransition,_args2 = arguments;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:cb = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};if (
            layerData) {_context2.next = 4;break;}
            cb(false);return _context2.abrupt("return");case 4:



            amendedData = getViewportData(viewer, layerData);

            viewer.restoreState(amendedData, null, immediate);

            doTransition = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var camera;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (
                        immediate) {_context.next = 3;break;}_context.next = 3;return (
                          Autodesk.Viewing.EventUtils.waitUntilTransitionEnded(viewer));case 3:


                        // Fix ALEX-6333
                        // RestoreState will async to update camera's all data. Here force update camera before load markup.
                        camera = viewer.navigation.getCamera();
                        viewer.navigation.updateCamera();
                        camera.updateMatrixWorld();
                        viewer.impl.sceneUpdated(true);

                        cb(true);case 8:case "end":return _context.stop();}}}, _callee);}));return function doTransition() {return _ref2.apply(this, arguments);};}();


            doTransition();_context2.next = 10;return (

              Autodesk.Viewing.EventUtils.waitUntilGeometryLoaded(viewer));case 10:
            viewer.impl.sceneUpdated(true);case 11:case "end":return _context2.stop();}}}, _callee2);}));return function restoreMarkupViewState(_x, _x2, _x3) {return _ref.apply(this, arguments);};}();

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsSerializer.js":
/*!****************************************************!*\
  !*** ./extensions/BimMarkups/MarkupsSerializer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "leafletWorldToMarkups": () => (/* binding */ leafletWorldToMarkups),
/* harmony export */   "generateSVGData": () => (/* binding */ generateSVGData),
/* harmony export */   "generateJsonData": () => (/* binding */ generateJsonData)
/* harmony export */ });
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsSceneState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsSceneState */ "./extensions/BimMarkups/MarkupsSceneState.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}




var removeUnnecessaryProperties = function removeUnnecessaryProperties(state, isGroup) {
  delete state.scale;
  delete state.translation;

  if (isGroup) {
    delete state.style;
    delete state.position;
    delete state.size;
    delete state.rotation;
  }
};

var leafletWorldToMarkups = function leafletWorldToMarkups(point, viewer) {
  var loadOptions;
  var bounds;

  if (viewer.model.isPdf(true)) {
    Autodesk.Viewing.PDFUtils.pdfToLeafletWorld(viewer, point);
    loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);
    bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);
  } else {
    var modelData = viewer.model.getData();
    loadOptions = modelData.loadOptions.loadOptions;
    bounds = modelData.bbox;
  }var _loadOptions =

  loadOptions,texWidth = _loadOptions.texWidth,texHeight = _loadOptions.texHeight;

  var worldPos = point;
  var worldTopLeft = new THREE.Vector3(bounds.min.x, bounds.max.y, 0);

  worldPos.sub(worldTopLeft);
  point.x = worldPos.x * texWidth / bounds.size().x;
  point.y = worldPos.y * texHeight / bounds.size().y;

  return point;
};

var leafletSizeFromWorldToMarkups = function leafletSizeFromWorldToMarkups(size, viewer) {
  var a = leafletWorldToMarkups(new THREE.Vector3(), viewer);
  var b = leafletWorldToMarkups(new THREE.Vector3(size, 0, 0), viewer);

  return a.distanceTo(b);
};

var convertAnchorsToMarkupSpecificNodeNames = function convertAnchorsToMarkupSpecificNodeNames(state) {
  var anchors = {};

  switch (state.type) {
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_RECTANGLE:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_CLOUD:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_CIRCLE:
      break;
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_ARROW:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_LINE:
      anchors.tail = state.anchors[0];
      anchors.head = state.anchors[1];
      break;
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_DIMENSION:
      anchors.firstAnchor = state.anchors[0];
      anchors.secondAnchor = state.anchors[1];
      break;
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_HIGHLIGHT:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_FREEHAND:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_POLYCLOUD:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_POLYLINE:
      anchors.locations = state.anchors;
      break;
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_ARROW_CALLOUT:
      //TODO
      break;
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_TEXT:
    case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_CALLOUT:
      //TODO
      break;}


  state.anchors = anchors;
};

var createSvgElement = function createSvgElement(type, _document) {
  return _document.createElementNS('http://www.w3.org/2000/svg', type);
};

var addSvgMetadata = function addSvgMetadata(svg, metadata, _document) {
  var metadataNode = _document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
  var dataVersionNode = _document.createElement('markup_document');

  metadataNode.appendChild(dataVersionNode);

  // NOTE: We could iterate over the properties, but we don't because these are the only ones supported
  dataVersionNode.setAttribute('data-model-version', metadata['data-model-version']); // Version. For example: "1"

  svg.insertBefore(metadataNode, svg.firstChild);
  return metadataNode;
};

var createMarkupPathSvg = function createMarkupPathSvg(closed, _document) {
  var svg = createSvgElement('g', _document);
  svg.setAttribute('cursor', 'inherit');
  svg.setAttribute('pointer-events', 'none');

  var path = createSvgElement('path', _document);
  path.setAttribute('id', 'markup');

  if (closed) {
    path.setAttribute('d', 'M 0 0 z');
  } else {
    path.setAttribute('d', 'M 0 0');
  }

  svg.appendChild(path);

  return svg;
};

var addMarkupMetadata = function addMarkupMetadata(shape, metadata, _document) {
  var metadataNode = _document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
  var dataVersionNode = _document.createElement('markup_element');

  metadataNode.appendChild(dataVersionNode);

  Object.keys(metadata).forEach(function (key) {
    dataVersionNode.setAttribute(key, metadata[key]);
  });

  shape.insertBefore(metadataNode, shape.firstChild);
  return metadataNode;
};

var svgNodeToString = function svgNodeToString(domNode) {
  var result = '';
  try {
    var xmlSerializer = new XMLSerializer();
    result = xmlSerializer.serializeToString(domNode);
  } catch (err) {
    console.error('svgNodeToString failed to generate string representation of domNode.');
  }

  return result;
};

var flattenObject = function flattenObject(obj) {
  var flattenObj = {};

  Object.keys(obj).forEach(function (key) {
    if (_typeof(obj[key]) === 'object' && !Array.isArray(obj[key])) {
      Object.keys(obj[key]).forEach(function (k) {
        flattenObj[k] = obj[key][k];
      });
    } else {
      flattenObj[key] = obj[key];
    }
  });

  return flattenObj;
};

var convertCoordinatesToStrings = function convertCoordinatesToStrings(state) {
  Object.keys(state).forEach(function (key) {
    if (Array.isArray(state[key])) {
      var arr = state[key];
      var coordinates = [];

      arr.forEach(function (item) {
        coordinates.push(item.x);
        coordinates.push(item.y);
      });

      state[key] = coordinates.join(' ');
    } else if (_typeof(state[key]) === 'object') {
      var obj = state[key];
      var _coordinates = [];

      _coordinates.push(obj.x);
      _coordinates.push(obj.y);

      state[key] = _coordinates.join(' ');
    }
  });
};

var generateSVGData = function generateSVGData(layer, viewer, renderer) {
  var _document = viewer.getDocument();
  var svg = createSvgElement('svg', _document);
  addSvgMetadata(svg, { 'data-model-version': '5' }, _document);

  var markups = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.getObjectAsList)(layer.markups);

  var viewerStateBackup = !viewer.impl.is2d ? viewer.getState() : null;

  var isLeaflet = viewer.model.isLeaflet();
  var isPdf = viewer.model.isPdf(true);

  var tmpCenter = new THREE.Vector3();
  markups.forEach(function (markup) {
    var state = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(markup.getState());

    if (!viewer.impl.is2d) {
      (0,_MarkupsSceneState__WEBPACK_IMPORTED_MODULE_2__.restoreMarkupViewState)(viewer, layer.layerData, true);
    }

    state.anchors.forEach(function (anchor) {
      markup.applyScaleAndTranslation(anchor);
      if (isLeaflet || isPdf)
      anchor.copy(leafletWorldToMarkups(anchor, viewer));
    });

    // Store size and position, then reverse translate the anchors
    if (markup.type !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_ARROW &&
    markup.type !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_DIMENSION &&
    !markup.isGroupMarkup()) {
      var boundingBox;

      if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_CALLOUT) {
        // To conform with old style
        state.isFrameUsed = state.isFrameUsed ? 1 : 0;
        // Store size without frame size
        boundingBox = markup.getWorldBoundingBoxTextOnly();
      } else {
        boundingBox = markup.getWorldBoundingBox();
      }

      var size = boundingBox.size();

      var center = boundingBox.getCenter(tmpCenter);

      if (isLeaflet || isPdf) {
        center.copy(leafletWorldToMarkups(center, viewer));
        size.x = leafletSizeFromWorldToMarkups(size.x, viewer);
        size.y = leafletSizeFromWorldToMarkups(size.y, viewer);
      }

      state.size = "".concat(size.x, " ").concat(size.y);
      state.position = "".concat(center.x, " ").concat(center.y);

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.applyTranslation)(state.anchors, center.clone().negate());
    }

    if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_DIMENSION) {
      if (isLeaflet || isPdf) {
        state.translation.copy(leafletWorldToMarkups(state.translation, viewer).sub(leafletWorldToMarkups(new THREE.Vector3(), viewer)));
      }
      state.offset = "".concat(state.translation.x, " ").concat(state.translation.y, " ").concat(state.translation.z);
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FONT_SIZE] *= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DIMENSION_FONT_SIZE_FACTOR;
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.THICKNESS] *= _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DIMENSION_THICKNESS_FACTOR;
    }

    if (isLeaflet || isPdf) {
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.THICKNESS] = leafletSizeFromWorldToMarkups(state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.THICKNESS], viewer);
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FONT_SIZE] = leafletSizeFromWorldToMarkups(state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FONT_SIZE], viewer);
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FONT_SIZE] *= renderer.getFontToWorldScale();
    }

    state.type = markup.type;

    // Support legacy markup extension - BLMV-3054.
    // Also support export of cloud callout without fill - BLMV-3523.
    if (state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FILL_COLOR] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.COLORS.NO_COLOR || markup.options.fillNotAllowed) {
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FILL_OPACITY] = 0;
      state.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.STYLE_PROPERTIES.FILL_COLOR] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.COLORS.NO_COLOR;
    }

    removeUnnecessaryProperties(state, markup.isGroupMarkup());

    convertAnchorsToMarkupSpecificNodeNames(state);

    var flatState = flattenObject(state);

    convertCoordinatesToStrings(flatState);

    var layerSVG = createMarkupPathSvg(flatState.closed, _document);
    addMarkupMetadata(layerSVG, flatState, _document);
    svg.appendChild(layerSVG);
  });

  if (viewerStateBackup) {
    viewer.restoreState(viewerStateBackup, null, true);
  }

  var output = svgNodeToString(svg);

  return output;
};

// Not in use for now.
var generateJsonData = function generateJsonData(layer) {
  var data = [];
  var markups = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_1__.getObjectAsList)(layer.markups);

  markups.forEach(function (markup) {
    var state = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(markup.getState());

    removeUnnecessaryProperties(state, markup.isGroupMarkup());

    data.push({
      type: markup.type,
      state: state,
      dataModelVersion: 6 });

  });

  return JSON.stringify(data);
};

/***/ }),

/***/ "./extensions/BimMarkups/MarkupsTool.js":
/*!**********************************************!*\
  !*** ./extensions/BimMarkups/MarkupsTool.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsTool)
/* harmony export */ });
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _EditHandlers_RectSelector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditHandlers/RectSelector */ "./extensions/BimMarkups/EditHandlers/RectSelector.js");
/* harmony import */ var _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupTypes/MarkupsTypesDictionary */ "./extensions/BimMarkups/MarkupTypes/MarkupsTypesDictionary.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var av = Autodesk.Viewing;var

MarkupsTool = /*#__PURE__*/function () {
  function MarkupsTool(markupsExtension) {_classCallCheck(this, MarkupsTool);
    this.markupsExtension = markupsExtension;
    this.setGlobalManager(markupsExtension.globalManager);
    this.viewer = markupsExtension.viewer;

    this.names = ['markups'];

    this.isActive = false;

    this.onCameraChangedBinded = this.onCameraChanged.bind(this);
    this.onEditStartBinded = this.onEditStart.bind(this);
    this.onEditEndBinded = this.onEditEnd.bind(this);
    this.onDrawEndBinded = this.onDrawEnd.bind(this);
    this.onCreationTypeChangedBinded = this.onCreationTypeChanged.bind(this);
    this.onSelectionChangedBinded = this.onSelectionChanged.bind(this);

    this.rectSelector = new _EditHandlers_RectSelector__WEBPACK_IMPORTED_MODULE_2__["default"](this.markupsExtension);

    this.lastDrawEndTime = -Infinity;
  }_createClass(MarkupsTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "getPriority", value: function getPriority()

    {
      return this.markupsExtension.markupsManager.isMarkupSessionOpen() ? 200 : 40;
    } }, { key: "updateToolPriority", value: function updateToolPriority()

    {
      this.markupsExtension.viewer.toolController.rearrangeByPriorities();
    } }, { key: "intersectHandler", value: function intersectHandler(

    markups, handlerName) {
      if (this.lastMousePos) {
        for (var i = markups.length - 1; i >= 0; i--) {
          var markup = markups[i];

          if (markup.isCompleted()) {
            var handler = markup[handlerName];

            if (handler) {
              var mousePos = this.lastMousePos.clone();
              var intersected = handler.intersect(mousePos);

              if (intersected || handler.isDragging()) {
                return handler.getCursor();
              }
            }
          }
        }
      }

      return null;
    } }, { key: "getCursor", value: function getCursor()

    {
      var duringCreationMarkup = this.markupsExtension.markupsManager.getDuringCreationMarkup(false);
      var selectableMarkups = this.markupsExtension.markupsManager.getEnabledMarkups();
      var activeLayer = this.markupsExtension.markupsManager.getActiveLayer();
      var hasSelection = this.hasSelection();

      var cursor = null;

      if (this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
        var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();
        var editableLinks = activeLayer.getAllLinks();

        cursor = duringCreationMarkup && duringCreationMarkup.creationHandler.getCursor(); // Get cursor of during creation markups.

        cursor = cursor || this.intersectHandler(editableLinks, 'anchorHandler');

        cursor = cursor || this.intersectHandler(inEditMarkups, 'anchorHandler');
        cursor = cursor || this.intersectHandler(inEditMarkups, 'scaleHandler');
        cursor = cursor || this.intersectHandler(inEditMarkups, 'rotationHandler');
        cursor = cursor || this.intersectHandler(inEditMarkups, 'translationHandler');
        cursor = cursor || this.intersectHandler(inEditMarkups, 'dimensionEditHandler');
      }

      cursor = cursor || this.intersectHandler(selectableMarkups, 'selectionHandler');

      if (!this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
        var visibleLinks = this.markupsExtension.markupsManager.getVisibleLinks();
        cursor = cursor || this.intersectHandler(visibleLinks, 'selectionHandler');
      }

      var creationType = this.markupsExtension.markupsManager.getMarkupCreationType();

      if (!cursor && creationType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.RECT_SELECTOR && !this.isRectSelectorActive()) {
        cursor = 'auto';
      }

      cursor = cursor || creationType && (hasSelection && !this.isRectSelectorActive() ? 'auto' : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_CREATION_CURSORS[creationType] || 'crosshair');

      return cursor;
    } }, { key: "register", value: function register()

    {
      this.snapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(this.viewer, { markupMode: true });
      this.viewer.toolController.registerTool(this.snapper);
    } }, { key: "deregister", value: function deregister()

    {
      if (this.snapper) {
        this.viewer.toolController.deregisterTool(this.snapper);
        this.snapper = null;
      }
    } }, { key: "activate", value: function activate(

    name) {
      if (name === this.getName() && !this.isActive) {
        this.isActive = true;
        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
        this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.onEditStartBinded);
        this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.onEditEndBinded);
        this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onDrawEndBinded);
        this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_CREATION_TYPE_CHANGED, this.onCreationTypeChangedBinded);
        this.addDocumentEventListener('selectionchange', this.onSelectionChangedBinded);
      }
    } }, { key: "deactivate", value: function deactivate(

    name) {
      if (name === this.getName() && this.isActive) {
        this.isActive = false;
        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
        this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_EDIT_START, this.onEditStartBinded);
        this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_EDIT_END, this.onEditEndBinded);
        this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_DRAWING_END, this.onDrawEndBinded);
        this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_CREATION_TYPE_CHANGED, this.onCreationTypeChangedBinded);
        this.removeDocumentEventListener('selectionchange', this.onSelectionChangedBinded);
        this.onCreationTypeChanged();
      }
    } }, { key: "onSelectionChanged", value: function onSelectionChanged()

    {
      var markups = this.markupsExtension.markupsManager.getSelectedMarkups();
      markups.forEach(function (markup) {
        if (markup.isTextMarkup() && markup.isInEdit()) {
          markup.textInputHandler.updateCaretPosition();
        }
      });
    } }, { key: "eventToWorld", value: function eventToWorld(

    event) {
      var pointScreen = { x: event.canvasX, y: event.canvasY };
      var point = this.markupsExtension.renderer.clientToWorld(pointScreen);

      return point;
    } }, { key: "getSnappedPosition", value: function getSnappedPosition()

    {
      if (!this.lastSnapPoint) {
        if (!this.viewer.impl.is2d && !this.isSnappingAllowed()) {
          this.lastSnapPoint = this.lastMousePos;
        } else {
          var pointScreen = { x: this.originalEvent.canvasX, y: this.originalEvent.canvasY };
          this.snapper.onMouseMove(pointScreen);

          if (!this.viewer.model.isLeaflet()) {
            this.snapper.indicator.render();
          }

          if (this.snapper.isSnapped()) {
            var point = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(this.snapper.getSnapResult(), this.viewer);
            this.lastSnapPoint = this.markupsExtension.renderer.documentCameraToMarkupsCamera(point);
          } else {
            this.lastSnapPoint = this.lastMousePos;
          }
        }
      }

      return this.lastSnapPoint.clone();
    } }, { key: "applyHandler", value: function applyHandler(

    items, handlerName, eventName, button) {
      for (var i = items.length - 1; i >= 0; i--) {
        var item = items[i];

        if (item.isCompleted()) {
          var handler = item[handlerName];
          if (handler) {
            var consume = handler[eventName](this.lastMousePos, button);

            if (consume) {
              return true;
            }
          }
        }
      }

      return false;
    } }, { key: "isNavigationToolActive", value: function isNavigationToolActive()

    {
      return this.viewer.getActiveNavigationTool() !== this.getName();
    } }, { key: "isSnappingAllowed", value: function isSnappingAllowed()

    {
      var markupCreationType = this.markupsExtension.markupsManager.getMarkupCreationType();
      return markupCreationType && _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_3__.markupsTypesDictionary[markupCreationType].withSnappingMarkup && (
      markupCreationType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MARKUP_TYPE_DIMENSION || !this.viewer.model.isLeaflet());
    }

    // Currently allow rect selecting only when session is open.
  }, { key: "isRectSelectorActive", value: function isRectSelectorActive() {
      return this.markupsExtension.markupsManager.isMarkupSessionOpen() && this.markupsExtension.markupsManager.getMarkupCreationType() === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.RECT_SELECTOR;
    } }, { key: "hasSelection", value: function hasSelection()

    {
      var isSessionOpen = this.markupsExtension.markupsManager.isMarkupSessionOpen();

      return this.markupsExtension.markupsManager.getSelectedMarkups().length > 0 ||
      !isSessionOpen && (
      this.markupsExtension.markupsManager.getSelectedLayers().length > 0 ||
      this.markupsExtension.markupsManager.getSelectedLinks().length > 0);
    }

    /**
       * Input handling
       */ }, { key: "handleMouseEvent", value: function handleMouseEvent(
    event, button, eventName, clickStart) {
      if (!this.markupsExtension.isToolEnabled()) {
        return false;
      }

      this.lastMousePos = this.eventToWorld(event);
      this.originalEvent = event;

      this.markupsExtension.renderer.updateRaycaster({ x: event.canvasX, y: event.canvasY });

      var markupCreationType = this.markupsExtension.markupsManager.getMarkupCreationType();
      var isSessionOpen = this.markupsExtension.markupsManager.isMarkupSessionOpen();

      var consumeEvent;
      var markup;

      if (!this.markupInEdit) {
        if (!markupCreationType ||
        !_MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_3__.markupsTypesDictionary[markupCreationType].useTimerBeforeSelection ||
        _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_3__.markupsTypesDictionary[markupCreationType].useTimerBeforeSelection && performance.now() - this.lastDrawEndTime > _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.TIMEOUT_TO_SELECT_AFTER_DRAWEND) {
          // Select & hover markups.
          var selectableMarkups = this.markupsExtension.markupsManager.getEnabledMarkups().filter(function (m) {return !m.isSelected();});
          consumeEvent = consumeEvent || this.applyHandler(selectableMarkups, 'selectionHandler', eventName, button);
        }
      }

      var activeLayer = this.markupsExtension.markupsManager.getActiveLayer();

      // Continue creating existing markup.
      if (markupCreationType) {
        markup = this.markupsExtension.markupsManager.getDuringCreationMarkup(false);

        if (markup) {
          if (!markup.isCompleted()) {
            if (consumeEvent) {
              // If another markup has been selected, cancel creation.
              markup.creationHandler.creationCancel();
            } else {
              var mousePos = markup.creationHandler.getSnappedPosition();

              // mousemove event shouldn't be triggered in creation handlers, unless the mouse moved the minimum threshold.
              if (eventName === 'handleMouseMove' && !(this.mouseMoved || markup.creationHandler.creationStarted)) {
                // Necessary in order to prevent unwanted navigation during creation.
                consumeEvent = true;
              } else {
                consumeEvent = markup.creationHandler[eventName](mousePos, button);
              }
            }
          }
        }
      }

      // Edit existing markups & link icons, using handlers.
      if (isSessionOpen) {
        // Links
        var editableLinks = activeLayer.getAllLinks();
        consumeEvent = consumeEvent || this.applyHandler(editableLinks, 'anchorHandler', eventName, button);

        // Markups
        var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();

        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'scaleHandler', eventName, button);
        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'anchorHandler', eventName, button);
        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'rotationHandler', eventName, button);
        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'translationHandler', eventName, button);
        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'dimensionEditHandler', eventName, button);
        consumeEvent = consumeEvent || this.applyHandler(inEditMarkups, 'textInputHandler', eventName, button);
      }

      // For Dimension markup only, the snapper indicator should be visible even before the creation has started.
      if (!consumeEvent && eventName === 'handleMouseMove' && this.isSnappingAllowed()) {
        this.getSnappedPosition();
      }

      // Selection rect. Currently allow rect selecting only when session is open.
      if (this.isRectSelectorActive()) {
        consumeEvent = consumeEvent || this.rectSelector[eventName](this.lastMousePos);
      }

      // Link icon click & hover.
      if (!isSessionOpen) {
        var visibleLinks = this.markupsExtension.markupsManager.getVisibleLinks();
        consumeEvent = consumeEvent || this.applyHandler(visibleLinks, 'selectionHandler', eventName, button);
      }

      // Click outside to deselect.
      if (!consumeEvent && (eventName === 'handleButtonUp' || eventName === 'handleButtonDown' && markupCreationType && _MarkupTypes_MarkupsTypesDictionary__WEBPACK_IMPORTED_MODULE_3__.markupsTypesDictionary[markupCreationType].singleClickMarkup)) {
        if (this.hasSelection() && !this.shiftDown && !this.mouseMoved && !this.isRectSelectorActive()) {
          this.markupsExtension.markupsManager.deselectAllMarkups();
          this.markupsExtension.markupsManager.deselectAllLinks();

          if (!isSessionOpen) {
            this.markupsExtension.markupsManager.deselectAllLayers(null);
          }

          consumeEvent = true;
        }
      }

      // Create new markup.
      if (!consumeEvent && clickStart && markupCreationType && !this.isNavigationToolActive()) {
        markup = this.markupsExtension.markupsManager.getDuringCreationMarkup(true);

        if (markup) {
          var _mousePos = markup.creationHandler.getSnappedPosition();
          consumeEvent = markup.creationHandler[eventName](_mousePos, button);

          if (!consumeEvent) {
            markup.creationHandler.creationCancel();
          }
        }
      }

      this.lastSnapPoint = null;

      return consumeEvent;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      this.dragging = true;
      this.buttonDownPos = new THREE.Vector2(event.canvasX, event.canvasY, 0);
      this.mouseMoved = false;
      this.buttonDownConsumed = false;
      this.selectedOnDown = false;

      this.panning = !Autodesk.Viewing.isMobileDevice() && (this.isRightClick(event) || this.isMiddleClick(event));

      if (this.panning) {
        return false;
      }

      this.markupsExtension.markupsManager.dispatchEvent({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.BUTTON_DOWN });

      this.buttonDownConsumed = this.handleMouseEvent(event, button, 'handleButtonDown', true);

      var selectedMarkups = this.markupsExtension.markupsManager.getSelectedMarkups();

      this.selectedOnDown = selectedMarkups.length > 0;

      return this.buttonDownConsumed;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      this.dragging = false;
      this.buttonDownPos = null;
      this.buttonUpConsumed = false;
      this.buttonUpCalled = true;

      if (this.panning || this.mouseMoved && !this.buttonDownConsumed) {
        this.panning = false;
        this.mouseMoved = false;
        return false;
      }

      var consumed = this.handleMouseEvent(event, button, 'handleButtonUp', false);


      var selectedMarkups = this.markupsExtension.markupsManager.getSelectedMarkups();

      // In case there is a selected markup, single click should only deselect it, and not start creating a new markup.
      if (!this.mouseMoved && this.selectedOnDown && !selectedMarkups[0]) {
        var markup = this.markupsExtension.markupsManager.getDuringCreationMarkup(false);
        if (markup) {
          markup.creationHandler.creationCancel();
        }
        this.markupsExtension.markupsManager.deselectAllMarkups();
      }

      this.buttonUpConsumed = consumed;
      var wasMouseMoved = this.mouseMoved;
      this.mouseMoved = false;

      return consumed && wasMouseMoved || this.isRectSelectorActive();
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      var consumed = this.handleMouseEvent(event, button, 'handleDoubleClick', false);
      var creationToolSelected = this.markupsExtension.markupsManager.isMarkupSessionOpen() && this.markupsExtension.markupsManager.getMarkupCreationType();
      return consumed || creationToolSelected;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      if (this.panning) {
        return false;
      }

      if (this.buttonDownPos && !this.mouseMoved) {
        this.mouseMoved = new THREE.Vector2(event.canvasX, event.canvasY, 0).distanceTo(this.buttonDownPos) > _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MIN_CHANGE_DISTANCE;
      }

      this.markupsExtension.markupsManager.unhoverAllLayers();
      this.markupsExtension.markupsManager.unhoverAllMarkups();

      var consumed = this.handleMouseEvent(event, null, 'handleMouseMove', false);

      return this.dragging && consumed;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {var _this = this;
      var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();

      var consumeEvent = false;

      var duringCreationMarkup = this.markupsExtension.markupsManager.getDuringCreationMarkup(false);

      if (duringCreationMarkup) {
        consumeEvent = duringCreationMarkup.creationHandler.handleKeyDown(event, keyCode);
      } else {
        this.markupsExtension.markupsManager.openActionGroup();
        var consumed;

        for (var i = inEditMarkups.length - 1; i >= 0; i--) {
          var markup = inEditMarkups[i];

          if (markup) {
            if (markup.isCompleted()) {
              consumed = markup.anchorHandler && markup.anchorHandler.handleKeyDown(event, keyCode);

              if (!consumed) {
                consumed = markup.textInputHandler && markup.textInputHandler.handleKeyDown(event, keyCode);
              }

              if (!consumed) {
                consumed = markup.scaleHandler && markup.scaleHandler.handleKeyDown(event, keyCode);
              }

              if (!consumed) {
                consumed = markup.rotationHandler && markup.rotationHandler.handleKeyDown(event, keyCode);
              }

              if (!consumed) {
                consumed = markup.translationHandler && markup.translationHandler.handleKeyDown(event, keyCode);
              }

              if (!consumed) {
                consumed = markup.dimensionEditHandler && markup.dimensionEditHandler.handleKeyDown(event, keyCode);
              }

              if (!consumed) {
                consumed = markup.selectionHandler && markup.selectionHandler.handleKeyDown(event, keyCode);
              }
            }
          }

          consumeEvent = consumeEvent || consumed;
        }

        this.markupsExtension.markupsManager.closeActionGroup();
      }

      var links = this.markupsExtension.markupsManager.getVisibleLinks();

      for (var _i = links.length - 1; _i >= 0; _i--) {
        var link = links[_i];

        consumeEvent = consumeEvent || link.anchorHandler && link.anchorHandler.handleKeyDown(event, keyCode);
        consumeEvent = consumeEvent || link.selectionHandler && link.selectionHandler.handleKeyDown(event, keyCode);
      }

      if (!consumeEvent) {
        switch (keyCode) {
          case Autodesk.Viewing.KeyCode.CONTROL:
            this.ctrlDown = true;
            break;
          case Autodesk.Viewing.KeyCode.SHIFT:
            this.shiftDown = true;
            consumeEvent = true;
            break;
          case Autodesk.Viewing.KeyCode.a:
            if (this.ctrlDown) {
              if (this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
                var layer = this.markupsExtension.markupsManager.getActiveLayer();
                layer.selectAllMarkups();
                consumeEvent = true;
              }
            }
            break;
          case Autodesk.Viewing.KeyCode.x:
            if (this.ctrlDown) {
              this.markupsExtension.cut();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.c:
            if (this.ctrlDown) {
              this.markupsExtension.copy();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.v:
            if (this.ctrlDown) {
              this.markupsExtension.paste();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.d: // Duplicate
            if (this.ctrlDown) {
              this.markupsExtension.copy();
              this.markupsExtension.paste();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.z:
            if (this.ctrlDown && !this.shiftDown) {
              this.markupsExtension.undo();
              consumeEvent = true;
            } else if (this.ctrlDown && this.shiftDown) {
              this.markupsExtension.redo();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.y:
            if (this.ctrlDown) {
              this.markupsExtension.redo();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.ESCAPE:
            if (this.markupsExtension.markupsManager.getSelectedMarkups().length > 0) {
              this.markupsExtension.markupsManager.deselectAllMarkups();
              consumeEvent = true;
            } else if (this.markupsExtension.markupsManager.isMarkupSessionOpen()) {
              var _layer = this.markupsExtension.markupsManager.getActiveLayer();

              if (_layer.isEmpty()) {
                this.markupsExtension.endMarkupSession(false);
              } else {
                this.markupsExtension.markupsManager.dispatchEvent({
                  type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DISCARD_PRESSED,
                  onConfirmCB: function onConfirmCB() {
                    _this.markupsExtension.endMarkupSession(false);
                  } });

              }
              consumeEvent = true;
            } else if (this.markupsExtension.markupsManager.getSelectedLayers().length > 0) {
              this.markupsExtension.markupsManager.deselectAllLayers();
              consumeEvent = true;
            }
            break;
          case Autodesk.Viewing.KeyCode.BACKSPACE:
          case Autodesk.Viewing.KeyCode.DELETE:
            this.markupsExtension.markupsManager.deleteInEditMarkups();
            break;
          default:
            break;}

      }

      return consumeEvent;
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event, button) {
      return this.buttonUpConsumed;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      var inEditMarkups = this.markupsExtension.markupsManager.getInEditMarkups();
      var duringCreationMarkup = this.markupsExtension.markupsManager.getDuringCreationMarkup(false);

      if (duringCreationMarkup) {
        duringCreationMarkup.creationHandler.handleKeyUp(event, keyCode);
      } else {
        this.markupsExtension.markupsManager.openActionGroup();

        for (var i = inEditMarkups.length - 1; i >= 0; i--) {
          var consumed = void 0;
          var markup = inEditMarkups[i];

          if (markup) {
            if (markup.isCompleted()) {
              event.isDuringEdit = i < inEditMarkups.length - 1;
              consumed = markup.anchorHandler && markup.anchorHandler.handleKeyUp(event, keyCode);

              if (!consumed) {
                consumed = markup.translationHandler && markup.translationHandler.handleKeyUp(event, keyCode);
              }
            }
          }
        }

        this.markupsExtension.markupsManager.closeActionGroup();
      }

      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.CONTROL:
          this.ctrlDown = false;
          break;
        case Autodesk.Viewing.KeyCode.SHIFT:
          this.shiftDown = false;
          break;
        default:
          break;}


      return false;
    } }, { key: "onCameraChanged", value: function onCameraChanged()

    {
      if (this.isSnappingAllowed() && !this.viewer.model.isLeaflet()) {
        this.snapper.indicator.render();
      }
    } }, { key: "onCreationTypeChanged", value: function onCreationTypeChanged()

    {
      this.snapper.indicator.clearOverlays();
    } }, { key: "onEditStart", value: function onEditStart()

    {
      this.markupInEdit = true;
      this.snapper.indicator.clearOverlays();
    } }, { key: "onEditEnd", value: function onEditEnd()

    {
      this.markupInEdit = false;
      this.snapper.indicator.clearOverlays();
    } }, { key: "onDrawEnd", value: function onDrawEnd()

    {
      this.lastDrawEndTime = performance.now();
    } }, { key: "isMiddleClick", value: function isMiddleClick(

    event) {
      return Autodesk.Viewing.Private.isMiddleClick(event);
    } }, { key: "isRightClick", value: function isRightClick(

    event) {
      return Autodesk.Viewing.Private.isRightClick(event, this.viewer.navigation);
    } }, { key: "handleBlur", value: function handleBlur()

    {
      this.ctrlDown = false;
      this.shiftDown = false;
    }

    // Mobile events
  }, { key: "handleSingleTap", value: function handleSingleTap(
    event) {
      var consumed = this.buttonUpConsumed;

      if (!this.buttonUpCalled) {
        this.handleButtonDown(event, 0);
        consumed = this.handleButtonUp(event, 0) || this.buttonUpConsumed;
      }

      // buttonUpCalled used to fix a bug where LMV sends sometimes both handleButtonUp and handleSingleTap on after the other.
      this.buttonUpCalled = false;

      return consumed;
    } }, { key: "handleDoubleTap", value: function handleDoubleTap(

    event) {
      return this.handleDoubleClick(event, 0);
    } }, { key: "isNavigationJustEnded", value: function isNavigationJustEnded()

    {
      return this.navigationEndTime && Date.now() - this.navigationEndTime < _MarkupsConstants__WEBPACK_IMPORTED_MODULE_1__.MOBILE_GESTURES_MIN_THRESHOLD_TIME;
    } }, { key: "handleGesture", value: function handleGesture(

    event) {
      var consumed;

      switch (event.type) {
        case 'dragstart':
          if (this.isNavigationJustEnded()) {
            return false;
          }

          return this.handleButtonDown(event, 0);
        case 'dragmove':
          if (this.isNavigationJustEnded()) {
            return false;
          }
          return this.handleMouseMove(event);
        case 'dragend':
          if (this.isNavigationJustEnded()) {
            return false;
          }
          consumed = this.handleButtonUp(event, 0);
          this.buttonUpCalled = false;
          return consumed;
        case 'pinchend':
          this.navigationEndTime = Date.now();
          break;
        case 'panend':
          this.navigationEndTime = Date.now();
          break;

        default:
          break;}


      return false;
    } }]);return MarkupsTool;}();


av.GlobalManagerMixin.call(MarkupsTool.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/MarkupsGeometryManager.js":
/*!*************************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/MarkupsGeometryManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsGeometryManager)
/* harmony export */ });
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MeshLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MeshLine */ "./extensions/BimMarkups/RendererHelpers/MeshLine.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _PenSmoothing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PenSmoothing */ "./extensions/BimMarkups/RendererHelpers/PenSmoothing.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var

MarkupsGeometryManager = /*#__PURE__*/function () {
  function MarkupsGeometryManager(markupsExtension) {_classCallCheck(this, MarkupsGeometryManager);
    this.markupsExtension = markupsExtension;

    this.geoCache = {};
  }_createClass(MarkupsGeometryManager, [{ key: "getStrokeGeometry", value: function getStrokeGeometry(

    markup) {
      if (this._isCacheSupported(markup.type)) {
        return this._getCachedStrokeGeometry(markup.type);
      } else {
        if (MarkupsGeometryManager.areAllAnchorsEqual(markup.editState.anchors)) {
          return this._createPointGeometry(markup);
        }
        return this._createStrokeGeometry(markup);
      }
    } }, { key: "getFillGeometry", value: function getFillGeometry(

    markup) {
      switch (markup.type) {
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYCLOUD:{
            var fill = { innerGeometry: this._getFillInnerGeometryFromAnchors(markup) };
            if (markup.meshLine.type !== _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE) {
              fill.arcGeometry = this._getFillCircleGeometry(markup.meshLine.radius);
              fill.fillGapGeometries = this._getFillingGapsGeometry(markup);
            }
            return fill;
          }
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYLINE:
          return this._getFillInnerGeometryFromAnchors(markup);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE:
          return this._getFillCircleGeometry(0.5, 72);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE:
          return this._getFillRectangleGeometry();
        default:
          return null;}

    } }, { key: "_getFillingGapsGeometry", value: function _getFillingGapsGeometry(

    markup) {
      var fillGapGeometries = [];
      for (var i = 0; i < markup.meshLine.intersectionObjects.length; i++) {var _markup$meshLine$inte =
        markup.meshLine.intersectionObjects[i],beginPoint = _markup$meshLine$inte.beginPoint,endPoint = _markup$meshLine$inte.endPoint,newCircle = _markup$meshLine$inte.newCircle,anchorPoint = _markup$meshLine$inte.anchorPoint,beginCircle = _markup$meshLine$inte.beginCircle,endCircle = _markup$meshLine$inte.endCircle;

        if (!beginPoint || !endPoint || !anchorPoint || !beginCircle || !endCircle || !newCircle) {
          return null;
        }

        var vertices = [];
        vertices.push(new THREE.Vector3(anchorPoint.x, anchorPoint.y, 0));
        vertices.push(new THREE.Vector3(beginCircle.x, beginCircle.y, 0));
        vertices.push(new THREE.Vector3(beginPoint.x, beginPoint.y, 0));
        vertices.push(new THREE.Vector3(newCircle.x, newCircle.y, 0));
        vertices.push(new THREE.Vector3(endPoint.x, endPoint.y, 0));
        vertices.push(new THREE.Vector3(endCircle.x, endCircle.y, 0));

        fillGapGeometries.push(new THREE.ShapeGeometry(new THREE.Shape(vertices)));
      }
      return fillGapGeometries;
    } }, { key: "_getFillCircleGeometry", value: function _getFillCircleGeometry(

    radius) {var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
      var hashName = 'circle-fill|r:' + radius + '|s:' + segments;
      if (!this.geoCache[hashName]) {
        this.geoCache[hashName] = new THREE.CircleGeometry(radius, segments);
      }
      return this.geoCache[hashName];
    } }, { key: "_getFillRectangleGeometry", value: function _getFillRectangleGeometry()

    {
      var hashName = 'rectangle-fill';
      if (!this.geoCache[hashName]) {
        this.geoCache[hashName] = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
      }
      return this.geoCache[hashName];
    } }, { key: "_getFillInnerGeometryFromAnchors", value: function _getFillInnerGeometryFromAnchors(

    markup) {
      if (markup.meshLine.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE) {
        return this._getFillCircleGeometry(0.5, 10);
      }
      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(markup.getAnchors());
      this._centerAndScaleLocations(anchors, markup.center, markup.scaleMatrix);
      if (markup.meshLine.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD) {
        this._shiftAnchorsInsideBox(markup, anchors, markup.meshLine.radius);
      }
      return anchors.length > 2 ? new THREE.ShapeGeometry(new THREE.Shape(anchors)) : null;
    } }, { key: "_getCachedStrokeGeometry", value: function _getCachedStrokeGeometry(

    type) {
      var hashName = type;
      if (!this.geoCache[hashName]) {
        this.geoCache[hashName] = this._createCachedStrokeGeometry(type);
      }

      return this.geoCache[hashName];
    } }, { key: "_isCacheSupported", value: function _isCacheSupported(

    type) {
      var supportedTypes = [_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE];
      return supportedTypes.includes(type);
    } }, { key: "isCachedGeometry", value: function isCachedGeometry(

    meshLine) {
      for (var key in this.geoCache) {
        if (meshLine === this.geoCache[key]) {
          return true;
        }
      }

      return false;
    } }, { key: "_createCachedStrokeGeometry", value: function _createCachedStrokeGeometry(

    type) {
      switch (type) {
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE:
          return this._createRectangleStrokeGeometry();
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE:
          return this._createCircleStrokeGeometry();
        default:
          return null;}

    } }, { key: "_createStrokeGeometry", value: function _createStrokeGeometry(

    markup) {
      switch (markup.type) {
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYCLOUD:{
            var geo = this._createCloudGeometry(markup);
            if (!geo) {
              geo = this._getCachedStrokeGeometry(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE);
            }
            return geo;
          }
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYLINE:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_LINE:
          return this._createLineGeometry(markup, 179);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_FREEHAND:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_HIGHLIGHT:
          return this._createLineGeometry(markup, 120);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_ARROW:
          return this._createArrowGeometry(markup);
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_DIMENSION:
          return this._createDimensionGeometry(markup);
        default:
          return null;}

    } }, { key: "_createPointGeometry", value: function _createPointGeometry(

    markup) {
      var capType, width;

      switch (markup.type) {
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_POLYCLOUD:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_FREEHAND:
        case _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_HIGHLIGHT:
          capType = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP;
          width = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.POINT_SIZE_IN_MM * this.markupsExtension.renderer.mmToWorldUnitFactor;
          break;
        default:
          capType = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_FLAT_CAP;
          width = this.markupsExtension.renderer.getNormaStrokeWidth();
          break;}


      var geometry = [
      { x: 0.0, y: 0.0, z: 0.0 },
      { x: width, y: 0.0, z: 0.0 }];


      return this._createMeshLine(geometry, markup.type, markup, null, { capType: capType });
    } }, { key: "_createMeshLine", value: function _createMeshLine(

    geometry, type, markup, connectivity) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};var widthCB = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var meshLine;
      if (markup) {
        meshLine = markup.meshLine;
        options.useExactSize = markup.completed;
      } else {
        options.useExactSize = true; // For a cached geometry
      }

      if (!meshLine || meshLine.type !== type) {
        meshLine = new _MeshLine__WEBPACK_IMPORTED_MODULE_3__.MeshLine(this.markupsExtension.renderer.supportsInt32Index());
      }

      meshLine.type = type;
      meshLine.setGeometry(geometry, widthCB, connectivity, options);

      return meshLine;
    } }, { key: "_createRectangleStrokeGeometry", value: function _createRectangleStrokeGeometry()

    {
      var geometry = [
      { x: -0.5, y: -0.5, z: 0 },
      { x: 0.5, y: -0.5, z: 0 },
      { x: 0.5, y: 0.5, z: 0 },
      { x: -0.5, y: 0.5, z: 0 },
      { x: -0.5, y: -0.5, z: 0 }];


      return this._createMeshLine(geometry, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_RECTANGLE, null, null, { isClosed: true });
    } }, { key: "_createCircleStrokeGeometry", value: function _createCircleStrokeGeometry()

    {
      var geometry = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.createArc)(0, 0, 0.5, 0, 2 * Math.PI, false, 72);
      return this._createMeshLine(geometry, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CIRCLE, null, null, { isClosed: true });
    } }, { key: "_centerAndScaleLocations", value: function _centerAndScaleLocations(

    locations, center, scale) {
      locations.forEach(function (location) {
        location.sub(center);
        location.applyMatrix4(scale);
      });
    } }, { key: "_createLineGeometry", value: function _createLineGeometry(

    markup) {var limitDegrees = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 29;
      var isPen = markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_FREEHAND || markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_HIGHLIGHT;
      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(markup.getEditState().anchors);

      this._centerAndScaleLocations(anchors, markup.center, markup.scaleMatrix);

      var connectivity = [],widths = null;
      if (markup.editState.closed) {
        anchors.push(anchors[0]);
      }

      if (isPen) {
        var segmentSize = 0.5 * markup.markupsExtension.renderer.mmToWorldUnitFactor;
        var useVariableWidth = false; //markup.type === MarkupsConstants.MARKUP_TYPE_FREEHAND && anchors[0] && anchors[0].width !== undefined; // TODO define width location in state
        var smoothie = (0,_PenSmoothing__WEBPACK_IMPORTED_MODULE_5__["default"])(anchors, segmentSize, useVariableWidth);
        anchors = smoothie.anchors;
        widths = smoothie.widths;
      }

      // Use a joinType if miter will be too long. Default limit taken from:
      // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit
      var prev = new THREE.Vector3();
      var next = new THREE.Vector3();
      var limit = Math.cos(limitDegrees * Math.PI / 180);

      for (var i = 1; i < anchors.length - 1; i++) {
        prev.copy(anchors[i - 1]).sub(anchors[i]).normalize();
        next.copy(anchors[i + 1]).sub(anchors[i]).normalize();
        if (next.dot(prev) > limit) {
          anchors.splice(i, 0, anchors[i]); // Adding a repeated point for the join
          widths && widths.splice(i, 0, widths[i]);
          connectivity[i] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END;
          i++;
        }
      }

      if (markup.editState.closed) {
        prev.copy(anchors[anchors.length - 2]).sub(anchors[anchors.length - 1]).normalize();
        next.copy(anchors[1]).sub(anchors[0]).normalize();
        if (next.dot(prev) > limit) {
          anchors.push(anchors[0]);
          widths && widths.push(widths[0]);
        }
      }

      return this._createMeshLine(anchors, markup.type, markup, connectivity, {
        capType: isPen ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_FLAT_CAP,
        joinType: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP,
        isClosed: markup.editState.closed }, widths);
    } }, { key: "_createArrowGeometry", value: function _createArrowGeometry(

    markup) {// Can probably be cached
      var t = markup.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS];

      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(markup.getEditState().anchors);
      // Actual anchors
      anchors[0].sub(markup.center); // Tail
      anchors[1].sub(markup.center); // Head

      var line = anchors[1].clone().sub(anchors[0]);

      var eyeVec = this.markupsExtension.renderer.getCameraEyeVector();
      var tipLength = Math.min(t * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.ARROW_TIP_LENGTH, line.length() / 2); // If the line length is short, then reduce tip length.

      var connectivity = [];

      // If the tip length is smaller than the thickness, don't render it at all.
      var withTip = tipLength > t;
      if (withTip) {
        var lineDirection = line.clone().normalize();
        var p = anchors[1].clone().sub(lineDirection.multiplyScalar(tipLength));
        var angle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(30);

        anchors[2] = p.clone();
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(anchors[2], angle, anchors[1], eyeVec);

        anchors[3] = anchors[1].clone();

        anchors[4] = p.clone();
        _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation(anchors[4], -angle, anchors[1], eyeVec);

        connectivity[1] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END;
        connectivity[2] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START;
      }

      var meshLine = this._createMeshLine(anchors, markup.type, markup, connectivity);

      // Find bounding points (for accurate bounding box). Needs to take into the account the arrow head
      if (withTip) {
        anchors[0].add(markup.center);
        anchors[1].add(markup.center);
        anchors[2].add(markup.center);
        anchors[4].add(markup.center);

        meshLine.boundingPoints = [anchors[0], anchors[2], anchors[1], anchors[4]];
      }

      return meshLine;
    } }, { key: "_createDimensionGeometry", value: function _createDimensionGeometry(

    markup) {
      var thickness = markup.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS] * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_THICKNESS_FACTOR;

      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(markup.getEditState().anchors);

      var points = [];
      var connectivity = [];

      function addSingleSegment(p1, p2) {
        points = points.concat([p1, p2]);
        connectivity = connectivity.concat([
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START,
        _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END]);

      }

      // Actual anchors
      anchors[0].sub(markup.center); // firstAnchor
      anchors[1].sub(markup.center); // secondAnchor

      addSingleSegment(anchors[0], anchors[1]);

      var lineDirection = anchors[0].clone().sub(anchors[1]);
      var eyeVec = this.markupsExtension.renderer.getCameraEyeVector();
      var normal = lineDirection.clone().cross(eyeVec).normalize();
      var tipLength = thickness * _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.DIMENSION_TIP_LENGTH;
      var halfTip = normal.clone().multiplyScalar(tipLength);
      var angle = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].degreesToRadians(45);

      // diagonal tip
      anchors[2] = anchors[0].clone().add(halfTip);
      anchors[3] = anchors[0].clone().sub(halfTip);
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation([anchors[2], anchors[3]], angle, anchors[0], eyeVec);
      addSingleSegment(anchors[2], anchors[3]);

      // diagonal tip
      anchors[4] = anchors[1].clone().add(halfTip);
      anchors[5] = anchors[1].clone().sub(halfTip);
      _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].applyRotation([anchors[4], anchors[5]], angle, anchors[1], eyeVec);
      addSingleSegment(anchors[4], anchors[5]);

      // Dashed line
      anchors[6] = anchors[0].clone();
      markup.applyInverseScaleAndTranslation(anchors[6]); // Dashed line start
      if (!(0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.isEqualVectors)(anchors[6], anchors[0])) {
        anchors[7] = anchors[0].clone().sub(anchors[0].clone().sub(anchors[6]).normalize().multiplyScalar(tipLength)); // Dashed line end
        addSingleSegment(anchors[6], anchors[7]);
      }

      // Dashed line
      anchors[8] = anchors[1].clone();
      markup.applyInverseScaleAndTranslation(anchors[8]); // Dashed line start
      if (!(0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.isEqualVectors)(anchors[8], anchors[1])) {
        anchors[9] = anchors[1].clone().sub(anchors[1].clone().sub(anchors[8]).normalize().multiplyScalar(tipLength)); // Dashed line end
        addSingleSegment(anchors[8], anchors[9]);
      }

      // straight tip
      anchors[10] = anchors[0].clone().add(halfTip);
      anchors[11] = anchors[0].clone().sub(halfTip);
      addSingleSegment(anchors[10], anchors[11]);

      // straight tip
      anchors[12] = anchors[1].clone().add(halfTip);
      anchors[13] = anchors[1].clone().sub(halfTip);
      addSingleSegment(anchors[12], anchors[13]);

      return this._createMeshLine(points, markup.type, markup, connectivity);
    } }, { key: "_createCloudGeometry", value: function _createCloudGeometry(

    markup) {
      var anchors = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_1__["default"].cloneDeep(markup.getEditState().anchors);

      if ((0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.isClockwise)(anchors, markup)) {
        anchors.reverse();
      }

      var radius = this.getCloudMinimumRadius(markup.editState.style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.STYLE_PROPERTIES.THICKNESS]);
      var radiusInMM = radius / this.markupsExtension.renderer.mmToWorldUnitFactor;

      this._centerAndScaleLocations(anchors, markup.center, markup.scaleMatrix);

      var isClosed = markup.editState.closed;
      var boundingBox;
      if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MARKUP_TYPE_CLOUD) {
        isClosed = true;
        var isShift = this._shiftAnchorsInsideBox(markup, anchors, radius);
        if (!isShift) {
          return null;
        }
      } else {// Polycloud
        boundingBox = new THREE.Box3();
        boundingBox.min.z = boundingBox.max.z = 0;
      }

      var intersectionObjects = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.handleIntersection)(anchors, radius);

      var arcs = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.createCloud)(anchors, radius, isClosed, intersectionObjects);

      if (arcs.length === 0) {
        return null;
      }

      var path = [];
      var connectivity = [];
      var prevPathLength = 0;

      for (var i = 0; i < arcs.length; i++) {
        var curr = arcs[i];
        // Hide circle if an anchor's circle is larger that 342 degrees
        if (curr.isAnchor) {
          var angleSize = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getArcAngleSize)(curr);
          if (angleSize > Math.PI * 1.9) {
            curr.begin = curr.end;
          }
        }
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.createArc)(curr.x, curr.y, radius, curr.begin, curr.end, false, null, path, radiusInMM, boundingBox);
        var length = path.length - prevPathLength;
        connectivity[prevPathLength] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START;
        connectivity[prevPathLength + length - 1] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END;
        prevPathLength += length;
      }

      var meshLine = this._createMeshLine(path, markup.type, markup, connectivity, {
        capType: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP,
        joinType: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP });

      meshLine.arcs = arcs;
      meshLine.radius = radius;
      meshLine.intersectionObjects = intersectionObjects;

      if (boundingBox) {// Polycloud
        boundingBox.applyMatrix4(markup.invScaleMatrix);
        boundingBox.translate(markup.center);
        // Store the 4 corners of the bounding box, so if it's rotated later on we get the proper bounds
        meshLine.boundingPoints = [boundingBox.min.clone(), boundingBox.max.clone(), boundingBox.max.clone(), boundingBox.min.clone()];
        meshLine.boundingPoints[1].y = boundingBox.min.y;
        meshLine.boundingPoints[3].y = boundingBox.max.y;
      }

      return meshLine;
    } }, { key: "_shiftAnchorsInsideBox", value: function _shiftAnchorsInsideBox(

    markup, anchors, radius) {
      var rightVec = anchors[0].clone().sub(anchors[1]).normalize();
      var upVec = anchors[2].clone().sub(anchors[1]).normalize();

      var width = anchors[0].distanceTo(anchors[1]) / 2;
      var height = anchors[2].distanceTo(anchors[1]) / 2;

      if (height < radius || width < radius) {
        return false;
      }

      for (var i = 0; i < anchors.length; i++) {
        // Shift anchors inside bounding box
        var anchor = anchors[i];

        var dist = radius * Math.sign(anchor.dot(upVec));
        anchor.sub(upVec.clone().multiplyScalar(dist));

        dist = radius * Math.sign(anchor.dot(rightVec));
        anchor.sub(rightVec.clone().multiplyScalar(dist));
      }

      return true;
    } }, { key: "getCloudMinimumRadius", value: function getCloudMinimumRadius(

    thickness) {
      var minRadius = this.markupsExtension.renderer.mmToWorldUnitFactor * (this.markupsExtension.viewer.impl.is2d ? 1 : 10);
      return Math.max(thickness * 3, minRadius);
    } }, { key: "destroy", value: function destroy()













    {
      for (var key in this.geoCache) {
        this.geoCache[key].dispose();
      }
      this.geoCache = null;
    } }], [{ key: "areAllAnchorsEqual", value: function areAllAnchorsEqual(anchors) {var first = anchors[0];for (var i = 1; i < anchors.length; i++) {if (!anchors[i].equals(first)) {return false;}}return true;} }]);return MarkupsGeometryManager;}();

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/MarkupsMaterialManager.js":
/*!*************************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/MarkupsMaterialManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsMaterialManager)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MeshLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MeshLine */ "./extensions/BimMarkups/RendererHelpers/MeshLine.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

MarkupsMaterialManager = /*#__PURE__*/function () {
  function MarkupsMaterialManager(markupsExtension) {_classCallCheck(this, MarkupsMaterialManager);
    this.markupsExtension = markupsExtension;
    this.viewer = markupsExtension.viewer;
    this.materials = {};
  }_createClass(MarkupsMaterialManager, [{ key: "_getHashName", value: function _getHashName(

    type, style, isFill, isTransparent) {
      var name = type;

      if (isFill) {
        name += '|f';
        if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_COLOR]) {
          name += '|c' + style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_COLOR];
        }
        if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_OPACITY] !== undefined) {
          name += '|o' + style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0);
        }
      } else {
        if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.THICKNESS]) {
          name += '|t' + style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.THICKNESS];
        }
        if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.COLOR]) {
          name += '|c' + style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.COLOR];
        }
        if (style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.OPACITY] !== undefined) {
          name += '|o' + style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0);
        }
      }
      return name;
    } }, { key: "_setResolution", value: function _setResolution(

    material, resolution) {
      if (material.uniforms && material.uniforms.resolution) {
        material.uniforms.resolution.value.set(resolution.width, resolution.height);
      }
    } }, { key: "getMaterial", value: function getMaterial(

    type, style, isFill) {
      var name = this._getHashName(type, style, isFill);

      if (this.materials[name]) {
        return this.materials[name];
      }

      return null;
    } }, { key: "_setFillBlending", value: function _setFillBlending(

    material) {
      material.blending = material.opacity < 1 ? THREE.NoBlending : THREE.NormalBlending;
    } }, { key: "_setStrokeBlending", value: function _setStrokeBlending(

    material) {
      if (material.uniforms.opacity.value < 1) {
        material.blending = THREE.CustomBlending;
        // Take color from source (the markup being shaded). This is akin to NoBlending for the RGB component.
        material.blendDst = THREE.ZeroFactor;
        material.blendSrc = THREE.OneFactor;
        material.blendEquation = THREE.AddEquation;
        if (!Autodesk.Viewing.isIE11) {
          // Note: IE11 doesn't support MaxEquation, so use just Add, but don't use AA to avoid
          // rendering artifacts
          //
          // Take the max alpha between source and destination,
          // so that AA areas that overlap the markup are shaded with the markup opacity
          // If the fill opacity is larger than the stroke opacity, the fill part that overlaps the stroke will
          // affect the alpha in those areas, though. So this is a limitation of the current approach.
          material.blendEquationAlpha = THREE.MaxEquation;
        }
      } else {
        material.blending = THREE.NormalBlending;
      }
    } }, { key: "_createStrokeMaterial", value: function _createStrokeMaterial(

    style, needsMiter, isTransparent) {
      var resolution = this.markupsExtension.renderer.getResolution();

      var matOpt = {
        color: new THREE.Color(style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.COLOR]),
        opacity: style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0),
        resolution: new THREE.Vector2(resolution.width, resolution.height),
        lineWidth: style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.THICKNESS],
        side: THREE.FrontSide,
        miter: needsMiter };


      var material = new _MeshLine__WEBPACK_IMPORTED_MODULE_1__.MeshLineMaterial(matOpt);
      this._setStrokeBlending(material);

      return material;
    } }, { key: "_createFillMaterial", value: function _createFillMaterial(

    style, isTransparent) {
      var matOpt = {
        color: new THREE.Color(style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_COLOR]),
        transparent: true,
        opacity: style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0),
        side: THREE.DoubleSide,
        wireframe: false };


      var material = new THREE.MeshBasicMaterial(matOpt);
      this._setFillBlending(material);

      return material;
    } }, { key: "_editStrokeMaterial", value: function _editStrokeMaterial(

    material, style, isTransparent) {
      material.uniforms.color.value.setStyle(style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.COLOR]);
      material.uniforms.lineWidth.value = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.THICKNESS];
      material.uniforms.opacity.value = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0);
      this._setStrokeBlending(material);
    } }, { key: "_editFillMaterial", value: function _editFillMaterial(

    material, style, isTransparent) {
      material.color.setStyle(style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_COLOR]);
      material.opacity = style[_MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.STYLE_PROPERTIES.FILL_OPACITY] * (isTransparent ? _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.DISABLED_OPACITY : 1.0);
      material.needsUpdate = true;
      this._setFillBlending(material);
    } }, { key: "hasThicknessChanged", value: function hasThicknessChanged(

    material, newMaterial) {
      return material && newMaterial &&
      material.uniforms && newMaterial.uniforms &&
      material.uniforms.lineWidth.value !== newMaterial.uniforms.lineWidth.value;
    } }, { key: "addMaterial", value: function addMaterial(

    markup, isFill) {
      var type = markup.type;
      var style = markup.editState.style;
      var isTransparent = markup.isTransparent();

      var name = this._getHashName(type, style, isFill, isTransparent);

      if (!this.materials[name]) {
        var material = isFill ? this._createFillMaterial(style, isTransparent) : this._createStrokeMaterial(style, markup.needsMiter(), isTransparent);
        material.depthWrite = false;
        material.depthTest = false;
        material.transparent = true;
        material.refCount = 1;
        material.name = name;
        this.materials[name] = material;
      } else {
        this.materials[name].refCount++;
      }

      return this.materials[name];
    } }, { key: "removeMaterial", value: function removeMaterial(

    material) {
      if (!this.materials[material.name]) {
        console.error('Trying to remove a non-existing material');
        return;
      }

      material.refCount--;
      if (material.refCount === 0) {
        material.dispose();
        material.needsUpdate = true;
        delete this.materials[material.name];
      }
    } }, { key: "editMaterial", value: function editMaterial(

    material, markup, isFill) {
      if (!this.materials[material.name]) {
        console.error('Trying to edit a non-existing material');
        return;
      }

      var type = markup.type;
      var style = markup.editState.style;
      var isTransparent = markup.isTransparent();

      var newName = this._getHashName(type, style, isFill, isTransparent);
      if (newName === material.name) {
        return; // No change being done
      }

      // Cases:
      // 1. Material is used only by one mesh and new style doesn't exist already: can edit in place
      // 2. Material with new style already exists: use new material instead of current one
      // 3. This material is in use in more than one place: create a new material so changes don't affect the other usages        

      if (material.refCount === 1 && !this.materials[newName]) {// Can edit in place
        if (isFill) {
          this._editFillMaterial(material, style, isTransparent);
        } else {
          this._editStrokeMaterial(material, style, isTransparent);
        }

        delete this.materials[material.name];
        material.name = newName;
        this.materials[newName] = material;
        material.needsUpdate = true;

        return material;
      }

      this.removeMaterial(material);

      return this.addMaterial(markup, isFill);
    } }, { key: "destroy", value: function destroy()

    {
      for (var key in this.materials) {
        this.materials[key].dispose();
        this.materials[key].needsUpdate = true;
      }

      this.materials = {};
    } }, { key: "updateScreenSize", value: function updateScreenSize(

    resolution) {
      for (var key in this.materials) {
        this._setResolution(this.materials[key], resolution);
      }
    } }]);return MarkupsMaterialManager;}();

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/MeshLine.js":
/*!***********************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/MeshLine.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshLine": () => (/* binding */ MeshLine),
/* harmony export */   "MeshLineMaterial": () => (/* binding */ MeshLineMaterial)
/* harmony export */ });
/* harmony import */ var _Shaders_MeshLineVert_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shaders/MeshLineVert.glsl */ "./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineVert.glsl");
/* harmony import */ var _Shaders_MeshLineVert_glsl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Shaders_MeshLineVert_glsl__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Shaders_MeshLineFrag_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shaders/MeshLineFrag.glsl */ "./extensions/BimMarkups/RendererHelpers/Shaders/MeshLineFrag.glsl");
/* harmony import */ var _Shaders_MeshLineFrag_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Shaders_MeshLineFrag_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");




function MeshLine(supportsInt32Index) {
  this.supportsInt32Index = supportsInt32Index;
}

MeshLine.prototype.create = function () {
  this.geometry = new THREE.BufferGeometry();
};

MeshLine.prototype.dispose = function () {
  if (this.geometry) {
    this.geometry.dispose();
    this.geometry = null;
  }

  if (this.attributes) {
    for (var key in this.attributes) {
      delete this.attributes[key].array;
    }
    this.attributes = null;
  }

  this.positions = null;
  this.previous = null;
  this.next = null;
  this.side = null;
  this.width = null;
  this.counters = null;
  this.indices_array = null;
};

MeshLine.prototype.setGeometry = function (sourceGeo, widthCB, connectivity, options) {var _this = this;
  this.sourceGeo = sourceGeo;

  if (Array.isArray(widthCB)) {
    this.widthArray = widthCB;
    this.widthCallback = function (i) {return _this.widthArray[i];};
  } else {
    this.widthCallback = widthCB;
  }

  this.sourceConnectivity = connectivity || [];
  this.connectivity = {};

  this.options = Object.assign({}, {
    capType: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_FLAT_CAP,
    joinType: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_FLAT_CAP,
    useExactSize: false },
  options);

  this.isClosed = !!this.options.isClosed;

  this.process();
};

MeshLine.prototype.isPointNear = function () {
  var a = new THREE.Vector3();
  var b = new THREE.Vector3();

  // get squared distance from a point to a segment
  function getSegmentDistSq(p) {
    var x = a.x;
    var y = a.y;
    var dx = b.x - x;
    var dy = b.y - y;

    if (dx !== 0 || dy !== 0) {

      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

      if (t > 1) {
        x = b.x;
        y = b.y;

      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
  }

  return function (point, thresholdSq, matrixWorld) {
    for (var i = 0, l = this.numPoints - 1; i < l; i++) {
      if (this.connectivity[i] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END) {
        continue;
      }

      a.fromArray(this.positions, 6 * i).applyMatrix4(matrixWorld);
      b.fromArray(this.positions, 6 * (i + 1)).applyMatrix4(matrixWorld);

      if (getSegmentDistSq(point) < thresholdSq) {
        return true;
      }
    }

    return false;
  };
}();

MeshLine.prototype.getPositionV3 = function (a) {
  var aa = a * 6;

  return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];
};

MeshLine.prototype.initArrays = function (numPoints) {
  // Factors explanation:
  // For position 6 because: (x, y, z) times 2 vertices per position
  // For prev and next 4 because: (x, y) times 2 vertices per position
  // It'd be preferable to use only x,y for position as well, but since this an attribute that threejs access to do things like
  // calculate bounding sphere, it could break some things (we could get away by calculating the bounding sphere ourselves,
  // but would need to check first that other things can't break as well. Probably not worth the effort)
  var useExactSize = this.options.useExactSize;
  if (!this.capacity || this.capacity < numPoints || useExactSize && this.capacity !== numPoints) {
    this.dispose();
    var capacity = useExactSize ? numPoints : Math.ceil(1.5 * numPoints);
    this.positions = new Float32Array(6 * capacity);
    this.previous = new Float32Array(4 * capacity);
    this.next = new Float32Array(4 * capacity);

    this.side = new Float32Array(2 * capacity); // Side joined with pointType
    this.width = new Float32Array(2 * capacity);
    this.counters = new Float32Array(2 * capacity);

    // 6 because 2 triangles times 3 vertices per 2 points. So if capacity is 2 --> 6*(2-1) = 6 indices for 2 triangles
    var indexSize = 6 * (capacity - 1);
    this.indices_array = this.supportsInt32Index && indexSize > 65535 ? new Uint32Array(indexSize) : new Uint16Array(indexSize);

    this.capacity = capacity;
  }

  this.numPoints = numPoints;
};

MeshLine.prototype.getWidth = function (idx, ratio) {
  if (this.widthCallback) {
    return this.widthCallback(idx, ratio);
  }

  return 1;
};

MeshLine.prototype.process = function () {var _this2 = this;
  var srcLength = this.sourceGeo.length;
  var maxCount = Math.max(1, srcLength - 1);

  var addPosition = function addPosition(from, to, count, type) {
    var v = _this2.sourceGeo[from];
    _this2.positions.set([v.x, v.y, v.z, v.x, v.y, v.z], to * 6);

    _this2.counters.set([count, count], to * 2);

    _this2.side.set([type, -type], to * 2);

    var w = _this2.getWidth(from, from / maxCount);
    _this2.width.set([w, w], to * 2);
  };

  var addPrevious = function addPrevious() {
    var v;
    if (_this2.isClosed) {
      v = _this2.getPositionV3(l - 2);
    } else {
      v = _this2.getPositionV3(0);
    }
    _this2.previous.set([v[0], v[1], v[0], v[1]], 0);

    for (var _j = 1; _j < l; _j++) {
      if (_this2.connectivity[_j] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START) {
        v = _this2.getPositionV3(_j);
      } else if (_this2.connectivity[_j] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END) {
        v = _this2.getPositionV3(_j - 2);
      } else {
        v = _this2.getPositionV3(_j - 1);
      }
      _this2.previous.set([v[0], v[1], v[0], v[1]], _j * 4);
    }
  };

  var addNext = function addNext() {
    var v;
    for (var _j2 = 0; _j2 < l - 1; _j2++) {
      if (_this2.connectivity[_j2] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END) {
        v = _this2.getPositionV3(_j2);
      } else if (_this2.connectivity[_j2] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START) {
        v = _this2.getPositionV3(_j2 + 2);
      } else {
        v = _this2.getPositionV3(_j2 + 1);
      }
      _this2.next.set([v[0], v[1], v[0], v[1]], _j2 * 4);
    }

    if (_this2.isClosed) {
      v = _this2.getPositionV3(1);
    } else {
      v = _this2.getPositionV3(l - 1);
    }
    _this2.next.set([v[0], v[1], v[0], v[1]], (l - 1) * 4);
  };

  var usedIndices = 0;
  var addIndices = function addIndices() {
    for (var _j3 = 0; _j3 < l - 1; _j3++) {
      if (_this2.connectivity[_j3] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END) {
        continue; // Do not add the rect between a path end and a path start
      }
      var n = _j3 * 2;
      _this2.indices_array.set(
      [n, n + 1, n + 2,
      n + 2, n + 1, n + 3], usedIndices);

      usedIndices += 6;
    }
  };

  var setAttributes = function setAttributes() {
    if (!_this2.attributes) {
      _this2.create();
      _this2.attributes = {
        position: new THREE.BufferAttribute(_this2.positions, 3),
        previous: new THREE.BufferAttribute(_this2.previous, 2),
        next: new THREE.BufferAttribute(_this2.next, 2),
        side: new THREE.BufferAttribute(_this2.side, 1),
        width: new THREE.BufferAttribute(_this2.width, 1),
        index: new THREE.BufferAttribute(_this2.indices_array, 1),
        counters: new THREE.BufferAttribute(_this2.counters, 1) };


      _this2.geometry.setAttribute('position', _this2.attributes.position);
      _this2.geometry.setAttribute('previous', _this2.attributes.previous);
      _this2.geometry.setAttribute('next', _this2.attributes.next);
      _this2.geometry.setAttribute('side', _this2.attributes.side);
      _this2.geometry.setAttribute('width', _this2.attributes.width);
      _this2.geometry.setAttribute('index', _this2.attributes.index);
      _this2.geometry.setAttribute('counters', _this2.attributes.counters);
    } else {
      _this2.attributes.position.array = _this2.positions;
      _this2.attributes.position.needsUpdate = true;
      _this2.attributes.previous.array = _this2.previous;
      _this2.attributes.previous.needsUpdate = true;
      _this2.attributes.next.array = _this2.next;
      _this2.attributes.next.needsUpdate = true;
      _this2.attributes.side.array = _this2.side;
      _this2.attributes.side.needsUpdate = true;
      _this2.attributes.width.array = _this2.width;
      _this2.attributes.width.needsUpdate = true;
      _this2.attributes.index.array = _this2.indices_array;
      _this2.attributes.index.needsUpdate = true;
      _this2.attributes.counters.array = _this2.counters;
      _this2.attributes.counters.needsUpdate = true;
    }
  };

  if (srcLength === 0) {
    setAttributes();
    return;
  }

  // If open (or joinType === MarkupsConstants.MESHLINE_PATH_ROUND_CAP, like polyline, because there are no endcaps when closed),
  // need to add 1 vertex for each endcap.
  if (!this.isClosed || this.options.joinType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_ROUND_CAP) {
    this.sourceConnectivity[0] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START;
    this.sourceConnectivity[srcLength - 1] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END;
  }

  // Calculate number of vertices needed
  // For each start / end in the middle, add another position
  var l = srcLength + this.sourceConnectivity.reduce(function (x) {return x + 1;}, 0);

  // Now init array beforehand.
  // If array already exists, check if it's big enough, and if not, use heuristic to increase size
  this.initArrays(l);

  // Iterate through geoSource. Add multiple points when connectivity calls for it
  // In the end, add prev, next, indices.
  var j = 0;
  for (var i = 0; i < srcLength; i++) {
    if (this.sourceConnectivity[i] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START) {
      var endType = i === 0 && !this.isClosed ? this.options.capType : this.options.joinType;
      this.connectivity[j] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_START;
      addPosition(i, j++, -1, endType);
      addPosition(i, j++, 0, endType);
    } else if (this.sourceConnectivity[i] === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END) {
      var _endType = i === srcLength - 1 && !this.isClosed ? this.options.capType : this.options.joinType;
      addPosition(i, j++, 1, _endType);
      this.connectivity[j] = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_END;
      addPosition(i, j++, 2, _endType);
    } else {
      addPosition(i, j++, i / maxCount, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_2__.MESHLINE_PATH_DEFAULT);
    }
  }

  addPrevious();
  addNext();
  addIndices();
  setAttributes();

  this.geometry.groups[0] = {
    index: 0,
    start: 0,
    count: usedIndices };

};

function MeshLineMaterial(parameters) {

  function check(v, d) {
    if (v === undefined) return d;
    return v;
  }

  THREE.Material.call(this);

  parameters = parameters || {};

  this.lineWidth = check(parameters.lineWidth, 1);
  this.miter = check(parameters.miter, true);
  this.color = check(parameters.color, new THREE.Color(0xffffff));
  this.opacity = check(parameters.opacity, 1);
  this.resolution = check(parameters.resolution, new THREE.Vector2(1, 1));

  var material = new THREE.RawShaderMaterial({
    uniforms: {
      lineWidth: { type: 'f', value: this.lineWidth },
      color: { type: 'c', value: this.color },
      opacity: { type: 'f', value: this.opacity },
      resolution: { type: 'v2', value: this.resolution } },

    vertexShader: (_Shaders_MeshLineVert_glsl__WEBPACK_IMPORTED_MODULE_0___default()),
    fragmentShader: (_Shaders_MeshLineFrag_glsl__WEBPACK_IMPORTED_MODULE_1___default()),
    attributes: {
      previous: { type: 'v2', value: new THREE.Vector2() },
      next: { type: 'v2', value: new THREE.Vector2() },
      side: { type: 'f', value: 0 },
      width: { type: 'f', value: 0 },
      counters: { type: 'f', value: 0 } } });



  material.type = 'MeshLineMaterial';
  if (Autodesk.Viewing.isIE11) {
    material.defines.IS_IE_11 = 1;
  }
  if (this.miter) {
    material.defines.MITER = 1;
  }

  delete parameters.lineWidth;
  delete parameters.color;
  delete parameters.opacity;
  delete parameters.resolution;
  delete parameters.miter;

  material.setValues(parameters);

  return material;
}

MeshLineMaterial.prototype = Object.create(THREE.Material.prototype);
MeshLineMaterial.prototype.constructor = MeshLineMaterial;

MeshLineMaterial.prototype.copy = function (source) {

  THREE.Material.prototype.copy.call(this, source);

  this.lineWidth = source.lineWidth;
  this.color.copy(source.color);
  this.opacity = source.opacity;
  this.resolution.copy(source.resolution);
  this.miter = source.miter;

  return this;
};

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/PenSmoothing.js":
/*!***************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/PenSmoothing.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ penSmoothing)
/* harmony export */ });
// Reference: http://scaledinnovation.com/analytics/splines/aboutSplines.html
function getControlPoints(x0, y0, x1, y1, x2, y2) {var tension = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.333;
  //  x0,y0,x1,y1 are the coordinates of the end (knot) pts of this segment
  //  x2,y2 is the next knot -- not connected here but needed to calculate p2
  //  p1 is the control point calculated here, from x1 back toward x0.
  //  p2 is the next control point, calculated here and returned to become the 
  //  next segment's p1.
  //  t is the 'tension' which controls how far the control points spread.

  //  Scaling factors: distances from this knot to the previous and following knots.
  var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  var d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

  var fa = tension * d01 / (d01 + d12);
  var fb = tension - fa;

  var p1x = x1 + fa * (x0 - x2);
  var p1y = y1 + fa * (y0 - y2);

  var p2x = x1 - fb * (x0 - x2);
  var p2y = y1 - fb * (y0 - y2);

  return [{ x: p1x, y: p1y }, { x: p2x, y: p2y }];
}

function calcQuadBezier(p0, p1, p2, t) {
  var tt = t * t;
  var u = 1 - t;
  var uu = u * u;

  var x = uu * p0.x;
  x += 2 * u * t * p1.x;
  x += tt * p2.x;
  var y = uu * p0.y;
  y += 2 * u * t * p1.y;
  y += tt * p2.y;

  return { x: x, y: y, z: 0 };
}

function calcCubicBezier(p0, p1, p2, p3, t) {
  var tt = t * t;
  var ttt = tt * t;
  var u = 1 - t;
  var uu = u * u;
  var uuu = uu * u;

  var x = uuu * p0.x;
  x += 3 * uu * t * p1.x;
  x += 3 * u * tt * p2.x;
  x += ttt * p3.x;
  var y = uuu * p0.y;
  y += 3 * uu * t * p1.y;
  y += 3 * u * tt * p2.y;
  y += ttt * p3.y;

  return { x: x, y: y, z: 0 };
}

var calcPolygonLength = function () {
  var calcDistance = function calcDistance(p1, p2) {
    var dx = p1.x - p2.x;
    var dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };

  return function (points) {
    var length = 0;

    for (var i = 1; i < points.length; i++) {
      length += calcDistance(points[i], points[i - 1]);
    }

    return length;
  };
}();

function addQuadBezier(startPoint, control, endPoint, segmentSize, points, widths) {
  var segments = Math.max(Math.round(calcPolygonLength([startPoint, control, endPoint]) / segmentSize), 4);
  for (var i = 0; i < segments; i++) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / segments;
    var point = calcQuadBezier(startPoint, control, endPoint, t);
    points.push(point);
    widths && widths.push(startPoint.width + t * t * (endPoint.width - startPoint.width));
  }
}

function addCubicBezier(startPoint, control1, control2, endPoint, segmentSize, points, widths) {
  var segments = Math.max(Math.round(calcPolygonLength([startPoint, control1, control2, endPoint]) / segmentSize), 4);
  for (var i = 0; i < segments; i++) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / segments;
    var point = calcCubicBezier(startPoint, control1, control2, endPoint, t);
    points.push(point);
    widths && widths.push(startPoint.width + t * t * t * (endPoint.width - startPoint.width));
  }
}

function penSmoothing(anchors, segmentSize, useVariableWidth) {
  if (anchors.length < 3) {
    return { anchors: anchors };
  }

  var cp = [];
  var finalAnchors = [];
  var widths = useVariableWidth ? [] : null;
  var n = anchors.length;
  // Low pass filter to smooth uneven input - doesn't seem necessary when using simplify. Leaving it just in case.
  // const alpha = 0.9;
  // for (let i = 1; i < n - 1; i++){
  //     anchors[i].x = anchors[i].x * alpha + (1 - alpha) * anchors[i - 1].x;
  //     anchors[i].y = anchors[i].y * alpha + (1 - alpha) * anchors[i - 1].y;
  // }

  // Calculate control points for bezier curves
  for (var i = 0; i < n - 2; i++) {
    cp = cp.concat(getControlPoints(anchors[i].x, anchors[i].y, anchors[i + 1].x, anchors[i + 1].y, anchors[i + 2].x, anchors[i + 2].y));
  }

  // First 2 points get a quadratic bezier (because need at least 3 points for a cubic one)
  addQuadBezier(anchors[0], cp[0], anchors[1], segmentSize, finalAnchors, widths);

  // Middle points get cubic beziers
  for (var _i = 1; _i < n - 3; _i++) {
    addCubicBezier(anchors[_i], cp[2 * _i - 1], cp[2 * _i], anchors[_i + 1], segmentSize, finalAnchors, widths);
  }

  // Last 2 points get a quadratic bezier again
  addQuadBezier(anchors[n - 2], cp[2 * n - 5], anchors[n - 1], segmentSize, finalAnchors, widths);

  // Since it's continuous, the quad and cubic functions don't add the last point
  // (to avoid duplicating with the first point of the next curve), so need to add the very last point here.
  finalAnchors.push(anchors[n - 1]);
  widths && widths.push(anchors[n - 1].width);

  return { anchors: finalAnchors, widths: widths };
}

/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/TextRenderer.js":
/*!***************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/TextRenderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextRenderer)
/* harmony export */ });
/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! html2canvas */ "./extensions/BimMarkups/node_modules/html2canvas/dist/html2canvas.js");
/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(html2canvas__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Utils/GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _TextRenderer_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextRenderer.css */ "./extensions/BimMarkups/RendererHelpers/TextRenderer.css");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}






var av = Autodesk.Viewing;var

TextRenderer = /*#__PURE__*/function () {
  function TextRenderer(markupsExtension) {_classCallCheck(this, TextRenderer);
    this.markupsExtension = markupsExtension;
    this.setGlobalManager(markupsExtension.globalManager);
    this.viewer = this.markupsExtension.viewer;
    this.container = this.viewer.appendOrderedElementToViewer('markup-text-container');
    this.container.className = 'markup-text-container';

    this.labels = {};
    this.textMarkups = {};
    this.textSizeCache = {};

    this.registerEventListeners();
  }_createClass(TextRenderer, [{ key: "registerEventListeners", value: function registerEventListeners()

    {
      this.onMarkupRemovedBinded = this.onMarkupRemoved.bind(this);
      this.onCameraChangedBinded = this.onCameraChanged.bind(this);
      this.onMarkupVisibilityChangedBinded = this.onMarkupVisibilityChanged.bind(this);
      this.onResizeBinded = this.onResize.bind(this);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__.MARKUPS_EVENTS.MARKUP_VISIBILITY_CHANGED, this.onMarkupVisibilityChangedBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__.MARKUPS_EVENTS.MARKUP_REMOVED, this.onMarkupRemovedBinded);
      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
      this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    } }, { key: "unregisterEventListeners", value: function unregisterEventListeners()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__.MARKUPS_EVENTS.MARKUP_VISIBILITY_CHANGED, this.onMarkupVisibilityChangedBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_1__.MARKUPS_EVENTS.MARKUP_REMOVED, this.onMarkupRemovedBinded);
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangedBinded);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    } }, { key: "onCameraChanged", value: function onCameraChanged()

    {
      this.renderTextMarkups();
    } }, { key: "onResize", value: function onResize()

    {var _this = this;
      this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, function () {
        _this.onCameraChanged();
      }, { once: true });
    } }, { key: "renderTextMarkups", value: function renderTextMarkups()

    {var _this2 = this;
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__.forAll)(this.textMarkups, function (markup) {
        _this2.renderMarkup(markup);
      });
    } }, { key: "updateLabelPositionAndSize", value: function updateLabelPositionAndSize(

    label, markup) {
      // If a style property didn't change, we don't want to reassign it.
      // Unnecessary style assignments cause layout thrashing and slows down the render.
      function assignStyleProperty(key, value) {
        if (label.styleCache[key] !== value) {
          label.style[key] = value;
          label.styleCache[key] = value;
        }
      }var _markup$getEditState =

      markup.getEditState(),text = _markup$getEditState.text;
      var textStyle = markup.getTextStyle();
      var fontToWorldScale = this.markupsExtension.renderer.getFontToWorldScale();
      var fontToClient = this.markupsExtension.renderer.sizeFromWorldToClient(fontToWorldScale);
      var clientBoundingBox = markup.getClientBoundingBoxTextOnly();

      var clientCenter = clientBoundingBox.getCenter(new THREE.Vector3());
      var clientSize = clientBoundingBox.getSize(new THREE.Vector3());
      var rotate = _Utils_GeometryUtils__WEBPACK_IMPORTED_MODULE_3__["default"].radiansToDegrees(markup.getRotation() + this.markupsExtension.renderer.getCameraRotation());

      // Browsers tend to round the values of font-size and line-height.
      // Every browser has its own logic to round the values, so each one has its own result.
      // The problem is, that because of this clamping, we get unwanted jumps for tall text labels,
      // while zooming in and out.
      // To solve it, we trim the font size by our own (floor function),
      // and in order to add the rest of the trimmed font size, we scale the label with what's left.
      // For browsers other than Safari it's easier, because we can just scale the text without changing the font-size at all.
      // in Safari, font scaling result in really low res result.
      if (Autodesk.Viewing.isSafari() || Autodesk.Viewing.isIOSDevice()) {
        var preciseSize = parseFloat(textStyle.fontSize) * fontToClient;
        var roundedSize = Math.floor(preciseSize) || 1;
        var scale = preciseSize / roundedSize;

        var width = clientSize.x / scale;
        textStyle.width = "".concat(width, "px");
        textStyle.fontSize = "".concat(roundedSize, "px");

        Object.keys(textStyle).forEach(function (key) {
          assignStyleProperty(key, textStyle[key]);
        });

        label.style.transform = "translate(".concat(clientCenter.x, "px, ").concat(clientCenter.y, "px)\n                                    translate(-50%, -50%)\n                                    rotate(").concat(

        rotate, "deg)\n                                    scale(").concat(
        scale, ")");
      } else {var _markup$getTextWidthI =
        markup.getTextWidthInFontScale(),preciseWidth = _markup$getTextWidthI.preciseWidth,_width = _markup$getTextWidthI.width;
        textStyle.width = "".concat(_width, "px"); // In font scale

        Object.keys(textStyle).forEach(function (key) {
          assignStyleProperty(key, textStyle[key]);
        });

        var widthDiff = (preciseWidth - _width) * fontToClient; // Compensation due to rounding (in client scale)

        label.style.transform = "translate(".concat(clientCenter.x - widthDiff / 2, "px, ").concat(clientCenter.y, "px)\n                                    translate(-50%, -50%)\n                                    rotate(").concat(

        rotate, "deg)\n                                    scale(").concat(
        fontToClient, ")");
      }

      if (!markup.textInputHandler.textboxActive) {
        label.innerText = text ? text : '';
      }
    } }, { key: "renderMarkup", value: function renderMarkup(

    markup) {
      if (!markup.editState.anchors[0]) {
        return;
      }

      var label = this.labels[markup.id];

      var _document = this.getDocument();
      if (!label) {
        label = _document.createElement('div');
        label.className = 'markup-text';
        label.id = markup.id;var _markup$getEditState2 =
        markup.getEditState(),text = _markup$getEditState2.text;
        label.innerText = text ? text : '';
        label.styleCache = {};
        this.container.appendChild(label);
        this.labels[markup.id] = label;
        this.textMarkups[markup.id] = markup;
      }

      if (markup.isVisible() && !label.classList.contains('visible')) {
        label.classList.add('visible');
      } else if (!markup.isVisible() && label.classList.contains('visible')) {
        label.classList.remove('visible');
      }

      if (markup.editState.isSingleLine && !label.classList.contains('single-line')) {
        label.classList.add('single-line');
      }

      if (markup.isVisible()) {
        this.updateLabelPositionAndSize(label, markup);
      }
    } }, { key: "getLabel", value: function getLabel(

    markup) {
      return this.labels[markup.id];
    } }, { key: "onMarkupVisibilityChanged", value: function onMarkupVisibilityChanged(_ref)

    {var markup = _ref.markup,visible = _ref.visible;
      if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_4__.MARKUP_TYPE_CALLOUT) {
        this.renderMarkup(markup);
      }
    } }, { key: "onMarkupRemoved", value: function onMarkupRemoved(_ref2)

    {var markup = _ref2.markup;
      var name = markup.id;
      var markupElement = this.labels[name];

      if (markupElement) {
        this.container.removeChild(markupElement);
      }

      delete this.labels[name];
      delete this.textMarkups[name];
    } }, { key: "isEmpty", value: function isEmpty()

    {
      return Object.keys(this.labels).length === 0;
    } }, { key: "renderTextToCanvas", value: function renderTextToCanvas(

    canvas, camera, scale, afterCloneBeforeRender, afterCloneAfterRender, cb) {var _this3 = this;
      // In case there are not text markups on canvas, just return the original canvas.
      if (this.isEmpty()) {
        cb(canvas);
        return;
      }

      var visibleTextMarkupsIds = {};

      // Because this operation is async, we need to make sure that we render all the text markups that were visible at this point.
      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__.getObjectAsList)(this.textMarkups).forEach(function (markup) {
        if (markup.isVisible()) {
          visibleTextMarkupsIds[markup.id] = true;
        }
      });

      var options = {
        backgroundColor: null,
        logging: false,
        scale: scale,
        onclone: function onclone(doc) {
          afterCloneBeforeRender();

          var documentCameraBackup = _this3.markupsExtension.renderer.documentCamera;
          var markupsCameraBackup = _this3.markupsExtension.renderer.markupsCamera;
          _this3.markupsExtension.renderer.documentCamera = camera;
          _this3.markupsExtension.renderer.markupsCamera = camera;

          var container = doc.getElementsByClassName('markup-text-container')[0];
          var labels = container.children;

          // All the labels here are clones of the original labels.
          // The changes made here are relevant only for the canvas rendering.
          for (var i = 0; i < labels.length; i++) {
            var label = labels[i];

            if (visibleTextMarkupsIds[label.id]) {
              var markup = _this3.textMarkups[label.id];
              if (!label.classList.contains('visible')) {
                label.classList.add('visible');
              }

              label.styleCache = {};
              _this3.updateLabelPositionAndSize(label, markup);
            } else if (label.classList.contains('visible')) {
              label.classList.remove('visible');
            }
          }

          _this3.markupsExtension.renderer.documentCamera = documentCameraBackup;
          _this3.markupsExtension.renderer.markupsCamera = markupsCameraBackup;

          afterCloneAfterRender();
        } };


      html2canvas__WEBPACK_IMPORTED_MODULE_0___default()(this.container, options).then(function (res) {
        var _document = _this3.getDocument();
        var textCanvas = _document.createElement('canvas');
        textCanvas.width = res.width;
        textCanvas.height = res.height;
        var ctx = textCanvas.getContext('2d');

        // Flip text vertically.
        ctx.translate(0, textCanvas.height);
        ctx.scale(1, -1);
        ctx.drawImage(res, 0, 0);

        // Copy the image contents to the canvas
        var canvasCtx = canvas.getContext('2d');
        canvasCtx.globalCompositeOperation = 'source-over';
        canvasCtx.drawImage(textCanvas, 0, 0);
        cb(canvas);
      });
    } }, { key: "destroy", value: function destroy()

    {var _this4 = this;
      this.unregisterEventListeners();

      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_2__.forAll)(this.labels, function (label) {
        _this4.container.removeChild(label);
      });

      this.labels = null;
      this.textMarkups = null;
      this.textSizeCache = null;

      this.markupsExtension = null;
      this.viewer = null;
    } }]);return TextRenderer;}();


av.GlobalManagerMixin.call(TextRenderer.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/Service/MarkupServiceWeb.js":
/*!***********************************************************!*\
  !*** ./extensions/BimMarkups/Service/MarkupServiceWeb.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupServiceWeb)
/* harmony export */ });
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsServiceBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsServiceBase */ "./extensions/BimMarkups/Service/MarkupsServiceBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var throttle = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");

var NumberOfRetries = 5;
var RetryDelay = 500; // ms
var MaxRequestInBatch = 25; // According to https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-BatchGetDownloadURLs
var BatchRequestThrottleDuration = 30; // ms
var
MarkupServiceWeb = /*#__PURE__*/function (_MarkupServiceBase) {_inherits(MarkupServiceWeb, _MarkupServiceBase);var _super = _createSuper(MarkupServiceWeb);
  function MarkupServiceWeb(markupsExtension, options) {var _this;_classCallCheck(this, MarkupServiceWeb);
    _this = _super.call(this, markupsExtension, options);

    // Which type to use: markups or issues
    var type = 'markup';
    _this.issueType = _this.ISSUES_TYPE[type];
    // End Points
    var config = _this.ENV_TABLE[options.env] || _this.ENV_TABLE['Development'];
    _this.ISSUE_SERVICE_URL = config.ISSUE_SERVICE;
    _this.OBJECT_STORAGE_SERVICE_URL = config.OBJECT_STORAGE;

    // Additional properties related to issue service JSON API call.
    // ??? consider to leverage an existing JSON API JS client
    // ??? to manage all calls, but right now do straightforward RESTful handling.
    _this.maxPageLimit = 200; // Now, issue service can return 200 items at once.

    // Record all ongoing request, then can cancel them if no longer needed.
    _this.xhrReq = [];

    _this.signedS3Requests = {};

    _this.headers = [
    {
      name: 'x-ads-acm-namespace',
      value: _this.options.acmNamespace },

    {
      name: 'x-ads-acm-check-groups',
      value: 'true' }];



    if (_this.options.acmScopes) {
      _this.headers.push({
        name: 'x-ads-acm-scopes',
        value: _this.options.acmScopes });

    }

    _this.flushSignedS3DownloadRequestsThrottled = throttle(function () {
      _this.flushSignedS3DownloadRequests();
    }, BatchRequestThrottleDuration);return _this;
  }_createClass(MarkupServiceWeb, [{ key: "checkValidation",


































































    /**
                                                              * This is a dummy check that the must have value is set
                                                              * so that service is ready to call
                                                             */value: function checkValidation()
    {
      var token = this.getAccessToken();
      this.valid = !!token && !!this.options.issueProject && !!this.issueType;

      return this.valid;
    }

    // Wait "duration" ms and then resolve.
  }, { key: "wait", value: function wait(duration) {
      return new Promise(function (resolve) {
        setTimeout(resolve, duration);
      });
    }

    // Given a direct OSS URL, returns a signedURL for  upload.
    // https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-GetUploadURL/s
    //
    // url - original OSS url
  }, { key: "getSignedS3UploadUrl", value: function getSignedS3UploadUrl(url) {var _this2 = this;
      return new Promise(function (resolve, reject) {
        url += "/signeds3upload";

        var callbacks = _this2.getAjaxCallback(resolve, reject, true);
        var xhr = _this2.createRequest('GET', url, 'application/vnd.api+json', callbacks, false, false);
        xhr.responseType = 'json';
        _this2.injectHeaders(xhr, _this2.headers);
        xhr.send();
      });
    }

    // Instead of triggering an HTTP request for each objectKey individually, we aggregate the requests
    // into a single batch request. The max number of objectKeys per batch request is 25 (MaxRequestInBatch):
    // https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-BatchGetDownloadURLs
  }, { key: "getSignedS3DownloadUrl", value: function getSignedS3DownloadUrl(bucketId, objectKey) {var _this3 = this;
      return new Promise(function (resolve, reject) {
        if (!_this3.signedS3Requests[bucketId]) {
          _this3.signedS3Requests[bucketId] = {};
        }

        _this3.signedS3Requests[bucketId][objectKey] = { resolve: resolve, reject: reject };

        if (Object.keys(_this3.signedS3Requests[bucketId]).length === MaxRequestInBatch) {
          _this3.flushSignedS3DownloadRequests();
        } else {
          _this3.flushSignedS3DownloadRequestsThrottled();
        }
      });
    } }, { key: "flushSignedS3DownloadRequests", value: function flushSignedS3DownloadRequests()

    {var _this4 = this;
      Object.keys(this.signedS3Requests).forEach(function (bucketId) {
        var url = "".concat(_this4.OBJECT_STORAGE_SERVICE_URL, "buckets/").concat(bucketId, "/objects/batchsigneds3download?useCdn=true");

        var bucketIdRequests = _this4.signedS3Requests[bucketId];

        var callbacks = {
          onLoad: function onLoad(event) {
            var response = event.currentTarget.response;

            if (event.currentTarget.status === 200) {
              Object.keys(response.results).forEach(function (objectKey) {
                var res = response.results[objectKey];

                if (res.status === 'complete') {
                  bucketIdRequests[objectKey].resolve(res.url);
                } else {
                  // The specific objectKey has an error - reject it.
                  bucketIdRequests[objectKey].reject(res);
                }
              });
            } else {
              // In case of any status other than 200 for this batch request, it means that the entire request is illegible or problematic.
              // In that case, we'll reject all of the sub requests.
              // https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-BatchGetDownloadURLs
              Object.keys(response.results).forEach(function (objectKey) {
                bucketIdRequests[objectKey].reject(event);
              });
            }
          } };


        var xhr = _this4.createRequest('POST', url, 'application/json', callbacks, false, true);
        xhr.responseType = 'json';
        _this4.injectHeaders(xhr, _this4.headers);

        var body = { requests: Object.keys(bucketIdRequests).map(function (objectKey) {return { objectKey: objectKey };}) };
        var bodyString = JSON.stringify(body);

        xhr.send(bodyString);
      });

      // Remove sent requests from the queue.
      this.signedS3Requests = {};
    }

    // When an upload to OSS is done, we must call the completeUpload API - otherwise, it won't be visible.
    // https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-CompleteUpload
  }, { key: "completeUpload", value: function completeUpload(url, uploadKey, resolve, reject) {
      url += "/signeds3upload";

      var callbacks = this.getAjaxCallback(resolve, reject, true);
      var xhr = this.createRequest('POST', url, 'application/json', callbacks, false, false);
      xhr.responseType = 'json';
      this.injectHeaders(xhr, this.headers);
      xhr.send(JSON.stringify({ uploadKey: uploadKey }));
    }

    // // Helper function for retrying requests.
  }, { key: "sendWithRetry", value: function () {var _sendWithRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(func, args) {var i, result;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                i = 0;case 1:if (!(i < NumberOfRetries)) {_context.next = 22;break;}_context.prev = 2;_context.next = 5;return (

                  func.apply(this, args));case 5:result = _context.sent;return _context.abrupt("return",
                result);case 9:_context.prev = 9;_context.t0 = _context["catch"](2);

                console.error(_context.t0);if (!(

                NumberOfRetries === i + 1)) {_context.next = 16;break;}throw _context.t0;case 16:


                console.warn('Request failed - Retrying...');_context.next = 19;return (
                  this.wait(RetryDelay));case 19:i++;_context.next = 1;break;case 22:case "end":return _context.stop();}}}, _callee, this, [[2, 9]]);}));function sendWithRetry(_x, _x2) {return _sendWithRetry.apply(this, arguments);}return sendWithRetry;}()





    /**
                                                                                                                                                                                                                                                                  *
                                                                                                                                                                                                                                                                  *
                                                                                                                                                                                                                                                                  * @param {Array} [additionalHeaders] - Additional headers with items {name:String, value:String}
                                                                                                                                                                                                                                                                  * @returns {Promise}
                                                                                                                                                                                                                                                                  */ }, { key: "_requestMarkups", value: function _requestMarkups(
    pageLimit, offset, additionalHeaders, statuses) {var _this5 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      if (!pageLimit) {
        pageLimit = this.maxPageLimit;
      }
      if (!offset) {
        offset = 0;
      }

      return new Promise(function (resolve, reject) {
        if (!_this5.options.documentUrn) {
          return reject();
        }

        // Add page limit and offset query parameters for JSON API usage.
        var url = [_this5.ISSUE_SERVICE_URL, 'containers/', _this5.options.issueProject, _this5.issueType.endpoint].join('');
        url = [url, '?page[limit]=' + pageLimit + '&page[offset]=' + offset].join('');

        if (_this5.options.documentUrn) {
          // If specify document urn, then request issues filtered by this urn.
          var doc = encodeURIComponent(_this5.options.documentUrn);
          url = [url, '&filter[target_urn]=', doc].join('');
        }

        url = [url, '&include=attachments'].join('');

        if (statuses) {
          url = [url, '&filter[status]=', statuses].join('');
        }

        // Sort the results by its created time in descent order
        // TODO: as the request goes more complex, need to consider to
        // refactor this to use a JSON API library to better manage
        // different request paramters.
        url = [url, '&sort=-created_at'].join('');

        var callbacks = _this5.getAjaxCallback(resolve, reject);

        var xhr = _this5.createRequest('GET', url, 'application/vnd.api+json', callbacks, false, true);
        _this5.injectHeaders(xhr, additionalHeaders);
        xhr.send();
      });
    } }, { key: "requestMarkups", value: function requestMarkups()

    {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
      return this.sendWithRetry(this._requestMarkups, args);
    }

    /**
       *
       *
       * @param {Object}
       * @param {Array} [additionalHeaders] - Additional headers with items {name:String, value:String}
       * @returns {Promise}
       */ }, { key: "postMarkups", value: function postMarkups(
    metadata, additionalHeaders) {var _this6 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this6.ISSUE_SERVICE_URL, 'containers/', _this6.options.issueProject, _this6.issueType.endpoint].join('');
        var callbacks = _this6.getAjaxCallback(resolve, reject);
        var xhr = _this6.createRequest('POST', url, 'application/vnd.api+json', callbacks, false, false);

        _this6.injectHeaders(xhr, additionalHeaders);

        var body = {
          data: {
            type: _this6.issueType.value,
            attributes: metadata } };



        xhr.send(JSON.stringify(body));
      }).then(this.parseResponse);
    } }, { key: "fetchOSSBucketForAttachment", value: function fetchOSSBucketForAttachment(

    attachment) {var _this7 = this;
      return new Promise(function (resolve, reject) {
        _this7.fetchLocationForNewOssAttachment([], {
          onLoad: function onLoad(event) {
            var xhr = event.currentTarget;
            if (xhr.status === 201 || xhr.status === 200) {
              // interprete  response and pare oss bucket and key
              // Then fill in attachment.ossPath
              var bucketData = JSON.parse(xhr.responseText);
              attachment.ossPath = bucketData.data.attributes.urn;
              resolve();
            } else {
              reject('Failed fetching OSS Bucket');
            }
          },
          onError: reject,
          onTimeout: reject });

      });
    } }, { key: "uploadAttachment", value: function uploadAttachment(

    attachment) {
      // At this point, oss bucket and key should all be fetched.
      var bucketData = this.extractOssBucketAndId(attachment.ossPath);
      var bucketId = bucketData[0];
      var bucketKey = bucketData[1];

      return this.postAttachment(bucketKey, attachment.data, bucketId);

    } }, { key: "_postLayer", value: function () {var _postLayer2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      metadata, markupResources, originalMarkupGuid) {var _this8 = this;var fetchOSSBucketForAttachments, uploadAttachments, postMarkup, result;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                // Post markup steps,
                // 1. Fetch OSS bucket location.
                // 2. Upload attachment to the OSS bucket.
                // 3. Post markup object.

                fetchOSSBucketForAttachments = function fetchOSSBucketForAttachments() {
                  if (markupResources.length === 0) {
                    return Promise.resolve();
                  }

                  // This is an array of promise
                  var pa = markupResources.map(function (attachment) {
                    return _this8.fetchOSSBucketForAttachment(attachment);
                  });

                  return Promise.all(pa);
                };

                uploadAttachments = function uploadAttachments() {
                  if (markupResources.length === 0) {
                    return Promise.resolve();
                  }

                  var pa = markupResources.map(function (attachment) {
                    return _this8.uploadAttachment(attachment);
                  });

                  return Promise.all(pa);
                };

                postMarkup = function postMarkup() {
                  markupResources.forEach(function (attachment) {
                    metadata.resource_urns[attachment.type] = attachment.ossPath;
                  });

                  if (originalMarkupGuid) {
                    return _this8.updateLayer(originalMarkupGuid, metadata);
                  }

                  return _this8.postMarkups(metadata, []);
                };_context2.next = 5;return (

                  fetchOSSBucketForAttachments());case 5:_context2.next = 7;return (
                  uploadAttachments());case 7:_context2.next = 9;return (
                  postMarkup());case 9:result = _context2.sent;return _context2.abrupt("return",
                result);case 11:case "end":return _context2.stop();}}}, _callee2);}));function _postLayer(_x3, _x4, _x5) {return _postLayer2.apply(this, arguments);}return _postLayer;}() }, { key: "postLayer", value: function postLayer()


    {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
      return this.sendWithRetry(this._postLayer, args);
    } }, { key: "parseResponse", value: function parseResponse(

    result) {
      try {
        var attachObj = JSON.parse(result);
        var attachData = attachObj.data;

        return Promise.resolve(attachData);
      } catch (e) {
        return Promise.reject(e);
      }
    } }, { key: "_publishLayer", value: function _publishLayer(

    markupId) {var _this9 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this9.ISSUE_SERVICE_URL, 'containers/', _this9.options.issueProject, _this9.issueType.endpoint, '/', markupId].join('');
        var callbacks = _this9.getAjaxCallback(resolve, reject);
        var xhr = _this9.createRequest('PATCH', url, 'application/vnd.api+json', callbacks, false, false);

        var body = {
          data: {
            type: _this9.issueType.value,
            id: markupId,
            attributes: {
              status: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_PUBLISHED } } };




        xhr.send(JSON.stringify(body));
      }).then(this.parseResponse);
    } }, { key: "publishLayer", value: function publishLayer()

    {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}
      return this.sendWithRetry(this._publishLayer, args);
    } }, { key: "_archiveLayer", value: function _archiveLayer(

    markupId, closeVersion) {var _this10 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this10.ISSUE_SERVICE_URL, 'containers/', _this10.options.issueProject, _this10.issueType.endpoint, '/', markupId].join('');
        var callbacks = _this10.getAjaxCallback(resolve, reject);
        var xhr = _this10.createRequest('PATCH', url, 'application/vnd.api+json', callbacks, false, false);

        var body = {
          data: {
            type: _this10.issueType.value,
            id: markupId,
            attributes: {
              close_version: closeVersion,
              status: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_0__.MARKUP_STATUS_ARCHIVED } } };




        xhr.send(JSON.stringify(body));
      }).then(this.parseResponse);
    } }, { key: "archiveLayer", value: function archiveLayer()

    {for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {args[_key4] = arguments[_key4];}
      return this.sendWithRetry(this._archiveLayer, args);
    } }, { key: "fetchLocationForNewOssAttachment", value: function fetchLocationForNewOssAttachment(

    additionalHeaders, callbacks) {
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      var url = [this.ISSUE_SERVICE_URL, 'containers/', this.options.issueProject, '/oss_objects'].join('');
      var xhr = this.createRequest('POST', url, 'application/vnd.api+json', callbacks, false, false);
      this.injectHeaders(xhr, additionalHeaders);

      var body = {
        data: {
          type: 'oss_objects' } };



      xhr.send(JSON.stringify(body));

      return null;
    } }, { key: "_getAttachment", value: function () {var _getAttachment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      urn, isBinaryData) {var _this11 = this;var dataParts, url, isSigned;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:if (
                this.checkValidation()) {_context3.next = 2;break;}return _context3.abrupt("return",
                Promise.reject('Service is unavailable.'));case 2:

                dataParts = this.extractOssBucketAndId(urn);


                isSigned = false;_context3.prev = 4;_context3.next = 7;return (


                  this.getSignedS3DownloadUrl(dataParts[0], dataParts[1]));case 7:url = _context3.sent;
                isSigned = true;_context3.next = 15;break;case 11:_context3.prev = 11;_context3.t0 = _context3["catch"](4);

                // In case that we couldn't get the signed URL for some reason, try to use the original URL.
                // If it's under 10MB it should work - so we got lucky.
                console.warn("Fallback to direct OSS download.", _context3.t0);
                url = [this.OBJECT_STORAGE_SERVICE_URL, 'buckets/', dataParts[0], '/objects/', dataParts[1]].join('');case 15:return _context3.abrupt("return",


                new Promise(function (resolve, reject) {
                  var callbacks = _this11.getAjaxCallback(resolve, reject, isBinaryData);

                  var xhr = _this11.createRequest('GET', url, null, callbacks, isSigned, true);

                  if (isBinaryData) {
                    xhr.responseType = 'arraybuffer';
                  }

                  _this11.injectHeaders(xhr, _this11.headers);

                  xhr.send();
                }));case 16:case "end":return _context3.stop();}}}, _callee3, this, [[4, 11]]);}));function _getAttachment(_x6, _x7) {return _getAttachment2.apply(this, arguments);}return _getAttachment;}() }, { key: "getAttachment", value: function getAttachment()


    {for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {args[_key5] = arguments[_key5];}
      return this.sendWithRetry(this._getAttachment, args);
    } }, { key: "postAttachment", value: function () {var _postAttachment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(

      objectKey, fileData, bucketId) {var _this12 = this;var originalUrl, url, uploadKey, isSigned, res;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:if (
                this.checkValidation()) {_context4.next = 2;break;}return _context4.abrupt("return",
                Promise.reject('Service is unavailable.'));case 2:


                originalUrl = [this.OBJECT_STORAGE_SERVICE_URL, 'buckets/', bucketId, '/objects/', objectKey].join('');
                url = originalUrl;

                isSigned = false;_context4.prev = 5;_context4.next = 8;return (


                  this.getSignedS3UploadUrl(url));case 8:res = _context4.sent;
                url = res.urls[0];
                uploadKey = res.uploadKey;
                isSigned = true;_context4.next = 17;break;case 14:_context4.prev = 14;_context4.t0 = _context4["catch"](5);

                // In case that we couldn't get the signed URL for some reason, try to use the original URL.
                // If it's under 10MB it should work - so we got lucky.
                console.warn("Fallback to direct OSS upload.", _context4.t0);case 17:return _context4.abrupt("return",


                new Promise(function (resolve, reject) {
                  var callbacks = {
                    onLoad: function onLoad(event) {
                      // Upload attachment successfully.
                      var xhr = event.currentTarget;
                      if (xhr.status === 200 || xhr.status === 201) {
                        if (isSigned) {
                          _this12.completeUpload(originalUrl, uploadKey, resolve, reject);
                        } else {
                          resolve();
                        }

                      } else {
                        reject('Failed uploading attachment');
                      }
                    },
                    onError: reject,
                    onTimeout: reject };


                  var xhr = _this12.createRequest('PUT', url, 'text/plain', callbacks, isSigned, false);

                  _this12.injectHeaders(xhr, _this12.headers);
                  xhr.send(fileData);

                }));case 18:case "end":return _context4.stop();}}}, _callee4, this, [[5, 14]]);}));function postAttachment(_x8, _x9, _x10) {return _postAttachment.apply(this, arguments);}return postAttachment;}() }, { key: "updateLayer", value: function updateLayer(


    markupId, updateMarkupAttrs) {var _this13 = this;var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this13.ISSUE_SERVICE_URL, 'containers/', _this13.options.issueProject, _this13.issueType.endpoint, '/', markupId].join('');
        var callbacks = _this13.getAjaxCallback(resolve, reject);

        var xhr = _this13.createRequest('PATCH', url, 'application/vnd.api+json', callbacks, false, false);
        _this13.injectHeaders(xhr, additionalHeaders);

        var body = {
          data: {
            type: _this13.issueType.value,
            id: markupId,
            attributes: updateMarkupAttrs || {} } };



        xhr.send(JSON.stringify(body));

      }).then(this.parseResponse);
    } }, { key: "_deleteLayer", value: function _deleteLayer(

    layerId) {var _this14 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this14.ISSUE_SERVICE_URL, 'containers/', _this14.options.issueProject, _this14.ISSUES_TYPE.markup.endpoint + '/', layerId].join('');
        var callbacks = _this14.getAjaxCallback(resolve, reject);
        var xhr = _this14.createRequest('DELETE', url, 'application/vnd.api+json', callbacks, false, false);

        // no body
        xhr.send();
      });
    } }, { key: "deleteLayer", value: function deleteLayer()

    {for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {args[_key6] = arguments[_key6];}
      return this.sendWithRetry(this._deleteLayer, args);
    } }, { key: "_postDocumentAttachment", value: function _postDocumentAttachment(

    docAttachment, additionalHeaders) {var _this15 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable.');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this15.ISSUE_SERVICE_URL, 'containers/', _this15.options.issueProject, _this15.ATTACHMENT.endpoint].join('');
        var callbacks = _this15.getAjaxCallback(resolve, reject);
        var xhr = _this15.createRequest('POST', url, 'application/vnd.api+json', callbacks, false, false);

        _this15.injectHeaders(xhr, additionalHeaders);

        var body = {
          data: {
            type: _this15.ATTACHMENT.value,
            attributes: docAttachment.attributes } };



        xhr.send(JSON.stringify(body));
      }).then(this.parseResponse);
    } }, { key: "postDocumentAttachment", value: function postDocumentAttachment()

    {for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {args[_key7] = arguments[_key7];}
      return this.sendWithRetry(this._postDocumentAttachment, args);
    } }, { key: "_deleteDocumentAttachment", value: function _deleteDocumentAttachment(

    docAttachmentId) {var _this16 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this16.ISSUE_SERVICE_URL, 'containers/', _this16.options.issueProject, _this16.ATTACHMENT.endpoint + '/', docAttachmentId].join('');
        var callbacks = _this16.getAjaxCallback(resolve, reject);
        var xhr = _this16.createRequest('DELETE', url, 'application/vnd.api+json', callbacks, false, false);

        // no body
        xhr.send();
      });
    } }, { key: "deleteDocumentAttachment", value: function deleteDocumentAttachment()

    {for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {args[_key8] = arguments[_key8];}
      return this.sendWithRetry(this._deleteDocumentAttachment, args);
    } }, { key: "_renameDocumentAttachment", value: function _renameDocumentAttachment(

    docAttachmentId, newName) {var _this17 = this;
      if (!this.checkValidation()) {
        return Promise.reject('Service is unavailable');
      }

      return new Promise(function (resolve, reject) {
        var url = [_this17.ISSUE_SERVICE_URL, 'containers/', _this17.options.issueProject, _this17.ATTACHMENT.endpoint + '/', docAttachmentId].join('');
        var callbacks = _this17.getAjaxCallback(resolve, reject);
        var xhr = _this17.createRequest('PATCH', url, 'application/vnd.api+json', callbacks, false, false);

        var body = {
          data: {
            type: _this17.ATTACHMENT.value,
            id: docAttachmentId,
            attributes: {
              name: newName } } };




        // no body
        xhr.send(JSON.stringify(body));
      }).then(this.parseResponse);
    } }, { key: "renameDocumentAttachment", value: function renameDocumentAttachment()

    {for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {args[_key9] = arguments[_key9];}
      return this.sendWithRetry(this._renameDocumentAttachment, args);
    }

    /**
       * Extracts the bucket id and the attachment id from an OSS URN.
       * @param {String} ossUrn
       * @returns {Array} With values: [ <bucket_id>, <attachment_id> ]
       */ }, { key: "extractOssBucketAndId", value: function extractOssBucketAndId(
    ossUrn) {
      var dataParts = ossUrn.split('/'); // Returns 2 array with 2 elements [ <stuff + bucket_id>, <attachment_id> ]
      var bucketId = dataParts[0]; // Something like 'urn:adsk.objects:os.object:issues'
      var tmpArray = bucketId.split(':'); // We need to get 'issues' at the end.
      dataParts[0] = tmpArray[tmpArray.length - 1];
      return dataParts;
    } }, { key: "cancelRequests", value: function cancelRequests()

    {
      // Start cancel all pending xhr calls.
      var count = this.xhrReq.length;

      for (var i = count - 1; i >= 0; i--) {
        if (this.xhrReq[i]) {
          this.xhrReq[i].abort();
        }
      }

      this.xhrReq = [];
    } }, { key: "removeXhr", value: function removeXhr(

    xhr) {
      var idx = this.xhrReq.indexOf(xhr);

      if (idx > -1) {
        this.xhrReq.splice(idx, 1);
      }
    } }, { key: "addXhr", value: function addXhr(

    xhr) {
      this.xhrReq.push(xhr);
    } }, { key: "getAccessToken", value: function getAccessToken()

    {
      if (!this.markupsExtension.options.getAccessToken) {
        return;
      }

      var token;

      // getAccessToken calls a synched function in docs-ui-web: https://git.autodesk.com/BIM360/docs-ui-web/blob/055ec7debc3ac81107f13863c59f042bb53d04a2/src/javascripts/services/token_service.js#L36
      // It makes sure that only after the CB is called with an updated token, the rest of the code wil be called.
      // If there is no need to update the token, the current token will be returned.
      this.markupsExtension.options.getAccessToken(function (t, exp) {
        token = t;
      });
      // Will be called only after the updated token is updated:
      return token;
    }

    /**
       * Returns an object compatible with our AJAX callbacks mechanism.
       * Internal usage only.
       *
       * @param {Function} resolve
       * @param {Function} reject
       * @param {Boolean} [isBinaryData] Whether the response is to be binary or not (defaults to not-binary)
       * @returns {{onLoad: Function, onError: Function, onTimeout: Function}}
       */ }, { key: "getAjaxCallback", value: function getAjaxCallback(
    resolve, reject, isBinaryData) {
      return {
        onLoad: function onLoad(event) {
          if (event.currentTarget.status === 201 ||
          event.currentTarget.status === 200 ||
          event.currentTarget.status === 204)
          {
            resolve(isBinaryData ? event.currentTarget.response :
            event.currentTarget.responseText);
          } else {
            reject(event);
          }
        },
        onError: reject,
        onTimeout: reject };

    }

    /**
       * Creates a request object to communicate with the issues endpoint.
       * Returned value is ready to initiate async operation through it's send() method
       * (it hasn't been called yet)
       *
       * @param {String} operation - POST, GET, DELETE
       * @param {String} url - REST endpoint
       * @param {String} contentType - Content type header
       * @param {Object} callbacks - {onLoad:Function, onError:Function, onTimeout:Function}
       * @param {boolean} noAuthorization - Whether authorization headers should be added.
       * @param {boolean} cancelable - Whether the request can be canceled manually or not.
       * @returns {XMLHttpRequest}
       */ }, { key: "createRequest", value: function createRequest(
    operation, url, contentType, callbacks, noAuthorization, cancelable) {var _this18 = this;
      var xhr = new XMLHttpRequest();
      xhr.open(operation, url, true);

      if (contentType) {
        xhr.setRequestHeader('Content-Type', contentType);
      }

      if (!noAuthorization) {
        var token = this.getAccessToken();
        xhr.setRequestHeader('Authorization', 'Bearer ' + token);
      }

      xhr.setRequestHeader('Access-Control-Allow-Origin', '*');

      xhr.onload = function () {_this18.removeXhr(xhr);callbacks.onLoad.apply(callbacks, arguments);};
      xhr.onerror = function () {_this18.removeXhr(xhr);callbacks.onError.apply(callbacks, arguments);};
      xhr.ontimeout = function () {_this18.removeXhr(xhr);callbacks.onTimeout.apply(callbacks, arguments);};

      // Don't call any callback intentionally, so in case of an abort there won't be any fallback or retry mechanism.
      // onabort is being called ONLY when calling xhr.abort() directly: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/onabort
      xhr.onabort = function () {_this18.removeXhr(xhr);};

      if (cancelable) {
        this.addXhr(xhr);
      }

      return xhr;
    }

    /**
       * Injects additional RequestHeaders before dispatching the async op to the issue endpoint.
       *
       * @param {XMLHttpRequest} xhr
       * @param {Array} additionalHeaders - Additional headers with items {name:String, value:String}
       */ }, { key: "injectHeaders", value: function injectHeaders(
    xhr, additionalHeaders) {
      if (additionalHeaders) {
        additionalHeaders.forEach(function (headerInfo) {
          xhr.setRequestHeader(headerInfo.name, headerInfo.value);
        });
      }
    } }, { key: "ENV_TABLE", get: function get() {return { Local: { ISSUE_SERVICE: 'https://developer-dev.api.autodesk.com/issues-dev/v1/', OBJECT_STORAGE: 'https://developer-dev.api.autodesk.com/oss/v2/' }, Development: { ISSUE_SERVICE: 'https://developer-stg.api.autodesk.com/issues-dev/v1/', OBJECT_STORAGE: 'https://developer-stg.api.autodesk.com/oss/v2/' }, Qa: { ISSUE_SERVICE: 'https://developer-stg.api.autodesk.com/issues-qa/v1/', OBJECT_STORAGE: 'https://developer-stg.api.autodesk.com/oss/v2/' }, Staging: { ISSUE_SERVICE: 'https://developer-stg.api.autodesk.com/issues-stg/v1/', OBJECT_STORAGE: 'https://developer-stg.api.autodesk.com/oss/v2/' }, Production: { ISSUE_SERVICE: 'https://developer.api.autodesk.com/issues/v1/', OBJECT_STORAGE: 'https://developer.api.autodesk.com/oss/v2/' } };} }, { key: "ISSUES_TYPE", get: function get() {return { issue: { value: 'issues', endpoint: '/issues' }, markup: { value: 'markups', endpoint: '/markups' }, area_markup: { value: 'areas', endpoint: '/areas' }, area_status: { value: 'area_statuses', endpoint: '/area-statuses' } };} // This is the endpoint to get generic attachment for either a makrup
    // or an issue.
    // Note: this attachment is used for user explicitly attach any documents
    // to a markup/issue. There is another concept of 'attachment' inside of
    // markup which is part of markup data.
    // So, I will refer to this attachment as DocumentAttachment to eliminate
    // any misread.
  }, { key: "ATTACHMENT", get: function get() {return { value: 'attachments', endpoint: '/attachments' };} }]);return MarkupServiceWeb;}(_MarkupsServiceBase__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Service/MarkupsServiceBase.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/Service/MarkupsServiceBase.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupServiceBase)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var MarkupServiceBase = /*#__PURE__*/function () {
  function MarkupServiceBase(markupsExtension, options) {_classCallCheck(this, MarkupServiceBase);
    this.markupsExtension = markupsExtension;
    this.options = options || {};
  }_createClass(MarkupServiceBase, [{ key: "postLayer", value: function () {var _postLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      metadata, additionalHeaders) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                console.log('postLayer');return _context.abrupt("return",

                new Promise(function (resolve, reject) {
                }));case 2:case "end":return _context.stop();}}}, _callee);}));function postLayer(_x, _x2) {return _postLayer.apply(this, arguments);}return postLayer;}() }, { key: "publishLayer", value: function publishLayer(


    markupId) {
      console.log('publishLayer');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "archiveLayer", value: function archiveLayer(

    markupId, closeVersion) {
      console.log('archiveLayer');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "updateLayer", value: function updateLayer(

    guid, metadata) {var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      console.log('updateLayer');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "deleteLayer", value: function deleteLayer(

    layerId) {
      console.log('deleteLayer');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "postDocumentAttachment", value: function postDocumentAttachment(

    docAttachment, additionalHeaders) {
      console.log('postDocumentAttachment');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "deleteDocumentAttachment", value: function deleteDocumentAttachment(

    docAttachmentId) {
      console.log('deleteDocumentAttachment');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "renameDocumentAttachment", value: function renameDocumentAttachment(

    docAttachmentId, newName) {
      console.log('renameDocumentAttachment');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "requestMarkups", value: function requestMarkups(

    pageLimit, offset, additionalHeaders, statuses) {
      console.log('requestMarkups');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "getAttachment", value: function getAttachment(

    urn, isBinaryData, additionalHeaders) {
      console.log('getAttachment');

      return new Promise(function (resolve, reject) {
      });
    } }, { key: "cancelRequests", value: function cancelRequests()

    {
      console.log('cancelRequests');
    } }]);return MarkupServiceBase;}();

/***/ }),

/***/ "./extensions/BimMarkups/Service/MarkupsServiceMobile.js":
/*!***************************************************************!*\
  !*** ./extensions/BimMarkups/Service/MarkupsServiceMobile.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupServiceMobile)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MarkupsServiceBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupsServiceBase */ "./extensions/BimMarkups/Service/MarkupsServiceBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var

MarkupServiceMobile = /*#__PURE__*/function (_MarkupServiceBase) {_inherits(MarkupServiceMobile, _MarkupServiceBase);var _super = _createSuper(MarkupServiceMobile);
  function MarkupServiceMobile(markupsExtension, options) {var _this;_classCallCheck(this, MarkupServiceMobile);
    _this = _super.call(this, markupsExtension, options);

    _this.pendingRequests = {};return _this;
  }_createClass(MarkupServiceMobile, [{ key: "requestMarkups", value: function requestMarkups()

    {
      // For mobile apps, the flow of requesting markups is simpler than in MarkupsServiceWeb.
      // Once the native app gets `markupToolLoaded` callback, it should handle the connection with the backend,
      // and just send us the completed markups using `loadLayers` API.
      this.markupsExtension.mobileCallbacks.markupToolLoaded();

      // This Promise won't get resolved by purpose.
      return new Promise(function (resolve, reject) {});
    } }, { key: "postLayer", value: function postLayer(

    metadata, resources, originalMarkupGuid) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      if (originalMarkupGuid) {
        this.markupsExtension.mobileCallbacks.updateLayer(originalMarkupGuid, metadata, resources, requestId);
      } else {
        this.markupsExtension.mobileCallbacks.postLayer(metadata, resources, requestId);
      }

      return this.returnDelayedPromise(requestId);
    }

    // Used to update metadata only.
  }, { key: "updateLayer", value: function updateLayer(originalMarkupGuid, metadata) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      this.markupsExtension.mobileCallbacks.updateLayer(originalMarkupGuid, metadata);

      return this.returnDelayedPromise(requestId);
    } }, { key: "deleteLayer", value: function deleteLayer(

    guid) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      this.markupsExtension.mobileCallbacks.deleteLayer(guid, requestId);

      return this.returnDelayedPromise(requestId);
    } }, { key: "publishLayer", value: function publishLayer(

    guid) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      this.markupsExtension.mobileCallbacks.publishLayer(guid, requestId);

      return this.returnDelayedPromise(requestId);
    } }, { key: "archiveLayer", value: function archiveLayer(

    guid, closeVersion) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      this.markupsExtension.mobileCallbacks.archiveLayer(guid, closeVersion, requestId);

      return this.returnDelayedPromise(requestId);
    }

    // NOT YET IMPLEMENTED
  }, { key: "postDocumentAttachment", value: function postDocumentAttachment(docAttachment, additionalHeaders) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      // this.markupsExtension.mobileCallbacks.postDocumentAttachment(docAttachment, additionalHeaders);

      return this.returnDelayedPromise(requestId);
    }

    // NOT YET IMPLEMENTED
  }, { key: "deleteDocumentAttachment", value: function deleteDocumentAttachment(docAttachmentId) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      // this.markupsExtension.mobileCallbacks.deleteDocumentAttachment(docAttachmentId);

      return this.returnDelayedPromise(requestId);
    }

    // NOT YET IMPLEMENTED
  }, { key: "renameDocumentAttachment", value: function renameDocumentAttachment(docAttachmentId, newName) {
      var requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();

      // this.markupsExtension.mobileCallbacks.renameDocumentAttachment(docAttachmentId, newName);

      return this.returnDelayedPromise(requestId);
    }

    //
    // Private methods.
    //
  }, { key: "cancelRequests", value: function cancelRequests()
    {var _this2 = this;
      Object.keys(this.pendingRequests).forEach(function (requestId) {
        _this2.pendingRequests[requestId].reject();
        delete _this2.pendingRequests[requestId];
      });
    }

    // A generic method to return a delayed promise.
    // It is used to wait for the mobile app to return us a result from a backend request.
  }, { key: "returnDelayedPromise", value: function returnDelayedPromise(requestId) {
      var delayedPromise = {};

      var p = new Promise(function (resolve, reject) {
        delayedPromise.resolve = resolve;
        delayedPromise.reject = reject;
      });

      this.pendingRequests[requestId] = delayedPromise;

      return p;
    }

    // Called after the mobile app completed a request from the backend.
    // In case of failure, it is called with isSuccess: false.
  }, { key: "onRequestCompleted", value: function onRequestCompleted(result, isSuccess, requestId) {
      if (!this.pendingRequests[requestId]) {
        return;
      }

      if (isSuccess) {
        this.pendingRequests[requestId].resolve(result);
      } else {
        this.pendingRequests[requestId].reject();
      }

      delete this.pendingRequests[requestId];
    } }]);return MarkupServiceMobile;}(_MarkupsServiceBase__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/BimMarkups/Service/MarkupsServiceOperator.js":
/*!*****************************************************************!*\
  !*** ./extensions/BimMarkups/Service/MarkupsServiceOperator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsServiceOperator)
/* harmony export */ });
/* harmony import */ var _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LodashUtils */ "./extensions/BimMarkups/Utils/LodashUtils.js");
/* harmony import */ var _MarkupServiceWeb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkupServiceWeb */ "./extensions/BimMarkups/Service/MarkupServiceWeb.js");
/* harmony import */ var _MarkupsServiceMobile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsServiceMobile */ "./extensions/BimMarkups/Service/MarkupsServiceMobile.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _MarkupsSceneState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../MarkupsSceneState */ "./extensions/BimMarkups/MarkupsSceneState.js");
/* harmony import */ var _MarkupsSerializer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../MarkupsSerializer */ "./extensions/BimMarkups/MarkupsSerializer.js");
/* harmony import */ var _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../MarkupsLayerData */ "./extensions/BimMarkups/MarkupsLayerData.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}







var

MARKUP_ERRORS = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_ERRORS;var

MarkupsServiceOperator = /*#__PURE__*/function () {function MarkupsServiceOperator() {_classCallCheck(this, MarkupsServiceOperator);}_createClass(MarkupsServiceOperator, [{ key: "reset", value: function reset(
    markupsExtension) {
      this.markupsExtension = markupsExtension;
      this.markupsManager = markupsExtension.markupsManager;
      this.markupsCache = markupsExtension.markupsCache;
      this.viewer = markupsExtension.viewer;
      this.options = this.markupsExtension.options;

      // Keep track on how many save processes are active.
      this.savingCounter = 0;

      var isMobileApp = markupsExtension.options.isMobileApp;

      var serviceClass = this.options.serviceClass || _MarkupServiceWeb__WEBPACK_IMPORTED_MODULE_1__["default"];
      this.service = isMobileApp ? new _MarkupsServiceMobile__WEBPACK_IMPORTED_MODULE_2__["default"](this.markupsExtension, this.options) : new serviceClass(this.markupsExtension, this.options);

      this.errorHandler = this.options.errorHandler || function () {};

      this.onSessionEndedBinded = this.onSessionEnded.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.onSessionEndedBinded);

      this.onLayerDeletedBinded = this.onLayerDeleted.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_DELETE, this.onLayerDeletedBinded);

      this.onDocumentAttachmentCreationStartBinded = this.onDocumentAttachmentCreationStart.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.DOCUMENT_ATTACHMENT_CREATION_START, this.onDocumentAttachmentCreationStartBinded);

      this.renameDocumentAttachmentBinded = this.renameDocumentAttachment.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.DOCUMENT_ATTACHMENT_RENAME, this.renameDocumentAttachmentBinded);

      this.deleteDocumentAttachmentBinded = this.deleteDocumentAttachment.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.DOCUMENT_ATTACHMENT_DELETE, this.deleteDocumentAttachmentBinded);

      this.onPublishLayerBinded = this.onPublishLayer.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_PUBLISH, this.onPublishLayerBinded);

      this.onArchiveLayerBinded = this.onArchiveLayer.bind(this);
      this.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_ARCHIVE, this.onArchiveLayerBinded);
    } }, { key: "onSessionEnded", value: function onSessionEnded(_ref)

    {var layer = _ref.layer,save = _ref.save;
      if (save && !layer.isEmpty()) {
        this.saveLayer(layer);
      }
    } }, { key: "onLayerDeleted", value: function onLayerDeleted(_ref2)

    {var layerData = _ref2.layerData;
      if (layerData) {
        this.deleteLayer(layerData);
      }
    } }, { key: "onPublishLayer", value: function onPublishLayer(_ref3)

    {var layerData = _ref3.layerData;
      if (layerData) {
        this.publishLayer(layerData);
      }
    } }, { key: "onArchiveLayer", value: function onArchiveLayer(_ref4)

    {var layerData = _ref4.layerData;
      if (layerData) {
        this.archiveLayer(layerData);
      }
    } }, { key: "fetchMarkups", value: function fetchMarkups()

    {var _this = this;
      var urn = this.options.documentUrn;
      this.numOfMarkupsLoaded = 0;

      var maxPageLimit = this.getMaxPageLimit();
      var offset = 0;
      var data = { layersData: [], relatedResources: [] };

      var markupStatusFilter = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_STATUSES_TO_LOAD;

      var requestFuncRecursive = function requestFuncRecursive() {
        return _this.requestMarkups(data, maxPageLimit, offset, markupStatusFilter).
        then(function (result) {
          if (result && result.nextReq) {
            offset += maxPageLimit;
            return requestFuncRecursive();
          }
        }).catch(function (e) {
          console.warn('requestMarkups failed or canceled.');
        });
      };

      requestFuncRecursive().then(function () {return _this.getMetadata(data, urn);}).catch(function (e) {return e;});
    } }, { key: "requestMarkups", value: function requestMarkups(

    data, pageLimit, offset) {var statuses = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_STATUSES_TO_LOAD;
      return this.service.requestMarkups(pageLimit, offset, null, statuses).then(function (result) {
        try {var _data$layersData;
          var resultObj = JSON.parse(result);
          (_data$layersData = data.layersData).push.apply(_data$layersData, _toConsumableArray(resultObj.data));

          var included = resultObj.included;
          if (included && Array.isArray(included)) {var _data$relatedResource;
            (_data$relatedResource = data.relatedResources).push.apply(_data$relatedResource, _toConsumableArray(included));
          }

          return Promise.resolve({
            nextReq: resultObj.links.next });

        } catch (e) {
          return Promise.reject(e);
        }
      }, function () {
        return Promise.reject();
      });
    } }, { key: "getMetadata", value: function getMetadata(_ref5,

    urn) {var _this2 = this;var relatedResources = _ref5.relatedResources,layersData = _ref5.layersData;
      // Prioritize downloading current sheet's markups first
      var predicate = function predicate(l) {return (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.isSheetNameEqual)(l.attributes.markup_metadata.sheetName, _this2.options.sheetName);};

      var currentSheetLayersData = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].remove(layersData, predicate);

      layersData = currentSheetLayersData.concat(layersData);

      layersData.forEach(function (data) {
        var metadata = data.attributes;

        // In case of some bad markup data, do a pre-process to filter out any objects that don't have markup_metadata。
        if (!metadata.markup_metadata) {
          return;
        }

        var startVersion = metadata.starting_version;

        // Filter by version.
        if (_this2.options.documentVersion < startVersion) {
          return;
        }

        metadata.tags = metadata.tags || {};
        var resourceEmbed = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.isTrueValue)(metadata.tags.resourceEmbed);

        // If layerData already in cache, don't add it again.
        var cachedLayerData = _this2.markupsCache.get(data.id);

        var layerData = cachedLayerData || new _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_8__["default"]();

        if (!cachedLayerData) {
          layerData.guid = data.id;
          layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_OPEN;
          layerData.metadata = metadata;

          if (metadata.close_version > 0) {
            layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_CLOSED;
          }

          // If the resources are embedded to markup object, then can retrieve it right away.
          var resources = metadata.resource_urns;

          if (resources) {
            var markupSvgData = _this2.createEmptyResourceObject(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SVG, resourceEmbed, resources);

            if (markupSvgData) {
              layerData.resources.push(markupSvgData);
            }

            var markupScreenCapture = _this2.createEmptyResourceObject(_MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE, resourceEmbed, resources);

            if (markupScreenCapture) {
              layerData.resources.push(markupScreenCapture);
            }
          }

          _this2.markupsCache.add(layerData.guid, layerData, urn);
        }

        _this2.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_FETCHED, layerData: layerData });

        _this2.getAttachment(layerData);
      });

      if (!this.fetchedAllMarkups && this.numOfMarkupsLoaded === this.markupsCache.length()) {
        this.fetchedAllMarkups = true;
        this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.ALL_MARKUPS_LOADED, amount: this.numOfMarkupsLoaded });
      }

      this.getUserProfiles();
      this.getProjectUsers();
      this.getRevisions();
      this.getAttachedDocumentData(relatedResources);

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_METADATA_FETCHED });

      return Promise.resolve();
    } }, { key: "notify", value: function notify(

    event) {
      if (this.markupsManager) {
        try {
          this.markupsManager.dispatchEvent(event);
        } catch (error) {
          console.warn(error);
          // Dispatch can fail if a sheet is being changed during loading.
        }
      }
    } }, { key: "getAttachment", value: function getAttachment(

    layerData) {var _this3 = this;
      var pa = layerData.resources.map(function (resource) {
        var result = null;

        // If data already there, then it is either a embed resource or it is already downloaded and cached.
        if (resource.data) {
          result = { layerData: layerData, resourceType: resource.type };
          _this3.onGetAttachment(result);

          return Promise.resolve(result);
        }

        // The thumbnail is in base64 format so not a binary.
        var ossDataType = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.ATTACHMENT_DATA_TYPE_TEXT;

        // OSS data type is to determine whether the attachment is binary or not.
        var isBinaryData = ossDataType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.ATTACHMENT_DATA_TYPE_BINARY;

        return _this3.service.getAttachment(resource.ossPath, isBinaryData).then(function (resourceData) {
          if (!resourceData) {
            return Promise.resolve(null);
          }

          resource.data = resourceData;
          result = { layerData: layerData, resourceType: resource.type };
          _this3.onGetAttachment(result);

          return Promise.resolve(result);
        }).catch(function (e) {
          // Request fail or canceled by demand.
        });
      });

      return Promise.all(pa);
    } }, { key: "onGetAttachment", value: function onGetAttachment(

    layerAndAttachType) {var
      layerData = layerAndAttachType.layerData,resourceType = layerAndAttachType.resourceType;

      if (resourceType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SVG) {
        this.numOfMarkupsLoaded += 1;

        this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_RESOURCE_FETCHED, layerData: layerData });

        if (!this.fetchedAllMarkups && this.numOfMarkupsLoaded === this.markupsCache.length()) {
          this.fetchedAllMarkups = true;
          this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.ALL_MARKUPS_LOADED, amount: this.numOfMarkupsLoaded });
        }
      }

      if (resourceType === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE) {
        this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_THUMBNAIL_FETCHED, layerData: layerData });
      }
    } }, { key: "createEmptyResourceObject", value: function createEmptyResourceObject(

    resourceType, resourceEmbed, resources) {
      if (resources[resourceType]) {
        var markupResource = {
          type: resourceType,
          data: null,
          id: null,
          ossPath: null };


        if (!resourceEmbed) {
          markupResource.ossPath = resources[resourceType];
        } else {
          markupResource.data = resources[resourceType];
        }
        return markupResource;
      }

      return null;
    } }, { key: "getAttachedDocumentData", value: function getAttachedDocumentData(

    attachments) {var _this4 = this;
      if (!attachments || !Array.isArray(attachments) || attachments.length === 0) {
        return;
      }

      if (!this.options.getAttachedDocumentCallback) {
        return;
      }

      var layerDatas = this.markupsCache.getAsList();

      var filteredAttachments = attachments.filter(function (at) {
        return layerDatas.some(function (layerData) {return at.attributes && at.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.LINK_TYPE_ATTACHMENTS && layerData.guid === at.attributes.issue_id;});
      });

      if (filteredAttachments.length > 0) {
        this.options.getAttachedDocumentCallback(filteredAttachments, function (response) {
          layerDatas.forEach(function (layerData) {
            if (response) {var _layerData$attachment;
              (_layerData$attachment = layerData.attachments).push.apply(_layerData$attachment, _toConsumableArray(response.filter(function (res) {
                return res.attributes.issue_id === layerData.guid && layerData.attachments.findIndex(function (attachment) {return attachment.id === res.id;}) === -1;
              })));

              layerData.attachments.forEach(function (documentAttachment) {
                _this4.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, layerData: layerData, documentAttachment: documentAttachment });
              });
            }
          });
        });
      }
    } }, { key: "getUserProfiles", value: function getUserProfiles()

    {var _this5 = this;
      // client must provide the callback function
      if (!this.options.getUserProfileCallback) {
        return;
      }


      (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.forAll)(this.markupsCache.getCache(), function (layerData) {
        var oxygenId = layerData.metadata.created_by;

        if (oxygenId && !layerData.userName) {
          _this5.options.getUserProfileCallback(oxygenId, function (userInfo) {
            // Now only take user name out of the profile
            if (userInfo && userInfo.name) {
              layerData.userName = userInfo.name;
              _this5.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_METADATA_FETCHED });
            }
          });
        }
      });
    } }, { key: "getProjectUsers", value: function getProjectUsers()

    {var _this6 = this;
      // client must provide the callback function
      if (!this.options.getProjectUsersCallback) {
        return;
      }

      var callback = this.options.getProjectUsersCallback;

      callback(function (users) {
        _this6.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.PROJECT_USERS_FETCHED, users: users });
      });
    }

    /**
       * [getRevision: get revision number to an internal wip version on the given document]
       */ }, { key: "getRevisions", value: function getRevisions()
    {var _this7 = this;
      if (!this.options.getRevisionCallback) {
        return;
      }

      // Assume the returned version object is an array that contains
      // map from internal wip version to the revision number.
      this.options.getRevisionCallback(this.options.documentUrn, function (versions) {
        (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.forAll)(_this7.markupsCache.getCache(), function (layerData) {
          if (!layerData || !layerData.metadata) {
            return;
          }

          var internalVersion = layerData.metadata.starting_version;
          layerData.metadata.tags.starting_revision = versions[internalVersion];
        });

        _this7.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_METADATA_FETCHED });
      });
    } }, { key: "generateMarkupDescription", value: function generateMarkupDescription(

    layer) {
      var description = [];

      layer.getAllMarkups().forEach(function (markup) {
        if (markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_TEXT || markup.type === _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_TYPE_CALLOUT) {
          description.push(markup.state.text);
        }
      });

      return description.join('.\n');
    } }, { key: "generateMetadata", value: function generateMetadata(

    status, layer) {var _this8 = this;
      var metadata = {};

      metadata.target_urn = this.options.documentUrn;
      metadata.starting_version = this.options.documentVersion;
      metadata.resource_urns = {};

      var sceneState = this.viewer.getState();
      var globalOffset = this.viewer.model ? this.viewer.model.getData().globalOffset : null;

      metadata.markup_metadata = (0,_MarkupsSceneState__WEBPACK_IMPORTED_MODULE_6__.generateSceneMetadata)(sceneState, globalOffset, this.options);
      metadata.markup_metadata.links = (0,_MarkupsCommon__WEBPACK_IMPORTED_MODULE_4__.getObjectAsList)(layer.links).map(function (link) {
        var position = link.state.position && link.state.position.clone();

        if (position && _this8.markupsExtension.viewer.model.isPdf(true)) {
          Autodesk.Viewing.PDFUtils.pdfToLeafletWorld(_this8.markupsExtension.viewer, position);
        }

        return {
          id: link.guid,
          type: link.type,
          position: position };

      });

      metadata.description = this.generateMarkupDescription(layer);

      // [Ugly Revision]: record the revision label
      metadata.tags = {
        starting_revision: this.options.documentRevision || this.options.documentVersion };


      // Add collection urn in if specified.
      if (this.options.collectionUrn) {
        metadata.collection_urn = this.options.collectionUrn;
      }

      // Add user name as a tag to markup object, it is a tricky way of quickly getting user's display name
      // when retrieving from server.
      if (this.options.userName) {
        metadata.tags.userName = this.options.userName;
      }

      metadata.status = status;

      // https://jira.autodesk.com/browse/BLMV-2918
      // Update originalDocumentResolution when saving / updating a markup, in order to make sure that the markup will
      // maintain the same position for different DPIs of the same document.
      if (this.viewer.model.isLeaflet()) {
        var modelData = this.viewer.model.getData();var
        loadOptions = modelData.loadOptions.loadOptions;
        metadata.markup_metadata.originalDocumentResolution = [loadOptions.texWidth, loadOptions.texHeight];
      }

      return metadata;
    } }, { key: "saveLayer", value: function saveLayer(

    layer) {var _this9 = this;
      var urn = this.options.documentUrn;
      var isNew = !layer.layerData;
      var tmpId = "".concat(layer.id, "_tmp");
      var layerData = isNew ? new _MarkupsLayerData__WEBPACK_IMPORTED_MODULE_8__["default"]() : layer.layerData;
      var tmpLayerData;

      // 2. Generate markup object
      var metadata = this.generateMetadata(isNew ? this.markupsExtension.getCreationStatusType() : layerData.metadata.status, layer);

      // 3. Get markups data
      var svgResource = {
        type: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SVG,
        data: (0,_MarkupsSerializer__WEBPACK_IMPORTED_MODULE_7__.generateSVGData)(layer, this.markupsExtension.viewer, this.markupsExtension.renderer),
        id: null,
        ossPath: null };


      // screen capture
      var screenCaptureData = {
        type: _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_RESOURCE_TYPE_SCREEN_CAPTURE,
        data: null,
        id: null,
        ossPath: null };


      var resources = [svgResource, screenCaptureData];

      layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_SAVING;
      layerData.originalCreationTime = isNew ? new Date().toISOString() : metadata.created_at;
      layer.layerData = layerData;

      if (isNew) {
        tmpLayerData = _Utils_LodashUtils__WEBPACK_IMPORTED_MODULE_0__["default"].cloneDeep(layerData);
        tmpLayerData.metadata = metadata;
        tmpLayerData.resources = resources;
        this.markupsCache.add(tmpId, tmpLayerData, urn);
      }
      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCING, layerData: layerData, layer: layer });

      this.savingCounter++;

      this.markupsManager.generateScreenCapture(layer).then(function (img) {
        resources[1].data = img;

        if (!isNew) {
          layerData.resources = resources;
        }

        _this9.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCING, layerData: layerData, layer: layer });

        _this9.service.postLayer(metadata, resources, isNew ? undefined : layer.getGuid()).then(function (result) {
          var guid = result.id;
          layerData.guid = guid;
          layerData.metadata = result.attributes;
          layerData.resources = resources;
          layerData.attachments = layerData.attachments || [];
          layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_SAVE_SUCCEED;
          _this9.markupsCache.add(guid, layerData, urn);
          layerData.userName = layerData.metadata.tags.userName;
        }).catch(function (e) {
          if (isNew) {
            layer.layerData = null;
          } else {
            layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_SAVE_FAILED;
          }

          _this9.errorHandler(Autodesk.Viewing.i18n.translate('Failed to save markup'), MARKUP_ERRORS.MARKUP_SAVE_FAILED, e);
          console.error('Failed to save markup', layerData, e);
        }).finally(function () {
          _this9.markupsCache.remove(tmpId, urn);
          _this9.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData, layer: layer });
          _this9.savingCounter--;
        });
      }).catch(function () {
        _this9.savingCounter--;
      });
    }

    // ////////////////////////////////////////////////////////////////////// //
    // Start: Common private method
    // ////////////////////////////////////////////////////////////////////// //
  }, { key: "onDocumentAttachmentCreationStart", value: function onDocumentAttachmentCreationStart(_ref6)
    {var _this10 = this;var documentAttachments = _ref6.documentAttachments,layerData = _ref6.layerData;
      if (documentAttachments.length === 0) {
        return;
      }

      // TODO: at the moment, support save one at a time.
      if (documentAttachments.length > 1) {
        console.error('Dont save multiple attachments at a time.');
        return;
      }

      documentAttachments.forEach(function (at) {
        at.attributes.issue_id = layerData.guid;
        at.attributes.attachment_type = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.LINK_TYPE_DOCUMENT_ATTACHMENT;
      });

      var documentAttachment = documentAttachments[0];

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCING, documentAttachment: documentAttachment, layerData: layerData });
      this.service.postDocumentAttachment(documentAttachment).then(function (attachment) {
        if (attachment && attachment.attributes && attachment.attributes.issue_id) {
          documentAttachment.attributes = attachment.attributes;
          documentAttachment.id = attachment.id;
          layerData.attachments.splice(0, 0, documentAttachment);
          _this10.markupsManager.createLinkMetadata(layerData);
        }

        _this10.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
      }).catch(function (e) {
        _this10.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
        _this10.errorHandler(Autodesk.Viewing.i18n.translate('Failed to create markup attachment'), MARKUP_ERRORS.MARKUP_ATTACHMENT_CREATE_FAILED, e);
        console.error('Failed to create markup attachment', e);
      });
    }

    // ////////////////////////////////////////////////////////////////////// //
    // End: Common private method
    // ////////////////////////////////////////////////////////////////////// //
  }, { key: "deleteDocumentAttachment", value: function deleteDocumentAttachment(_ref7)
    {var _this11 = this;var documentAttachment = _ref7.documentAttachment,layerData = _ref7.layerData;
      documentAttachment.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_ATTACHMENT_DELETEING;

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCING, documentAttachment: documentAttachment, layerData: layerData });

      this.service.deleteDocumentAttachment(documentAttachment.id).then(function () {
        var docAttachments = layerData.attachments;
        var index = docAttachments.indexOf(documentAttachment);

        if (index > -1) {
          docAttachments.splice(index, 1);
        }
        _this11.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
      }).catch(function (e) {
        _this11.errorHandler(Autodesk.Viewing.i18n.translate('Failed to delete markup attachment'), MARKUP_ERRORS.MARKUP_ATTACHMENT_DELETE_FAILED, e);
        _this11.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
      });
    } }, { key: "renameDocumentAttachment", value: function renameDocumentAttachment(_ref8)

    {var _this12 = this;var documentAttachment = _ref8.documentAttachment,newName = _ref8.newName,layerData = _ref8.layerData;
      documentAttachment.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_ATTACHMENT_RENAMING;
      documentAttachment.tmpName = newName;

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCING, documentAttachment: documentAttachment, layerData: layerData });

      this.service.renameDocumentAttachment(documentAttachment.id, newName).then(function (attachData) {
        documentAttachment.attributes = attachData.attributes;

        documentAttachment.status = undefined;
        documentAttachment.tmpName = undefined;
        _this12.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
      }).catch(function (e) {
        // If rename failed, the name of the attachment will still stay the old one.
        documentAttachment.status = undefined;
        documentAttachment.tmpName = undefined;
        _this12.errorHandler(Autodesk.Viewing.i18n.translate('Failed to rename markup attachment'), MARKUP_ERRORS.MARKUP_ATTACHMENT_RENAME_FAILED, e);
        _this12.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LINK_SYNCED, documentAttachment: documentAttachment, layerData: layerData });
      });
    } }, { key: "updateLinkPosition", value: function updateLinkPosition(

    markupGuid, linkId, pos) {var _this13 = this;
      var position = pos.clone();

      if (this.markupsExtension.viewer.model.isPdf(true)) {
        Autodesk.Viewing.PDFUtils.pdfToLeafletWorld(this.markupsExtension.viewer, position);
      }

      var metadata = {
        markup_metadata: {
          links: [{
            id: linkId,
            position: position }] } };




      return this.service.updateLayer(markupGuid, metadata).then(function (attachData) {
        return Promise.resolve(attachData);
      }, function (e) {
        _this13.errorHandler(Autodesk.Viewing.i18n.translate('Failed to update markup attachment'), MARKUP_ERRORS.MARKUP_ATTACHMENT_UPDATE_FAILED, e);
        return Promise.reject('Failed to change the link position: ' + linkId);
      });
    } }, { key: "deleteLayer", value: function deleteLayer(

    layerData) {var _this14 = this;
      if (!layerData.guid) {
        // In case the argument is layer's guid.
        layerData = this.markupsCache.get(layerData);
      }

      layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_DELETING;

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCING, layerData: layerData });

      var urn = this.options.documentUrn;

      return this.service.deleteLayer(layerData.guid).then(function (result) {
        _this14.markupsCache.remove(layerData.guid, urn);
        layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_DELETE_SUCCEED;
        _this14.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });
        return Promise.resolve(true);
      }, function (e) {
        // Failed to delete the document.
        layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_DELETE_FAILED;
        _this14.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });
        _this14.errorHandler(Autodesk.Viewing.i18n.translate('Failed to delete markup'), MARKUP_ERRORS.MARKUP_DELETE_FAILED, e);
        return Promise.reject('Failed to delete markup: ' + layerData.guid);
      });
    }

    // WARNING - for develop usage only!!!
  }, { key: "deleteAllLayers", value: function deleteAllLayers() {var _this15 = this;
      this.markupsCache.getAsList().forEach(function (layer) {
        _this15.deleteLayer(layer);
      });
    } }, { key: "publishLayer", value: function publishLayer(

    layerData) {var _this16 = this;
      if (!layerData.guid) {
        // In case the argument is layer's guid.
        layerData = this.markupsCache.get(layerData);
      }

      var prevStatus = layerData.status;
      layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_PUBLISHING;

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCING, layerData: layerData });
      this.service.publishLayer(layerData.guid).then(function (updatedMetadata) {
        // Update local markup data
        layerData.status = prevStatus;
        layerData.metadata = updatedMetadata.attributes;
        _this16.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });
        return Promise.resolve();
      }).catch(function (e) {
        // Fail to publish layer
        layerData.status = prevStatus;
        _this16.errorHandler(Autodesk.Viewing.i18n.translate('Failed to publish markup'), MARKUP_ERRORS.MARKUP_PUBLISH_FAILED, e);
        _this16.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });
      });
    } }, { key: "archiveLayer", value: function archiveLayer(

    layerData) {var _this17 = this;
      if (!layerData.guid) {
        // In case the argument is layer's guid.
        layerData = this.markupsCache.get(layerData);
      }

      var prevStatus = layerData.status;
      layerData.status = _MarkupsConstants__WEBPACK_IMPORTED_MODULE_3__.MARKUP_STATUS_ARCHIVING;

      this.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCING, layerData: layerData });
      this.service.archiveLayer(layerData.guid, this.options.currentRawDocumentVersion).then(function (updatedMetadata) {
        layerData.status = prevStatus;
        layerData.metadata = updatedMetadata.attributes;

        _this17.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });

        return Promise.resolve();
      }).catch(function (e) {
        // Fail to archive layer
        layerData.status = prevStatus;
        _this17.errorHandler(Autodesk.Viewing.i18n.translate('Failed to archive markup'), MARKUP_ERRORS.MARKUP_ARCHIVE_FAILED, e);
        _this17.notify({ type: _MarkupsEvents__WEBPACK_IMPORTED_MODULE_5__.MARKUPS_EVENTS.LAYER_SYNCED, layerData: layerData });
      });
    } }, { key: "cancelRequests", value: function cancelRequests()

    {
      this.service.cancelRequests();
    } }, { key: "terminate", value: function terminate()

    {
      this.cancelRequests();

      this.markupsExtension = null;
      this.markupsManager = null;
      this.service = null;
    } }, { key: "getMaxPageLimit", value: function getMaxPageLimit()

    {
      return this.service.maxPageLimit;
    } }]);return MarkupsServiceOperator;}();

/***/ }),

/***/ "./extensions/BimMarkups/ThirdParty/textarea-caret/textarea-caret.js":
/*!***************************************************************************!*\
  !*** ./extensions/BimMarkups/ThirdParty/textarea-caret/textarea-caret.js ***!
  \***************************************************************************/
/***/ ((module) => {

/* jshint browser: true */

(function () {

  // We'll copy the properties below into the mirror div.
  // Note that some browsers, such as Firefox, do not concatenate properties
  // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),
  // so we have to list every single property explicitly.
  var properties = [
  'direction', // RTL support
  'boxSizing',
  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
  'height',
  'overflowX',
  'overflowY', // copy the scrollbar for IE

  'borderTopWidth',
  'borderRightWidth',
  'borderBottomWidth',
  'borderLeftWidth',
  'borderStyle',

  'paddingTop',
  'paddingRight',
  'paddingBottom',
  'paddingLeft',

  // https://developer.mozilla.org/en-US/docs/Web/CSS/font
  'fontStyle',
  'fontVariant',
  'fontWeight',
  'fontStretch',
  'fontSize',
  'fontSizeAdjust',
  'lineHeight',
  'fontFamily',

  'textAlign',
  'textTransform',
  'textIndent',
  'textDecoration', // might not make a difference, but better be safe

  'letterSpacing',
  'wordSpacing',

  'tabSize',
  'MozTabSize'];



  var isBrowser = typeof window !== 'undefined';
  var isFirefox = isBrowser && window.mozInnerScreenX != null;

  function getCaretCoordinates(element, position, options) {
    var _document = element.ownerDocument;
    var _window = _document.defaultView || _document.parentWindow;
    if (!isBrowser) {
      throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');
    }

    var debug = options && options.debug || false;
    if (debug) {
      var el = _document.querySelector('#input-textarea-caret-position-mirror-div');
      if (el) el.parentNode.removeChild(el);
    }

    // The mirror div will replicate the textarea's style
    var div = _document.createElement('div');
    div.id = 'input-textarea-caret-position-mirror-div';
    _document.body.appendChild(div);

    var style = div.style;
    var computed = _window.getComputedStyle ? _window.getComputedStyle(element) : element.currentStyle; // currentStyle for IE < 9
    var isInput = element.nodeName === 'INPUT';

    // Default textarea styles
    style.whiteSpace = 'pre-wrap';
    if (!isInput)
    style.wordWrap = 'break-word'; // only for textarea-s

    // Position off-screen
    style.position = 'absolute'; // required to return coordinates properly
    if (!debug)
    style.visibility = 'hidden'; // not 'display: none' because we want rendering

    // Transfer the element's properties to the div
    properties.forEach(function (prop) {
      if (isInput && prop === 'lineHeight') {
        // Special case for <input>s because text is rendered centered and line height may be != height
        style.lineHeight = computed.height;
      } else {
        style[prop] = computed[prop];
      }
    });

    if (isFirefox) {
      // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
      if (element.scrollHeight > parseInt(computed.height))
      style.overflowY = 'scroll';
    } else {
      style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
    }

    div.textContent = element.value.substring(0, position);
    // The second special handling for input type="text" vs textarea:
    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
    if (isInput)
    div.textContent = div.textContent.replace(/\s/g, "\xA0");

    var span = _document.createElement('span');
    // Wrapping must be replicated *exactly*, including when a long word gets
    // onto the next line, with whitespace at the end of the line before (#7).
    // The  *only* reliable way to do that is to copy the *entire* rest of the
    // textarea's content into the <span> created at the caret position.
    // For inputs, just '.' would be enough, but no need to bother.
    span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all
    div.appendChild(span);

    var coordinates = {
      top: span.offsetTop + parseInt(computed['borderTopWidth']),
      left: span.offsetLeft + parseInt(computed['borderLeftWidth']),
      height: parseInt(computed['lineHeight']) };


    if (debug) {
      span.style.backgroundColor = '#aaa';
    } else {
      _document.body.removeChild(div);
    }

    return coordinates;
  }

  if ( true && typeof module.exports != 'undefined') {
    module.exports = getCaretCoordinates;
  } else if (isBrowser) {
    window.getCaretCoordinates = getCaretCoordinates;
  }

})();

/***/ }),

/***/ "./extensions/BimMarkups/UI/MarkupsUI.js":
/*!***********************************************!*\
  !*** ./extensions/BimMarkups/UI/MarkupsUI.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsUI)
/* harmony export */ });
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;var

MarkupsUI = /*#__PURE__*/function () {
  function MarkupsUI(markupsExtension) {_classCallCheck(this, MarkupsUI);
    this.viewer = markupsExtension.viewer;
    this.setGlobalManager(markupsExtension.globalManager);
    this.options = markupsExtension.options;
    this.markupsExtension = markupsExtension;

    this.createUI();
  }_createClass(MarkupsUI, [{ key: "createUI", value: function createUI()

    {
      var uiClasses = this.options.uiClasses;
      if (!uiClasses) {
        return;
      }

      var _document = this.getDocument();
      this.uiContainer = _document.createElement('div');
      this.uiContainer.id = 'MarkupsUI_Container';
      this.uiContainer.className = 'MarkupsUI_Container';
      this.viewer.container.appendChild(this.uiContainer);

      var ToolbarClass = uiClasses.ToolbarClass;
      this.toolbar = ToolbarClass && new ToolbarClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);

      var CreationToastClass = uiClasses.CreationToastClass;
      this.creationToast = CreationToastClass && new CreationToastClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);

      var ContextualMenuClass = uiClasses.ContextualMenuClass;
      this.contextualMenu = ContextualMenuClass && new ContextualMenuClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);

      var AttachmentsPreviewPanelClass = uiClasses.AttachmentsPreviewPanelClass;
      this.attachmentsPreviewPanel = AttachmentsPreviewPanelClass && new AttachmentsPreviewPanelClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);

      var MarkupsDialogModalsClass = uiClasses.MarkupsDialogModalsClass;
      this.MarkupsDialogModals = MarkupsDialogModalsClass && new MarkupsDialogModalsClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);

      if (this.viewer.impl.is2d) {
        var MarkupsVisibilityButtonClass = uiClasses.MarkupsVisibilityButtonClass;
        this.markupsVisibilityButton = MarkupsVisibilityButtonClass && new MarkupsVisibilityButtonClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);
      } else {
        var ExitMarkupViewClass = uiClasses.ExitMarkupViewClass;
        this.exitMarkupView = ExitMarkupViewClass && new ExitMarkupViewClass(this.markupsExtension, this.uiContainer, this.viewer, this.options);
      }


      this.registerEventListeners();
    } }, { key: "destroy", value: function destroy()

    {
      if (this.toolbar) {
        this.toolbar.destroy();
        this.toolbar = null;
      }

      if (this.creationToast) {
        this.creationToast.destroy();
        this.creationToast = null;
      }

      if (this.contextualMenu) {
        this.contextualMenu.destroy();
        this.contextualMenu = null;
      }

      if (this.attachmentsPreviewPanel) {
        this.attachmentsPreviewPanel.destroy();
        this.attachmentsPreviewPanel = null;
      }

      if (this.markupsVisibilityButton) {
        this.markupsVisibilityButton.destroy();
        this.markupsVisibilityButton = null;
      }

      if (this.exitMarkupView) {
        this.exitMarkupView.destroy();
        this.exitMarkupView = null;
      }

      this.unregisterEventListeners();

      if (this.uiContainer) {
        this.viewer.container.removeChild(this.uiContainer);
        this.uiContainer = null;
      }

      this.markupsExtension = null;
      this.viewer = null;
      this.options = null;
    }

    ////////////////////////////////////////////////
    ///////// Handle LMV navigation buttons ////////
    ////////////////////////////////////////////////
  }, { key: "registerEventListeners", value: function registerEventListeners()
    {
      this.onSessionStartBinded = this.onSessionStart.bind(this);
      this.onSessionEndBinded = this.onSessionEnd.bind(this);

      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.onSessionStartBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.onSessionEndBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_SELECTED, this.onSessionStartBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DESELECTED, this.onSessionEndBinded);
      this.markupsExtension.markupsManager.addEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_CREATION_TYPE_CHANGED, this.onSessionStartBinded);
    } }, { key: "unregisterEventListeners", value: function unregisterEventListeners()

    {
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_START, this.onSessionStartBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_SESSION_END, this.onSessionEndBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_SELECTED, this.onSessionStartBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.LAYER_DESELECTED, this.onSessionEndBinded);
      this.markupsExtension.markupsManager.removeEventListener(_MarkupsEvents__WEBPACK_IMPORTED_MODULE_0__.MARKUPS_EVENTS.MARKUP_CREATION_TYPE_CHANGED, this.onSessionStartBinded);
    } }, { key: "onSessionStart", value: function onSessionStart()

    {
      this.selectNavigationButton(null);

      if (this.viewer.impl.is2d) {
        this.handleNavButtonEvents(true);
      }
    } }, { key: "onSessionEnd", value: function onSessionEnd()

    {
      if (this.viewer.impl.is2d) {
        this.handleNavButtonEvents(false);
      }

      this.selectNavigationButton(this.markupsExtension.markupsManager.navigationToolBackup);
    } }, { key: "getNavigationControls", value: function getNavigationControls()

    {
      var LMVtoolbar = this.viewer.getToolbar();
      var navigationControls = LMVtoolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);
      return navigationControls._controls;
    }

    // Add / remove listeners for client event on each navigation toolbar button.
  }, { key: "handleNavButtonEvents", value: function handleNavButtonEvents(addEventListener) {var _this = this;
      this.onNavButtonClickBinded = this.onNavButtonClick.bind(this);
      var buttons = this.getNavigationControls();

      var handleButtonEvents = function handleButtonEvents(button) {
        if (addEventListener) {
          if (!button.hasEventListener(Autodesk.Viewing.UI.Button.Event.CLICK, _this.onNavButtonClickBinded)) {
            button.addEventListener(Autodesk.Viewing.UI.Button.Event.CLICK, _this.onNavButtonClickBinded);
          }
        } else {
          button.removeEventListener(Autodesk.Viewing.UI.Button.Event.CLICK, _this.onNavButtonClickBinded);
        }
      };

      buttons.forEach(function (button) {
        handleButtonEvents(button);

        if (button.subMenu) {
          var subButtons = button.subMenu._controls;
          subButtons.forEach(function (subButton) {
            handleButtonEvents(subButton);
          });
        }
      });
    } }, { key: "onNavButtonClick", value: function onNavButtonClick(

    event) {var _this2 = this;
      var buttons = this.getNavigationControls();

      buttons.forEach(function (button) {
        if (button._id !== event.target._id) {
          button.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        } else if (button.getState() === Autodesk.Viewing.UI.Button.State.INACTIVE) {
          _this2.markupsExtension.markupsManager.changeMarkupCreationType(null);
          button.setState(Autodesk.Viewing.UI.Button.State.ACTIVE); // This is mandatory to actually change the active navigation tool & update icon.

          setTimeout(function () {
            _this2.markupsExtension.markupsManager.navigationToolBackup = _this2.viewer.getActiveNavigationTool();
          });
        }
      });
    }

    // Setup active navigation tool on viewer and also activate corresponding button on navigation toolbar.
  }, { key: "selectNavigationButton", value: function selectNavigationButton(toolName) {
      var setButtonState = function setButtonState(button) {
        var isActive = button._id.toLowerCase().indexOf(toolName) !== -1;
        button.setState(isActive ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE);
      };

      var buttons = this.getNavigationControls();

      buttons.forEach(function (button) {
        setButtonState(button);

        // Add additional check for group button
        if (button.subMenu) {
          button.subMenu._controls.forEach(function (subButton) {
            setButtonState(subButton);
          });
        }
      });
    } }]);return MarkupsUI;}();


av.GlobalManagerMixin.call(MarkupsUI.prototype);

/***/ }),

/***/ "./extensions/BimMarkups/Utils/ActionManager/Action.js":
/*!*************************************************************!*\
  !*** ./extensions/BimMarkups/Utils/ActionManager/Action.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Action)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               * Action
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               * A base class for a single Action.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               * You should implement undo and redo methods.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var

Action = /*#__PURE__*/function () {
  function Action(actionManager) {_classCallCheck(this, Action);
    this.actionManager = actionManager;
  }_createClass(Action, [{ key: "execute", value: function execute()

    {
      this.actionManager.execute(this);
    } }, { key: "undo", value: function undo()

    {
    } }, { key: "redo", value: function redo()

    {
    } }]);return Action;}();

/***/ }),

/***/ "./extensions/BimMarkups/Utils/ActionManager/ActionManager.js":
/*!********************************************************************!*\
  !*** ./extensions/BimMarkups/Utils/ActionManager/ActionManager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ActionManager)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Action */ "./extensions/BimMarkups/Utils/ActionManager/Action.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * ActionManager
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Implementation of Command Pattern - https://en.wikipedia.org/wiki/Command_pattern.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Use in order to manage actions with undo and redo operations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * This class extends EventDispatcher, so for every action, it triggers an event.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var

ActionManager = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(ActionManager, _Autodesk$Viewing$Eve);var _super = _createSuper(ActionManager);
  function ActionManager() {var _this;_classCallCheck(this, ActionManager);
    _this = _super.call(this);

    _this.undoStack = [];
    _this.redoStack = [];

    _this.isGroupOpen = false;
    _this.nextActionId = 0;return _this;
  }_createClass(ActionManager, [{ key: "execute", value: function execute(

    action) {
      this.clearStack(this.redoStack);

      action.id = this.nextActionId;
      this.nextActionId += 1;

      action.redo();

      if (this.isGroupOpen) {
        this.group.push(action);
      } else {
        this.undoStack.push(action);
      }

      action.trigger = ActionManager.EXECUTE;
      this.notify(action);
    } }, { key: "undo", value: function undo()

    {var allowRedo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this.undoStack.length === 0) {
        return;
      }

      if (this.isGroupOpen) {
        console.warn('Cannot undo while action group is open!');
        return;
      }

      var action = this.undoStack.pop();
      if (allowRedo) {
        this.redoStack.push(action);
      }

      if (action instanceof _Action__WEBPACK_IMPORTED_MODULE_0__["default"]) {
        action.undo();
      } else {
        // Action group
        for (var i = action.length - 1; i >= 0; i--) {
          action[i].undo();
        }
      }

      action.trigger = ActionManager.UNDO;
      this.notify(action);
    } }, { key: "redo", value: function redo()

    {
      if (this.redoStack.length === 0) {
        return;
      }

      if (this.isGroupOpen) {
        console.warn('Cannot redo while action group is open!');
        return;
      }

      var action = this.redoStack.pop();
      this.undoStack.push(action);

      if (action instanceof _Action__WEBPACK_IMPORTED_MODULE_0__["default"]) {
        action.redo();
      } else {
        // Action group
        for (var i = 0; i < action.length; i++) {
          action[i].redo();
        }
      }

      action.trigger = ActionManager.REDO;
      this.notify(action);
    } }, { key: "clear", value: function clear()

    {
      this.clearStack(this.undoStack);
      this.clearStack(this.redoStack);

      this.isGroupOpen = false;
      this.group = [];

      this.notify([]);
    } }, { key: "clearStack", value: function clearStack(

    stack) {
      stack.splice(0, stack.length);
    } }, { key: "isUndoStackEmpty", value: function isUndoStackEmpty()

    {
      return this.undoStack.length === 0;
    } }, { key: "isRedoStackEmpty", value: function isRedoStackEmpty()

    {
      return this.redoStack.length === 0;
    } }, { key: "notify", value: function notify(

    actionGroup) {
      actionGroup = actionGroup instanceof _Action__WEBPACK_IMPORTED_MODULE_0__["default"] ? [actionGroup] : actionGroup;

      this.dispatchEvent({
        type: ActionManager.HISTORY_CHANGED_EVENT,
        actionGroup: actionGroup,
        hasUndo: !this.isUndoStackEmpty(),
        hasRedo: !this.isRedoStackEmpty() });

    } }, { key: "openActionGroup", value: function openActionGroup()

    {
      if (this.isGroupOpen) {
        console.warn('Cannot open a new action group while another one is still open');
        return;
      }

      this.group = [];
      this.undoStack.push(this.group);
      this.isGroupOpen = true;
    } }, { key: "closeActionGroup", value: function closeActionGroup()

    {
      if (this.group.length === 0) {
        this.undoStack.pop();
      }

      this.isGroupOpen = false;
    } }]);return ActionManager;}(Autodesk.Viewing.EventDispatcher);


// ActionManager Events
ActionManager.HISTORY_CHANGED_EVENT = 'action-manager.history.changed.event';
ActionManager.UNDO = 'action-manager.undo';
ActionManager.REDO = 'action-manager.redo';
ActionManager.EXECUTE = 'action-manager.execute';

/***/ }),

/***/ "./extensions/BimMarkups/Utils/CameraUtils.js":
/*!****************************************************!*\
  !*** ./extensions/BimMarkups/Utils/CameraUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GeometryUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometryUtils */ "./extensions/BimMarkups/Utils/GeometryUtils.js");


var CameraUtils = {};

// Same as viewer.worldToClient, but with a camera as argument.
CameraUtils.worldToClient = function (viewer, point, camera) {
  var p = new THREE.Vector4(point.x, point.y, point.z, 1);
  p.applyMatrix4(camera.matrixWorldInverse);
  p.applyMatrix4(camera.projectionMatrix);

  // Don't want to mirror values with negative z (behind camera)
  if (p.w > 0) {
    p.x /= p.w;
    p.y /= p.w;
    p.z /= p.w;
  }

  return viewer.impl.viewportToClient(p.x, p.y);
};

CameraUtils.getCameraEyeVector = function (camera) {
  return camera.target.clone().sub(camera.position).normalize();
};

CameraUtils.getCameraRightVector = function (camera) {
  var eye = CameraUtils.getCameraEyeVector(camera);
  return new THREE.Vector3().crossVectors(eye, camera.up).normalize();
};

CameraUtils.getCameraUpVector = function (camera) {
  var right = CameraUtils.getCameraRightVector(camera);
  var eye = CameraUtils.getCameraEyeVector(camera);
  return new THREE.Vector3().crossVectors(right, eye).normalize();
};

CameraUtils.getCameraRotation = function (camera) {
  return _GeometryUtils__WEBPACK_IMPORTED_MODULE_0__["default"].getSignedAngle(CameraUtils.getCameraUpVector(camera), new THREE.Vector3(0, 1, 0), CameraUtils.getCameraEyeVector(camera));
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CameraUtils);

/***/ }),

/***/ "./extensions/BimMarkups/Utils/GeometryUtils.js":
/*!******************************************************!*\
  !*** ./extensions/BimMarkups/Utils/GeometryUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GeometryUtils = {};

GeometryUtils.radiansToDegrees = function (radians) {
  return radians * (180 / Math.PI);
};

GeometryUtils.degreesToRadians = function (degrees) {
  return degrees * (Math.PI / 180);
};

GeometryUtils.applyRotation = function (points, angle, pivot, frontVector) {
  if (!(points instanceof Array)) {
    points = [points];
  }

  points.forEach(function (point) {
    point.sub(pivot);
    point.applyAxisAngle(frontVector, angle);
    point.add(pivot);
  });
};

GeometryUtils.getSignedAngle = function (v1, v2, eyeVector) {
  var angle = v1.angleTo(v2);

  var n = v1.clone().cross(v2).normalize();
  var sign = eyeVector.dot(n) > 0 ? 1 : -1;

  return angle * sign;
};

GeometryUtils.swapBoundingBoxY = function (boundingBox) {var _ref =
  [boundingBox.min.y, boundingBox.max.y];boundingBox.max.y = _ref[0];boundingBox.min.y = _ref[1];

  return boundingBox;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometryUtils);

/***/ }),

/***/ "./extensions/BimMarkups/Utils/LodashUtils.js":
/*!****************************************************!*\
  !*** ./extensions/BimMarkups/Utils/LodashUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
var findLast = __webpack_require__(/*! lodash/findLast */ "./node_modules/lodash/findLast.js");
var debounce = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
var remove = __webpack_require__(/*! lodash/remove */ "./node_modules/lodash/remove.js");

var LodashUtils = {};

LodashUtils.cloneDeep = function (obj) {
  return cloneDeep(obj);
};

LodashUtils.findLast = function (array, predicate) {
  return findLast(array, predicate);
};

LodashUtils.debounce = function (func, wait, options) {
  return debounce(func, wait, options);
};

LodashUtils.remove = function (array, predicate) {
  return remove(array, predicate);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LodashUtils);

/***/ }),

/***/ "./extensions/BimMarkups/node_modules/html2canvas/dist/html2canvas.js":
/*!****************************************************************************!*\
  !*** ./extensions/BimMarkups/node_modules/html2canvas/dist/html2canvas.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);} /*!
                                                                                                                                                                                                                                                                                                                                                                                * html2canvas 1.2.2 <https://html2canvas.hertzen.com>
                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
                                                                                                                                                                                                                                                                                                                                                                                * Released under MIT License
                                                                                                                                                                                                                                                                                                                                                                                */
(function (global, factory) {
  ( false ? 0 : _typeof(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() :
   true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (
  0);
})(this, function () {'use strict';

  /*! *****************************************************************************
                                    Copyright (c) Microsoft Corporation.
                                      Permission to use, copy, modify, and/or distribute this software for any
                                    purpose with or without fee is hereby granted.
                                      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
                                    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
                                    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
                                    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
                                    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
                                    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
                                    PERFORMANCE OF THIS SOFTWARE.
                                    ***************************************************************************** */


  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf ||
    { __proto__: [] } instanceof Array && function (d, b) {d.__proto__ = b;} ||
    function (d, b) {for (var p in b) {if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];}};
    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {this.constructor = d;}
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];}
      }
      return t;
    };
    return _assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {return value instanceof P ? value : new P(function (resolve) {resolve(value);});}
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {try {step(generator.next(value));} catch (e) {reject(e);}}
      function rejected(value) {try {step(generator["throw"](value));} catch (e) {reject(e);}}
      function step(result) {result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);}
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function sent() {if (t[0] & 1) throw t[1];return t[1];}, trys: [], ops: [] },f,y,t,g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {return this;}), g;
    function verb(n) {return function (v) {return step([n, v]);};}
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) {try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:case 1:t = op;break;
            case 4:_.label++;return { value: op[1], done: false };
            case 5:_.label++;y = op[1];op = [0];continue;
            case 7:op = _.ops.pop();_.trys.pop();continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {_ = 0;continue;}
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {_.label = op[1];break;}
              if (op[0] === 6 && _.label < t[1]) {_.label = t[1];t = op;break;}
              if (t && _.label < t[2]) {_.label = t[2];_.ops.push(op);break;}
              if (t[2]) _.ops.pop();
              _.trys.pop();continue;}

          op = body.call(thisArg, _);
        } catch (e) {op = [6, e];y = 0;} finally {f = t = 0;}}
      if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
  }

  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || from);
  }

  var Bounds = /** @class */function () {
    function Bounds(left, top, width, height) {
      this.left = left;
      this.top = top;
      this.width = width;
      this.height = height;
    }
    Bounds.prototype.add = function (x, y, w, h) {
      return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
    };
    Bounds.fromClientRect = function (context, clientRect) {
      return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds.fromDOMRectList = function (context, domRectList) {
      var domRect = domRectList[0];
      return domRect ?
      new Bounds(domRect.x + context.windowBounds.left, domRect.y + context.windowBounds.top, domRect.width, domRect.height) :
      Bounds.EMPTY;
    };
    Bounds.EMPTY = new Bounds(0, 0, 0, 0);
    return Bounds;
  }();
  var parseBounds = function parseBounds(context, node) {
    return Bounds.fromClientRect(context, node.getBoundingClientRect());
  };
  var parseDocumentSize = function parseDocumentSize(document) {
    var body = document.body;
    var documentElement = document.documentElement;
    if (!body || !documentElement) {
      throw new Error("Unable to get document size");
    }
    var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
    var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
    return new Bounds(0, 0, width, height);
  };

  /*
      * css-line-break 2.0.1 <https://github.com/niklasvh/css-line-break#readme>
      * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
      * Released under MIT License
      */
  var toCodePoints = function toCodePoints(str) {
    var codePoints = [];
    var i = 0;
    var length = str.length;
    while (i < length) {
      var value = str.charCodeAt(i++);
      if (value >= 0xd800 && value <= 0xdbff && i < length) {
        var extra = str.charCodeAt(i++);
        if ((extra & 0xfc00) === 0xdc00) {
          codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
        } else
        {
          codePoints.push(value);
          i--;
        }
      } else
      {
        codePoints.push(value);
      }
    }
    return codePoints;
  };
  var fromCodePoint = function fromCodePoint() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    if (String.fromCodePoint) {
      return String.fromCodePoint.apply(String, codePoints);
    }
    var length = codePoints.length;
    if (!length) {
      return '';
    }
    var codeUnits = [];
    var index = -1;
    var result = '';
    while (++index < length) {
      var codePoint = codePoints[index];
      if (codePoint <= 0xffff) {
        codeUnits.push(codePoint);
      } else
      {
        codePoint -= 0x10000;
        codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);
      }
      if (index + 1 === length || codeUnits.length > 0x4000) {
        result += String.fromCharCode.apply(String, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  var decode = function decode(base64) {
    var bufferLength = base64.length * 0.75,len = base64.length,i,p = 0,encoded1,encoded2,encoded3,encoded4;
    if (base64[base64.length - 1] === '=') {
      bufferLength--;
      if (base64[base64.length - 2] === '=') {
        bufferLength--;
      }
    }
    var buffer = typeof ArrayBuffer !== 'undefined' &&
    typeof Uint8Array !== 'undefined' &&
    typeof Uint8Array.prototype.slice !== 'undefined' ?
    new ArrayBuffer(bufferLength) :
    new Array(bufferLength);
    var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
    for (i = 0; i < len; i += 4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i + 1)];
      encoded3 = lookup[base64.charCodeAt(i + 2)];
      encoded4 = lookup[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
  };
  var polyUint16Array = function polyUint16Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i = 0; i < length; i += 2) {
      bytes.push(buffer[i + 1] << 8 | buffer[i]);
    }
    return bytes;
  };
  var polyUint32Array = function polyUint32Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i = 0; i < length; i += 4) {
      bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
    }
    return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1 = 6 + 5;
  /**
                               * Shift size for shifting left the index array values.
                               * Increases possible data size with 16-bit index values at the cost
                               * of compactability.
                               * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
                               */
  var UTRIE2_INDEX_SHIFT = 2;
  /**
                               * Difference between the two shift sizes,
                               * for getting an index-1 offset from an index-2 offset. 6=11-5
                               */
  var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  /**
                                                           * The part of the index-2 table for U+D800..U+DBFF stores values for
                                                           * lead surrogate code _units_ not code _points_.
                                                           * Values for lead surrogate code _points_ are indexed with this portion of the table.
                                                           * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
                                                           */
  var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  /**
                                                                                            * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
                                                                                            * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
                                                                                            */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
                                                                                                           * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
                                                                                                           * Variable length, for code points up to highStart, where the last single-value range starts.
                                                                                                           * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
                                                                                                           * (For 0x100000 supplementary code points U+10000..U+10ffff.)
                                                                                                           *
                                                                                                           * The part of the index-2 table for supplementary code points starts
                                                                                                           * after this index-1 table.
                                                                                                           *
                                                                                                           * Both the index-1 table and the following part of the index-2 table
                                                                                                           * are omitted completely if there is only BMP data.
                                                                                                           */
  var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  /**
                                                                                              * Number of index-1 entries for the BMP. 32=0x20
                                                                                              * This part of the index-1 table is omitted from the serialized form.
                                                                                              */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  var slice16 = function slice16(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32 = function slice32(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64 = function createTrieFromBase64(base64) {
    var buffer = decode(base64);
    var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
    var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
    var headerLength = 24;
    var index = slice16(view16, headerLength / 2, view32[4] / 2);
    var data = view32[5] === 2 ?
    slice16(view16, (headerLength + view32[4]) / 2) :
    slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
    return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie = /** @class */function () {
    function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index;
      this.data = data;
    }
    /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
    Trie.prototype.get = function (codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 0x0d800 || codePoint > 0x0dbff && codePoint <= 0x0ffff) {
          // Ordinary BMP code point, excluding leading surrogates.
          // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
          // 16 bit data is stored in the index array itself.
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 0xffff) {
          // Lead Surrogate Code Point.  A Separate index section is stored for
          // lead surrogate code units and code points.
          //   The main index has the code unit data.
          //   For this function, we need the code point data.
          // Note: this expression could be refactored for slightly improved efficiency, but
          //       surrogate code points will be so rare in practice that it's not worth it.
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 0xd800 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          // Supplemental code point, use two-level lookup.
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 0x10ffff) {
          return this.data[this.highValueIndex];
        }
      }
      // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
      return this.errorValue;
    };
    return Trie;
  }();

  var base64 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

  /* @flow */
  var LETTER_NUMBER_MODIFIER = 50;
  // Non-tailorable Line Breaking Classes
  var BK = 1; //  Cause a line break (after)
  var CR = 2; //  Cause a line break (after), except between CR and LF
  var LF = 3; //  Cause a line break (after)
  var CM = 4; //  Prohibit a line break between the character and the preceding character
  var NL = 5; //  Cause a line break (after)
  var WJ = 7; //  Prohibit line breaks before and after
  var ZW = 8; //  Provide a break opportunity
  var GL = 9; //  Prohibit line breaks before and after
  var SP = 10; // Enable indirect line breaks
  var ZWJ = 11; // Prohibit line breaks within joiner sequences
  // Break Opportunities
  var B2 = 12; //  Provide a line break opportunity before and after the character
  var BA = 13; //  Generally provide a line break opportunity after the character
  var BB = 14; //  Generally provide a line break opportunity before the character
  var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
  var CB = 16; //   Provide a line break opportunity contingent on additional information
  // Characters Prohibiting Certain Breaks
  var CL = 17; //  Prohibit line breaks before
  var CP = 18; //  Prohibit line breaks before
  var EX = 19; //  Prohibit line breaks before
  var IN = 20; //  Allow only indirect line breaks between pairs
  var NS = 21; //  Allow only indirect line breaks before
  var OP = 22; //  Prohibit line breaks after
  var QU = 23; //  Act like they are both opening and closing
  // Numeric Context
  var IS = 24; //  Prevent breaks after any and before numeric
  var NU = 25; //  Form numeric expressions for line breaking purposes
  var PO = 26; //  Do not break following a numeric expression
  var PR = 27; //  Do not break in front of a numeric expression
  var SY = 28; //  Prevent a break before; and allow a break after
  // Other Characters
  var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
  var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
  var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
  var EB = 32; //  Do not break from following Emoji Modifier
  var EM = 33; //  Do not break from preceding Emoji Base
  var H2 = 34; //  Form Korean syllable blocks
  var H3 = 35; //  Form Korean syllable blocks
  var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
  var ID = 37; //  Break before or after; except in some numeric context
  var JL = 38; //  Form Korean syllable blocks
  var JV = 39; //  Form Korean syllable blocks
  var JT = 40; //  Form Korean syllable blocks
  var RI = 41; //  Keep pairs together. For pairs; break before and after other classes
  var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
  var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
  var ea_OP = [0x2329, 0xff08];
  var BREAK_MANDATORY = '!';
  var BREAK_NOT_ALLOWED = '×';
  var BREAK_ALLOWED = '÷';
  var UnicodeTrie = createTrieFromBase64(base64);
  var ALPHABETICS = [AL, HL];
  var HARD_LINE_BREAKS = [BK, CR, LF, NL];
  var SPACE$1 = [SP, ZW];
  var PREFIX_POSTFIX = [PR, PO];
  var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  var HYPHEN = [HY, BA];
  var codePointsToCharacterClasses = function codePointsToCharacterClasses(codePoints, lineBreak) {
    if (lineBreak === void 0) {lineBreak = 'strict';}
    var types = [];
    var indices = [];
    var categories = [];
    codePoints.forEach(function (codePoint, index) {
      var classType = UnicodeTrie.get(codePoint);
      if (classType > LETTER_NUMBER_MODIFIER) {
        categories.push(true);
        classType -= LETTER_NUMBER_MODIFIER;
      } else
      {
        categories.push(false);
      }
      if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
        // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
        if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
          indices.push(index);
          return types.push(CB);
        }
      }
      if (classType === CM || classType === ZWJ) {
        // LB10 Treat any remaining combining mark or ZWJ as AL.
        if (index === 0) {
          indices.push(index);
          return types.push(AL);
        }
        // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
        // the base character in all of the following rules. Treat ZWJ as if it were CM.
        var prev = types[index - 1];
        if (LINE_BREAKS.indexOf(prev) === -1) {
          indices.push(indices[index - 1]);
          return types.push(prev);
        }
        indices.push(index);
        return types.push(AL);
      }
      indices.push(index);
      if (classType === CJ) {
        return types.push(lineBreak === 'strict' ? NS : ID);
      }
      if (classType === SA) {
        return types.push(AL);
      }
      if (classType === AI) {
        return types.push(AL);
      }
      // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
      // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
      // to take into account the actual line breaking properties for these characters.
      if (classType === XX) {
        if (codePoint >= 0x20000 && codePoint <= 0x2fffd || codePoint >= 0x30000 && codePoint <= 0x3fffd) {
          return types.push(ID);
        } else
        {
          return types.push(AL);
        }
      }
      types.push(classType);
    });
    return [indices, types, categories];
  };
  var isAdjacentWithSpaceIgnored = function isAdjacentWithSpaceIgnored(a, b, currentIndex, classTypes) {
    var current = classTypes[currentIndex];
    if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
      var i = currentIndex;
      while (i <= classTypes.length) {
        i++;
        var next = classTypes[i];
        if (next === b) {
          return true;
        }
        if (next !== SP) {
          break;
        }
      }
    }
    if (current === SP) {
      var i = currentIndex;
      while (i > 0) {
        i--;
        var prev = classTypes[i];
        if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
          var n = currentIndex;
          while (n <= classTypes.length) {
            n++;
            var next = classTypes[n];
            if (next === b) {
              return true;
            }
            if (next !== SP) {
              break;
            }
          }
        }
        if (prev !== SP) {
          break;
        }
      }
    }
    return false;
  };
  var previousNonSpaceClassType = function previousNonSpaceClassType(currentIndex, classTypes) {
    var i = currentIndex;
    while (i >= 0) {
      var type = classTypes[i];
      if (type === SP) {
        i--;
      } else
      {
        return type;
      }
    }
    return 0;
  };
  var _lineBreakAtIndex = function _lineBreakAtIndex(codePoints, classTypes, indicies, index, forbiddenBreaks) {
    if (indicies[index] === 0) {
      return BREAK_NOT_ALLOWED;
    }
    var currentIndex = index - 1;
    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
      return BREAK_NOT_ALLOWED;
    }
    var beforeIndex = currentIndex - 1;
    var afterIndex = currentIndex + 1;
    var current = classTypes[currentIndex];
    // LB4 Always break after hard line breaks.
    // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
    var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
    var next = classTypes[afterIndex];
    if (current === CR && next === LF) {
      return BREAK_NOT_ALLOWED;
    }
    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
      return BREAK_MANDATORY;
    }
    // LB6 Do not break before hard line breaks.
    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB7 Do not break before spaces or zero width space.
    if (SPACE$1.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
      return BREAK_ALLOWED;
    }
    // LB8a Do not break after a zero width joiner.
    if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ) {
      return BREAK_NOT_ALLOWED;
    }
    // zwj emojis
    if ((current === EB || current === EM) && UnicodeTrie.get(codePoints[afterIndex]) === ZWJ) {
      return BREAK_NOT_ALLOWED;
    }
    // LB11 Do not break before or after Word joiner and related characters.
    if (current === WJ || next === WJ) {
      return BREAK_NOT_ALLOWED;
    }
    // LB12 Do not break after NBSP and related characters.
    if (current === GL) {
      return BREAK_NOT_ALLOWED;
    }
    // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
      return BREAK_NOT_ALLOWED;
    }
    // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB14 Do not break after ‘[’, even after spaces.
    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
      return BREAK_NOT_ALLOWED;
    }
    // LB15 Do not break within ‘”[’, even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED;
    }
    // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED;
    }
    // LB17 Do not break within ‘——’, even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED;
    }
    // LB18 Break after spaces.
    if (current === SP) {
      return BREAK_ALLOWED;
    }
    // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
    if (current === QU || next === QU) {
      return BREAK_NOT_ALLOWED;
    }
    // LB20 Break before and after unresolved CB.
    if (next === CB || current === CB) {
      return BREAK_ALLOWED;
    }
    // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
      return BREAK_NOT_ALLOWED;
    }
    // LB21a Don't break after Hebrew + Hyphen.
    if (before === HL && HYPHEN.indexOf(current) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB21b Don’t break between Solidus and Hebrew letters.
    if (current === SY && next === HL) {
      return BREAK_NOT_ALLOWED;
    }
    // LB22 Do not break before ellipsis.
    if (next === IN) {
      return BREAK_NOT_ALLOWED;
    }
    // LB23 Do not break between digits and letters.
    if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
      return BREAK_NOT_ALLOWED;
    }
    // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
    if (current === PR && [ID, EB, EM].indexOf(next) !== -1 ||
    [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
      return BREAK_NOT_ALLOWED;
    }
    // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
    if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 ||
    PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB25 Do not break between the following pairs of classes relevant to numbers:
    if (
    // (PR | PO) × ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (
    next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) ||
    // ( OP | HY ) × NU
    [OP, HY].indexOf(current) !== -1 && next === NU ||
    // NU ×	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
      var prevIndex = currentIndex;
      while (prevIndex >= 0) {
        var type = classTypes[prevIndex];
        if (type === NU) {
          return BREAK_NOT_ALLOWED;
        } else
        if ([SY, IS].indexOf(type) !== -1) {
          prevIndex--;
        } else
        {
          break;
        }
      }
    }
    // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
    if ([PR, PO].indexOf(next) !== -1) {
      var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
      while (prevIndex >= 0) {
        var type = classTypes[prevIndex];
        if (type === NU) {
          return BREAK_NOT_ALLOWED;
        } else
        if ([SY, IS].indexOf(type) !== -1) {
          prevIndex--;
        } else
        {
          break;
        }
      }
    }
    // LB26 Do not break a Korean syllable.
    if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 ||
    [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 ||
    [JT, H3].indexOf(current) !== -1 && next === JT) {
      return BREAK_NOT_ALLOWED;
    }
    // LB27 Treat a Korean Syllable Block the same as ID.
    if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 ||
    KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
      return BREAK_NOT_ALLOWED;
    }
    // LB28 Do not break between alphabetics (“at”).
    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
    if (ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
    next === OP &&
    ea_OP.indexOf(codePoints[afterIndex]) === -1 ||
    ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
      return BREAK_NOT_ALLOWED;
    }
    // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
    // indicators preceding the position of the break.
    if (current === RI && next === RI) {
      var i = indicies[currentIndex];
      var count = 1;
      while (i > 0) {
        i--;
        if (classTypes[i] === RI) {
          count++;
        } else
        {
          break;
        }
      }
      if (count % 2 !== 0) {
        return BREAK_NOT_ALLOWED;
      }
    }
    // LB30b Do not break between an emoji base and an emoji modifier.
    if (current === EB && next === EM) {
      return BREAK_NOT_ALLOWED;
    }
    return BREAK_ALLOWED;
  };
  var cssFormattedClasses = function cssFormattedClasses(codePoints, options) {
    if (!options) {
      options = { lineBreak: 'normal', wordBreak: 'normal' };
    }
    var _a = codePointsToCharacterClasses(codePoints, options.lineBreak),indicies = _a[0],classTypes = _a[1],isLetterNumber = _a[2];
    if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
      classTypes = classTypes.map(function (type) {return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;});
    }
    var forbiddenBreakpoints = options.wordBreak === 'keep-all' ?
    isLetterNumber.map(function (letterNumber, i) {
      return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
    }) :
    undefined;
    return [indicies, classTypes, forbiddenBreakpoints];
  };
  var Break = /** @class */function () {
    function Break(codePoints, lineBreak, start, end) {
      this.codePoints = codePoints;
      this.required = lineBreak === BREAK_MANDATORY;
      this.start = start;
      this.end = end;
    }
    Break.prototype.slice = function () {
      return fromCodePoint.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break;
  }();
  var LineBreaker = function LineBreaker(str, options) {
    var codePoints = toCodePoints(str);
    var _a = cssFormattedClasses(codePoints, options),indicies = _a[0],classTypes = _a[1],forbiddenBreakpoints = _a[2];
    var length = codePoints.length;
    var lastEnd = 0;
    var nextIndex = 0;
    return {
      next: function next() {
        if (nextIndex >= length) {
          return { done: true, value: null };
        }
        var lineBreak = BREAK_NOT_ALLOWED;
        while (nextIndex < length &&
        (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
        BREAK_NOT_ALLOWED) {}
        if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {
          var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
          lastEnd = nextIndex;
          return { value: value, done: false };
        }
        return { done: true, value: null };
      } };

  };

  // https://www.w3.org/TR/css-syntax-3
  var TokenType;
  (function (TokenType) {
    TokenType[TokenType["STRING_TOKEN"] = 0] = "STRING_TOKEN";
    TokenType[TokenType["BAD_STRING_TOKEN"] = 1] = "BAD_STRING_TOKEN";
    TokenType[TokenType["LEFT_PARENTHESIS_TOKEN"] = 2] = "LEFT_PARENTHESIS_TOKEN";
    TokenType[TokenType["RIGHT_PARENTHESIS_TOKEN"] = 3] = "RIGHT_PARENTHESIS_TOKEN";
    TokenType[TokenType["COMMA_TOKEN"] = 4] = "COMMA_TOKEN";
    TokenType[TokenType["HASH_TOKEN"] = 5] = "HASH_TOKEN";
    TokenType[TokenType["DELIM_TOKEN"] = 6] = "DELIM_TOKEN";
    TokenType[TokenType["AT_KEYWORD_TOKEN"] = 7] = "AT_KEYWORD_TOKEN";
    TokenType[TokenType["PREFIX_MATCH_TOKEN"] = 8] = "PREFIX_MATCH_TOKEN";
    TokenType[TokenType["DASH_MATCH_TOKEN"] = 9] = "DASH_MATCH_TOKEN";
    TokenType[TokenType["INCLUDE_MATCH_TOKEN"] = 10] = "INCLUDE_MATCH_TOKEN";
    TokenType[TokenType["LEFT_CURLY_BRACKET_TOKEN"] = 11] = "LEFT_CURLY_BRACKET_TOKEN";
    TokenType[TokenType["RIGHT_CURLY_BRACKET_TOKEN"] = 12] = "RIGHT_CURLY_BRACKET_TOKEN";
    TokenType[TokenType["SUFFIX_MATCH_TOKEN"] = 13] = "SUFFIX_MATCH_TOKEN";
    TokenType[TokenType["SUBSTRING_MATCH_TOKEN"] = 14] = "SUBSTRING_MATCH_TOKEN";
    TokenType[TokenType["DIMENSION_TOKEN"] = 15] = "DIMENSION_TOKEN";
    TokenType[TokenType["PERCENTAGE_TOKEN"] = 16] = "PERCENTAGE_TOKEN";
    TokenType[TokenType["NUMBER_TOKEN"] = 17] = "NUMBER_TOKEN";
    TokenType[TokenType["FUNCTION"] = 18] = "FUNCTION";
    TokenType[TokenType["FUNCTION_TOKEN"] = 19] = "FUNCTION_TOKEN";
    TokenType[TokenType["IDENT_TOKEN"] = 20] = "IDENT_TOKEN";
    TokenType[TokenType["COLUMN_TOKEN"] = 21] = "COLUMN_TOKEN";
    TokenType[TokenType["URL_TOKEN"] = 22] = "URL_TOKEN";
    TokenType[TokenType["BAD_URL_TOKEN"] = 23] = "BAD_URL_TOKEN";
    TokenType[TokenType["CDC_TOKEN"] = 24] = "CDC_TOKEN";
    TokenType[TokenType["CDO_TOKEN"] = 25] = "CDO_TOKEN";
    TokenType[TokenType["COLON_TOKEN"] = 26] = "COLON_TOKEN";
    TokenType[TokenType["SEMICOLON_TOKEN"] = 27] = "SEMICOLON_TOKEN";
    TokenType[TokenType["LEFT_SQUARE_BRACKET_TOKEN"] = 28] = "LEFT_SQUARE_BRACKET_TOKEN";
    TokenType[TokenType["RIGHT_SQUARE_BRACKET_TOKEN"] = 29] = "RIGHT_SQUARE_BRACKET_TOKEN";
    TokenType[TokenType["UNICODE_RANGE_TOKEN"] = 30] = "UNICODE_RANGE_TOKEN";
    TokenType[TokenType["WHITESPACE_TOKEN"] = 31] = "WHITESPACE_TOKEN";
    TokenType[TokenType["EOF_TOKEN"] = 32] = "EOF_TOKEN";
  })(TokenType || (TokenType = {}));
  var FLAG_UNRESTRICTED = 1 << 0;
  var FLAG_ID = 1 << 1;
  var FLAG_INTEGER = 1 << 2;
  var FLAG_NUMBER = 1 << 3;
  var LINE_FEED = 0x000a;
  var SOLIDUS = 0x002f;
  var REVERSE_SOLIDUS = 0x005c;
  var CHARACTER_TABULATION = 0x0009;
  var SPACE = 0x0020;
  var QUOTATION_MARK = 0x0022;
  var EQUALS_SIGN = 0x003d;
  var NUMBER_SIGN = 0x0023;
  var DOLLAR_SIGN = 0x0024;
  var PERCENTAGE_SIGN = 0x0025;
  var APOSTROPHE = 0x0027;
  var LEFT_PARENTHESIS = 0x0028;
  var RIGHT_PARENTHESIS = 0x0029;
  var LOW_LINE = 0x005f;
  var HYPHEN_MINUS = 0x002d;
  var EXCLAMATION_MARK = 0x0021;
  var LESS_THAN_SIGN = 0x003c;
  var GREATER_THAN_SIGN = 0x003e;
  var COMMERCIAL_AT = 0x0040;
  var LEFT_SQUARE_BRACKET = 0x005b;
  var RIGHT_SQUARE_BRACKET = 0x005d;
  var CIRCUMFLEX_ACCENT = 0x003d;
  var LEFT_CURLY_BRACKET = 0x007b;
  var QUESTION_MARK = 0x003f;
  var RIGHT_CURLY_BRACKET = 0x007d;
  var VERTICAL_LINE = 0x007c;
  var TILDE = 0x007e;
  var CONTROL = 0x0080;
  var REPLACEMENT_CHARACTER = 0xfffd;
  var ASTERISK = 0x002a;
  var PLUS_SIGN = 0x002b;
  var COMMA = 0x002c;
  var COLON = 0x003a;
  var SEMICOLON = 0x003b;
  var FULL_STOP = 0x002e;
  var NULL = 0x0000;
  var BACKSPACE = 0x0008;
  var LINE_TABULATION = 0x000b;
  var SHIFT_OUT = 0x000e;
  var INFORMATION_SEPARATOR_ONE = 0x001f;
  var DELETE = 0x007f;
  var EOF = -1;
  var ZERO = 0x0030;
  var a = 0x0061;
  var e = 0x0065;
  var f = 0x0066;
  var u = 0x0075;
  var z = 0x007a;
  var A = 0x0041;
  var E = 0x0045;
  var F = 0x0046;
  var U = 0x0055;
  var Z = 0x005a;
  var isDigit = function isDigit(codePoint) {return codePoint >= ZERO && codePoint <= 0x0039;};
  var isSurrogateCodePoint = function isSurrogateCodePoint(codePoint) {return codePoint >= 0xd800 && codePoint <= 0xdfff;};
  var isHex = function isHex(codePoint) {
    return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
  };
  var isLowerCaseLetter = function isLowerCaseLetter(codePoint) {return codePoint >= a && codePoint <= z;};
  var isUpperCaseLetter = function isUpperCaseLetter(codePoint) {return codePoint >= A && codePoint <= Z;};
  var isLetter = function isLetter(codePoint) {return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);};
  var isNonASCIICodePoint = function isNonASCIICodePoint(codePoint) {return codePoint >= CONTROL;};
  var isWhiteSpace = function isWhiteSpace(codePoint) {
    return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  };
  var isNameStartCodePoint = function isNameStartCodePoint(codePoint) {
    return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  };
  var isNameCodePoint = function isNameCodePoint(codePoint) {
    return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  };
  var isNonPrintableCodePoint = function isNonPrintableCodePoint(codePoint) {
    return codePoint >= NULL && codePoint <= BACKSPACE ||
    codePoint === LINE_TABULATION ||
    codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE ||
    codePoint === DELETE;
  };
  var isValidEscape = function isValidEscape(c1, c2) {
    if (c1 !== REVERSE_SOLIDUS) {
      return false;
    }
    return c2 !== LINE_FEED;
  };
  var isIdentifierStart = function isIdentifierStart(c1, c2, c3) {
    if (c1 === HYPHEN_MINUS) {
      return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
    } else
    if (isNameStartCodePoint(c1)) {
      return true;
    } else
    if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
      return true;
    }
    return false;
  };
  var isNumberStart = function isNumberStart(c1, c2, c3) {
    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
      if (isDigit(c2)) {
        return true;
      }
      return c2 === FULL_STOP && isDigit(c3);
    }
    if (c1 === FULL_STOP) {
      return isDigit(c2);
    }
    return isDigit(c1);
  };
  var stringToNumber = function stringToNumber(codePoints) {
    var c = 0;
    var sign = 1;
    if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
      if (codePoints[c] === HYPHEN_MINUS) {
        sign = -1;
      }
      c++;
    }
    var integers = [];
    while (isDigit(codePoints[c])) {
      integers.push(codePoints[c++]);
    }
    var int = integers.length ? parseInt(fromCodePoint.apply(void 0, integers), 10) : 0;
    if (codePoints[c] === FULL_STOP) {
      c++;
    }
    var fraction = [];
    while (isDigit(codePoints[c])) {
      fraction.push(codePoints[c++]);
    }
    var fracd = fraction.length;
    var frac = fracd ? parseInt(fromCodePoint.apply(void 0, fraction), 10) : 0;
    if (codePoints[c] === E || codePoints[c] === e) {
      c++;
    }
    var expsign = 1;
    if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
      if (codePoints[c] === HYPHEN_MINUS) {
        expsign = -1;
      }
      c++;
    }
    var exponent = [];
    while (isDigit(codePoints[c])) {
      exponent.push(codePoints[c++]);
    }
    var exp = exponent.length ? parseInt(fromCodePoint.apply(void 0, exponent), 10) : 0;
    return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  };
  var LEFT_PARENTHESIS_TOKEN = {
    type: TokenType.LEFT_PARENTHESIS_TOKEN };

  var RIGHT_PARENTHESIS_TOKEN = {
    type: TokenType.RIGHT_PARENTHESIS_TOKEN };

  var COMMA_TOKEN = { type: TokenType.COMMA_TOKEN };
  var SUFFIX_MATCH_TOKEN = { type: TokenType.SUFFIX_MATCH_TOKEN };
  var PREFIX_MATCH_TOKEN = { type: TokenType.PREFIX_MATCH_TOKEN };
  var COLUMN_TOKEN = { type: TokenType.COLUMN_TOKEN };
  var DASH_MATCH_TOKEN = { type: TokenType.DASH_MATCH_TOKEN };
  var INCLUDE_MATCH_TOKEN = { type: TokenType.INCLUDE_MATCH_TOKEN };
  var LEFT_CURLY_BRACKET_TOKEN = {
    type: TokenType.LEFT_CURLY_BRACKET_TOKEN };

  var RIGHT_CURLY_BRACKET_TOKEN = {
    type: TokenType.RIGHT_CURLY_BRACKET_TOKEN };

  var SUBSTRING_MATCH_TOKEN = { type: TokenType.SUBSTRING_MATCH_TOKEN };
  var BAD_URL_TOKEN = { type: TokenType.BAD_URL_TOKEN };
  var BAD_STRING_TOKEN = { type: TokenType.BAD_STRING_TOKEN };
  var CDO_TOKEN = { type: TokenType.CDO_TOKEN };
  var CDC_TOKEN = { type: TokenType.CDC_TOKEN };
  var COLON_TOKEN = { type: TokenType.COLON_TOKEN };
  var SEMICOLON_TOKEN = { type: TokenType.SEMICOLON_TOKEN };
  var LEFT_SQUARE_BRACKET_TOKEN = {
    type: TokenType.LEFT_SQUARE_BRACKET_TOKEN };

  var RIGHT_SQUARE_BRACKET_TOKEN = {
    type: TokenType.RIGHT_SQUARE_BRACKET_TOKEN };

  var WHITESPACE_TOKEN = { type: TokenType.WHITESPACE_TOKEN };
  var EOF_TOKEN = { type: TokenType.EOF_TOKEN };
  var Tokenizer = /** @class */function () {
    function Tokenizer() {
      this._value = [];
    }
    Tokenizer.prototype.write = function (chunk) {
      this._value = this._value.concat(toCodePoints(chunk));
    };
    Tokenizer.prototype.read = function () {
      var tokens = [];
      var token = this.consumeToken();
      while (token !== EOF_TOKEN) {
        tokens.push(token);
        token = this.consumeToken();
      }
      return tokens;
    };
    Tokenizer.prototype.consumeToken = function () {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value = this.consumeName();
            return { type: TokenType.HASH_TOKEN, value: value, flags: flags };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e2 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c = this.consumeCodePoint();
              if (c === ASTERISK) {
                c = this.consumeCodePoint();
                if (c === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
          this.peekCodePoint(1) === HYPHEN_MINUS &&
          this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value = this.consumeName();
            return { type: TokenType.AT_KEYWORD_TOKEN, value: value };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u:
        case U:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;}

      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: TokenType.DELIM_TOKEN, value: fromCodePoint(codePoint) };
    };
    Tokenizer.prototype.consumeCodePoint = function () {
      var value = this._value.shift();
      return typeof value === 'undefined' ? -1 : value;
    };
    Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer.prototype.peekCodePoint = function (delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer.prototype.consumeUnicodeRangeToken = function () {
      var digits = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) {return digit === QUESTION_MARK ? ZERO : digit;})), 16);
        var end = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) {return digit === QUESTION_MARK ? F : digit;})), 16);
        return { type: TokenType.UNICODE_RANGE_TOKEN, start: start_1, end: end };
      }
      var start = parseInt(fromCodePoint.apply(void 0, digits), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end = parseInt(fromCodePoint.apply(void 0, endDigits), 16);
        return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: end };
      } else
      {
        return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: start };
      }
    };
    Tokenizer.prototype.consumeIdentLikeToken = function () {
      var value = this.consumeName();
      if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else
      if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: TokenType.FUNCTION_TOKEN, value: value };
      }
      return { type: TokenType.IDENT_TOKEN, value: value };
    };
    Tokenizer.prototype.consumeUrlToken = function () {
      var value = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: TokenType.URL_TOKEN, value: '' };
      }
      var next = this.peekCodePoint(0);
      if (next === APOSTROPHE || next === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === TokenType.STRING_TOKEN) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: TokenType.URL_TOKEN, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
        } else
        if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else
        if (codePoint === QUOTATION_MARK ||
        codePoint === APOSTROPHE ||
        codePoint === LEFT_PARENTHESIS ||
        isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else
        if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value.push(this.consumeEscapedCodePoint());
          } else
          {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else
        {
          value.push(codePoint);
        }
      }
    };
    Tokenizer.prototype.consumeWhiteSpace = function () {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer.prototype.consumeBadUrlRemnants = function () {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer.prototype.consumeStringSlice = function (count) {
      var SLICE_STACK_SIZE = 60000;
      var value = '';
      while (count > 0) {
        var amount = Math.min(SLICE_STACK_SIZE, count);
        value += fromCodePoint.apply(void 0, this._value.splice(0, amount));
        count -= amount;
      }
      this._value.shift();
      return value;
    };
    Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
      var value = '';
      var i = 0;
      do {
        var codePoint = this._value[i];
        if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
          value += this.consumeStringSlice(i);
          return { type: TokenType.STRING_TOKEN, value: value };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next = this._value[i + 1];
          if (next !== EOF && next !== undefined) {
            if (next === LINE_FEED) {
              value += this.consumeStringSlice(i);
              i = -1;
              this._value.shift();
            } else
            if (isValidEscape(codePoint, next)) {
              value += this.consumeStringSlice(i);
              value += fromCodePoint(this.consumeEscapedCodePoint());
              i = -1;
            }
          }
        }
        i++;
      } while (true);
    };
    Tokenizer.prototype.consumeNumber = function () {
      var repr = [];
      var type = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type];
    };
    Tokenizer.prototype.consumeNumericToken = function () {
      var _a = this.consumeNumber(),number = _a[0],flags = _a[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: TokenType.DIMENSION_TOKEN, number: number, flags: flags, unit: unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: TokenType.PERCENTAGE_TOKEN, number: number, flags: flags };
      }
      return { type: TokenType.NUMBER_TOKEN, number: number, flags: flags };
    };
    Tokenizer.prototype.consumeEscapedCodePoint = function () {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex = fromCodePoint(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
          hex += fromCodePoint(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer.prototype.consumeName = function () {
      var result = '';
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint(codePoint);
        } else
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint(this.consumeEscapedCodePoint());
        } else
        {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer;
  }();

  var Parser = /** @class */function () {
    function Parser(tokens) {
      this._tokens = tokens;
    }
    Parser.create = function (value) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value);
      return new Parser(tokenizer.read());
    };
    Parser.parseValue = function (value) {
      return Parser.create(value).parseComponentValue();
    };
    Parser.parseValues = function (value) {
      return Parser.create(value).parseComponentValues();
    };
    Parser.prototype.parseComponentValue = function () {
      var token = this.consumeToken();
      while (token.type === TokenType.WHITESPACE_TOKEN) {
        token = this.consumeToken();
      }
      if (token.type === TokenType.EOF_TOKEN) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token);
      var value = this.consumeComponentValue();
      do {
        token = this.consumeToken();
      } while (token.type === TokenType.WHITESPACE_TOKEN);
      if (token.type === TokenType.EOF_TOKEN) {
        return value;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser.prototype.parseComponentValues = function () {
      var values = [];
      while (true) {
        var value = this.consumeComponentValue();
        if (value.type === TokenType.EOF_TOKEN) {
          return values;
        }
        values.push(value);
        values.push();
      }
    };
    Parser.prototype.consumeComponentValue = function () {
      var token = this.consumeToken();
      switch (token.type) {
        case TokenType.LEFT_CURLY_BRACKET_TOKEN:
        case TokenType.LEFT_SQUARE_BRACKET_TOKEN:
        case TokenType.LEFT_PARENTHESIS_TOKEN:
          return this.consumeSimpleBlock(token.type);
        case TokenType.FUNCTION_TOKEN:
          return this.consumeFunction(token);}

      return token;
    };
    Parser.prototype.consumeSimpleBlock = function (type) {
      var block = { type: type, values: [] };
      var token = this.consumeToken();
      while (true) {
        if (token.type === TokenType.EOF_TOKEN || isEndingTokenFor(token, type)) {
          return block;
        }
        this.reconsumeToken(token);
        block.values.push(this.consumeComponentValue());
        token = this.consumeToken();
      }
    };
    Parser.prototype.consumeFunction = function (functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: TokenType.FUNCTION };

      while (true) {
        var token = this.consumeToken();
        if (token.type === TokenType.EOF_TOKEN || token.type === TokenType.RIGHT_PARENTHESIS_TOKEN) {
          return cssFunction;
        }
        this.reconsumeToken(token);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser.prototype.consumeToken = function () {
      var token = this._tokens.shift();
      return typeof token === 'undefined' ? EOF_TOKEN : token;
    };
    Parser.prototype.reconsumeToken = function (token) {
      this._tokens.unshift(token);
    };
    return Parser;
  }();
  var isDimensionToken = function isDimensionToken(token) {return token.type === TokenType.DIMENSION_TOKEN;};
  var isNumberToken = function isNumberToken(token) {return token.type === TokenType.NUMBER_TOKEN;};
  var isIdentToken = function isIdentToken(token) {return token.type === TokenType.IDENT_TOKEN;};
  var isStringToken = function isStringToken(token) {return token.type === TokenType.STRING_TOKEN;};
  var isIdentWithValue = function isIdentWithValue(token, value) {
    return isIdentToken(token) && token.value === value;
  };
  var nonWhiteSpace = function nonWhiteSpace(token) {return token.type !== TokenType.WHITESPACE_TOKEN;};
  var nonFunctionArgSeparator = function nonFunctionArgSeparator(token) {
    return token.type !== TokenType.WHITESPACE_TOKEN && token.type !== TokenType.COMMA_TOKEN;
  };
  var parseFunctionArgs = function parseFunctionArgs(tokens) {
    var args = [];
    var arg = [];
    tokens.forEach(function (token) {
      if (token.type === TokenType.COMMA_TOKEN) {
        if (arg.length === 0) {
          throw new Error("Error parsing function args, zero tokens for arg");
        }
        args.push(arg);
        arg = [];
        return;
      }
      if (token.type !== TokenType.WHITESPACE_TOKEN) {
        arg.push(token);
      }
    });
    if (arg.length) {
      args.push(arg);
    }
    return args;
  };
  var isEndingTokenFor = function isEndingTokenFor(token, type) {
    if (type === TokenType.LEFT_CURLY_BRACKET_TOKEN && token.type === TokenType.RIGHT_CURLY_BRACKET_TOKEN) {
      return true;
    }
    if (type === TokenType.LEFT_SQUARE_BRACKET_TOKEN && token.type === TokenType.RIGHT_SQUARE_BRACKET_TOKEN) {
      return true;
    }
    return type === TokenType.LEFT_PARENTHESIS_TOKEN && token.type === TokenType.RIGHT_PARENTHESIS_TOKEN;
  };

  var isLength = function isLength(token) {
    return token.type === TokenType.NUMBER_TOKEN || token.type === TokenType.DIMENSION_TOKEN;
  };

  var isLengthPercentage = function isLengthPercentage(token) {
    return token.type === TokenType.PERCENTAGE_TOKEN || isLength(token);
  };
  var parseLengthPercentageTuple = function parseLengthPercentageTuple(tokens) {
    return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  };
  var ZERO_LENGTH = {
    type: TokenType.NUMBER_TOKEN,
    number: 0,
    flags: FLAG_INTEGER };

  var FIFTY_PERCENT = {
    type: TokenType.PERCENTAGE_TOKEN,
    number: 50,
    flags: FLAG_INTEGER };

  var HUNDRED_PERCENT = {
    type: TokenType.PERCENTAGE_TOKEN,
    number: 100,
    flags: FLAG_INTEGER };

  var getAbsoluteValueForTuple = function getAbsoluteValueForTuple(tuple, width, height) {
    var x = tuple[0],y = tuple[1];
    return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
  };
  var getAbsoluteValue = function getAbsoluteValue(token, parent) {
    if (token.type === TokenType.PERCENTAGE_TOKEN) {
      return token.number / 100 * parent;
    }
    if (isDimensionToken(token)) {
      switch (token.unit) {
        case 'rem':
        case 'em':
          return 16 * token.number; // TODO use correct font-size
        case 'px':
        default:
          return token.number;}

    }
    return token.number;
  };

  var DEG = 'deg';
  var GRAD = 'grad';
  var RAD = 'rad';
  var TURN = 'turn';
  var angle = {
    name: 'angle',
    parse: function parse(_context, value) {
      if (value.type === TokenType.DIMENSION_TOKEN) {
        switch (value.unit) {
          case DEG:
            return Math.PI * value.number / 180;
          case GRAD:
            return Math.PI / 200 * value.number;
          case RAD:
            return value.number;
          case TURN:
            return Math.PI * 2 * value.number;}

      }
      throw new Error("Unsupported angle type");
    } };

  var isAngle = function isAngle(value) {
    if (value.type === TokenType.DIMENSION_TOKEN) {
      if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
        return true;
      }
    }
    return false;
  };
  var parseNamedSide = function parseNamedSide(tokens) {
    var sideOrCorner = tokens.
    filter(isIdentToken).
    map(function (ident) {return ident.value;}).
    join(' ');
    switch (sideOrCorner) {
      case 'to bottom right':
      case 'to right bottom':
      case 'left top':
      case 'top left':
        return [ZERO_LENGTH, ZERO_LENGTH];
      case 'to top':
      case 'bottom':
        return deg(0);
      case 'to bottom left':
      case 'to left bottom':
      case 'right top':
      case 'top right':
        return [ZERO_LENGTH, HUNDRED_PERCENT];
      case 'to right':
      case 'left':
        return deg(90);
      case 'to top left':
      case 'to left top':
      case 'right bottom':
      case 'bottom right':
        return [HUNDRED_PERCENT, HUNDRED_PERCENT];
      case 'to bottom':
      case 'top':
        return deg(180);
      case 'to top right':
      case 'to right top':
      case 'left bottom':
      case 'bottom left':
        return [HUNDRED_PERCENT, ZERO_LENGTH];
      case 'to left':
      case 'right':
        return deg(270);}

    return 0;
  };
  var deg = function deg(_deg) {return Math.PI * _deg / 180;};

  var color$1 = {
    name: 'color',
    parse: function parse(context, value) {
      if (value.type === TokenType.FUNCTION) {
        var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
        if (typeof colorFunction === 'undefined') {
          throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
        }
        return colorFunction(context, value.values);
      }
      if (value.type === TokenType.HASH_TOKEN) {
        if (value.value.length === 3) {
          var r = value.value.substring(0, 1);
          var g = value.value.substring(1, 2);
          var b = value.value.substring(2, 3);
          return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
        }
        if (value.value.length === 4) {
          var r = value.value.substring(0, 1);
          var g = value.value.substring(1, 2);
          var b = value.value.substring(2, 3);
          var a = value.value.substring(3, 4);
          return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
        }
        if (value.value.length === 6) {
          var r = value.value.substring(0, 2);
          var g = value.value.substring(2, 4);
          var b = value.value.substring(4, 6);
          return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
        }
        if (value.value.length === 8) {
          var r = value.value.substring(0, 2);
          var g = value.value.substring(2, 4);
          var b = value.value.substring(4, 6);
          var a = value.value.substring(6, 8);
          return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
        }
      }
      if (value.type === TokenType.IDENT_TOKEN) {
        var namedColor = COLORS[value.value.toUpperCase()];
        if (typeof namedColor !== 'undefined') {
          return namedColor;
        }
      }
      return COLORS.TRANSPARENT;
    } };

  var isTransparent = function isTransparent(color) {return (0xff & color) === 0;};
  var asString = function asString(color) {
    var alpha = 0xff & color;
    var blue = 0xff & color >> 8;
    var green = 0xff & color >> 16;
    var red = 0xff & color >> 24;
    return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  };
  var pack = function pack(r, g, b, a) {
    return (r << 24 | g << 16 | b << 8 | Math.round(a * 255) << 0) >>> 0;
  };
  var getTokenColorValue = function getTokenColorValue(token, i) {
    if (token.type === TokenType.NUMBER_TOKEN) {
      return token.number;
    }
    if (token.type === TokenType.PERCENTAGE_TOKEN) {
      var max = i === 3 ? 1 : 255;
      return i === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
    }
    return 0;
  };
  var rgb = function rgb(_context, args) {
    var tokens = args.filter(nonFunctionArgSeparator);
    if (tokens.length === 3) {
      var _a = tokens.map(getTokenColorValue),r = _a[0],g = _a[1],b = _a[2];
      return pack(r, g, b, 1);
    }
    if (tokens.length === 4) {
      var _b = tokens.map(getTokenColorValue),r = _b[0],g = _b[1],b = _b[2],a = _b[3];
      return pack(r, g, b, a);
    }
    return 0;
  };
  function hue2rgb(t1, t2, hue) {
    if (hue < 0) {
      hue += 1;
    }
    if (hue >= 1) {
      hue -= 1;
    }
    if (hue < 1 / 6) {
      return (t2 - t1) * hue * 6 + t1;
    } else
    if (hue < 1 / 2) {
      return t2;
    } else
    if (hue < 2 / 3) {
      return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
    } else
    {
      return t1;
    }
  }
  var hsl = function hsl(context, args) {
    var tokens = args.filter(nonFunctionArgSeparator);
    var hue = tokens[0],saturation = tokens[1],lightness = tokens[2],alpha = tokens[3];
    var h = (hue.type === TokenType.NUMBER_TOKEN ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
    var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
    var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
    var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
    if (s === 0) {
      return pack(l * 255, l * 255, l * 255, 1);
    }
    var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var t1 = l * 2 - t2;
    var r = hue2rgb(t1, t2, h + 1 / 3);
    var g = hue2rgb(t1, t2, h);
    var b = hue2rgb(t1, t2, h - 1 / 3);
    return pack(r * 255, g * 255, b * 255, a);
  };
  var SUPPORTED_COLOR_FUNCTIONS = {
    hsl: hsl,
    hsla: hsl,
    rgb: rgb,
    rgba: rgb };

  var parseColor = function parseColor(context, value) {
    return color$1.parse(context, Parser.create(value).parseComponentValue());
  };
  var COLORS = {
    ALICEBLUE: 0xf0f8ffff,
    ANTIQUEWHITE: 0xfaebd7ff,
    AQUA: 0x00ffffff,
    AQUAMARINE: 0x7fffd4ff,
    AZURE: 0xf0ffffff,
    BEIGE: 0xf5f5dcff,
    BISQUE: 0xffe4c4ff,
    BLACK: 0x000000ff,
    BLANCHEDALMOND: 0xffebcdff,
    BLUE: 0x0000ffff,
    BLUEVIOLET: 0x8a2be2ff,
    BROWN: 0xa52a2aff,
    BURLYWOOD: 0xdeb887ff,
    CADETBLUE: 0x5f9ea0ff,
    CHARTREUSE: 0x7fff00ff,
    CHOCOLATE: 0xd2691eff,
    CORAL: 0xff7f50ff,
    CORNFLOWERBLUE: 0x6495edff,
    CORNSILK: 0xfff8dcff,
    CRIMSON: 0xdc143cff,
    CYAN: 0x00ffffff,
    DARKBLUE: 0x00008bff,
    DARKCYAN: 0x008b8bff,
    DARKGOLDENROD: 0xb886bbff,
    DARKGRAY: 0xa9a9a9ff,
    DARKGREEN: 0x006400ff,
    DARKGREY: 0xa9a9a9ff,
    DARKKHAKI: 0xbdb76bff,
    DARKMAGENTA: 0x8b008bff,
    DARKOLIVEGREEN: 0x556b2fff,
    DARKORANGE: 0xff8c00ff,
    DARKORCHID: 0x9932ccff,
    DARKRED: 0x8b0000ff,
    DARKSALMON: 0xe9967aff,
    DARKSEAGREEN: 0x8fbc8fff,
    DARKSLATEBLUE: 0x483d8bff,
    DARKSLATEGRAY: 0x2f4f4fff,
    DARKSLATEGREY: 0x2f4f4fff,
    DARKTURQUOISE: 0x00ced1ff,
    DARKVIOLET: 0x9400d3ff,
    DEEPPINK: 0xff1493ff,
    DEEPSKYBLUE: 0x00bfffff,
    DIMGRAY: 0x696969ff,
    DIMGREY: 0x696969ff,
    DODGERBLUE: 0x1e90ffff,
    FIREBRICK: 0xb22222ff,
    FLORALWHITE: 0xfffaf0ff,
    FORESTGREEN: 0x228b22ff,
    FUCHSIA: 0xff00ffff,
    GAINSBORO: 0xdcdcdcff,
    GHOSTWHITE: 0xf8f8ffff,
    GOLD: 0xffd700ff,
    GOLDENROD: 0xdaa520ff,
    GRAY: 0x808080ff,
    GREEN: 0x008000ff,
    GREENYELLOW: 0xadff2fff,
    GREY: 0x808080ff,
    HONEYDEW: 0xf0fff0ff,
    HOTPINK: 0xff69b4ff,
    INDIANRED: 0xcd5c5cff,
    INDIGO: 0x4b0082ff,
    IVORY: 0xfffff0ff,
    KHAKI: 0xf0e68cff,
    LAVENDER: 0xe6e6faff,
    LAVENDERBLUSH: 0xfff0f5ff,
    LAWNGREEN: 0x7cfc00ff,
    LEMONCHIFFON: 0xfffacdff,
    LIGHTBLUE: 0xadd8e6ff,
    LIGHTCORAL: 0xf08080ff,
    LIGHTCYAN: 0xe0ffffff,
    LIGHTGOLDENRODYELLOW: 0xfafad2ff,
    LIGHTGRAY: 0xd3d3d3ff,
    LIGHTGREEN: 0x90ee90ff,
    LIGHTGREY: 0xd3d3d3ff,
    LIGHTPINK: 0xffb6c1ff,
    LIGHTSALMON: 0xffa07aff,
    LIGHTSEAGREEN: 0x20b2aaff,
    LIGHTSKYBLUE: 0x87cefaff,
    LIGHTSLATEGRAY: 0x778899ff,
    LIGHTSLATEGREY: 0x778899ff,
    LIGHTSTEELBLUE: 0xb0c4deff,
    LIGHTYELLOW: 0xffffe0ff,
    LIME: 0x00ff00ff,
    LIMEGREEN: 0x32cd32ff,
    LINEN: 0xfaf0e6ff,
    MAGENTA: 0xff00ffff,
    MAROON: 0x800000ff,
    MEDIUMAQUAMARINE: 0x66cdaaff,
    MEDIUMBLUE: 0x0000cdff,
    MEDIUMORCHID: 0xba55d3ff,
    MEDIUMPURPLE: 0x9370dbff,
    MEDIUMSEAGREEN: 0x3cb371ff,
    MEDIUMSLATEBLUE: 0x7b68eeff,
    MEDIUMSPRINGGREEN: 0x00fa9aff,
    MEDIUMTURQUOISE: 0x48d1ccff,
    MEDIUMVIOLETRED: 0xc71585ff,
    MIDNIGHTBLUE: 0x191970ff,
    MINTCREAM: 0xf5fffaff,
    MISTYROSE: 0xffe4e1ff,
    MOCCASIN: 0xffe4b5ff,
    NAVAJOWHITE: 0xffdeadff,
    NAVY: 0x000080ff,
    OLDLACE: 0xfdf5e6ff,
    OLIVE: 0x808000ff,
    OLIVEDRAB: 0x6b8e23ff,
    ORANGE: 0xffa500ff,
    ORANGERED: 0xff4500ff,
    ORCHID: 0xda70d6ff,
    PALEGOLDENROD: 0xeee8aaff,
    PALEGREEN: 0x98fb98ff,
    PALETURQUOISE: 0xafeeeeff,
    PALEVIOLETRED: 0xdb7093ff,
    PAPAYAWHIP: 0xffefd5ff,
    PEACHPUFF: 0xffdab9ff,
    PERU: 0xcd853fff,
    PINK: 0xffc0cbff,
    PLUM: 0xdda0ddff,
    POWDERBLUE: 0xb0e0e6ff,
    PURPLE: 0x800080ff,
    REBECCAPURPLE: 0x663399ff,
    RED: 0xff0000ff,
    ROSYBROWN: 0xbc8f8fff,
    ROYALBLUE: 0x4169e1ff,
    SADDLEBROWN: 0x8b4513ff,
    SALMON: 0xfa8072ff,
    SANDYBROWN: 0xf4a460ff,
    SEAGREEN: 0x2e8b57ff,
    SEASHELL: 0xfff5eeff,
    SIENNA: 0xa0522dff,
    SILVER: 0xc0c0c0ff,
    SKYBLUE: 0x87ceebff,
    SLATEBLUE: 0x6a5acdff,
    SLATEGRAY: 0x708090ff,
    SLATEGREY: 0x708090ff,
    SNOW: 0xfffafaff,
    SPRINGGREEN: 0x00ff7fff,
    STEELBLUE: 0x4682b4ff,
    TAN: 0xd2b48cff,
    TEAL: 0x008080ff,
    THISTLE: 0xd8bfd8ff,
    TOMATO: 0xff6347ff,
    TRANSPARENT: 0x00000000,
    TURQUOISE: 0x40e0d0ff,
    VIOLET: 0xee82eeff,
    WHEAT: 0xf5deb3ff,
    WHITE: 0xffffffff,
    WHITESMOKE: 0xf5f5f5ff,
    YELLOW: 0xffff00ff,
    YELLOWGREEN: 0x9acd32ff };


  var PropertyDescriptorParsingType;
  (function (PropertyDescriptorParsingType) {
    PropertyDescriptorParsingType[PropertyDescriptorParsingType["VALUE"] = 0] = "VALUE";
    PropertyDescriptorParsingType[PropertyDescriptorParsingType["LIST"] = 1] = "LIST";
    PropertyDescriptorParsingType[PropertyDescriptorParsingType["IDENT_VALUE"] = 2] = "IDENT_VALUE";
    PropertyDescriptorParsingType[PropertyDescriptorParsingType["TYPE_VALUE"] = 3] = "TYPE_VALUE";
    PropertyDescriptorParsingType[PropertyDescriptorParsingType["TOKEN_VALUE"] = 4] = "TOKEN_VALUE";
  })(PropertyDescriptorParsingType || (PropertyDescriptorParsingType = {}));

  var BACKGROUND_CLIP;
  (function (BACKGROUND_CLIP) {
    BACKGROUND_CLIP[BACKGROUND_CLIP["BORDER_BOX"] = 0] = "BORDER_BOX";
    BACKGROUND_CLIP[BACKGROUND_CLIP["PADDING_BOX"] = 1] = "PADDING_BOX";
    BACKGROUND_CLIP[BACKGROUND_CLIP["CONTENT_BOX"] = 2] = "CONTENT_BOX";
  })(BACKGROUND_CLIP || (BACKGROUND_CLIP = {}));
  var backgroundClip = {
    name: 'background-clip',
    initialValue: 'border-box',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return tokens.map(function (token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case 'padding-box':
              return BACKGROUND_CLIP.PADDING_BOX;
            case 'content-box':
              return BACKGROUND_CLIP.CONTENT_BOX;}

        }
        return BACKGROUND_CLIP.BORDER_BOX;
      });
    } };


  var backgroundColor = {
    name: "background-color",
    initialValue: 'transparent',
    prefix: false,
    type: PropertyDescriptorParsingType.TYPE_VALUE,
    format: 'color' };


  var parseColorStop = function parseColorStop(context, args) {
    var color = color$1.parse(context, args[0]);
    var stop = args[1];
    return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
  };
  var processColorStops = function processColorStops(stops, lineLength) {
    var first = stops[0];
    var last = stops[stops.length - 1];
    if (first.stop === null) {
      first.stop = ZERO_LENGTH;
    }
    if (last.stop === null) {
      last.stop = HUNDRED_PERCENT;
    }
    var processStops = [];
    var previous = 0;
    for (var i = 0; i < stops.length; i++) {
      var stop_1 = stops[i].stop;
      if (stop_1 !== null) {
        var absoluteValue = getAbsoluteValue(stop_1, lineLength);
        if (absoluteValue > previous) {
          processStops.push(absoluteValue);
        } else
        {
          processStops.push(previous);
        }
        previous = absoluteValue;
      } else
      {
        processStops.push(null);
      }
    }
    var gapBegin = null;
    for (var i = 0; i < processStops.length; i++) {
      var stop_2 = processStops[i];
      if (stop_2 === null) {
        if (gapBegin === null) {
          gapBegin = i;
        }
      } else
      if (gapBegin !== null) {
        var gapLength = i - gapBegin;
        var beforeGap = processStops[gapBegin - 1];
        var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
        for (var g = 1; g <= gapLength; g++) {
          processStops[gapBegin + g - 1] = gapValue * g;
        }
        gapBegin = null;
      }
    }
    return stops.map(function (_a, i) {
      var color = _a.color;
      return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
    });
  };
  var getAngleFromCorner = function getAngleFromCorner(corner, width, height) {
    var centerX = width / 2;
    var centerY = height / 2;
    var x = getAbsoluteValue(corner[0], width) - centerX;
    var y = centerY - getAbsoluteValue(corner[1], height);
    return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
  };
  var calculateGradientDirection = function calculateGradientDirection(angle, width, height) {
    var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfLineLength = lineLength / 2;
    var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
    var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
    return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  };
  var distance = function distance(a, b) {return Math.sqrt(a * a + b * b);};
  var findCorner = function findCorner(width, height, x, y, closest) {
    var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]];

    return corners.reduce(function (stat, corner) {
      var cx = corner[0],cy = corner[1];
      var d = distance(x - cx, y - cy);
      if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
        return {
          optimumCorner: corner,
          optimumDistance: d };

      }
      return stat;
    }, {
      optimumDistance: closest ? Infinity : -Infinity,
      optimumCorner: null }).
    optimumCorner;
  };
  var calculateRadius = function calculateRadius(gradient, x, y, width, height) {
    var rx = 0;
    var ry = 0;
    switch (gradient.size) {
      case CSSRadialExtent.CLOSEST_SIDE:
        // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
        // If the shape is an ellipse, it exactly meets the closest side in each dimension.
        if (gradient.shape === CSSRadialShape.CIRCLE) {
          rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
        } else
        if (gradient.shape === CSSRadialShape.ELLIPSE) {
          rx = Math.min(Math.abs(x), Math.abs(x - width));
          ry = Math.min(Math.abs(y), Math.abs(y - height));
        }
        break;
      case CSSRadialExtent.CLOSEST_CORNER:
        // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
        // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
        if (gradient.shape === CSSRadialShape.CIRCLE) {
          rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
        } else
        if (gradient.shape === CSSRadialShape.ELLIPSE) {
          // Compute the ratio ry/rx (which is to be the same as for "closest-side")
          var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
          var _a = findCorner(width, height, x, y, true),cx = _a[0],cy = _a[1];
          rx = distance(cx - x, (cy - y) / c);
          ry = c * rx;
        }
        break;
      case CSSRadialExtent.FARTHEST_SIDE:
        // Same as closest-side, except the ending shape is sized based on the farthest side(s)
        if (gradient.shape === CSSRadialShape.CIRCLE) {
          rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
        } else
        if (gradient.shape === CSSRadialShape.ELLIPSE) {
          rx = Math.max(Math.abs(x), Math.abs(x - width));
          ry = Math.max(Math.abs(y), Math.abs(y - height));
        }
        break;
      case CSSRadialExtent.FARTHEST_CORNER:
        // Same as closest-corner, except the ending shape is sized based on the farthest corner.
        // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
        if (gradient.shape === CSSRadialShape.CIRCLE) {
          rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
        } else
        if (gradient.shape === CSSRadialShape.ELLIPSE) {
          // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
          var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
          var _b = findCorner(width, height, x, y, false),cx = _b[0],cy = _b[1];
          rx = distance(cx - x, (cy - y) / c);
          ry = c * rx;
        }
        break;}

    if (Array.isArray(gradient.size)) {
      rx = getAbsoluteValue(gradient.size[0], width);
      ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
    }
    return [rx, ry];
  };

  var linearGradient = function linearGradient(context, tokens) {
    var angle$1 = deg(180);
    var stops = [];
    parseFunctionArgs(tokens).forEach(function (arg, i) {
      if (i === 0) {
        var firstToken = arg[0];
        if (firstToken.type === TokenType.IDENT_TOKEN && firstToken.value === 'to') {
          angle$1 = parseNamedSide(arg);
          return;
        } else
        if (isAngle(firstToken)) {
          angle$1 = angle.parse(context, firstToken);
          return;
        }
      }
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    });
    return { angle: angle$1, stops: stops, type: CSSImageType.LINEAR_GRADIENT };
  };

  var prefixLinearGradient = function prefixLinearGradient(context, tokens) {
    var angle$1 = deg(180);
    var stops = [];
    parseFunctionArgs(tokens).forEach(function (arg, i) {
      if (i === 0) {
        var firstToken = arg[0];
        if (firstToken.type === TokenType.IDENT_TOKEN &&
        ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
          angle$1 = parseNamedSide(arg);
          return;
        } else
        if (isAngle(firstToken)) {
          angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
          return;
        }
      }
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    });
    return {
      angle: angle$1,
      stops: stops,
      type: CSSImageType.LINEAR_GRADIENT };

  };

  var webkitGradient = function webkitGradient(context, tokens) {
    var angle = deg(180);
    var stops = [];
    var type = CSSImageType.LINEAR_GRADIENT;
    var shape = CSSRadialShape.CIRCLE;
    var size = CSSRadialExtent.FARTHEST_CORNER;
    var position = [];
    parseFunctionArgs(tokens).forEach(function (arg, i) {
      var firstToken = arg[0];
      if (i === 0) {
        if (isIdentToken(firstToken) && firstToken.value === 'linear') {
          type = CSSImageType.LINEAR_GRADIENT;
          return;
        } else
        if (isIdentToken(firstToken) && firstToken.value === 'radial') {
          type = CSSImageType.RADIAL_GRADIENT;
          return;
        }
      }
      if (firstToken.type === TokenType.FUNCTION) {
        if (firstToken.name === 'from') {
          var color = color$1.parse(context, firstToken.values[0]);
          stops.push({ stop: ZERO_LENGTH, color: color });
        } else
        if (firstToken.name === 'to') {
          var color = color$1.parse(context, firstToken.values[0]);
          stops.push({ stop: HUNDRED_PERCENT, color: color });
        } else
        if (firstToken.name === 'color-stop') {
          var values = firstToken.values.filter(nonFunctionArgSeparator);
          if (values.length === 2) {
            var color = color$1.parse(context, values[1]);
            var stop_1 = values[0];
            if (isNumberToken(stop_1)) {
              stops.push({
                stop: { type: TokenType.PERCENTAGE_TOKEN, number: stop_1.number * 100, flags: stop_1.flags },
                color: color });

            }
          }
        }
      }
    });
    return type === CSSImageType.LINEAR_GRADIENT ?
    {
      angle: (angle + deg(180)) % deg(360),
      stops: stops,
      type: type } :

    { size: size, shape: shape, stops: stops, position: position, type: type };
  };

  var CLOSEST_SIDE = 'closest-side';
  var FARTHEST_SIDE = 'farthest-side';
  var CLOSEST_CORNER = 'closest-corner';
  var FARTHEST_CORNER = 'farthest-corner';
  var CIRCLE = 'circle';
  var ELLIPSE = 'ellipse';
  var COVER = 'cover';
  var CONTAIN = 'contain';
  var radialGradient = function radialGradient(context, tokens) {
    var shape = CSSRadialShape.CIRCLE;
    var size = CSSRadialExtent.FARTHEST_CORNER;
    var stops = [];
    var position = [];
    parseFunctionArgs(tokens).forEach(function (arg, i) {
      var isColorStop = true;
      if (i === 0) {
        var isAtPosition_1 = false;
        isColorStop = arg.reduce(function (acc, token) {
          if (isAtPosition_1) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case 'center':
                  position.push(FIFTY_PERCENT);
                  return acc;
                case 'top':
                case 'left':
                  position.push(ZERO_LENGTH);
                  return acc;
                case 'right':
                case 'bottom':
                  position.push(HUNDRED_PERCENT);
                  return acc;}

            } else
            if (isLengthPercentage(token) || isLength(token)) {
              position.push(token);
            }
          } else
          if (isIdentToken(token)) {
            switch (token.value) {
              case CIRCLE:
                shape = CSSRadialShape.CIRCLE;
                return false;
              case ELLIPSE:
                shape = CSSRadialShape.ELLIPSE;
                return false;
              case 'at':
                isAtPosition_1 = true;
                return false;
              case CLOSEST_SIDE:
                size = CSSRadialExtent.CLOSEST_SIDE;
                return false;
              case COVER:
              case FARTHEST_SIDE:
                size = CSSRadialExtent.FARTHEST_SIDE;
                return false;
              case CONTAIN:
              case CLOSEST_CORNER:
                size = CSSRadialExtent.CLOSEST_CORNER;
                return false;
              case FARTHEST_CORNER:
                size = CSSRadialExtent.FARTHEST_CORNER;
                return false;}

          } else
          if (isLength(token) || isLengthPercentage(token)) {
            if (!Array.isArray(size)) {
              size = [];
            }
            size.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      }
      if (isColorStop) {
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      }
    });
    return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
  };

  var prefixRadialGradient = function prefixRadialGradient(context, tokens) {
    var shape = CSSRadialShape.CIRCLE;
    var size = CSSRadialExtent.FARTHEST_CORNER;
    var stops = [];
    var position = [];
    parseFunctionArgs(tokens).forEach(function (arg, i) {
      var isColorStop = true;
      if (i === 0) {
        isColorStop = arg.reduce(function (acc, token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case 'center':
                position.push(FIFTY_PERCENT);
                return false;
              case 'top':
              case 'left':
                position.push(ZERO_LENGTH);
                return false;
              case 'right':
              case 'bottom':
                position.push(HUNDRED_PERCENT);
                return false;}

          } else
          if (isLengthPercentage(token) || isLength(token)) {
            position.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      } else
      if (i === 1) {
        isColorStop = arg.reduce(function (acc, token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case CIRCLE:
                shape = CSSRadialShape.CIRCLE;
                return false;
              case ELLIPSE:
                shape = CSSRadialShape.ELLIPSE;
                return false;
              case CONTAIN:
              case CLOSEST_SIDE:
                size = CSSRadialExtent.CLOSEST_SIDE;
                return false;
              case FARTHEST_SIDE:
                size = CSSRadialExtent.FARTHEST_SIDE;
                return false;
              case CLOSEST_CORNER:
                size = CSSRadialExtent.CLOSEST_CORNER;
                return false;
              case COVER:
              case FARTHEST_CORNER:
                size = CSSRadialExtent.FARTHEST_CORNER;
                return false;}

          } else
          if (isLength(token) || isLengthPercentage(token)) {
            if (!Array.isArray(size)) {
              size = [];
            }
            size.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      }
      if (isColorStop) {
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      }
    });
    return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
  };

  var CSSImageType;
  (function (CSSImageType) {
    CSSImageType[CSSImageType["URL"] = 0] = "URL";
    CSSImageType[CSSImageType["LINEAR_GRADIENT"] = 1] = "LINEAR_GRADIENT";
    CSSImageType[CSSImageType["RADIAL_GRADIENT"] = 2] = "RADIAL_GRADIENT";
  })(CSSImageType || (CSSImageType = {}));
  var isLinearGradient = function isLinearGradient(background) {
    return background.type === CSSImageType.LINEAR_GRADIENT;
  };
  var isRadialGradient = function isRadialGradient(background) {
    return background.type === CSSImageType.RADIAL_GRADIENT;
  };
  var CSSRadialShape;
  (function (CSSRadialShape) {
    CSSRadialShape[CSSRadialShape["CIRCLE"] = 0] = "CIRCLE";
    CSSRadialShape[CSSRadialShape["ELLIPSE"] = 1] = "ELLIPSE";
  })(CSSRadialShape || (CSSRadialShape = {}));
  var CSSRadialExtent;
  (function (CSSRadialExtent) {
    CSSRadialExtent[CSSRadialExtent["CLOSEST_SIDE"] = 0] = "CLOSEST_SIDE";
    CSSRadialExtent[CSSRadialExtent["FARTHEST_SIDE"] = 1] = "FARTHEST_SIDE";
    CSSRadialExtent[CSSRadialExtent["CLOSEST_CORNER"] = 2] = "CLOSEST_CORNER";
    CSSRadialExtent[CSSRadialExtent["FARTHEST_CORNER"] = 3] = "FARTHEST_CORNER";
  })(CSSRadialExtent || (CSSRadialExtent = {}));
  var image = {
    name: 'image',
    parse: function parse(context, value) {
      if (value.type === TokenType.URL_TOKEN) {
        var image_1 = { url: value.value, type: CSSImageType.URL };
        context.cache.addImage(value.value);
        return image_1;
      }
      if (value.type === TokenType.FUNCTION) {
        var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
        if (typeof imageFunction === 'undefined') {
          throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
        }
        return imageFunction(context, value.values);
      }
      throw new Error("Unsupported image type " + value.type);
    } };

  function isSupportedImage(value) {
    return !(value.type === TokenType.IDENT_TOKEN && value.value === 'none') && (
    value.type !== TokenType.FUNCTION || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
  }
  var SUPPORTED_IMAGE_FUNCTIONS = {
    'linear-gradient': linearGradient,
    '-moz-linear-gradient': prefixLinearGradient,
    '-ms-linear-gradient': prefixLinearGradient,
    '-o-linear-gradient': prefixLinearGradient,
    '-webkit-linear-gradient': prefixLinearGradient,
    'radial-gradient': radialGradient,
    '-moz-radial-gradient': prefixRadialGradient,
    '-ms-radial-gradient': prefixRadialGradient,
    '-o-radial-gradient': prefixRadialGradient,
    '-webkit-radial-gradient': prefixRadialGradient,
    '-webkit-gradient': webkitGradient };


  var backgroundImage = {
    name: 'background-image',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var first = tokens[0];
      if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
        return [];
      }
      return tokens.
      filter(function (value) {return nonFunctionArgSeparator(value) && isSupportedImage(value);}).
      map(function (value) {return image.parse(context, value);});
    } };


  var backgroundOrigin = {
    name: 'background-origin',
    initialValue: 'border-box',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return tokens.map(function (token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case 'padding-box':
              return 1 /* PADDING_BOX */;
            case 'content-box':
              return 2 /* CONTENT_BOX */;}

        }
        return 0 /* BORDER_BOX */;
      });
    } };


  var backgroundPosition = {
    name: 'background-position',
    initialValue: '0% 0%',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(_context, tokens) {
      return parseFunctionArgs(tokens).
      map(function (values) {return values.filter(isLengthPercentage);}).
      map(parseLengthPercentageTuple);
    } };


  var BACKGROUND_REPEAT;
  (function (BACKGROUND_REPEAT) {
    BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT"] = 0] = "REPEAT";
    BACKGROUND_REPEAT[BACKGROUND_REPEAT["NO_REPEAT"] = 1] = "NO_REPEAT";
    BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_X"] = 2] = "REPEAT_X";
    BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_Y"] = 3] = "REPEAT_Y";
  })(BACKGROUND_REPEAT || (BACKGROUND_REPEAT = {}));
  var backgroundRepeat = {
    name: 'background-repeat',
    initialValue: 'repeat',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return parseFunctionArgs(tokens).
      map(function (values) {
        return values.
        filter(isIdentToken).
        map(function (token) {return token.value;}).
        join(' ');
      }).
      map(parseBackgroundRepeat);
    } };

  var parseBackgroundRepeat = function parseBackgroundRepeat(value) {
    switch (value) {
      case 'no-repeat':
        return BACKGROUND_REPEAT.NO_REPEAT;
      case 'repeat-x':
      case 'repeat no-repeat':
        return BACKGROUND_REPEAT.REPEAT_X;
      case 'repeat-y':
      case 'no-repeat repeat':
        return BACKGROUND_REPEAT.REPEAT_Y;
      case 'repeat':
      default:
        return BACKGROUND_REPEAT.REPEAT;}

  };

  var BACKGROUND_SIZE;
  (function (BACKGROUND_SIZE) {
    BACKGROUND_SIZE["AUTO"] = "auto";
    BACKGROUND_SIZE["CONTAIN"] = "contain";
    BACKGROUND_SIZE["COVER"] = "cover";
  })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  var backgroundSize = {
    name: 'background-size',
    initialValue: '0',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return parseFunctionArgs(tokens).map(function (values) {return values.filter(isBackgroundSizeInfoToken);});
    } };

  var isBackgroundSizeInfoToken = function isBackgroundSizeInfoToken(value) {
    return isIdentToken(value) || isLengthPercentage(value);
  };

  var borderColorForSide = function borderColorForSide(side) {return {
      name: "border-" + side + "-color",
      initialValue: 'transparent',
      prefix: false,
      type: PropertyDescriptorParsingType.TYPE_VALUE,
      format: 'color' };
  };
  var borderTopColor = borderColorForSide('top');
  var borderRightColor = borderColorForSide('right');
  var borderBottomColor = borderColorForSide('bottom');
  var borderLeftColor = borderColorForSide('left');

  var borderRadiusForSide = function borderRadiusForSide(side) {return {
      name: "border-radius-" + side,
      initialValue: '0 0',
      prefix: false,
      type: PropertyDescriptorParsingType.LIST,
      parse: function parse(_context, tokens) {
        return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
      } };
  };
  var borderTopLeftRadius = borderRadiusForSide('top-left');
  var borderTopRightRadius = borderRadiusForSide('top-right');
  var borderBottomRightRadius = borderRadiusForSide('bottom-right');
  var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

  var BORDER_STYLE;
  (function (BORDER_STYLE) {
    BORDER_STYLE[BORDER_STYLE["NONE"] = 0] = "NONE";
    BORDER_STYLE[BORDER_STYLE["SOLID"] = 1] = "SOLID";
    BORDER_STYLE[BORDER_STYLE["DASHED"] = 2] = "DASHED";
    BORDER_STYLE[BORDER_STYLE["DOTTED"] = 3] = "DOTTED";
    BORDER_STYLE[BORDER_STYLE["DOUBLE"] = 4] = "DOUBLE";
  })(BORDER_STYLE || (BORDER_STYLE = {}));
  var borderStyleForSide = function borderStyleForSide(side) {return {
      name: "border-" + side + "-style",
      initialValue: 'solid',
      prefix: false,
      type: PropertyDescriptorParsingType.IDENT_VALUE,
      parse: function parse(_context, style) {
        switch (style) {
          case 'none':
            return BORDER_STYLE.NONE;
          case 'dashed':
            return BORDER_STYLE.DASHED;
          case 'dotted':
            return BORDER_STYLE.DOTTED;
          case 'double':
            return BORDER_STYLE.DOUBLE;}

        return BORDER_STYLE.SOLID;
      } };
  };
  var borderTopStyle = borderStyleForSide('top');
  var borderRightStyle = borderStyleForSide('right');
  var borderBottomStyle = borderStyleForSide('bottom');
  var borderLeftStyle = borderStyleForSide('left');

  var borderWidthForSide = function borderWidthForSide(side) {return {
      name: "border-" + side + "-width",
      initialValue: '0',
      type: PropertyDescriptorParsingType.VALUE,
      prefix: false,
      parse: function parse(_context, token) {
        if (isDimensionToken(token)) {
          return token.number;
        }
        return 0;
      } };
  };
  var borderTopWidth = borderWidthForSide('top');
  var borderRightWidth = borderWidthForSide('right');
  var borderBottomWidth = borderWidthForSide('bottom');
  var borderLeftWidth = borderWidthForSide('left');

  var color = {
    name: "color",
    initialValue: 'transparent',
    prefix: false,
    type: PropertyDescriptorParsingType.TYPE_VALUE,
    format: 'color' };


  var display = {
    name: 'display',
    initialValue: 'inline-block',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return tokens.filter(isIdentToken).reduce(function (bit, token) {
        return bit | parseDisplayValue(token.value);
      }, 0 /* NONE */);
    } };

  var parseDisplayValue = function parseDisplayValue(display) {
    switch (display) {
      case 'block':
      case '-webkit-box':
        return 2 /* BLOCK */;
      case 'inline':
        return 4 /* INLINE */;
      case 'run-in':
        return 8 /* RUN_IN */;
      case 'flow':
        return 16 /* FLOW */;
      case 'flow-root':
        return 32 /* FLOW_ROOT */;
      case 'table':
        return 64 /* TABLE */;
      case 'flex':
      case '-webkit-flex':
        return 128 /* FLEX */;
      case 'grid':
      case '-ms-grid':
        return 256 /* GRID */;
      case 'ruby':
        return 512 /* RUBY */;
      case 'subgrid':
        return 1024 /* SUBGRID */;
      case 'list-item':
        return 2048 /* LIST_ITEM */;
      case 'table-row-group':
        return 4096 /* TABLE_ROW_GROUP */;
      case 'table-header-group':
        return 8192 /* TABLE_HEADER_GROUP */;
      case 'table-footer-group':
        return 16384 /* TABLE_FOOTER_GROUP */;
      case 'table-row':
        return 32768 /* TABLE_ROW */;
      case 'table-cell':
        return 65536 /* TABLE_CELL */;
      case 'table-column-group':
        return 131072 /* TABLE_COLUMN_GROUP */;
      case 'table-column':
        return 262144 /* TABLE_COLUMN */;
      case 'table-caption':
        return 524288 /* TABLE_CAPTION */;
      case 'ruby-base':
        return 1048576 /* RUBY_BASE */;
      case 'ruby-text':
        return 2097152 /* RUBY_TEXT */;
      case 'ruby-base-container':
        return 4194304 /* RUBY_BASE_CONTAINER */;
      case 'ruby-text-container':
        return 8388608 /* RUBY_TEXT_CONTAINER */;
      case 'contents':
        return 16777216 /* CONTENTS */;
      case 'inline-block':
        return 33554432 /* INLINE_BLOCK */;
      case 'inline-list-item':
        return 67108864 /* INLINE_LIST_ITEM */;
      case 'inline-table':
        return 134217728 /* INLINE_TABLE */;
      case 'inline-flex':
        return 268435456 /* INLINE_FLEX */;
      case 'inline-grid':
        return 536870912 /* INLINE_GRID */;}

    return 0 /* NONE */;
  };

  var FLOAT;
  (function (FLOAT) {
    FLOAT[FLOAT["NONE"] = 0] = "NONE";
    FLOAT[FLOAT["LEFT"] = 1] = "LEFT";
    FLOAT[FLOAT["RIGHT"] = 2] = "RIGHT";
    FLOAT[FLOAT["INLINE_START"] = 3] = "INLINE_START";
    FLOAT[FLOAT["INLINE_END"] = 4] = "INLINE_END";
  })(FLOAT || (FLOAT = {}));
  var float = {
    name: 'float',
    initialValue: 'none',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, float) {
      switch (float) {
        case 'left':
          return FLOAT.LEFT;
        case 'right':
          return FLOAT.RIGHT;
        case 'inline-start':
          return FLOAT.INLINE_START;
        case 'inline-end':
          return FLOAT.INLINE_END;}

      return FLOAT.NONE;
    } };


  var letterSpacing = {
    name: 'letter-spacing',
    initialValue: '0',
    prefix: false,
    type: PropertyDescriptorParsingType.VALUE,
    parse: function parse(_context, token) {
      if (token.type === TokenType.IDENT_TOKEN && token.value === 'normal') {
        return 0;
      }
      if (token.type === TokenType.NUMBER_TOKEN) {
        return token.number;
      }
      if (token.type === TokenType.DIMENSION_TOKEN) {
        return token.number;
      }
      return 0;
    } };


  var LINE_BREAK;
  (function (LINE_BREAK) {
    LINE_BREAK["NORMAL"] = "normal";
    LINE_BREAK["STRICT"] = "strict";
  })(LINE_BREAK || (LINE_BREAK = {}));
  var lineBreak = {
    name: 'line-break',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, lineBreak) {
      switch (lineBreak) {
        case 'strict':
          return LINE_BREAK.STRICT;
        case 'normal':
        default:
          return LINE_BREAK.NORMAL;}

    } };


  var lineHeight = {
    name: 'line-height',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.TOKEN_VALUE };

  var computeLineHeight = function computeLineHeight(token, fontSize) {
    if (isIdentToken(token) && token.value === 'normal') {
      return 1.2 * fontSize;
    } else
    if (token.type === TokenType.NUMBER_TOKEN) {
      return fontSize * token.number;
    } else
    if (isLengthPercentage(token)) {
      return getAbsoluteValue(token, fontSize);
    }
    return fontSize;
  };

  var listStyleImage = {
    name: 'list-style-image',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.VALUE,
    prefix: false,
    parse: function parse(context, token) {
      if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
        return null;
      }
      return image.parse(context, token);
    } };


  var LIST_STYLE_POSITION;
  (function (LIST_STYLE_POSITION) {
    LIST_STYLE_POSITION[LIST_STYLE_POSITION["INSIDE"] = 0] = "INSIDE";
    LIST_STYLE_POSITION[LIST_STYLE_POSITION["OUTSIDE"] = 1] = "OUTSIDE";
  })(LIST_STYLE_POSITION || (LIST_STYLE_POSITION = {}));
  var listStylePosition = {
    name: 'list-style-position',
    initialValue: 'outside',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, position) {
      switch (position) {
        case 'inside':
          return LIST_STYLE_POSITION.INSIDE;
        case 'outside':
        default:
          return LIST_STYLE_POSITION.OUTSIDE;}

    } };


  var LIST_STYLE_TYPE;
  (function (LIST_STYLE_TYPE) {
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["NONE"] = -1] = "NONE";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISC"] = 0] = "DISC";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CIRCLE"] = 1] = "CIRCLE";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["SQUARE"] = 2] = "SQUARE";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL"] = 3] = "DECIMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_DECIMAL"] = 4] = "CJK_DECIMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL_LEADING_ZERO"] = 5] = "DECIMAL_LEADING_ZERO";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ROMAN"] = 6] = "LOWER_ROMAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ROMAN"] = 7] = "UPPER_ROMAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_GREEK"] = 8] = "LOWER_GREEK";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ALPHA"] = 9] = "LOWER_ALPHA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ALPHA"] = 10] = "UPPER_ALPHA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARABIC_INDIC"] = 11] = "ARABIC_INDIC";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARMENIAN"] = 12] = "ARMENIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["BENGALI"] = 13] = "BENGALI";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CAMBODIAN"] = 14] = "CAMBODIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_EARTHLY_BRANCH"] = 15] = "CJK_EARTHLY_BRANCH";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_HEAVENLY_STEM"] = 16] = "CJK_HEAVENLY_STEM";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_IDEOGRAPHIC"] = 17] = "CJK_IDEOGRAPHIC";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DEVANAGARI"] = 18] = "DEVANAGARI";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["ETHIOPIC_NUMERIC"] = 19] = "ETHIOPIC_NUMERIC";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["GEORGIAN"] = 20] = "GEORGIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["GUJARATI"] = 21] = "GUJARATI";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["GURMUKHI"] = 22] = "GURMUKHI";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["HEBREW"] = 22] = "HEBREW";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA"] = 23] = "HIRAGANA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA_IROHA"] = 24] = "HIRAGANA_IROHA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_FORMAL"] = 25] = "JAPANESE_FORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_INFORMAL"] = 26] = "JAPANESE_INFORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KANNADA"] = 27] = "KANNADA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA"] = 28] = "KATAKANA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA_IROHA"] = 29] = "KATAKANA_IROHA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KHMER"] = 30] = "KHMER";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANGUL_FORMAL"] = 31] = "KOREAN_HANGUL_FORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_FORMAL"] = 32] = "KOREAN_HANJA_FORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_INFORMAL"] = 33] = "KOREAN_HANJA_INFORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["LAO"] = 34] = "LAO";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ARMENIAN"] = 35] = "LOWER_ARMENIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["MALAYALAM"] = 36] = "MALAYALAM";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["MONGOLIAN"] = 37] = "MONGOLIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["MYANMAR"] = 38] = "MYANMAR";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["ORIYA"] = 39] = "ORIYA";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["PERSIAN"] = 40] = "PERSIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_FORMAL"] = 41] = "SIMP_CHINESE_FORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_INFORMAL"] = 42] = "SIMP_CHINESE_INFORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["TAMIL"] = 43] = "TAMIL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["TELUGU"] = 44] = "TELUGU";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["THAI"] = 45] = "THAI";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["TIBETAN"] = 46] = "TIBETAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_FORMAL"] = 47] = "TRAD_CHINESE_FORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_INFORMAL"] = 48] = "TRAD_CHINESE_INFORMAL";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ARMENIAN"] = 49] = "UPPER_ARMENIAN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_OPEN"] = 50] = "DISCLOSURE_OPEN";
    LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_CLOSED"] = 51] = "DISCLOSURE_CLOSED";
  })(LIST_STYLE_TYPE || (LIST_STYLE_TYPE = {}));
  var listStyleType = {
    name: 'list-style-type',
    initialValue: 'none',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, type) {
      switch (type) {
        case 'disc':
          return LIST_STYLE_TYPE.DISC;
        case 'circle':
          return LIST_STYLE_TYPE.CIRCLE;
        case 'square':
          return LIST_STYLE_TYPE.SQUARE;
        case 'decimal':
          return LIST_STYLE_TYPE.DECIMAL;
        case 'cjk-decimal':
          return LIST_STYLE_TYPE.CJK_DECIMAL;
        case 'decimal-leading-zero':
          return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
        case 'lower-roman':
          return LIST_STYLE_TYPE.LOWER_ROMAN;
        case 'upper-roman':
          return LIST_STYLE_TYPE.UPPER_ROMAN;
        case 'lower-greek':
          return LIST_STYLE_TYPE.LOWER_GREEK;
        case 'lower-alpha':
          return LIST_STYLE_TYPE.LOWER_ALPHA;
        case 'upper-alpha':
          return LIST_STYLE_TYPE.UPPER_ALPHA;
        case 'arabic-indic':
          return LIST_STYLE_TYPE.ARABIC_INDIC;
        case 'armenian':
          return LIST_STYLE_TYPE.ARMENIAN;
        case 'bengali':
          return LIST_STYLE_TYPE.BENGALI;
        case 'cambodian':
          return LIST_STYLE_TYPE.CAMBODIAN;
        case 'cjk-earthly-branch':
          return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
        case 'cjk-heavenly-stem':
          return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
        case 'cjk-ideographic':
          return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
        case 'devanagari':
          return LIST_STYLE_TYPE.DEVANAGARI;
        case 'ethiopic-numeric':
          return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
        case 'georgian':
          return LIST_STYLE_TYPE.GEORGIAN;
        case 'gujarati':
          return LIST_STYLE_TYPE.GUJARATI;
        case 'gurmukhi':
          return LIST_STYLE_TYPE.GURMUKHI;
        case 'hebrew':
          return LIST_STYLE_TYPE.HEBREW;
        case 'hiragana':
          return LIST_STYLE_TYPE.HIRAGANA;
        case 'hiragana-iroha':
          return LIST_STYLE_TYPE.HIRAGANA_IROHA;
        case 'japanese-formal':
          return LIST_STYLE_TYPE.JAPANESE_FORMAL;
        case 'japanese-informal':
          return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
        case 'kannada':
          return LIST_STYLE_TYPE.KANNADA;
        case 'katakana':
          return LIST_STYLE_TYPE.KATAKANA;
        case 'katakana-iroha':
          return LIST_STYLE_TYPE.KATAKANA_IROHA;
        case 'khmer':
          return LIST_STYLE_TYPE.KHMER;
        case 'korean-hangul-formal':
          return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
        case 'korean-hanja-formal':
          return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
        case 'korean-hanja-informal':
          return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
        case 'lao':
          return LIST_STYLE_TYPE.LAO;
        case 'lower-armenian':
          return LIST_STYLE_TYPE.LOWER_ARMENIAN;
        case 'malayalam':
          return LIST_STYLE_TYPE.MALAYALAM;
        case 'mongolian':
          return LIST_STYLE_TYPE.MONGOLIAN;
        case 'myanmar':
          return LIST_STYLE_TYPE.MYANMAR;
        case 'oriya':
          return LIST_STYLE_TYPE.ORIYA;
        case 'persian':
          return LIST_STYLE_TYPE.PERSIAN;
        case 'simp-chinese-formal':
          return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
        case 'simp-chinese-informal':
          return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
        case 'tamil':
          return LIST_STYLE_TYPE.TAMIL;
        case 'telugu':
          return LIST_STYLE_TYPE.TELUGU;
        case 'thai':
          return LIST_STYLE_TYPE.THAI;
        case 'tibetan':
          return LIST_STYLE_TYPE.TIBETAN;
        case 'trad-chinese-formal':
          return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
        case 'trad-chinese-informal':
          return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
        case 'upper-armenian':
          return LIST_STYLE_TYPE.UPPER_ARMENIAN;
        case 'disclosure-open':
          return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
        case 'disclosure-closed':
          return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
        case 'none':
        default:
          return LIST_STYLE_TYPE.NONE;}

    } };


  var marginForSide = function marginForSide(side) {return {
      name: "margin-" + side,
      initialValue: '0',
      prefix: false,
      type: PropertyDescriptorParsingType.TOKEN_VALUE };
  };
  var marginTop = marginForSide('top');
  var marginRight = marginForSide('right');
  var marginBottom = marginForSide('bottom');
  var marginLeft = marginForSide('left');

  var OVERFLOW;
  (function (OVERFLOW) {
    OVERFLOW[OVERFLOW["VISIBLE"] = 0] = "VISIBLE";
    OVERFLOW[OVERFLOW["HIDDEN"] = 1] = "HIDDEN";
    OVERFLOW[OVERFLOW["SCROLL"] = 2] = "SCROLL";
    OVERFLOW[OVERFLOW["AUTO"] = 3] = "AUTO";
  })(OVERFLOW || (OVERFLOW = {}));
  var overflow = {
    name: 'overflow',
    initialValue: 'visible',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return tokens.filter(isIdentToken).map(function (overflow) {
        switch (overflow.value) {
          case 'hidden':
            return OVERFLOW.HIDDEN;
          case 'scroll':
            return OVERFLOW.SCROLL;
          case 'auto':
            return OVERFLOW.AUTO;
          case 'visible':
          default:
            return OVERFLOW.VISIBLE;}

      });
    } };


  var OVERFLOW_WRAP;
  (function (OVERFLOW_WRAP) {
    OVERFLOW_WRAP["NORMAL"] = "normal";
    OVERFLOW_WRAP["BREAK_WORD"] = "break-word";
  })(OVERFLOW_WRAP || (OVERFLOW_WRAP = {}));
  var overflowWrap = {
    name: 'overflow-wrap',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, overflow) {
      switch (overflow) {
        case 'break-word':
          return OVERFLOW_WRAP.BREAK_WORD;
        case 'normal':
        default:
          return OVERFLOW_WRAP.NORMAL;}

    } };


  var paddingForSide = function paddingForSide(side) {return {
      name: "padding-" + side,
      initialValue: '0',
      prefix: false,
      type: PropertyDescriptorParsingType.TYPE_VALUE,
      format: 'length-percentage' };
  };
  var paddingTop = paddingForSide('top');
  var paddingRight = paddingForSide('right');
  var paddingBottom = paddingForSide('bottom');
  var paddingLeft = paddingForSide('left');

  var TEXT_ALIGN;
  (function (TEXT_ALIGN) {
    TEXT_ALIGN[TEXT_ALIGN["LEFT"] = 0] = "LEFT";
    TEXT_ALIGN[TEXT_ALIGN["CENTER"] = 1] = "CENTER";
    TEXT_ALIGN[TEXT_ALIGN["RIGHT"] = 2] = "RIGHT";
  })(TEXT_ALIGN || (TEXT_ALIGN = {}));
  var textAlign = {
    name: 'text-align',
    initialValue: 'left',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, textAlign) {
      switch (textAlign) {
        case 'right':
          return TEXT_ALIGN.RIGHT;
        case 'center':
        case 'justify':
          return TEXT_ALIGN.CENTER;
        case 'left':
        default:
          return TEXT_ALIGN.LEFT;}

    } };


  var POSITION;
  (function (POSITION) {
    POSITION[POSITION["STATIC"] = 0] = "STATIC";
    POSITION[POSITION["RELATIVE"] = 1] = "RELATIVE";
    POSITION[POSITION["ABSOLUTE"] = 2] = "ABSOLUTE";
    POSITION[POSITION["FIXED"] = 3] = "FIXED";
    POSITION[POSITION["STICKY"] = 4] = "STICKY";
  })(POSITION || (POSITION = {}));
  var position = {
    name: 'position',
    initialValue: 'static',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, position) {
      switch (position) {
        case 'relative':
          return POSITION.RELATIVE;
        case 'absolute':
          return POSITION.ABSOLUTE;
        case 'fixed':
          return POSITION.FIXED;
        case 'sticky':
          return POSITION.STICKY;}

      return POSITION.STATIC;
    } };


  var textShadow = {
    name: 'text-shadow',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(context, tokens) {
      if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
        return [];
      }
      return parseFunctionArgs(tokens).map(function (values) {
        var shadow = {
          color: COLORS.TRANSPARENT,
          offsetX: ZERO_LENGTH,
          offsetY: ZERO_LENGTH,
          blur: ZERO_LENGTH };

        var c = 0;
        for (var i = 0; i < values.length; i++) {
          var token = values[i];
          if (isLength(token)) {
            if (c === 0) {
              shadow.offsetX = token;
            } else
            if (c === 1) {
              shadow.offsetY = token;
            } else
            {
              shadow.blur = token;
            }
            c++;
          } else
          {
            shadow.color = color$1.parse(context, token);
          }
        }
        return shadow;
      });
    } };


  var TEXT_TRANSFORM;
  (function (TEXT_TRANSFORM) {
    TEXT_TRANSFORM[TEXT_TRANSFORM["NONE"] = 0] = "NONE";
    TEXT_TRANSFORM[TEXT_TRANSFORM["LOWERCASE"] = 1] = "LOWERCASE";
    TEXT_TRANSFORM[TEXT_TRANSFORM["UPPERCASE"] = 2] = "UPPERCASE";
    TEXT_TRANSFORM[TEXT_TRANSFORM["CAPITALIZE"] = 3] = "CAPITALIZE";
  })(TEXT_TRANSFORM || (TEXT_TRANSFORM = {}));
  var textTransform = {
    name: 'text-transform',
    initialValue: 'none',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, textTransform) {
      switch (textTransform) {
        case 'uppercase':
          return TEXT_TRANSFORM.UPPERCASE;
        case 'lowercase':
          return TEXT_TRANSFORM.LOWERCASE;
        case 'capitalize':
          return TEXT_TRANSFORM.CAPITALIZE;}

      return TEXT_TRANSFORM.NONE;
    } };


  var transform$1 = {
    name: 'transform',
    initialValue: 'none',
    prefix: true,
    type: PropertyDescriptorParsingType.VALUE,
    parse: function parse(_context, token) {
      if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
        return null;
      }
      if (token.type === TokenType.FUNCTION) {
        var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
        if (typeof transformFunction === 'undefined') {
          throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
        }
        return transformFunction(token.values);
      }
      return null;
    } };

  var matrix = function matrix(args) {
    var values = args.filter(function (arg) {return arg.type === TokenType.NUMBER_TOKEN;}).map(function (arg) {return arg.number;});
    return values.length === 6 ? values : null;
  };
  // doesn't support 3D transforms at the moment
  var matrix3d = function matrix3d(args) {
    var values = args.filter(function (arg) {return arg.type === TokenType.NUMBER_TOKEN;}).map(function (arg) {return arg.number;});
    var a1 = values[0],b1 = values[1];values[2];values[3];var a2 = values[4],b2 = values[5];values[6];values[7];values[8];values[9];values[10];values[11];var a4 = values[12],b4 = values[13];values[14];values[15];
    return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  };
  var SUPPORTED_TRANSFORM_FUNCTIONS = {
    matrix: matrix,
    matrix3d: matrix3d };


  var DEFAULT_VALUE = {
    type: TokenType.PERCENTAGE_TOKEN,
    number: 50,
    flags: FLAG_INTEGER };

  var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  var transformOrigin = {
    name: 'transform-origin',
    initialValue: '50% 50%',
    prefix: true,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      var origins = tokens.filter(isLengthPercentage);
      if (origins.length !== 2) {
        return DEFAULT;
      }
      return [origins[0], origins[1]];
    } };


  var VISIBILITY;
  (function (VISIBILITY) {
    VISIBILITY[VISIBILITY["VISIBLE"] = 0] = "VISIBLE";
    VISIBILITY[VISIBILITY["HIDDEN"] = 1] = "HIDDEN";
    VISIBILITY[VISIBILITY["COLLAPSE"] = 2] = "COLLAPSE";
  })(VISIBILITY || (VISIBILITY = {}));
  var visibility = {
    name: 'visible',
    initialValue: 'none',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, visibility) {
      switch (visibility) {
        case 'hidden':
          return VISIBILITY.HIDDEN;
        case 'collapse':
          return VISIBILITY.COLLAPSE;
        case 'visible':
        default:
          return VISIBILITY.VISIBLE;}

    } };


  var WORD_BREAK;
  (function (WORD_BREAK) {
    WORD_BREAK["NORMAL"] = "normal";
    WORD_BREAK["BREAK_ALL"] = "break-all";
    WORD_BREAK["KEEP_ALL"] = "keep-all";
  })(WORD_BREAK || (WORD_BREAK = {}));
  var wordBreak = {
    name: 'word-break',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, wordBreak) {
      switch (wordBreak) {
        case 'break-all':
          return WORD_BREAK.BREAK_ALL;
        case 'keep-all':
          return WORD_BREAK.KEEP_ALL;
        case 'normal':
        default:
          return WORD_BREAK.NORMAL;}

    } };


  var zIndex = {
    name: 'z-index',
    initialValue: 'auto',
    prefix: false,
    type: PropertyDescriptorParsingType.VALUE,
    parse: function parse(_context, token) {
      if (token.type === TokenType.IDENT_TOKEN) {
        return { auto: true, order: 0 };
      }
      if (isNumberToken(token)) {
        return { auto: false, order: token.number };
      }
      throw new Error("Invalid z-index number parsed");
    } };


  var opacity = {
    name: 'opacity',
    initialValue: '1',
    type: PropertyDescriptorParsingType.VALUE,
    prefix: false,
    parse: function parse(_context, token) {
      if (isNumberToken(token)) {
        return token.number;
      }
      return 1;
    } };


  var textDecorationColor = {
    name: "text-decoration-color",
    initialValue: 'transparent',
    prefix: false,
    type: PropertyDescriptorParsingType.TYPE_VALUE,
    format: 'color' };


  var textDecorationLine = {
    name: 'text-decoration-line',
    initialValue: 'none',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      return tokens.
      filter(isIdentToken).
      map(function (token) {
        switch (token.value) {
          case 'underline':
            return 1 /* UNDERLINE */;
          case 'overline':
            return 2 /* OVERLINE */;
          case 'line-through':
            return 3 /* LINE_THROUGH */;
          case 'none':
            return 4 /* BLINK */;}

        return 0 /* NONE */;
      }).
      filter(function (line) {return line !== 0 /* NONE */;});
    } };


  var fontFamily = {
    name: "font-family",
    initialValue: '',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      var accumulator = [];
      var results = [];
      tokens.forEach(function (token) {
        switch (token.type) {
          case TokenType.IDENT_TOKEN:
          case TokenType.STRING_TOKEN:
            accumulator.push(token.value);
            break;
          case TokenType.NUMBER_TOKEN:
            accumulator.push(token.number.toString());
            break;
          case TokenType.COMMA_TOKEN:
            results.push(accumulator.join(' '));
            accumulator.length = 0;
            break;}

      });
      if (accumulator.length) {
        results.push(accumulator.join(' '));
      }
      return results.map(function (result) {return result.indexOf(' ') === -1 ? result : "'" + result + "'";});
    } };


  var fontSize = {
    name: "font-size",
    initialValue: '0',
    prefix: false,
    type: PropertyDescriptorParsingType.TYPE_VALUE,
    format: 'length' };


  var fontWeight = {
    name: 'font-weight',
    initialValue: 'normal',
    type: PropertyDescriptorParsingType.VALUE,
    prefix: false,
    parse: function parse(_context, token) {
      if (isNumberToken(token)) {
        return token.number;
      }
      if (isIdentToken(token)) {
        switch (token.value) {
          case 'bold':
            return 700;
          case 'normal':
          default:
            return 400;}

      }
      return 400;
    } };


  var fontVariant = {
    name: 'font-variant',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(_context, tokens) {
      return tokens.filter(isIdentToken).map(function (token) {return token.value;});
    } };


  var FONT_STYLE;
  (function (FONT_STYLE) {
    FONT_STYLE["NORMAL"] = "normal";
    FONT_STYLE["ITALIC"] = "italic";
    FONT_STYLE["OBLIQUE"] = "oblique";
  })(FONT_STYLE || (FONT_STYLE = {}));
  var fontStyle = {
    name: 'font-style',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.IDENT_VALUE,
    parse: function parse(_context, overflow) {
      switch (overflow) {
        case 'oblique':
          return FONT_STYLE.OBLIQUE;
        case 'italic':
          return FONT_STYLE.ITALIC;
        case 'normal':
        default:
          return FONT_STYLE.NORMAL;}

    } };


  var contains = function contains(bit, value) {return (bit & value) !== 0;};

  var content = {
    name: 'content',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(_context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var first = tokens[0];
      if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
        return [];
      }
      return tokens;
    } };


  var counterIncrement = {
    name: 'counter-increment',
    initialValue: 'none',
    prefix: true,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      if (tokens.length === 0) {
        return null;
      }
      var first = tokens[0];
      if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
        return null;
      }
      var increments = [];
      var filtered = tokens.filter(nonWhiteSpace);
      for (var i = 0; i < filtered.length; i++) {
        var counter = filtered[i];
        var next = filtered[i + 1];
        if (counter.type === TokenType.IDENT_TOKEN) {
          var increment = next && isNumberToken(next) ? next.number : 1;
          increments.push({ counter: counter.value, increment: increment });
        }
      }
      return increments;
    } };


  var counterReset = {
    name: 'counter-reset',
    initialValue: 'none',
    prefix: true,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var resets = [];
      var filtered = tokens.filter(nonWhiteSpace);
      for (var i = 0; i < filtered.length; i++) {
        var counter = filtered[i];
        var next = filtered[i + 1];
        if (isIdentToken(counter) && counter.value !== 'none') {
          var reset = next && isNumberToken(next) ? next.number : 0;
          resets.push({ counter: counter.value, reset: reset });
        }
      }
      return resets;
    } };


  var quotes = {
    name: 'quotes',
    initialValue: 'none',
    prefix: true,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      if (tokens.length === 0) {
        return null;
      }
      var first = tokens[0];
      if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
        return null;
      }
      var quotes = [];
      var filtered = tokens.filter(isStringToken);
      if (filtered.length % 2 !== 0) {
        return null;
      }
      for (var i = 0; i < filtered.length; i += 2) {
        var open_1 = filtered[i].value;
        var close_1 = filtered[i + 1].value;
        quotes.push({ open: open_1, close: close_1 });
      }
      return quotes;
    } };

  var getQuote = function getQuote(quotes, depth, open) {
    if (!quotes) {
      return '';
    }
    var quote = quotes[Math.min(depth, quotes.length - 1)];
    if (!quote) {
      return '';
    }
    return open ? quote.open : quote.close;
  };

  var boxShadow = {
    name: 'box-shadow',
    initialValue: 'none',
    type: PropertyDescriptorParsingType.LIST,
    prefix: false,
    parse: function parse(context, tokens) {
      if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
        return [];
      }
      return parseFunctionArgs(tokens).map(function (values) {
        var shadow = {
          color: 0x000000ff,
          offsetX: ZERO_LENGTH,
          offsetY: ZERO_LENGTH,
          blur: ZERO_LENGTH,
          spread: ZERO_LENGTH,
          inset: false };

        var c = 0;
        for (var i = 0; i < values.length; i++) {
          var token = values[i];
          if (isIdentWithValue(token, 'inset')) {
            shadow.inset = true;
          } else
          if (isLength(token)) {
            if (c === 0) {
              shadow.offsetX = token;
            } else
            if (c === 1) {
              shadow.offsetY = token;
            } else
            if (c === 2) {
              shadow.blur = token;
            } else
            {
              shadow.spread = token;
            }
            c++;
          } else
          {
            shadow.color = color$1.parse(context, token);
          }
        }
        return shadow;
      });
    } };


  var PAINT_ORDER_LAYER;
  (function (PAINT_ORDER_LAYER) {
    PAINT_ORDER_LAYER[PAINT_ORDER_LAYER["FILL"] = 0] = "FILL";
    PAINT_ORDER_LAYER[PAINT_ORDER_LAYER["STROKE"] = 1] = "STROKE";
    PAINT_ORDER_LAYER[PAINT_ORDER_LAYER["MARKERS"] = 2] = "MARKERS";
  })(PAINT_ORDER_LAYER || (PAINT_ORDER_LAYER = {}));
  var paintOrder = {
    name: 'paint-order',
    initialValue: 'normal',
    prefix: false,
    type: PropertyDescriptorParsingType.LIST,
    parse: function parse(_context, tokens) {
      var DEFAULT_VALUE = [PAINT_ORDER_LAYER.FILL, PAINT_ORDER_LAYER.STROKE, PAINT_ORDER_LAYER.MARKERS];
      var layers = [];
      tokens.filter(isIdentToken).forEach(function (token) {
        switch (token.value) {
          case 'stroke':
            layers.push(PAINT_ORDER_LAYER.STROKE);
            break;
          case 'fill':
            layers.push(PAINT_ORDER_LAYER.FILL);
            break;
          case 'markers':
            layers.push(PAINT_ORDER_LAYER.MARKERS);
            break;}

      });
      DEFAULT_VALUE.forEach(function (value) {
        if (layers.indexOf(value) === -1) {
          layers.push(value);
        }
      });
      return layers;
    } };


  var webkitTextStrokeColor = {
    name: "-webkit-text-stroke-color",
    initialValue: 'currentcolor',
    prefix: false,
    type: PropertyDescriptorParsingType.TYPE_VALUE,
    format: 'color' };


  var webkitTextStrokeWidth = {
    name: "-webkit-text-stroke-width",
    initialValue: '0',
    type: PropertyDescriptorParsingType.VALUE,
    prefix: false,
    parse: function parse(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    } };


  var CSSParsedDeclaration = /** @class */function () {
    function CSSParsedDeclaration(context, declaration) {
      var _a, _b;
      this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
      this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
      this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
      this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
      this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
      this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
      this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
      this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
      this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
      this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
      this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
      this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
      this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
      this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
      this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
      this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
      this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
      this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
      this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
      this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
      this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
      this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
      this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
      this.color = parse(context, color, declaration.color);
      this.display = parse(context, display, declaration.display);
      this.float = parse(context, float, declaration.cssFloat);
      this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
      this.fontSize = parse(context, fontSize, declaration.fontSize);
      this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
      this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
      this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
      this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
      this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
      this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
      this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
      this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
      this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
      this.marginTop = parse(context, marginTop, declaration.marginTop);
      this.marginRight = parse(context, marginRight, declaration.marginRight);
      this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
      this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
      this.opacity = parse(context, opacity, declaration.opacity);
      var overflowTuple = parse(context, overflow, declaration.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
      this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
      this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
      this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
      this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
      this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
      this.position = parse(context, position, declaration.position);
      this.textAlign = parse(context, textAlign, declaration.textAlign);
      this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
      this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
      this.textShadow = parse(context, textShadow, declaration.textShadow);
      this.textTransform = parse(context, textTransform, declaration.textTransform);
      this.transform = parse(context, transform$1, declaration.transform);
      this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
      this.visibility = parse(context, visibility, declaration.visibility);
      this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
      this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
      this.zIndex = parse(context, zIndex, declaration.zIndex);
    }
    CSSParsedDeclaration.prototype.isVisible = function () {
      return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;
    };
    CSSParsedDeclaration.prototype.isTransparent = function () {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration.prototype.isTransformed = function () {
      return this.transform !== null;
    };
    CSSParsedDeclaration.prototype.isPositioned = function () {
      return this.position !== POSITION.STATIC;
    };
    CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration.prototype.isFloating = function () {
      return this.float !== FLOAT.NONE;
    };
    CSSParsedDeclaration.prototype.isInlineLevel = function () {
      return contains(this.display, 4 /* INLINE */) ||
      contains(this.display, 33554432 /* INLINE_BLOCK */) ||
      contains(this.display, 268435456 /* INLINE_FLEX */) ||
      contains(this.display, 536870912 /* INLINE_GRID */) ||
      contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
      contains(this.display, 134217728 /* INLINE_TABLE */);
    };
    return CSSParsedDeclaration;
  }();
  var CSSParsedPseudoDeclaration = /** @class */function () {
    function CSSParsedPseudoDeclaration(context, declaration) {
      this.content = parse(context, content, declaration.content);
      this.quotes = parse(context, quotes, declaration.quotes);
    }
    return CSSParsedPseudoDeclaration;
  }();
  var CSSParsedCounterDeclaration = /** @class */function () {
    function CSSParsedCounterDeclaration(context, declaration) {
      this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
      this.counterReset = parse(context, counterReset, declaration.counterReset);
    }
    return CSSParsedCounterDeclaration;
  }();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parse = function parse(context, descriptor, style) {
    var tokenizer = new Tokenizer();
    var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
    tokenizer.write(value);
    var parser = new Parser(tokenizer.read());
    switch (descriptor.type) {
      case PropertyDescriptorParsingType.IDENT_VALUE:
        var token = parser.parseComponentValue();
        return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
      case PropertyDescriptorParsingType.VALUE:
        return descriptor.parse(context, parser.parseComponentValue());
      case PropertyDescriptorParsingType.LIST:
        return descriptor.parse(context, parser.parseComponentValues());
      case PropertyDescriptorParsingType.TOKEN_VALUE:
        return parser.parseComponentValue();
      case PropertyDescriptorParsingType.TYPE_VALUE:
        switch (descriptor.format) {
          case 'angle':
            return angle.parse(context, parser.parseComponentValue());
          case 'color':
            return color$1.parse(context, parser.parseComponentValue());
          case 'image':
            return image.parse(context, parser.parseComponentValue());
          case 'length':
            var length_1 = parser.parseComponentValue();
            return isLength(length_1) ? length_1 : ZERO_LENGTH;
          case 'length-percentage':
            var value_1 = parser.parseComponentValue();
            return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;}

        break;}

  };

  var ElementContainer = /** @class */function () {
    function ElementContainer(context, element) {
      this.context = context;
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      this.textNodes = [];
      this.elements = [];
      if (this.styles.transform !== null && isHTMLElementNode(element)) {
        // getBoundingClientRect takes transforms into account
        element.style.transform = 'none';
      }
      this.bounds = parseBounds(this.context, element);
      this.flags = 0;
    }
    return ElementContainer;
  }();

  var testRangeBounds = function testRangeBounds(document) {
    var TEST_HEIGHT = 123;
    if (document.createRange) {
      var range = document.createRange();
      if (range.getBoundingClientRect) {
        var testElement = document.createElement('boundtest');
        testElement.style.height = TEST_HEIGHT + "px";
        testElement.style.display = 'block';
        document.body.appendChild(testElement);
        range.selectNode(testElement);
        var rangeBounds = range.getBoundingClientRect();
        var rangeHeight = Math.round(rangeBounds.height);
        document.body.removeChild(testElement);
        if (rangeHeight === TEST_HEIGHT) {
          return true;
        }
      }
    }
    return false;
  };
  var testIOSLineBreak = function testIOSLineBreak(document) {
    var testElement = document.createElement('boundtest');
    testElement.style.width = '50px';
    testElement.style.display = 'block';
    testElement.style.fontSize = '12px';
    testElement.style.letterSpacing = '0px';
    testElement.style.wordSpacing = '0px';
    document.body.appendChild(testElement);
    var range = document.createRange();
    testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
    var node = testElement.firstChild;
    var textList = toCodePoints(node.data).map(function (i) {return fromCodePoint(i);});
    var offset = 0;
    var prev = {};
    // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
    var supports = textList.every(function (text, i) {
      range.setStart(node, offset);
      range.setEnd(node, offset + text.length);
      var rect = range.getBoundingClientRect();
      offset += text.length;
      var boundAhead = rect.x > prev.x || rect.y > prev.y;
      prev = rect;
      if (i === 0) {
        return true;
      }
      return boundAhead;
    });
    document.body.removeChild(testElement);
    return supports;
  };
  var testCORS = function testCORS() {return typeof new Image().crossOrigin !== 'undefined';};
  var testResponseType = function testResponseType() {return typeof new XMLHttpRequest().responseType === 'string';};
  var testSVG = function testSVG(document) {
    var img = new Image();
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    if (!ctx) {
      return false;
    }
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
    try {
      ctx.drawImage(img, 0, 0);
      canvas.toDataURL();
    }
    catch (e) {
      return false;
    }
    return true;
  };
  var isGreenPixel = function isGreenPixel(data) {
    return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  };
  var testForeignObject = function testForeignObject(document) {
    var canvas = document.createElement('canvas');
    var size = 100;
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext('2d');
    if (!ctx) {
      return Promise.reject(false);
    }
    ctx.fillStyle = 'rgb(0, 255, 0)';
    ctx.fillRect(0, 0, size, size);
    var img = new Image();
    var greenImageSrc = canvas.toDataURL();
    img.src = greenImageSrc;
    var svg = createForeignObjectSVG(size, size, 0, 0, img);
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, size, size);
    return loadSerializedSVG$1(svg).
    then(function (img) {
      ctx.drawImage(img, 0, 0);
      var data = ctx.getImageData(0, 0, size, size).data;
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, size, size);
      var node = document.createElement('div');
      node.style.backgroundImage = "url(" + greenImageSrc + ")";
      node.style.height = size + "px";
      // Firefox 55 does not render inline <img /> tags
      return isGreenPixel(data) ?
      loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) :
      Promise.reject(false);
    }).
    then(function (img) {
      ctx.drawImage(img, 0, 0);
      // Edge does not render background-images
      return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
    }).
    catch(function () {return false;});
  };
  var createForeignObjectSVG = function createForeignObjectSVG(width, height, x, y, node) {
    var xmlns = 'http://www.w3.org/2000/svg';
    var svg = document.createElementNS(xmlns, 'svg');
    var foreignObject = document.createElementNS(xmlns, 'foreignObject');
    svg.setAttributeNS(null, 'width', width.toString());
    svg.setAttributeNS(null, 'height', height.toString());
    foreignObject.setAttributeNS(null, 'width', '100%');
    foreignObject.setAttributeNS(null, 'height', '100%');
    foreignObject.setAttributeNS(null, 'x', x.toString());
    foreignObject.setAttributeNS(null, 'y', y.toString());
    foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
    svg.appendChild(foreignObject);
    foreignObject.appendChild(node);
    return svg;
  };
  var loadSerializedSVG$1 = function loadSerializedSVG$1(svg) {
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.onload = function () {return resolve(img);};
      img.onerror = reject;
      img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
    });
  };
  var FEATURES = {
    get SUPPORT_RANGE_BOUNDS() {
      var value = testRangeBounds(document);
      Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
      return value;
    },
    get SUPPORT_WORD_BREAKING() {
      var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
      Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
      return value;
    },
    get SUPPORT_SVG_DRAWING() {
      var value = testSVG(document);
      Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
      return value;
    },
    get SUPPORT_FOREIGNOBJECT_DRAWING() {
      var value = typeof Array.from === 'function' && typeof window.fetch === 'function' ?
      testForeignObject(document) :
      Promise.resolve(false);
      Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
      return value;
    },
    get SUPPORT_CORS_IMAGES() {
      var value = testCORS();
      Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
      return value;
    },
    get SUPPORT_RESPONSE_TYPE() {
      var value = testResponseType();
      Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
      return value;
    },
    get SUPPORT_CORS_XHR() {
      var value = ('withCredentials' in new XMLHttpRequest());
      Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
      return value;
    } };


  var TextBounds = /** @class */function () {
    function TextBounds(text, bounds) {
      this.text = text;
      this.bounds = bounds;
    }
    return TextBounds;
  }();
  var parseTextBounds = function parseTextBounds(context, value, styles, node) {
    var textList = breakText(value, styles);
    var textBounds = [];
    var offset = 0;
    textList.forEach(function (text) {
      if (styles.textDecorationLine.length || text.trim().length > 0) {
        if (FEATURES.SUPPORT_RANGE_BOUNDS) {
          if (!FEATURES.SUPPORT_WORD_BREAKING) {
            textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, createRange(node, offset, text.length).getClientRects())));
          } else
          {
            textBounds.push(new TextBounds(text, getRangeBounds(context, node, offset, text.length)));
          }
        } else
        {
          var replacementNode = node.splitText(text.length);
          textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
          node = replacementNode;
        }
      } else
      if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
        node = node.splitText(text.length);
      }
      offset += text.length;
    });
    return textBounds;
  };
  var getWrapperBounds = function getWrapperBounds(context, node) {
    var ownerDocument = node.ownerDocument;
    if (ownerDocument) {
      var wrapper = ownerDocument.createElement('html2canvaswrapper');
      wrapper.appendChild(node.cloneNode(true));
      var parentNode = node.parentNode;
      if (parentNode) {
        parentNode.replaceChild(wrapper, node);
        var bounds = parseBounds(context, wrapper);
        if (wrapper.firstChild) {
          parentNode.replaceChild(wrapper.firstChild, wrapper);
        }
        return bounds;
      }
    }
    return Bounds.EMPTY;
  };
  var createRange = function createRange(node, offset, length) {
    var ownerDocument = node.ownerDocument;
    if (!ownerDocument) {
      throw new Error('Node has no owner document');
    }
    var range = ownerDocument.createRange();
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return range;
  };
  var getRangeBounds = function getRangeBounds(context, node, offset, length) {
    return Bounds.fromClientRect(context, createRange(node, offset, length).getBoundingClientRect());
  };
  var breakText = function breakText(value, styles) {
    return styles.letterSpacing !== 0 ? toCodePoints(value).map(function (i) {return fromCodePoint(i);}) : breakWords(value, styles);
  };
  // https://drafts.csswg.org/css-text/#word-separator
  var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
  var breakWords = function breakWords(str, styles) {
    var breaker = LineBreaker(str, {
      lineBreak: styles.lineBreak,
      wordBreak: styles.overflowWrap === OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : styles.wordBreak });

    var words = [];
    var bk;
    var _loop_1 = function _loop_1() {
      if (bk.value) {
        var value = bk.value.slice();
        var codePoints = toCodePoints(value);
        var word_1 = '';
        codePoints.forEach(function (codePoint) {
          if (wordSeparators.indexOf(codePoint) === -1) {
            word_1 += fromCodePoint(codePoint);
          } else
          {
            if (word_1.length) {
              words.push(word_1);
            }
            words.push(fromCodePoint(codePoint));
            word_1 = '';
          }
        });
        if (word_1.length) {
          words.push(word_1);
        }
      }
    };
    while (!(bk = breaker.next()).done) {
      _loop_1();
    }
    return words;
  };

  var TextContainer = /** @class */function () {
    function TextContainer(context, node, styles) {
      this.text = transform(node.data, styles.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles, node);
    }
    return TextContainer;
  }();
  var transform = function transform(text, _transform) {
    switch (_transform) {
      case TEXT_TRANSFORM.LOWERCASE:
        return text.toLowerCase();
      case TEXT_TRANSFORM.CAPITALIZE:
        return text.replace(CAPITALIZE, capitalize);
      case TEXT_TRANSFORM.UPPERCASE:
        return text.toUpperCase();
      default:
        return text;}

  };
  var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  var capitalize = function capitalize(m, p1, p2) {
    if (m.length > 0) {
      return p1 + p2.toUpperCase();
    }
    return m;
  };

  var ImageElementContainer = /** @class */function (_super) {
    __extends(ImageElementContainer, _super);
    function ImageElementContainer(context, img) {
      var _this = _super.call(this, context, img) || this;
      _this.src = img.currentSrc || img.src;
      _this.intrinsicWidth = img.naturalWidth;
      _this.intrinsicHeight = img.naturalHeight;
      _this.context.cache.addImage(_this.src);
      return _this;
    }
    return ImageElementContainer;
  }(ElementContainer);

  var CanvasElementContainer = /** @class */function (_super) {
    __extends(CanvasElementContainer, _super);
    function CanvasElementContainer(context, canvas) {
      var _this = _super.call(this, context, canvas) || this;
      _this.canvas = canvas;
      _this.intrinsicWidth = canvas.width;
      _this.intrinsicHeight = canvas.height;
      return _this;
    }
    return CanvasElementContainer;
  }(ElementContainer);

  var SVGElementContainer = /** @class */function (_super) {
    __extends(SVGElementContainer, _super);
    function SVGElementContainer(context, img) {
      var _this = _super.call(this, context, img) || this;
      var s = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute('width', bounds.width + "px");
      img.setAttribute('height', bounds.height + "px");
      _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
      _this.intrinsicWidth = img.width.baseVal.value;
      _this.intrinsicHeight = img.height.baseVal.value;
      _this.context.cache.addImage(_this.svg);
      return _this;
    }
    return SVGElementContainer;
  }(ElementContainer);

  var LIElementContainer = /** @class */function (_super) {
    __extends(LIElementContainer, _super);
    function LIElementContainer(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return LIElementContainer;
  }(ElementContainer);

  var OLElementContainer = /** @class */function (_super) {
    __extends(OLElementContainer, _super);
    function OLElementContainer(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.start = element.start;
      _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
      return _this;
    }
    return OLElementContainer;
  }(ElementContainer);

  var CHECKBOX_BORDER_RADIUS = [
  {
    type: TokenType.DIMENSION_TOKEN,
    flags: 0,
    unit: 'px',
    number: 3 }];


  var RADIO_BORDER_RADIUS = [
  {
    type: TokenType.PERCENTAGE_TOKEN,
    flags: 0,
    number: 50 }];


  var reformatInputBounds = function reformatInputBounds(bounds) {
    if (bounds.width > bounds.height) {
      return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
    } else
    if (bounds.width < bounds.height) {
      return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
    }
    return bounds;
  };
  var getInputValue = function getInputValue(node) {
    var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
    return value.length === 0 ? node.placeholder || '' : value;
  };
  var CHECKBOX = 'checkbox';
  var RADIO = 'radio';
  var PASSWORD = 'password';
  var INPUT_COLOR = 0x2a2a2aff;
  var InputElementContainer = /** @class */function (_super) {
    __extends(InputElementContainer, _super);
    function InputElementContainer(context, input) {
      var _this = _super.call(this, context, input) || this;
      _this.type = input.type.toLowerCase();
      _this.checked = input.checked;
      _this.value = getInputValue(input);
      if (_this.type === CHECKBOX || _this.type === RADIO) {
        _this.styles.backgroundColor = 0xdededeff;
        _this.styles.borderTopColor =
        _this.styles.borderRightColor =
        _this.styles.borderBottomColor =
        _this.styles.borderLeftColor =
        0xa5a5a5ff;
        _this.styles.borderTopWidth =
        _this.styles.borderRightWidth =
        _this.styles.borderBottomWidth =
        _this.styles.borderLeftWidth =
        1;
        _this.styles.borderTopStyle =
        _this.styles.borderRightStyle =
        _this.styles.borderBottomStyle =
        _this.styles.borderLeftStyle =
        BORDER_STYLE.SOLID;
        _this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];
        _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
        _this.bounds = reformatInputBounds(_this.bounds);
      }
      switch (_this.type) {
        case CHECKBOX:
          _this.styles.borderTopRightRadius =
          _this.styles.borderTopLeftRadius =
          _this.styles.borderBottomRightRadius =
          _this.styles.borderBottomLeftRadius =
          CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this.styles.borderTopRightRadius =
          _this.styles.borderTopLeftRadius =
          _this.styles.borderBottomRightRadius =
          _this.styles.borderBottomLeftRadius =
          RADIO_BORDER_RADIUS;
          break;}

      return _this;
    }
    return InputElementContainer;
  }(ElementContainer);

  var SelectElementContainer = /** @class */function (_super) {
    __extends(SelectElementContainer, _super);
    function SelectElementContainer(context, element) {
      var _this = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this.value = option ? option.text || '' : '';
      return _this;
    }
    return SelectElementContainer;
  }(ElementContainer);

  var TextareaElementContainer = /** @class */function (_super) {
    __extends(TextareaElementContainer, _super);
    function TextareaElementContainer(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return TextareaElementContainer;
  }(ElementContainer);

  var IFrameElementContainer = /** @class */function (_super) {
    __extends(IFrameElementContainer, _super);
    function IFrameElementContainer(context, iframe) {
      var _this = _super.call(this, context, iframe) || this;
      _this.src = iframe.src;
      _this.width = parseInt(iframe.width, 10) || 0;
      _this.height = parseInt(iframe.height, 10) || 0;
      _this.backgroundColor = _this.styles.backgroundColor;
      try {
        if (iframe.contentWindow &&
        iframe.contentWindow.document &&
        iframe.contentWindow.document.documentElement) {
          _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          // http://www.w3.org/TR/css3-background/#special-backgrounds
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ?
          parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) :
          COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ?
          parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) :
          COLORS.TRANSPARENT;
          _this.backgroundColor = isTransparent(documentBackgroundColor) ?
          isTransparent(bodyBackgroundColor) ?
          _this.styles.backgroundColor :
          bodyBackgroundColor :
          documentBackgroundColor;
        }
      }
      catch (e) {}
      return _this;
    }
    return IFrameElementContainer;
  }(ElementContainer);

  var LIST_OWNERS = ['OL', 'UL', 'MENU'];
  var parseNodeTree = function parseNodeTree(context, node, parent, root) {
    for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
      nextNode = childNode.nextSibling;
      if (isTextNode(childNode) && childNode.data.trim().length > 0) {
        parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
      } else
      if (isElementNode(childNode)) {
        if (isSlotElement(childNode) && childNode.assignedNodes) {
          childNode.assignedNodes().forEach(function (childNode) {return parseNodeTree(context, childNode, parent, root);});
        } else
        {
          var container = createContainer(context, childNode);
          if (container.styles.isVisible()) {
            if (createsRealStackingContext(childNode, container, root)) {
              container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
            } else
            if (createsStackingContext(container.styles)) {
              container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
            }
            if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
              container.flags |= 8 /* IS_LIST_OWNER */;
            }
            parent.elements.push(container);
            childNode.slot;
            if (childNode.shadowRoot) {
              parseNodeTree(context, childNode.shadowRoot, container, root);
            } else
            if (!isTextareaElement(childNode) &&
            !isSVGElement(childNode) &&
            !isSelectElement(childNode)) {
              parseNodeTree(context, childNode, container, root);
            }
          }
        }
      }
    }
  };
  var createContainer = function createContainer(context, element) {
    if (isImageElement(element)) {
      return new ImageElementContainer(context, element);
    }
    if (isCanvasElement(element)) {
      return new CanvasElementContainer(context, element);
    }
    if (isSVGElement(element)) {
      return new SVGElementContainer(context, element);
    }
    if (isLIElement(element)) {
      return new LIElementContainer(context, element);
    }
    if (isOLElement(element)) {
      return new OLElementContainer(context, element);
    }
    if (isInputElement(element)) {
      return new InputElementContainer(context, element);
    }
    if (isSelectElement(element)) {
      return new SelectElementContainer(context, element);
    }
    if (isTextareaElement(element)) {
      return new TextareaElementContainer(context, element);
    }
    if (isIFrameElement(element)) {
      return new IFrameElementContainer(context, element);
    }
    return new ElementContainer(context, element);
  };
  var parseTree = function parseTree(context, element) {
    var container = createContainer(context, element);
    container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
    parseNodeTree(context, element, container, container);
    return container;
  };
  var createsRealStackingContext = function createsRealStackingContext(node, container, root) {
    return container.styles.isPositionedWithZIndex() ||
    container.styles.opacity < 1 ||
    container.styles.isTransformed() ||
    isBodyElement(node) && root.styles.isTransparent();
  };
  var createsStackingContext = function createsStackingContext(styles) {return styles.isPositioned() || styles.isFloating();};
  var isTextNode = function isTextNode(node) {return node.nodeType === Node.TEXT_NODE;};
  var isElementNode = function isElementNode(node) {return node.nodeType === Node.ELEMENT_NODE;};
  var isHTMLElementNode = function isHTMLElementNode(node) {
    return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
  };
  var isSVGElementNode = function isSVGElementNode(element) {
    return _typeof(element.className) === 'object';
  };
  var isLIElement = function isLIElement(node) {return node.tagName === 'LI';};
  var isOLElement = function isOLElement(node) {return node.tagName === 'OL';};
  var isInputElement = function isInputElement(node) {return node.tagName === 'INPUT';};
  var isHTMLElement = function isHTMLElement(node) {return node.tagName === 'HTML';};
  var isSVGElement = function isSVGElement(node) {return node.tagName === 'svg';};
  var isBodyElement = function isBodyElement(node) {return node.tagName === 'BODY';};
  var isCanvasElement = function isCanvasElement(node) {return node.tagName === 'CANVAS';};
  var isImageElement = function isImageElement(node) {return node.tagName === 'IMG';};
  var isIFrameElement = function isIFrameElement(node) {return node.tagName === 'IFRAME';};
  var isStyleElement = function isStyleElement(node) {return node.tagName === 'STYLE';};
  var isScriptElement = function isScriptElement(node) {return node.tagName === 'SCRIPT';};
  var isTextareaElement = function isTextareaElement(node) {return node.tagName === 'TEXTAREA';};
  var isSelectElement = function isSelectElement(node) {return node.tagName === 'SELECT';};
  var isSlotElement = function isSlotElement(node) {return node.tagName === 'SLOT';};

  var CounterState = /** @class */function () {
    function CounterState() {
      this.counters = {};
    }
    CounterState.prototype.getCounterValue = function (name) {
      var counter = this.counters[name];
      if (counter && counter.length) {
        return counter[counter.length - 1];
      }
      return 1;
    };
    CounterState.prototype.getCounterValues = function (name) {
      var counter = this.counters[name];
      return counter ? counter : [];
    };
    CounterState.prototype.pop = function (counters) {
      var _this = this;
      counters.forEach(function (counter) {return _this.counters[counter].pop();});
    };
    CounterState.prototype.parse = function (style) {
      var _this = this;
      var counterIncrement = style.counterIncrement;
      var counterReset = style.counterReset;
      var canReset = true;
      if (counterIncrement !== null) {
        counterIncrement.forEach(function (entry) {
          var counter = _this.counters[entry.counter];
          if (counter && entry.increment !== 0) {
            canReset = false;
            if (!counter.length) {
              counter.push(1);
            }
            counter[Math.max(0, counter.length - 1)] += entry.increment;
          }
        });
      }
      var counterNames = [];
      if (canReset) {
        counterReset.forEach(function (entry) {
          var counter = _this.counters[entry.counter];
          counterNames.push(entry.counter);
          if (!counter) {
            counter = _this.counters[entry.counter] = [];
          }
          counter.push(entry.reset);
        });
      }
      return counterNames;
    };
    return CounterState;
  }();
  var ROMAN_UPPER = {
    integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'] };

  var ARMENIAN = {
    integers: [
    9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
    60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],

    values: [
    'Ք',
    'Փ',
    'Ւ',
    'Ց',
    'Ր',
    'Տ',
    'Վ',
    'Ս',
    'Ռ',
    'Ջ',
    'Պ',
    'Չ',
    'Ո',
    'Շ',
    'Ն',
    'Յ',
    'Մ',
    'Ճ',
    'Ղ',
    'Ձ',
    'Հ',
    'Կ',
    'Ծ',
    'Խ',
    'Լ',
    'Ի',
    'Ժ',
    'Թ',
    'Ը',
    'Է',
    'Զ',
    'Ե',
    'Դ',
    'Գ',
    'Բ',
    'Ա'] };


  var HEBREW = {
    integers: [
    10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
    19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],

    values: [
    'י׳',
    'ט׳',
    'ח׳',
    'ז׳',
    'ו׳',
    'ה׳',
    'ד׳',
    'ג׳',
    'ב׳',
    'א׳',
    'ת',
    'ש',
    'ר',
    'ק',
    'צ',
    'פ',
    'ע',
    'ס',
    'נ',
    'מ',
    'ל',
    'כ',
    'יט',
    'יח',
    'יז',
    'טז',
    'טו',
    'י',
    'ט',
    'ח',
    'ז',
    'ו',
    'ה',
    'ד',
    'ג',
    'ב',
    'א'] };


  var GEORGIAN = {
    integers: [
    10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
    80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],

    values: [
    'ჵ',
    'ჰ',
    'ჯ',
    'ჴ',
    'ხ',
    'ჭ',
    'წ',
    'ძ',
    'ც',
    'ჩ',
    'შ',
    'ყ',
    'ღ',
    'ქ',
    'ფ',
    'ჳ',
    'ტ',
    'ს',
    'რ',
    'ჟ',
    'პ',
    'ო',
    'ჲ',
    'ნ',
    'მ',
    'ლ',
    'კ',
    'ი',
    'თ',
    'ჱ',
    'ზ',
    'ვ',
    'ე',
    'დ',
    'გ',
    'ბ',
    'ა'] };


  var createAdditiveCounter = function createAdditiveCounter(value, min, max, symbols, fallback, suffix) {
    if (value < min || value > max) {
      return createCounterText(value, fallback, suffix.length > 0);
    }
    return symbols.integers.reduce(function (string, integer, index) {
      while (value >= integer) {
        value -= integer;
        string += symbols.values[index];
      }
      return string;
    }, '') + suffix;
  };
  var createCounterStyleWithSymbolResolver = function createCounterStyleWithSymbolResolver(value, codePointRangeLength, isNumeric, resolver) {
    var string = '';
    do {
      if (!isNumeric) {
        value--;
      }
      string = resolver(value) + string;
      value /= codePointRangeLength;
    } while (value * codePointRangeLength >= codePointRangeLength);
    return string;
  };
  var createCounterStyleFromRange = function createCounterStyleFromRange(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
    var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
    return (value < 0 ? '-' : '') + (
    createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
      return fromCodePoint(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
    }) +
    suffix);
  };
  var createCounterStyleFromSymbols = function createCounterStyleFromSymbols(value, symbols, suffix) {
    if (suffix === void 0) {suffix = '. ';}
    var codePointRangeLength = symbols.length;
    return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) {return symbols[Math.floor(codePoint % codePointRangeLength)];}) + suffix;
  };
  var CJK_ZEROS = 1 << 0;
  var CJK_TEN_COEFFICIENTS = 1 << 1;
  var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  var createCJKCounter = function createCJKCounter(value, numbers, multipliers, negativeSign, suffix, flags) {
    if (value < -9999 || value > 9999) {
      return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
    }
    var tmp = Math.abs(value);
    var string = suffix;
    if (tmp === 0) {
      return numbers[0] + string;
    }
    for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
      var coefficient = tmp % 10;
      if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
        string = numbers[coefficient] + string;
      } else
      if (coefficient > 1 ||
      coefficient === 1 && digit === 0 ||
      coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) ||
      coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 ||
      coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
        string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
      } else
      if (coefficient === 1 && digit > 0) {
        string = multipliers[digit - 1] + string;
      }
      tmp = Math.floor(tmp / 10);
    }
    return (value < 0 ? negativeSign : '') + string;
  };
  var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
  var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
  var JAPANESE_NEGATIVE = 'マイナス';
  var KOREAN_NEGATIVE = '마이너스';
  var createCounterText = function createCounterText(value, type, appendSuffix) {
    var defaultSuffix = appendSuffix ? '. ' : '';
    var cjkSuffix = appendSuffix ? '、' : '';
    var koreanSuffix = appendSuffix ? ', ' : '';
    var spaceSuffix = appendSuffix ? ' ' : '';
    switch (type) {
      case LIST_STYLE_TYPE.DISC:
        return '•' + spaceSuffix;
      case LIST_STYLE_TYPE.CIRCLE:
        return '◦' + spaceSuffix;
      case LIST_STYLE_TYPE.SQUARE:
        return '◾' + spaceSuffix;
      case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
        var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        return string.length < 4 ? "0" + string : string;
      case LIST_STYLE_TYPE.CJK_DECIMAL:
        return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
      case LIST_STYLE_TYPE.LOWER_ROMAN:
        return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
      case LIST_STYLE_TYPE.UPPER_ROMAN:
        return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
      case LIST_STYLE_TYPE.LOWER_GREEK:
        return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
      case LIST_STYLE_TYPE.LOWER_ALPHA:
        return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
      case LIST_STYLE_TYPE.UPPER_ALPHA:
        return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
      case LIST_STYLE_TYPE.ARABIC_INDIC:
        return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
      case LIST_STYLE_TYPE.ARMENIAN:
      case LIST_STYLE_TYPE.UPPER_ARMENIAN:
        return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
      case LIST_STYLE_TYPE.LOWER_ARMENIAN:
        return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
      case LIST_STYLE_TYPE.BENGALI:
        return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
      case LIST_STYLE_TYPE.CAMBODIAN:
      case LIST_STYLE_TYPE.KHMER:
        return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
      case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
        return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
      case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
        return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
      case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
      case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
        return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
        return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
        return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
        return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case LIST_STYLE_TYPE.JAPANESE_INFORMAL:
        return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
      case LIST_STYLE_TYPE.JAPANESE_FORMAL:
        return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
        return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
        return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
      case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
        return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case LIST_STYLE_TYPE.DEVANAGARI:
        return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
      case LIST_STYLE_TYPE.GEORGIAN:
        return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
      case LIST_STYLE_TYPE.GUJARATI:
        return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
      case LIST_STYLE_TYPE.GURMUKHI:
        return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
      case LIST_STYLE_TYPE.HEBREW:
        return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
      case LIST_STYLE_TYPE.HIRAGANA:
        return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
      case LIST_STYLE_TYPE.HIRAGANA_IROHA:
        return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
      case LIST_STYLE_TYPE.KANNADA:
        return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
      case LIST_STYLE_TYPE.KATAKANA:
        return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
      case LIST_STYLE_TYPE.KATAKANA_IROHA:
        return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
      case LIST_STYLE_TYPE.LAO:
        return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
      case LIST_STYLE_TYPE.MONGOLIAN:
        return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
      case LIST_STYLE_TYPE.MYANMAR:
        return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
      case LIST_STYLE_TYPE.ORIYA:
        return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
      case LIST_STYLE_TYPE.PERSIAN:
        return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
      case LIST_STYLE_TYPE.TAMIL:
        return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
      case LIST_STYLE_TYPE.TELUGU:
        return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
      case LIST_STYLE_TYPE.THAI:
        return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
      case LIST_STYLE_TYPE.TIBETAN:
        return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
      case LIST_STYLE_TYPE.DECIMAL:
      default:
        return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);}

  };

  var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
  var DocumentCloner = /** @class */function () {
    function DocumentCloner(context, element, options) {
      this.context = context;
      this.options = options;
      this.scrolledElements = [];
      this.referenceElement = element;
      this.counters = new CounterState();
      this.quoteDepth = 0;
      if (!element.ownerDocument) {
        throw new Error('Cloned element does not have an owner document');
      }
      this.documentElement = this.cloneNode(element.ownerDocument.documentElement);
    }
    DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
      var _this = this;
      var iframe = createIFrameContainer(ownerDocument, windowSize);
      if (!iframe.contentWindow) {
        return Promise.reject("Unable to find iframe window");
      }
      var scrollX = ownerDocument.defaultView.pageXOffset;
      var scrollY = ownerDocument.defaultView.pageYOffset;
      var cloneWindow = iframe.contentWindow;
      var documentClone = cloneWindow.document;
      /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
                                                 if window url is about:blank, we can assign the url to current by writing onto the document
                                                 */
      var iframeLoad = iframeLoader(iframe).then(function () {return __awaiter(_this, void 0, void 0, function () {
          var onclone, referenceElement;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                  cloneWindow.scrollTo(windowSize.left, windowSize.top);
                  if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (
                  cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                    this.context.logger.warn('Unable to restore scroll position for cloned document');
                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                  }
                }
                onclone = this.options.onclone;
                referenceElement = this.clonedReferenceElement;
                if (typeof referenceElement === 'undefined') {
                  return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                }
                if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
                return [4 /*yield*/, documentClone.fonts.ready];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
                return [4 /*yield*/, imagesReady(documentClone)];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                if (typeof onclone === 'function') {
                  return [2 /*return*/, Promise.resolve().
                  then(function () {return onclone(documentClone, referenceElement);}).
                  then(function () {return iframe;})];
                }
                return [2 /*return*/, iframe];}

          });
        });});
      documentClone.open();
      documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
      // Chrome scrolls the parent document for some reason after the write to the cloned window???
      restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
      documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
      documentClone.close();
      return iframeLoad;
    };
    DocumentCloner.prototype.createElementClone = function (node) {
      if (isCanvasElement(node)) {
        return this.createCanvasClone(node);
      }
      if (isStyleElement(node)) {
        return this.createStyleClone(node);
      }
      var clone = node.cloneNode(false);
      if (isImageElement(clone)) {
        if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
          clone.src = node.currentSrc;
          clone.srcset = '';
        }
        if (clone.loading === 'lazy') {
          clone.loading = 'eager';
        }
      }
      return clone;
    };
    DocumentCloner.prototype.createStyleClone = function (node) {
      try {
        var sheet = node.sheet;
        if (sheet && sheet.cssRules) {
          var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
            if (rule && typeof rule.cssText === 'string') {
              return css + rule.cssText;
            }
            return css;
          }, '');
          var style = node.cloneNode(false);
          style.textContent = css;
          return style;
        }
      }
      catch (e) {
        // accessing node.sheet.cssRules throws a DOMException
        this.context.logger.error('Unable to access cssRules property', e);
        if (e.name !== 'SecurityError') {
          throw e;
        }
      }
      return node.cloneNode(false);
    };
    DocumentCloner.prototype.createCanvasClone = function (canvas) {
      if (this.options.inlineImages && canvas.ownerDocument) {
        var img = canvas.ownerDocument.createElement('img');
        try {
          img.src = canvas.toDataURL();
          return img;
        }
        catch (e) {
          this.context.logger.info("Unable to clone canvas contents, canvas is tainted");
        }
      }
      var clonedCanvas = canvas.cloneNode(false);
      try {
        clonedCanvas.width = canvas.width;
        clonedCanvas.height = canvas.height;
        var ctx = canvas.getContext('2d');
        var clonedCtx = clonedCanvas.getContext('2d');
        if (clonedCtx) {
          if (ctx) {
            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
          } else
          {
            clonedCtx.drawImage(canvas, 0, 0);
          }
        }
        return clonedCanvas;
      }
      catch (e) {}
      return clonedCanvas;
    };
    DocumentCloner.prototype.cloneNode = function (node) {
      if (isTextNode(node)) {
        return document.createTextNode(node.data);
      }
      if (!node.ownerDocument) {
        return node.cloneNode(false);
      }
      var window = node.ownerDocument.defaultView;
      if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
        var clone = this.createElementClone(node);
        var style = window.getComputedStyle(node);
        var styleBefore = window.getComputedStyle(node, ':before');
        var styleAfter = window.getComputedStyle(node, ':after');
        if (this.referenceElement === node && isHTMLElementNode(clone)) {
          this.clonedReferenceElement = clone;
        }
        if (isBodyElement(clone)) {
          createPseudoHideStyles(clone);
        }
        var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
        for (var child = node.firstChild; child; child = child.nextSibling) {
          if (!isElementNode(child) ||
          !isScriptElement(child) &&
          !child.hasAttribute(IGNORE_ATTRIBUTE) && (
          typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child))) {
            if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
              clone.appendChild(this.cloneNode(child));
            }
          }
        }
        if (before) {
          clone.insertBefore(before, clone.firstChild);
        }
        var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
        if (after) {
          clone.appendChild(after);
        }
        this.counters.pop(counters);
        if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) {
          copyCSSStyles(style, clone);
        }
        if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
          this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
        }
        if ((isTextareaElement(node) || isSelectElement(node)) && (
        isTextareaElement(clone) || isSelectElement(clone))) {
          clone.value = node.value;
        }
        return clone;
      }
      return node.cloneNode(false);
    };
    DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
      var _this = this;
      if (!style) {
        return;
      }
      var value = style.content;
      var document = clone.ownerDocument;
      if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
        return;
      }
      this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
      var declaration = new CSSParsedPseudoDeclaration(this.context, style);
      var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
      copyCSSStyles(style, anonymousReplacedElement);
      declaration.content.forEach(function (token) {
        if (token.type === TokenType.STRING_TOKEN) {
          anonymousReplacedElement.appendChild(document.createTextNode(token.value));
        } else
        if (token.type === TokenType.URL_TOKEN) {
          var img = document.createElement('img');
          img.src = token.value;
          img.style.opacity = '1';
          anonymousReplacedElement.appendChild(img);
        } else
        if (token.type === TokenType.FUNCTION) {
          if (token.name === 'attr') {
            var attr = token.values.filter(isIdentToken);
            if (attr.length) {
              anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
            }
          } else
          if (token.name === 'counter') {
            var _a = token.values.filter(nonFunctionArgSeparator),counter = _a[0],counterStyle = _a[1];
            if (counter && isIdentToken(counter)) {
              var counterState = _this.counters.getCounterValue(counter.value);
              var counterType = counterStyle && isIdentToken(counterStyle) ?
              listStyleType.parse(_this.context, counterStyle.value) :
              LIST_STYLE_TYPE.DECIMAL;
              anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
            }
          } else
          if (token.name === 'counters') {
            var _b = token.values.filter(nonFunctionArgSeparator),counter = _b[0],delim = _b[1],counterStyle = _b[2];
            if (counter && isIdentToken(counter)) {
              var counterStates = _this.counters.getCounterValues(counter.value);
              var counterType_1 = counterStyle && isIdentToken(counterStyle) ?
              listStyleType.parse(_this.context, counterStyle.value) :
              LIST_STYLE_TYPE.DECIMAL;
              var separator = delim && delim.type === TokenType.STRING_TOKEN ? delim.value : '';
              var text = counterStates.
              map(function (value) {return createCounterText(value, counterType_1, false);}).
              join(separator);
              anonymousReplacedElement.appendChild(document.createTextNode(text));
            }
          } else
          ;
        } else
        if (token.type === TokenType.IDENT_TOKEN) {
          switch (token.value) {
            case 'open-quote':
              anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
              break;
            case 'close-quote':
              anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
              break;
            default:
              // safari doesn't parse string tokens correctly because of lack of quotes
              anonymousReplacedElement.appendChild(document.createTextNode(token.value));}

        }
      });
      anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      var newClassName = pseudoElt === PseudoElementType.BEFORE ?
      " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE :
      " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      if (isSVGElementNode(clone)) {
        clone.className.baseValue += newClassName;
      } else
      {
        clone.className += newClassName;
      }
      return anonymousReplacedElement;
    };
    DocumentCloner.destroy = function (container) {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
        return true;
      }
      return false;
    };
    return DocumentCloner;
  }();
  var PseudoElementType;
  (function (PseudoElementType) {
    PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
    PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
  })(PseudoElementType || (PseudoElementType = {}));
  var createIFrameContainer = function createIFrameContainer(ownerDocument, bounds) {
    var cloneIframeContainer = ownerDocument.createElement('iframe');
    cloneIframeContainer.className = 'html2canvas-container';
    cloneIframeContainer.style.visibility = 'hidden';
    cloneIframeContainer.style.position = 'fixed';
    cloneIframeContainer.style.left = '-10000px';
    cloneIframeContainer.style.top = '0px';
    cloneIframeContainer.style.border = '0';
    cloneIframeContainer.width = bounds.width.toString();
    cloneIframeContainer.height = bounds.height.toString();
    cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
    cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
    ownerDocument.body.appendChild(cloneIframeContainer);
    return cloneIframeContainer;
  };
  var imageReady = function imageReady(img) {
    return new Promise(function (resolve) {
      if (img.complete) {
        resolve();
        return;
      }
      if (!img.src) {
        resolve();
        return;
      }
      img.onload = resolve;
      img.onerror = resolve;
    });
  };
  var imagesReady = function imagesReady(document) {
    return Promise.all([].slice.call(document.images, 0).map(imageReady));
  };
  var iframeLoader = function iframeLoader(iframe) {
    return new Promise(function (resolve, reject) {
      var cloneWindow = iframe.contentWindow;
      if (!cloneWindow) {
        return reject("No window assigned for iframe");
      }
      var documentClone = cloneWindow.document;
      cloneWindow.onload = iframe.onload = function () {
        cloneWindow.onload = iframe.onload = null;
        var interval = setInterval(function () {
          if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
            clearInterval(interval);
            resolve(iframe);
          }
        }, 50);
      };
    });
  };
  var ignoredStyleProperties = [
  'all',
  'd',
  'content' // Safari shows pseudoelements if content is set
  ];
  var copyCSSStyles = function copyCSSStyles(style, target) {
    // Edge does not provide value for cssText
    for (var i = style.length - 1; i >= 0; i--) {
      var property = style.item(i);
      if (ignoredStyleProperties.indexOf(property) === -1) {
        target.style.setProperty(property, style.getPropertyValue(property));
      }
    }
    return target;
  };
  var serializeDoctype = function serializeDoctype(doctype) {
    var str = '';
    if (doctype) {
      str += '<!DOCTYPE ';
      if (doctype.name) {
        str += doctype.name;
      }
      if (doctype.internalSubset) {
        str += doctype.internalSubset;
      }
      if (doctype.publicId) {
        str += "\"" + doctype.publicId + "\"";
      }
      if (doctype.systemId) {
        str += "\"" + doctype.systemId + "\"";
      }
      str += '>';
    }
    return str;
  };
  var restoreOwnerScroll = function restoreOwnerScroll(ownerDocument, x, y) {
    if (ownerDocument &&
    ownerDocument.defaultView && (
    x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
      ownerDocument.defaultView.scrollTo(x, y);
    }
  };
  var restoreNodeScroll = function restoreNodeScroll(_a) {
    var element = _a[0],x = _a[1],y = _a[2];
    element.scrollLeft = x;
    element.scrollTop = y;
  };
  var PSEUDO_BEFORE = ':before';
  var PSEUDO_AFTER = ':after';
  var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
  var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
  var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
  var createPseudoHideStyles = function createPseudoHideStyles(body) {
    createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  };
  var createStyles = function createStyles(body, styles) {
    var document = body.ownerDocument;
    if (document) {
      var style = document.createElement('style');
      style.textContent = styles;
      body.appendChild(style);
    }
  };

  var CacheStorage = /** @class */function () {
    function CacheStorage() {
    }
    CacheStorage.getOrigin = function (url) {
      var link = CacheStorage._link;
      if (!link) {
        return 'about:blank';
      }
      link.href = url;
      link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
      return link.protocol + link.hostname + link.port;
    };
    CacheStorage.isSameOrigin = function (src) {
      return CacheStorage.getOrigin(src) === CacheStorage._origin;
    };
    CacheStorage.setContext = function (window) {
      CacheStorage._link = window.document.createElement('a');
      CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
    };
    CacheStorage._origin = 'about:blank';
    return CacheStorage;
  }();
  var Cache = /** @class */function () {
    function Cache(context, _options) {
      this.context = context;
      this._options = _options;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._cache = {};
    }
    Cache.prototype.addImage = function (src) {
      var result = Promise.resolve();
      if (this.has(src)) {
        return result;
      }
      if (isBlobImage(src) || isRenderable(src)) {
        (this._cache[src] = this.loadImage(src)).catch(function () {
          // prevent unhandled rejection
        });
        return result;
      }
      return result;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Cache.prototype.match = function (src) {
      return this._cache[src];
    };
    Cache.prototype.loadImage = function (key) {
      return __awaiter(this, void 0, void 0, function () {
        var isSameOrigin, useCORS, useProxy, src;
        var _this = this;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              isSameOrigin = CacheStorage.isSameOrigin(key);
              useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
              useProxy = !isInlineImage(key) &&
              !isSameOrigin &&
              !isBlobImage(key) &&
              typeof this._options.proxy === 'string' &&
              FEATURES.SUPPORT_CORS_XHR &&
              !useCORS;
              if (!isSameOrigin &&
              this._options.allowTaint === false &&
              !isInlineImage(key) &&
              !isBlobImage(key) &&
              !useProxy &&
              !useCORS) {
                return [2 /*return*/];
              }
              src = key;
              if (!useProxy) return [3 /*break*/, 2];
              return [4 /*yield*/, this.proxy(src)];
            case 1:
              src = _a.sent();
              _a.label = 2;
            case 2:
              this.context.logger.debug("Added image " + key.substring(0, 256));
              return [4 /*yield*/, new Promise(function (resolve, reject) {
                var img = new Image();
                img.onload = function () {return resolve(img);};
                img.onerror = reject;
                //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                if (isInlineBase64Image(src) || useCORS) {
                  img.crossOrigin = 'anonymous';
                }
                img.src = src;
                if (img.complete === true) {
                  // Inline XML images may fail to parse, throwing an Error later on
                  setTimeout(function () {return resolve(img);}, 500);
                }
                if (_this._options.imageTimeout > 0) {
                  setTimeout(function () {return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");}, _this._options.imageTimeout);
                }
              })];
            case 3:return [2 /*return*/, _a.sent()];}

        });
      });
    };
    Cache.prototype.has = function (key) {
      return typeof this._cache[key] !== 'undefined';
    };
    Cache.prototype.keys = function () {
      return Promise.resolve(Object.keys(this._cache));
    };
    Cache.prototype.proxy = function (src) {
      var _this = this;
      var proxy = this._options.proxy;
      if (!proxy) {
        throw new Error('No proxy defined');
      }
      var key = src.substring(0, 256);
      return new Promise(function (resolve, reject) {
        var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
        var xhr = new XMLHttpRequest();
        xhr.onload = function () {
          if (xhr.status === 200) {
            if (responseType === 'text') {
              resolve(xhr.response);
            } else
            {
              var reader_1 = new FileReader();
              reader_1.addEventListener('load', function () {return resolve(reader_1.result);}, false);
              reader_1.addEventListener('error', function (e) {return reject(e);}, false);
              reader_1.readAsDataURL(xhr.response);
            }
          } else
          {
            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
          }
        };
        xhr.onerror = reject;
        var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
        xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
        if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
          xhr.responseType = responseType;
        }
        if (_this._options.imageTimeout) {
          var timeout_1 = _this._options.imageTimeout;
          xhr.timeout = timeout_1;
          xhr.ontimeout = function () {return reject("Timed out (" + timeout_1 + "ms) proxying " + key);};
        }
        xhr.send();
      });
    };
    return Cache;
  }();
  var INLINE_SVG = /^data:image\/svg\+xml/i;
  var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  var INLINE_IMG = /^data:image\/.*/i;
  var isRenderable = function isRenderable(src) {return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);};
  var isInlineImage = function isInlineImage(src) {return INLINE_IMG.test(src);};
  var isInlineBase64Image = function isInlineBase64Image(src) {return INLINE_BASE64.test(src);};
  var isBlobImage = function isBlobImage(src) {return src.substr(0, 4) === 'blob';};
  var isSVG = function isSVG(src) {return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src);};

  var PathType;
  (function (PathType) {
    PathType[PathType["VECTOR"] = 0] = "VECTOR";
    PathType[PathType["BEZIER_CURVE"] = 1] = "BEZIER_CURVE";
  })(PathType || (PathType = {}));
  var equalPath = function equalPath(a, b) {
    if (a.length === b.length) {
      return a.some(function (v, i) {return v === b[i];});
    }
    return false;
  };
  var transformPath = function transformPath(path, deltaX, deltaY, deltaW, deltaH) {
    return path.map(function (point, index) {
      switch (index) {
        case 0:
          return point.add(deltaX, deltaY);
        case 1:
          return point.add(deltaX + deltaW, deltaY);
        case 2:
          return point.add(deltaX + deltaW, deltaY + deltaH);
        case 3:
          return point.add(deltaX, deltaY + deltaH);}

      return point;
    });
  };

  var Vector = /** @class */function () {
    function Vector(x, y) {
      this.type = PathType.VECTOR;
      this.x = x;
      this.y = y;
    }
    Vector.prototype.add = function (deltaX, deltaY) {
      return new Vector(this.x + deltaX, this.y + deltaY);
    };
    return Vector;
  }();

  var lerp = function lerp(a, b, t) {
    return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
  };
  var BezierCurve = /** @class */function () {
    function BezierCurve(start, startControl, endControl, end) {
      this.type = PathType.BEZIER_CURVE;
      this.start = start;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end;
    }
    BezierCurve.prototype.subdivide = function (t, firstHalf) {
      var ab = lerp(this.start, this.startControl, t);
      var bc = lerp(this.startControl, this.endControl, t);
      var cd = lerp(this.endControl, this.end, t);
      var abbc = lerp(ab, bc, t);
      var bccd = lerp(bc, cd, t);
      var dest = lerp(abbc, bccd, t);
      return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
    };
    BezierCurve.prototype.add = function (deltaX, deltaY) {
      return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve.prototype.reverse = function () {
      return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve;
  }();
  var isBezierCurve = function isBezierCurve(path) {return path.type === PathType.BEZIER_CURVE;};

  var BoundCurves = /** @class */function () {
    function BoundCurves(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height),tlh = _a[0],tlv = _a[1];
      var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height),trh = _b[0],trv = _b[1];
      var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height),brh = _c[0],brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height),blh = _d[0],blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth = styles.borderTopWidth;
      var borderRightWidth = styles.borderRightWidth;
      var borderBottomWidth = styles.borderBottomWidth;
      var borderLeftWidth = styles.borderLeftWidth;
      var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
      var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
      var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
      var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT) :
      new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
      this.topRightBorderDoubleOuterBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
      this.bottomRightBorderDoubleOuterBox =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
      this.bottomLeftBorderDoubleOuterBox =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
      this.topLeftBorderDoubleInnerBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth * 2 / 3, bounds.top + borderTopWidth * 2 / 3, tlh - borderLeftWidth * 2 / 3, tlv - borderTopWidth * 2 / 3, CORNER.TOP_LEFT) :
      new Vector(bounds.left + borderLeftWidth * 2 / 3, bounds.top + borderTopWidth * 2 / 3);
      this.topRightBorderDoubleInnerBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth * 2 / 3, trh - borderRightWidth * 2 / 3, trv - borderTopWidth * 2 / 3, CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth * 2 / 3, bounds.top + borderTopWidth * 2 / 3);
      this.bottomRightBorderDoubleInnerBox =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth * 2 / 3, brv - borderBottomWidth * 2 / 3, CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth * 2 / 3, bounds.top + bounds.height - borderBottomWidth * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth * 2 / 3, blv - borderBottomWidth * 2 / 3, CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left + borderLeftWidth * 2 / 3, bounds.top + bounds.height - borderBottomWidth * 2 / 3);
      this.topLeftBorderStroke =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT) :
      new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
      this.topRightBorderStroke =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
      this.bottomRightBorderStroke =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
      this.bottomLeftBorderStroke =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
      this.topLeftBorderBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) :
      new Vector(bounds.left, bounds.top);
      this.topRightBorderBox =
      trh > 0 || trv > 0 ?
      getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT) :
      new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
      this.topRightPaddingBox =
      trh > 0 || trv > 0 ?
      getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
      this.bottomRightPaddingBox =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
      this.bottomLeftPaddingBox =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
      this.topLeftContentBox =
      tlh > 0 || tlv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT) :
      new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
      this.topRightContentBox =
      trh > 0 || trv > 0 ?
      getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT) :
      new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
      this.bottomRightContentBox =
      brh > 0 || brv > 0 ?
      getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT) :
      new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
      this.bottomLeftContentBox =
      blh > 0 || blv > 0 ?
      getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT) :
      new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
    }
    return BoundCurves;
  }();
  var CORNER;
  (function (CORNER) {
    CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
    CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
    CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
    CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  })(CORNER || (CORNER = {}));
  var getCurvePoints = function getCurvePoints(x, y, r1, r2, position) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = r1 * kappa; // control point offset horizontal
    var oy = r2 * kappa; // control point offset vertical
    var xm = x + r1; // x-middle
    var ym = y + r2; // y-middle
    switch (position) {
      case CORNER.TOP_LEFT:
        return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
      case CORNER.TOP_RIGHT:
        return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
      case CORNER.BOTTOM_RIGHT:
        return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
      case CORNER.BOTTOM_LEFT:
      default:
        return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));}

  };
  var calculateBorderBoxPath = function calculateBorderBoxPath(curves) {
    return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  };
  var calculateContentBoxPath = function calculateContentBoxPath(curves) {
    return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox];

  };
  var calculatePaddingBoxPath = function calculatePaddingBoxPath(curves) {
    return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox];

  };

  var TransformEffect = /** @class */function () {
    function TransformEffect(offsetX, offsetY, matrix) {
      this.type = 0 /* TRANSFORM */;
      this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix;
    }
    return TransformEffect;
  }();
  var ClipEffect = /** @class */function () {
    function ClipEffect(path, target) {
      this.type = 1 /* CLIP */;
      this.target = target;
      this.path = path;
    }
    return ClipEffect;
  }();
  var OpacityEffect = /** @class */function () {
    function OpacityEffect(opacity) {
      this.type = 2 /* OPACITY */;
      this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      this.opacity = opacity;
    }
    return OpacityEffect;
  }();
  var isTransformEffect = function isTransformEffect(effect) {
    return effect.type === 0 /* TRANSFORM */;
  };
  var isClipEffect = function isClipEffect(effect) {return effect.type === 1 /* CLIP */;};
  var isOpacityEffect = function isOpacityEffect(effect) {return effect.type === 2 /* OPACITY */;};

  var StackingContext = /** @class */function () {
    function StackingContext(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext;
  }();
  var ElementPaint = /** @class */function () {
    function ElementPaint(element, parentStack) {
      this.container = element;
      this.effects = parentStack.slice(0);
      this.curves = new BoundCurves(element);
      if (element.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(element.styles.opacity));
      }
      if (element.styles.transform !== null) {
        var offsetX = element.bounds.left + element.styles.transformOrigin[0].number;
        var offsetY = element.bounds.top + element.styles.transformOrigin[1].number;
        var matrix = element.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
      }
      if (element.styles.overflowX !== OVERFLOW.VISIBLE) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox)) {
          this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
        } else
        {
          this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
          this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
        }
      }
    }
    ElementPaint.prototype.getParentEffects = function () {
      var effects = this.effects.slice(0);
      if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox = calculatePaddingBoxPath(this.curves);
        if (!equalPath(borderBox, paddingBox)) {
          effects.push(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
        }
      }
      return effects;
    };
    return ElementPaint;
  }();
  var parseStackTree = function parseStackTree(parent, stackingContext, realStackingContext, listItems) {
    parent.container.elements.forEach(function (child) {
      var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
      var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
      var paintContainer = new ElementPaint(child, parent.getParentEffects());
      if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
        listItems.push(paintContainer);
      }
      var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
      if (treatAsRealStackingContext || createsStackingContext) {
        var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
        var stack = new StackingContext(paintContainer);
        if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
          var order_1 = child.styles.zIndex.order;
          if (order_1 < 0) {
            var index_1 = 0;
            parentStack.negativeZIndex.some(function (current, i) {
              if (order_1 > current.element.container.styles.zIndex.order) {
                index_1 = i;
                return false;
              } else
              if (index_1 > 0) {
                return true;
              }
              return false;
            });
            parentStack.negativeZIndex.splice(index_1, 0, stack);
          } else
          if (order_1 > 0) {
            var index_2 = 0;
            parentStack.positiveZIndex.some(function (current, i) {
              if (order_1 >= current.element.container.styles.zIndex.order) {
                index_2 = i + 1;
                return false;
              } else
              if (index_2 > 0) {
                return true;
              }
              return false;
            });
            parentStack.positiveZIndex.splice(index_2, 0, stack);
          } else
          {
            parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
          }
        } else
        {
          if (child.styles.isFloating()) {
            parentStack.nonPositionedFloats.push(stack);
          } else
          {
            parentStack.nonPositionedInlineLevel.push(stack);
          }
        }
        parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
      } else
      {
        if (child.styles.isInlineLevel()) {
          stackingContext.inlineLevel.push(paintContainer);
        } else
        {
          stackingContext.nonInlineLevel.push(paintContainer);
        }
        parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
      }
      if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
        processListItems(child, listOwnerItems);
      }
    });
  };
  var processListItems = function processListItems(owner, elements) {
    var numbering = owner instanceof OLElementContainer ? owner.start : 1;
    var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
    for (var i = 0; i < elements.length; i++) {
      var item = elements[i];
      if (item.container instanceof LIElementContainer &&
      typeof item.container.value === 'number' &&
      item.container.value !== 0) {
        numbering = item.container.value;
      }
      item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
      numbering += reversed ? -1 : 1;
    }
  };
  var parseStackingContexts = function parseStackingContexts(container) {
    var paintContainer = new ElementPaint(container, []);
    var root = new StackingContext(paintContainer);
    var listItems = [];
    parseStackTree(paintContainer, root, root, listItems);
    processListItems(paintContainer.container, listItems);
    return root;
  };

  var parsePathForBorder = function parsePathForBorder(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);}

  };
  var parsePathForBorderDoubleOuter = function parsePathForBorderDoubleOuter(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);}

  };
  var parsePathForBorderDoubleInner = function parsePathForBorderDoubleInner(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);}

  };
  var parsePathForBorderStroke = function parsePathForBorderStroke(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
      case 1:
        return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
      case 2:
        return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
      case 3:
      default:
        return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);}

  };
  var createStrokePathFromCurves = function createStrokePathFromCurves(outer1, outer2) {
    var path = [];
    if (isBezierCurve(outer1)) {
      path.push(outer1.subdivide(0.5, false));
    } else
    {
      path.push(outer1);
    }
    if (isBezierCurve(outer2)) {
      path.push(outer2.subdivide(0.5, true));
    } else
    {
      path.push(outer2);
    }
    return path;
  };
  var createPathFromCurves = function createPathFromCurves(outer1, inner1, outer2, inner2) {
    var path = [];
    if (isBezierCurve(outer1)) {
      path.push(outer1.subdivide(0.5, false));
    } else
    {
      path.push(outer1);
    }
    if (isBezierCurve(outer2)) {
      path.push(outer2.subdivide(0.5, true));
    } else
    {
      path.push(outer2);
    }
    if (isBezierCurve(inner2)) {
      path.push(inner2.subdivide(0.5, true).reverse());
    } else
    {
      path.push(inner2);
    }
    if (isBezierCurve(inner1)) {
      path.push(inner1.subdivide(0.5, false).reverse());
    } else
    {
      path.push(inner1);
    }
    return path;
  };

  var paddingBox = function paddingBox(element) {
    var bounds = element.bounds;
    var styles = element.styles;
    return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  };
  var contentBox = function contentBox(element) {
    var styles = element.styles;
    var bounds = element.bounds;
    var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
    var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
    var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
    var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
    return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
  };

  var calculateBackgroundPositioningArea = function calculateBackgroundPositioningArea(backgroundOrigin, element) {
    if (backgroundOrigin === 0 /* BORDER_BOX */) {
        return element.bounds;
      }
    if (backgroundOrigin === 2 /* CONTENT_BOX */) {
        return contentBox(element);
      }
    return paddingBox(element);
  };
  var calculateBackgroundPaintingArea = function calculateBackgroundPaintingArea(backgroundClip, element) {
    if (backgroundClip === BACKGROUND_CLIP.BORDER_BOX) {
      return element.bounds;
    }
    if (backgroundClip === BACKGROUND_CLIP.CONTENT_BOX) {
      return contentBox(element);
    }
    return paddingBox(element);
  };
  var calculateBackgroundRendering = function calculateBackgroundRendering(container, index, intrinsicSize) {
    var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
    var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
    var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
    var sizeWidth = backgroundImageSize[0],sizeHeight = backgroundImageSize[1];
    var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
    var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
    var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
    var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
    return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  };
  var isAuto = function isAuto(token) {return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;};
  var hasIntrinsicValue = function hasIntrinsicValue(value) {return typeof value === 'number';};
  var calculateBackgroundSize = function calculateBackgroundSize(size, _a, bounds) {
    var intrinsicWidth = _a[0],intrinsicHeight = _a[1],intrinsicProportion = _a[2];
    var first = size[0],second = size[1];
    if (!first) {
      return [0, 0];
    }
    if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
      return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
    }
    var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
    if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
      if (hasIntrinsicValue(intrinsicProportion)) {
        var targetRatio = bounds.width / bounds.height;
        return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ?
        [bounds.width, bounds.width / intrinsicProportion] :
        [bounds.height * intrinsicProportion, bounds.height];
      }
      return [bounds.width, bounds.height];
    }
    var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
    var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
    var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
    // If the background-size is auto or auto auto:
    if (isAuto(first) && (!second || isAuto(second))) {
      // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
      if (hasIntrinsicWidth && hasIntrinsicHeight) {
        return [intrinsicWidth, intrinsicHeight];
      }
      // If the image has no intrinsic dimensions and has no intrinsic proportions,
      // it's rendered at the size of the background positioning area.
      if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
        return [bounds.width, bounds.height];
      }
      // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
      // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
      // The other dimension is computed using the specified dimension and the intrinsic proportions.
      if (hasIntrinsicDimensions && hasIntrinsicProportion) {
        var width_1 = hasIntrinsicWidth ?
        intrinsicWidth :
        intrinsicHeight * intrinsicProportion;
        var height_1 = hasIntrinsicHeight ?
        intrinsicHeight :
        intrinsicWidth / intrinsicProportion;
        return [width_1, height_1];
      }
      // If the image has only one intrinsic dimension but has no intrinsic proportions,
      // it's rendered using the specified dimension and the other dimension of the background positioning area.
      var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
      var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
      return [width_2, height_2];
    }
    // If the image has intrinsic proportions, it's stretched to the specified dimension.
    // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
    if (hasIntrinsicProportion) {
      var width_3 = 0;
      var height_3 = 0;
      if (isLengthPercentage(first)) {
        width_3 = getAbsoluteValue(first, bounds.width);
      } else
      if (isLengthPercentage(second)) {
        height_3 = getAbsoluteValue(second, bounds.height);
      }
      if (isAuto(first)) {
        width_3 = height_3 * intrinsicProportion;
      } else
      if (!second || isAuto(second)) {
        height_3 = width_3 / intrinsicProportion;
      }
      return [width_3, height_3];
    }
    // If the image has no intrinsic proportions, it's stretched to the specified dimension.
    // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
    // if there is one. If there is no such intrinsic dimension,
    // it becomes the corresponding dimension of the background positioning area.
    var width = null;
    var height = null;
    if (isLengthPercentage(first)) {
      width = getAbsoluteValue(first, bounds.width);
    } else
    if (second && isLengthPercentage(second)) {
      height = getAbsoluteValue(second, bounds.height);
    }
    if (width !== null && (!second || isAuto(second))) {
      height =
      hasIntrinsicWidth && hasIntrinsicHeight ?
      width / intrinsicWidth * intrinsicHeight :
      bounds.height;
    }
    if (height !== null && isAuto(first)) {
      width =
      hasIntrinsicWidth && hasIntrinsicHeight ?
      height / intrinsicHeight * intrinsicWidth :
      bounds.width;
    }
    if (width !== null && height !== null) {
      return [width, height];
    }
    throw new Error("Unable to calculate background-size for element");
  };
  var getBackgroundValueForIndex = function getBackgroundValueForIndex(values, index) {
    var value = values[index];
    if (typeof value === 'undefined') {
      return values[0];
    }
    return value;
  };
  var calculateBackgroundRepeatPath = function calculateBackgroundRepeatPath(repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
    var x = _a[0],y = _a[1];
    var width = _b[0],height = _b[1];
    switch (repeat) {
      case BACKGROUND_REPEAT.REPEAT_X:
        return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))];

      case BACKGROUND_REPEAT.REPEAT_Y:
        return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))];

      case BACKGROUND_REPEAT.NO_REPEAT:
        return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))];

      default:
        return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))];}


  };

  var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

  var SAMPLE_TEXT = 'Hidden Text';
  var FontMetrics = /** @class */function () {
    function FontMetrics(document) {
      this._data = {};
      this._document = document;
    }
    FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
      var container = this._document.createElement('div');
      var img = this._document.createElement('img');
      var span = this._document.createElement('span');
      var body = this._document.body;
      container.style.visibility = 'hidden';
      container.style.fontFamily = fontFamily;
      container.style.fontSize = fontSize;
      container.style.margin = '0';
      container.style.padding = '0';
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = '0';
      img.style.padding = '0';
      img.style.verticalAlign = 'baseline';
      span.style.fontFamily = fontFamily;
      span.style.fontSize = fontSize;
      span.style.margin = '0';
      span.style.padding = '0';
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = 'normal';
      img.style.verticalAlign = 'super';
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline: baseline, middle: middle };
    };
    FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
      var key = fontFamily + " " + fontSize;
      if (typeof this._data[key] === 'undefined') {
        this._data[key] = this.parseMetrics(fontFamily, fontSize);
      }
      return this._data[key];
    };
    return FontMetrics;
  }();

  var Renderer = /** @class */function () {
    function Renderer(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer;
  }();

  var MASK_OFFSET = 10000;
  var CanvasRenderer = /** @class */function (_super) {
    __extends(CanvasRenderer, _super);
    function CanvasRenderer(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this._activeEffects = [];
      _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
      _this.ctx = _this.canvas.getContext('2d');
      if (!options.canvas) {
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
      }
      _this.fontMetrics = new FontMetrics(document);
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.ctx.textBaseline = 'bottom';
      _this._activeEffects = [];
      _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
      return _this;
    }
    CanvasRenderer.prototype.applyEffects = function (effects, target) {
      var _this = this;
      while (this._activeEffects.length) {
        this.popEffect();
      }
      effects.filter(function (effect) {return contains(effect.target, target);}).forEach(function (effect) {return _this.applyEffect(effect);});
    };
    CanvasRenderer.prototype.applyEffect = function (effect) {
      this.ctx.save();
      if (isOpacityEffect(effect)) {
        this.ctx.globalAlpha = effect.opacity;
      }
      if (isTransformEffect(effect)) {
        this.ctx.translate(effect.offsetX, effect.offsetY);
        this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
        this.ctx.translate(-effect.offsetX, -effect.offsetY);
      }
      if (isClipEffect(effect)) {
        this.path(effect.path);
        this.ctx.clip();
      }
      this._activeEffects.push(effect);
    };
    CanvasRenderer.prototype.popEffect = function () {
      this._activeEffects.pop();
      this.ctx.restore();
    };
    CanvasRenderer.prototype.renderStack = function (stack) {
      return __awaiter(this, void 0, void 0, function () {
        var styles;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              styles = stack.element.container.styles;
              if (!styles.isVisible()) return [3 /*break*/, 2];
              return [4 /*yield*/, this.renderStackContent(stack)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderNode = function (paint) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
              return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
            case 1:
              _a.sent();
              return [4 /*yield*/, this.renderNodeContent(paint)];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
      var _this = this;
      if (letterSpacing === 0) {
        this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
      } else
      {
        var letters = toCodePoints(text.text).map(function (i) {return fromCodePoint(i);});
        letters.reduce(function (left, letter) {
          _this.ctx.fillText(letter, left, text.bounds.top + baseline);
          return left + _this.ctx.measureText(letter).width;
        }, text.bounds.left);
      }
    };
    CanvasRenderer.prototype.createFontStyle = function (styles) {
      var fontVariant = styles.fontVariant.
      filter(function (variant) {return variant === 'normal' || variant === 'small-caps';}).
      join('');
      var fontFamily = styles.fontFamily.join(', ');
      var fontSize = isDimensionToken(styles.fontSize) ?
      "" + styles.fontSize.number + styles.fontSize.unit :
      styles.fontSize.number + "px";
      return [
      [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
      fontFamily,
      fontSize];

    };
    CanvasRenderer.prototype.renderTextNode = function (text, styles) {
      return __awaiter(this, void 0, void 0, function () {
        var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
        var _this = this;
        return __generator(this, function (_c) {
          _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
          this.ctx.font = font;
          this.ctx.textBaseline = 'alphabetic';
          _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
          paintOrder = styles.paintOrder;
          text.textBounds.forEach(function (text) {
            paintOrder.forEach(function (paintOrderLayer) {
              switch (paintOrderLayer) {
                case PAINT_ORDER_LAYER.FILL:
                  _this.ctx.fillStyle = asString(styles.color);
                  _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                  var textShadows = styles.textShadow;
                  if (textShadows.length && text.text.trim().length) {
                    textShadows.
                    slice(0).
                    reverse().
                    forEach(function (textShadow) {
                      _this.ctx.shadowColor = asString(textShadow.color);
                      _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                      _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                      _this.ctx.shadowBlur = textShadow.blur.number;
                      _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                    });
                    _this.ctx.shadowColor = '';
                    _this.ctx.shadowOffsetX = 0;
                    _this.ctx.shadowOffsetY = 0;
                    _this.ctx.shadowBlur = 0;
                  }
                  if (styles.textDecorationLine.length) {
                    _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                    styles.textDecorationLine.forEach(function (textDecorationLine) {
                      switch (textDecorationLine) {
                        case 1 /* UNDERLINE */:
                          // Draws a line at the baseline of the font
                          // TODO As some browsers display the line as more than 1px if the font-size is big,
                          // need to take that into account both in position and size
                          _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                          break;
                        case 2 /* OVERLINE */:
                          _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                          break;
                        case 3 /* LINE_THROUGH */:
                          // TODO try and find exact position for line-through
                          _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                          break;}

                    });
                  }
                  break;
                case PAINT_ORDER_LAYER.STROKE:
                  if (styles.webkitTextStrokeWidth && text.text.trim().length) {
                    _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                    _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
                    _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
                  }
                  _this.ctx.strokeStyle = '';
                  _this.ctx.lineWidth = 0;
                  _this.ctx.lineJoin = 'miter';
                  break;}

            });
          });
          return [2 /*return*/];
        });
      });
    };
    CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
      if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
        var box = contentBox(container);
        var path = calculatePaddingBoxPath(curves);
        this.path(path);
        this.ctx.save();
        this.ctx.clip();
        this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
        this.ctx.restore();
      }
    };
    CanvasRenderer.prototype.renderNodeContent = function (paint) {
      return __awaiter(this, void 0, void 0, function () {
        var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
        return __generator(this, function (_c) {
          switch (_c.label) {
            case 0:
              this.applyEffects(paint.effects, 4 /* CONTENT */);
              container = paint.container;
              curves = paint.curves;
              styles = container.styles;
              _i = 0, _a = container.textNodes;
              _c.label = 1;
            case 1:
              if (!(_i < _a.length)) return [3 /*break*/, 4];
              child = _a[_i];
              return [4 /*yield*/, this.renderTextNode(child, styles)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              _i++;
              return [3 /*break*/, 1];
            case 4:
              if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
              _c.label = 5;
            case 5:
              _c.trys.push([5, 7,, 8]);
              return [4 /*yield*/, this.context.cache.match(container.src)];
            case 6:
              image = _c.sent();
              this.renderReplacedElement(container, curves, image);
              return [3 /*break*/, 8];
            case 7:
              _c.sent();
              this.context.logger.error("Error loading image " + container.src);
              return [3 /*break*/, 8];
            case 8:
              if (container instanceof CanvasElementContainer) {
                this.renderReplacedElement(container, curves, container.canvas);
              }
              if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
              _c.label = 9;
            case 9:
              _c.trys.push([9, 11,, 12]);
              return [4 /*yield*/, this.context.cache.match(container.svg)];
            case 10:
              image = _c.sent();
              this.renderReplacedElement(container, curves, image);
              return [3 /*break*/, 12];
            case 11:
              _c.sent();
              this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
              return [3 /*break*/, 12];
            case 12:
              if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
              iframeRenderer = new CanvasRenderer(this.context, {
                scale: this.options.scale,
                backgroundColor: container.backgroundColor,
                x: 0,
                y: 0,
                width: container.width,
                height: container.height });

              return [4 /*yield*/, iframeRenderer.render(container.tree)];
            case 13:
              canvas = _c.sent();
              if (container.width && container.height) {
                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
              }
              _c.label = 14;
            case 14:
              if (container instanceof InputElementContainer) {
                size = Math.min(container.bounds.width, container.bounds.height);
                if (container.type === CHECKBOX) {
                  if (container.checked) {
                    this.ctx.save();
                    this.path([
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)]);

                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                } else
                if (container.type === RADIO) {
                  if (container.checked) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                }
              }
              if (isTextInputElement(container) && container.value.length) {
                _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
                baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                this.ctx.font = fontFamily;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = 'alphabetic';
                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                bounds = contentBox(container);
                x = 0;
                switch (container.styles.textAlign) {
                  case TEXT_ALIGN.CENTER:
                    x += bounds.width / 2;
                    break;
                  case TEXT_ALIGN.RIGHT:
                    x += bounds.width;
                    break;}

                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                this.ctx.save();
                this.path([
                new Vector(bounds.left, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                new Vector(bounds.left, bounds.top + bounds.height)]);

                this.ctx.clip();
                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                this.ctx.restore();
                this.ctx.textBaseline = 'alphabetic';
                this.ctx.textAlign = 'left';
              }
              if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
              if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
              img = container.styles.listStyleImage;
              if (!(img.type === CSSImageType.URL)) return [3 /*break*/, 18];
              image = void 0;
              url = img.url;
              _c.label = 15;
            case 15:
              _c.trys.push([15, 17,, 18]);
              return [4 /*yield*/, this.context.cache.match(url)];
            case 16:
              image = _c.sent();
              this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
              return [3 /*break*/, 18];
            case 17:
              _c.sent();
              this.context.logger.error("Error loading list-style-image " + url);
              return [3 /*break*/, 18];
            case 18:return [3 /*break*/, 20];
            case 19:
              if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {
                fontFamily = this.createFontStyle(styles)[0];
                this.ctx.font = fontFamily;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = 'middle';
                this.ctx.textAlign = 'right';
                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                this.ctx.textBaseline = 'bottom';
                this.ctx.textAlign = 'left';
              }
              _c.label = 20;
            case 20:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderStackContent = function (stack) {
      return __awaiter(this, void 0, void 0, function () {
        var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
        return __generator(this, function (_p) {
          switch (_p.label) {
            case 0:
              // https://www.w3.org/TR/css-position-3/#painting-order
              // 1. the background and borders of the element forming the stacking context.
              return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
            case 1:
              // https://www.w3.org/TR/css-position-3/#painting-order
              // 1. the background and borders of the element forming the stacking context.
              _p.sent();
              _i = 0, _a = stack.negativeZIndex;
              _p.label = 2;
            case 2:
              if (!(_i < _a.length)) return [3 /*break*/, 5];
              child = _a[_i];
              return [4 /*yield*/, this.renderStack(child)];
            case 3:
              _p.sent();
              _p.label = 4;
            case 4:
              _i++;
              return [3 /*break*/, 2];
            case 5:
              // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
              return [4 /*yield*/, this.renderNodeContent(stack.element)];
            case 6:
              // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
              _p.sent();
              _b = 0, _c = stack.nonInlineLevel;
              _p.label = 7;
            case 7:
              if (!(_b < _c.length)) return [3 /*break*/, 10];
              child = _c[_b];
              return [4 /*yield*/, this.renderNode(child)];
            case 8:
              _p.sent();
              _p.label = 9;
            case 9:
              _b++;
              return [3 /*break*/, 7];
            case 10:
              _d = 0, _e = stack.nonPositionedFloats;
              _p.label = 11;
            case 11:
              if (!(_d < _e.length)) return [3 /*break*/, 14];
              child = _e[_d];
              return [4 /*yield*/, this.renderStack(child)];
            case 12:
              _p.sent();
              _p.label = 13;
            case 13:
              _d++;
              return [3 /*break*/, 11];
            case 14:
              _f = 0, _g = stack.nonPositionedInlineLevel;
              _p.label = 15;
            case 15:
              if (!(_f < _g.length)) return [3 /*break*/, 18];
              child = _g[_f];
              return [4 /*yield*/, this.renderStack(child)];
            case 16:
              _p.sent();
              _p.label = 17;
            case 17:
              _f++;
              return [3 /*break*/, 15];
            case 18:
              _h = 0, _j = stack.inlineLevel;
              _p.label = 19;
            case 19:
              if (!(_h < _j.length)) return [3 /*break*/, 22];
              child = _j[_h];
              return [4 /*yield*/, this.renderNode(child)];
            case 20:
              _p.sent();
              _p.label = 21;
            case 21:
              _h++;
              return [3 /*break*/, 19];
            case 22:
              _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
              _p.label = 23;
            case 23:
              if (!(_k < _l.length)) return [3 /*break*/, 26];
              child = _l[_k];
              return [4 /*yield*/, this.renderStack(child)];
            case 24:
              _p.sent();
              _p.label = 25;
            case 25:
              _k++;
              return [3 /*break*/, 23];
            case 26:
              _m = 0, _o = stack.positiveZIndex;
              _p.label = 27;
            case 27:
              if (!(_m < _o.length)) return [3 /*break*/, 30];
              child = _o[_m];
              return [4 /*yield*/, this.renderStack(child)];
            case 28:
              _p.sent();
              _p.label = 29;
            case 29:
              _m++;
              return [3 /*break*/, 27];
            case 30:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.mask = function (paths) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(this.canvas.width, 0);
      this.ctx.lineTo(this.canvas.width, this.canvas.height);
      this.ctx.lineTo(0, this.canvas.height);
      this.ctx.lineTo(0, 0);
      this.formatPath(paths.slice(0).reverse());
      this.ctx.closePath();
    };
    CanvasRenderer.prototype.path = function (paths) {
      this.ctx.beginPath();
      this.formatPath(paths);
      this.ctx.closePath();
    };
    CanvasRenderer.prototype.formatPath = function (paths) {
      var _this = this;
      paths.forEach(function (point, index) {
        var start = isBezierCurve(point) ? point.start : point;
        if (index === 0) {
          _this.ctx.moveTo(start.x, start.y);
        } else
        {
          _this.ctx.lineTo(start.x, start.y);
        }
        if (isBezierCurve(point)) {
          _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
        }
      });
    };
    CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
      this.path(path);
      this.ctx.fillStyle = pattern;
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer.prototype.resizeImage = function (image, width, height) {
      var _a;
      if (image.width === width && image.height === height) {
        return image;
      }
      var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
      var canvas = ownerDocument.createElement('canvas');
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
      var ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
      return canvas;
    };
    CanvasRenderer.prototype.renderBackgroundImage = function (container) {
      return __awaiter(this, void 0, void 0, function () {
        var index, _loop_1, this_1, _i, _a, backgroundImage;
        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              index = container.styles.backgroundImage.length - 1;
              _loop_1 = function _loop_1(backgroundImage) {
                var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
                return __generator(this, function (_h) {
                  switch (_h.label) {
                    case 0:
                      if (!(backgroundImage.type === CSSImageType.URL)) return [3 /*break*/, 5];
                      image = void 0;
                      url = backgroundImage.url;
                      _h.label = 1;
                    case 1:
                      _h.trys.push([1, 3,, 4]);
                      return [4 /*yield*/, this_1.context.cache.match(url)];
                    case 2:
                      image = _h.sent();
                      return [3 /*break*/, 4];
                    case 3:
                      _h.sent();
                      this_1.context.logger.error("Error loading background-image " + url);
                      return [3 /*break*/, 4];
                    case 4:
                      if (image) {
                        _c = calculateBackgroundRendering(container, index, [
                        image.width,
                        image.height,
                        image.width / image.height]),
                        path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                        pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                        this_1.renderRepeat(path, pattern, x, y);
                      }
                      return [3 /*break*/, 6];
                    case 5:
                      if (isLinearGradient(backgroundImage)) {
                        _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                        _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                        canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        ctx = canvas.getContext('2d');
                        gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                        processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                          return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        ctx.fillStyle = gradient_1;
                        ctx.fillRect(0, 0, width, height);
                        if (width > 0 && height > 0) {
                          pattern = this_1.ctx.createPattern(canvas, 'repeat');
                          this_1.renderRepeat(path, pattern, x, y);
                        }
                      } else
                      if (isRadialGradient(backgroundImage)) {
                        _f = calculateBackgroundRendering(container, index, [
                        null,
                        null,
                        null]),
                        path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                        position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                        x = getAbsoluteValue(position[0], width);
                        y = getAbsoluteValue(position[position.length - 1], height);
                        _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
                        if (rx > 0 && ry > 0) {
                          radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                          processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          this_1.path(path);
                          this_1.ctx.fillStyle = radialGradient_1;
                          if (rx !== ry) {
                            midX = container.bounds.left + 0.5 * container.bounds.width;
                            midY = container.bounds.top + 0.5 * container.bounds.height;
                            f = ry / rx;
                            invF = 1 / f;
                            this_1.ctx.save();
                            this_1.ctx.translate(midX, midY);
                            this_1.ctx.transform(1, 0, 0, f, 0, 0);
                            this_1.ctx.translate(-midX, -midY);
                            this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                            this_1.ctx.restore();
                          } else
                          {
                            this_1.ctx.fill();
                          }
                        }
                      }
                      _h.label = 6;
                    case 6:
                      index--;
                      return [2 /*return*/];}

                });
              };
              this_1 = this;
              _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
              _b.label = 1;
            case 1:
              if (!(_i < _a.length)) return [3 /*break*/, 4];
              backgroundImage = _a[_i];
              return [5 /*yield**/, _loop_1(backgroundImage)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              _i++;
              return [3 /*break*/, 1];
            case 4:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          this.path(parsePathForBorder(curvePoints, side));
          this.ctx.fillStyle = asString(color);
          this.ctx.fill();
          return [2 /*return*/];
        });
      });
    };
    CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function () {
        var outerPaths, innerPaths;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(width < 3)) return [3 /*break*/, 2];
              return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
            case 1:
              _a.sent();
              return [2 /*return*/];
            case 2:
              outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
              this.path(outerPaths);
              this.ctx.fillStyle = asString(color);
              this.ctx.fill();
              innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
              this.path(innerPaths);
              this.ctx.fill();
              return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
      return __awaiter(this, void 0, void 0, function () {
        var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
        var _this = this;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this.applyEffects(paint.effects, 2 /* BACKGROUND_BORDERS */);
              styles = paint.container.styles;
              hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
              borders = [
              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }];

              backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
              if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
              this.ctx.save();
              this.path(backgroundPaintingArea);
              this.ctx.clip();
              if (!isTransparent(styles.backgroundColor)) {
                this.ctx.fillStyle = asString(styles.backgroundColor);
                this.ctx.fill();
              }
              return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
            case 1:
              _a.sent();
              this.ctx.restore();
              styles.boxShadow.
              slice(0).
              reverse().
              forEach(function (shadow) {
                _this.ctx.save();
                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                if (shadow.inset) {
                  _this.path(borderBoxArea);
                  _this.ctx.clip();
                  _this.mask(shadowPaintingArea);
                } else
                {
                  _this.mask(borderBoxArea);
                  _this.ctx.clip();
                  _this.path(shadowPaintingArea);
                }
                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                _this.ctx.shadowColor = asString(shadow.color);
                _this.ctx.shadowBlur = shadow.blur.number;
                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                _this.ctx.fill();
                _this.ctx.restore();
              });
              _a.label = 2;
            case 2:
              side = 0;
              _i = 0, borders_1 = borders;
              _a.label = 3;
            case 3:
              if (!(_i < borders_1.length)) return [3 /*break*/, 13];
              border = borders_1[_i];
              if (!(border.style !== BORDER_STYLE.NONE && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
              if (!(border.style === BORDER_STYLE.DASHED)) return [3 /*break*/, 5];
              return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DASHED)];
            case 4:
              _a.sent();
              return [3 /*break*/, 11];
            case 5:
              if (!(border.style === BORDER_STYLE.DOTTED)) return [3 /*break*/, 7];
              return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DOTTED)];
            case 6:
              _a.sent();
              return [3 /*break*/, 11];
            case 7:
              if (!(border.style === BORDER_STYLE.DOUBLE)) return [3 /*break*/, 9];
              return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
            case 8:
              _a.sent();
              return [3 /*break*/, 11];
            case 9:return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
            case 10:
              _a.sent();
              _a.label = 11;
            case 11:
              side++;
              _a.label = 12;
            case 12:
              _i++;
              return [3 /*break*/, 3];
            case 13:return [2 /*return*/];}

        });
      });
    };
    CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
      return __awaiter(this, void 0, void 0, function () {
        var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
        return __generator(this, function (_a) {
          this.ctx.save();
          strokePaths = parsePathForBorderStroke(curvePoints, side);
          boxPaths = parsePathForBorder(curvePoints, side);
          if (style === BORDER_STYLE.DASHED) {
            this.path(boxPaths);
            this.ctx.clip();
          }
          if (isBezierCurve(boxPaths[0])) {
            startX = boxPaths[0].start.x;
            startY = boxPaths[0].start.y;
          } else
          {
            startX = boxPaths[0].x;
            startY = boxPaths[0].y;
          }
          if (isBezierCurve(boxPaths[1])) {
            endX = boxPaths[1].end.x;
            endY = boxPaths[1].end.y;
          } else
          {
            endX = boxPaths[1].x;
            endY = boxPaths[1].y;
          }
          if (side === 0 || side === 2) {
            length = Math.abs(startX - endX);
          } else
          {
            length = Math.abs(startY - endY);
          }
          this.ctx.beginPath();
          if (style === BORDER_STYLE.DOTTED) {
            this.formatPath(strokePaths);
          } else
          {
            this.formatPath(boxPaths.slice(0, 2));
          }
          dashLength = width < 3 ? width * 3 : width * 2;
          spaceLength = width < 3 ? width * 2 : width;
          if (style === BORDER_STYLE.DOTTED) {
            dashLength = width;
            spaceLength = width;
          }
          useLineDash = true;
          if (length <= dashLength * 2) {
            useLineDash = false;
          } else
          if (length <= dashLength * 2 + spaceLength) {
            multiplier = length / (2 * dashLength + spaceLength);
            dashLength *= multiplier;
            spaceLength *= multiplier;
          } else
          {
            numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
            minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
            maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
            spaceLength =
            maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ?
            minSpace :
            maxSpace;
          }
          if (useLineDash) {
            if (style === BORDER_STYLE.DOTTED) {
              this.ctx.setLineDash([0, dashLength + spaceLength]);
            } else
            {
              this.ctx.setLineDash([dashLength, spaceLength]);
            }
          }
          if (style === BORDER_STYLE.DOTTED) {
            this.ctx.lineCap = 'round';
            this.ctx.lineWidth = width;
          } else
          {
            this.ctx.lineWidth = width * 2 + 1.1;
          }
          this.ctx.strokeStyle = asString(color);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          // dashed round edge gap
          if (style === BORDER_STYLE.DASHED) {
            if (isBezierCurve(boxPaths[0])) {
              path1 = boxPaths[3];
              path2 = boxPaths[0];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
            if (isBezierCurve(boxPaths[1])) {
              path1 = boxPaths[1];
              path2 = boxPaths[2];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
          }
          this.ctx.restore();
          return [2 /*return*/];
        });
      });
    };
    CanvasRenderer.prototype.render = function (element) {
      return __awaiter(this, void 0, void 0, function () {
        var stack;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
              }
              stack = parseStackingContexts(element);
              return [4 /*yield*/, this.renderStack(stack)];
            case 1:
              _a.sent();
              this.applyEffects([], 2 /* BACKGROUND_BORDERS */);
              return [2 /*return*/, this.canvas];}

        });
      });
    };
    return CanvasRenderer;
  }(Renderer);
  var isTextInputElement = function isTextInputElement(container) {
    if (container instanceof TextareaElementContainer) {
      return true;
    } else
    if (container instanceof SelectElementContainer) {
      return true;
    } else
    if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
      return true;
    }
    return false;
  };
  var calculateBackgroundCurvedPaintingArea = function calculateBackgroundCurvedPaintingArea(clip, curves) {
    switch (clip) {
      case BACKGROUND_CLIP.BORDER_BOX:
        return calculateBorderBoxPath(curves);
      case BACKGROUND_CLIP.CONTENT_BOX:
        return calculateContentBoxPath(curves);
      case BACKGROUND_CLIP.PADDING_BOX:
      default:
        return calculatePaddingBoxPath(curves);}

  };
  var canvasTextAlign = function canvasTextAlign(textAlign) {
    switch (textAlign) {
      case TEXT_ALIGN.CENTER:
        return 'center';
      case TEXT_ALIGN.RIGHT:
        return 'right';
      case TEXT_ALIGN.LEFT:
      default:
        return 'left';}

  };

  var ForeignObjectRenderer = /** @class */function (_super) {
    __extends(ForeignObjectRenderer, _super);
    function ForeignObjectRenderer(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
      _this.ctx = _this.canvas.getContext('2d');
      _this.options = options;
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
      return _this;
    }
    ForeignObjectRenderer.prototype.render = function (element) {
      return __awaiter(this, void 0, void 0, function () {
        var svg, img;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
              return [4 /*yield*/, loadSerializedSVG(svg)];
            case 1:
              img = _a.sent();
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
              }
              this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
              return [2 /*return*/, this.canvas];}

        });
      });
    };
    return ForeignObjectRenderer;
  }(Renderer);
  var loadSerializedSVG = function loadSerializedSVG(svg) {
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.onload = function () {
        resolve(img);
      };
      img.onerror = reject;
      img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
    });
  };

  var Logger = /** @class */function () {
    function Logger(_a) {
      var id = _a.id,enabled = _a.enabled;
      this.id = id;
      this.enabled = enabled;
      this.start = Date.now();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Logger.prototype.debug = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        // eslint-disable-next-line no-console
        if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
          // eslint-disable-next-line no-console
          console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else
        {
          this.info.apply(this, args);
        }
      }
    };
    Logger.prototype.getTime = function () {
      return Date.now() - this.start;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Logger.prototype.info = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        // eslint-disable-next-line no-console
        if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
          // eslint-disable-next-line no-console
          console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        }
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Logger.prototype.warn = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        // eslint-disable-next-line no-console
        if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
          // eslint-disable-next-line no-console
          console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else
        {
          this.info.apply(this, args);
        }
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Logger.prototype.error = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        // eslint-disable-next-line no-console
        if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
          // eslint-disable-next-line no-console
          console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else
        {
          this.info.apply(this, args);
        }
      }
    };
    Logger.instances = {};
    return Logger;
  }();

  var Context = /** @class */function () {
    function Context(options, windowBounds) {
      var _a;
      this.windowBounds = windowBounds;
      this.instanceName = "#" + Context.instanceCount++;
      this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
      this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
    }
    Context.instanceCount = 1;
    return Context;
  }();

  var html2canvas = function html2canvas(element, options) {
    if (options === void 0) {options = {};}
    return renderElement(element, options);
  };
  if (typeof window !== 'undefined') {
    CacheStorage.setContext(window);
  }
  var renderElement = function renderElement(element, opts) {return __awaiter(void 0, void 0, void 0, function () {
      var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
      return __generator(this, function (_t) {
        switch (_t.label) {
          case 0:
            if (!element || _typeof(element) !== 'object') {
              return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
            }
            ownerDocument = element.ownerDocument;
            if (!ownerDocument) {
              throw new Error("Element is not attached to a Document");
            }
            defaultView = ownerDocument.defaultView;
            if (!defaultView) {
              throw new Error("Document is not attached to a Window");
            }
            resourceOptions = {
              allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
              imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
              proxy: opts.proxy,
              useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false };

            contextOptions = _assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
            windowOptions = {
              windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
              windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
              scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
              scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset };

            windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
            context = new Context(contextOptions, windowBounds);
            foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
            cloneOptions = {
              onclone: opts.onclone,
              ignoreElements: opts.ignoreElements,
              inlineImages: foreignObjectRendering,
              copyStyles: foreignObjectRendering };

            context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
            documentCloner = new DocumentCloner(context, element, cloneOptions);
            clonedElement = documentCloner.clonedReferenceElement;
            if (!clonedElement) {
              return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
            }
            return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
          case 1:
            container = _t.sent();
            _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ?
            parseDocumentSize(clonedElement.ownerDocument) :
            parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
            backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
            renderOptions = {
              canvas: opts.canvas,
              backgroundColor: backgroundColor,
              scale: (_m = (_l = opts.scale) !== null && _l !== void 0 ? _l : defaultView.devicePixelRatio) !== null && _m !== void 0 ? _m : 1,
              x: ((_o = opts.x) !== null && _o !== void 0 ? _o : 0) + left,
              y: ((_p = opts.y) !== null && _p !== void 0 ? _p : 0) + top,
              width: (_q = opts.width) !== null && _q !== void 0 ? _q : Math.ceil(width),
              height: (_r = opts.height) !== null && _r !== void 0 ? _r : Math.ceil(height) };

            if (!foreignObjectRendering) return [3 /*break*/, 3];
            context.logger.debug("Document cloned, using foreign object rendering");
            renderer = new ForeignObjectRenderer(context, renderOptions);
            return [4 /*yield*/, renderer.render(clonedElement)];
          case 2:
            canvas = _t.sent();
            return [3 /*break*/, 5];
          case 3:
            context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
            context.logger.debug("Starting DOM parsing");
            root = parseTree(context, clonedElement);
            if (backgroundColor === root.styles.backgroundColor) {
              root.styles.backgroundColor = COLORS.TRANSPARENT;
            }
            context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
            renderer = new CanvasRenderer(context, renderOptions);
            return [4 /*yield*/, renderer.render(root)];
          case 4:
            canvas = _t.sent();
            _t.label = 5;
          case 5:
            if ((_s = opts.removeContainer) !== null && _s !== void 0 ? _s : true) {
              if (!DocumentCloner.destroy(container)) {
                context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
              }
            }
            context.logger.debug("Finished rendering");
            return [2 /*return*/, canvas];}

      });
    });};
  var parseBackgroundColor = function parseBackgroundColor(context, element, backgroundColorOverride) {
    var ownerDocument = element.ownerDocument;
    // http://www.w3.org/TR/css3-background/#special-backgrounds
    var documentBackgroundColor = ownerDocument.documentElement ?
    parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) :
    COLORS.TRANSPARENT;
    var bodyBackgroundColor = ownerDocument.body ?
    parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) :
    COLORS.TRANSPARENT;
    var defaultBackgroundColor = typeof backgroundColorOverride === 'string' ?
    parseColor(context, backgroundColorOverride) :
    backgroundColorOverride === null ?
    COLORS.TRANSPARENT :
    0xffffffff;
    return element === ownerDocument.documentElement ?
    isTransparent(documentBackgroundColor) ?
    isTransparent(bodyBackgroundColor) ?
    defaultBackgroundColor :
    bodyBackgroundColor :
    documentBackgroundColor :
    defaultBackgroundColor;
  };

  return html2canvas;

});

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_basePullAt.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePullAt.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseUnset = __webpack_require__(/*! ./_baseUnset */ "./node_modules/lodash/_baseUnset.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

module.exports = basePullAt;


/***/ }),

/***/ "./node_modules/lodash/_baseSlice.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseSlice.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseUnset.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnset.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    last = __webpack_require__(/*! ./last */ "./node_modules/lodash/last.js"),
    parent = __webpack_require__(/*! ./_parent */ "./node_modules/lodash/_parent.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_parent.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_parent.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSlice = __webpack_require__(/*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js");

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/findLast.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/findLast.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findLastIndex = __webpack_require__(/*! ./findLastIndex */ "./node_modules/lodash/findLastIndex.js");

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

module.exports = findLast;


/***/ }),

/***/ "./node_modules/lodash/findLastIndex.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/findLastIndex.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax(length + index, 0)
      : nativeMin(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

module.exports = findLastIndex;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/remove.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/remove.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    basePullAt = __webpack_require__(/*! ./_basePullAt */ "./node_modules/lodash/_basePullAt.js");

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

module.exports = remove;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debounce = __webpack_require__(/*! ./debounce */ "./node_modules/lodash/debounce.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/mdn-polyfills/MouseEvent.js":
/*!**************************************************!*\
  !*** ./node_modules/mdn-polyfills/MouseEvent.js ***!
  \**************************************************/
/***/ (() => {

!function(){try{return new MouseEvent("test")}catch(e){}var e=function(e,t){t=t||{bubbles:!1,cancelable:!1};var n=document.createEvent("MouseEvent");return n.initMouseEvent(e,t.bubbles,t.cancelable,window,0,t.screenX||0,t.screenY||0,t.clientX||0,t.clientY||0,t.ctrlKey||!1,t.altKey||!1,t.shiftKey||!1,t.metaKey||!1,t.button||0,t.relatedTarget||null),n};e.prototype=Event.prototype,window.MouseEvent=e}();


/***/ }),

/***/ "./extensions/BimMarkups/FrameRenderer.css":
/*!*************************************************!*\
  !*** ./extensions/BimMarkups/FrameRenderer.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_FrameRenderer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./FrameRenderer.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/FrameRenderer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_FrameRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_FrameRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_FrameRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_FrameRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./extensions/BimMarkups/Links/LinksRenderer.css":
/*!*******************************************************!*\
  !*** ./extensions/BimMarkups/Links/LinksRenderer.css ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_LinksRenderer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./LinksRenderer.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/Links/LinksRenderer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_LinksRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_LinksRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_LinksRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_LinksRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./extensions/BimMarkups/RendererHelpers/TextRenderer.css":
/*!****************************************************************!*\
  !*** ./extensions/BimMarkups/RendererHelpers/TextRenderer.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_TextRenderer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./TextRenderer.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./extensions/BimMarkups/RendererHelpers/TextRenderer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_TextRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_TextRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_TextRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_TextRenderer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var style = document.createElement("style");
  options.setAttributes(style, options.attributes);
  options.insert(style);
  return style;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(style) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    style.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute("media", media);
  } else {
    style.removeAttribute("media");
  }

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, style);
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


function domAPI(options) {
  var style = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(style, options, obj);
    },
    remove: function remove() {
      removeStyleElement(style);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, style) {
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************************************!*\
  !*** ./extensions/BimMarkups/BimMarkups.js ***!
  \*********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MarkupsExtension)
/* harmony export */ });
/* harmony import */ var _MarkupsTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkupsTool */ "./extensions/BimMarkups/MarkupsTool.js");
/* harmony import */ var _UI_MarkupsUI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UI/MarkupsUI */ "./extensions/BimMarkups/UI/MarkupsUI.js");
/* harmony import */ var _MarkupsManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkupsManager */ "./extensions/BimMarkups/MarkupsManager.js");
/* harmony import */ var _MarkupsRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkupsRenderer */ "./extensions/BimMarkups/MarkupsRenderer.js");
/* harmony import */ var _FilterManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FilterManager */ "./extensions/BimMarkups/FilterManager.js");
/* harmony import */ var _MarkupsPermissionManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MarkupsPermissionManager */ "./extensions/BimMarkups/MarkupsPermissionManager.js");
/* harmony import */ var _MarkupsMobileCallbacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MarkupsMobileCallbacks */ "./extensions/BimMarkups/MarkupsMobileCallbacks.js");
/* harmony import */ var _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MarkupsConstants */ "./extensions/BimMarkups/MarkupsConstants.js");
/* harmony import */ var _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MarkupsEvents */ "./extensions/BimMarkups/MarkupsEvents.js");
/* harmony import */ var _CacheObject__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CacheObject */ "./extensions/BimMarkups/CacheObject.js");
/* harmony import */ var _Service_MarkupsServiceOperator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Service/MarkupsServiceOperator */ "./extensions/BimMarkups/Service/MarkupsServiceOperator.js");
/* harmony import */ var _MarkupsCommon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MarkupsCommon */ "./extensions/BimMarkups/MarkupsCommon.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}












var namespace = AutodeskNamespace('Autodesk.BIM360.Markups');var

MarkupsExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(MarkupsExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(MarkupsExtension);
  function MarkupsExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, MarkupsExtension);
    _this = _super.call(this, viewer, options);
    _this.viewer = viewer;
    _this.options = options;

    _this.onModelLoadedBinded = _this.onModelLoaded.bind(_assertThisInitialized(_this));return _this;
  }_createClass(MarkupsExtension, [{ key: "onModelLoaded", value: function onModelLoaded(

    event) {
      // It is possible that a model has been loaded as hidden, and it's not the viewer's main model.
      if (!this.viewer.model || this.initialized) {
        return;
      }

      this.initCache();

      var model = event.model;
      var node = model.getDocumentNode();

      if (node) {
        this.sheetList = node.getRootNode().search({ type: 'geometry' });
        this.options.sheetGUID = node.guid();
        this.options.sheetName = node.name();
        this.options.fileName = node.findViewableParent().name();
      } else {
        this.sheetList = [];
      }

      this.markupsManager = new _MarkupsManager__WEBPACK_IMPORTED_MODULE_2__["default"](this);

      this.filterManager = new _FilterManager__WEBPACK_IMPORTED_MODULE_4__["default"](this, this.options);

      this.permissionManager = new _MarkupsPermissionManager__WEBPACK_IMPORTED_MODULE_5__["default"](this.options);

      this.markupsTool = new _MarkupsTool__WEBPACK_IMPORTED_MODULE_0__["default"](this);

      this.viewer.toolController.registerTool(this.markupsTool);

      var prevLock = this.viewer.toolController.setIsLocked(false);
      this.viewer.toolController.activateTool(this.markupsTool.getName());
      this.viewer.toolController.setIsLocked(prevLock);

      this.renderer = new _MarkupsRenderer__WEBPACK_IMPORTED_MODULE_3__["default"](this);

      this.markupsManager.setDefaultCreationStyleProperties(); // Needs renderer to set default thickness

      if (!this.options.isMobileApp) {
        this.markupsUI = new _UI_MarkupsUI__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this.initMarkupsPanel();
      } else {
        this.mobileCallbacks = new _MarkupsMobileCallbacks__WEBPACK_IMPORTED_MODULE_6__["default"](this);
      }

      this.initServiceOperator();

      this.selectInitialLayer();

      this.initialized = true;
    } }, { key: "initCache", value: function initCache()

    {
      if (!Object.prototype.hasOwnProperty.call(this.cache, 'markupsCache')) {
        this.cache.markupsCache = new _CacheObject__WEBPACK_IMPORTED_MODULE_9__["default"]();
      }

      this.markupsCache = this.cache.markupsCache;

      if (this.markupsCache.currentUrn !== this.options.documentUrn) {
        this.cache.layerToSelect = null;
        this.cache.layerToEdit = null;
        this.cache.filters = null;
      }

      this.cache.markupsCache.setCurrentUrn(this.options.documentUrn);

    } }, { key: "initServiceOperator", value: function initServiceOperator()

    {
      if (!this.serviceOperator) {
        this.serviceOperator = new _Service_MarkupsServiceOperator__WEBPACK_IMPORTED_MODULE_10__["default"]();
      }

      this.serviceOperator.reset(this);
      this.serviceOperator.fetchMarkups();
    } }, { key: "initMarkupsPanel", value: function initMarkupsPanel()

    {
      if (this.options.panelContainer && this.options.uiClasses && this.options.uiClasses.MarkupPanelClass) {
        if (!this.cache.markupsPanel) {
          this.cache.markupsPanel = new this.options.uiClasses.MarkupPanelClass();
          this.cache.markupsPanel.reset(this);
        } else {
          this.cache.markupsPanel.reset(this);
        }
      }
    } }, { key: "selectInitialLayer", value: function selectInitialLayer()

    {var _this2 = this;
      // Wait until the camera will be initialized before selecting a layer.
      setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  Autodesk.Viewing.EventUtils.waitUntilTransitionEnded(_this2.viewer));case 2:

                if (_this2.cache.layerToSelect) {
                  _this2.selectLayer(_this2.cache.layerToSelect, true, true);
                  _this2.cache.layerToSelect = null;
                }

                if (_this2.cache.layerToEdit) {
                  _this2.editLayer(_this2.cache.layerToEdit, true, true, true);
                  _this2.cache.layerToEdit = null;
                }case 4:case "end":return _context.stop();}}}, _callee);})));

    } }, { key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:


                this.cache = this.getCache();_context2.next = 3;return (

                  this.viewer.loadExtension('Autodesk.Snapping'));case 3:

                if (this.viewer.model) {
                  this.onModelLoaded({ model: this.viewer.model });
                } else {
                  this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelLoadedBinded);
                }return _context2.abrupt("return",

                true);case 5:case "end":return _context2.stop();}}}, _callee2, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelLoadedBinded);

      if (this.mobileCallbacks) {
        this.mobileCallbacks.destroy();
        this.mobileCallbacks = null;
      }

      if (this.markupsUI) {
        this.markupsUI.destroy();
        this.markupsUI = null;
      }

      if (this.renderer) {
        this.renderer.destroy();
        this.renderer = null;
      }

      if (this.markupsTool) {
        this.viewer.toolController.deregisterTool(this.markupsTool);
        this.markupsTool = null;
      }

      if (this.markupsManager) {
        this.markupsManager.destroy();
        this.markupsManager = null;
      }

      if (this.filterManager) {
        this.filterManager.destroy();
        this.filterManager = null;
      }

      if (this.permissionManager) {
        this.permissionManager.destroy();
        this.permissionManager = null;
      }

      if (this.serviceOperator) {
        this.serviceOperator.terminate();
        this.serviceOperator = null;
      }

      this.markupsCache = null;
      this.initialized = false;

      return true;
    }

    /**
       * Public interface
       */ }, { key: "startMarkupSession", value: function startMarkupSession(

    creationType, layer) {
      this.markupsManager.startMarkupSession(creationType, layer);
    } }, { key: "endMarkupSession", value: function endMarkupSession(

    save) {
      this.markupsManager.endMarkupSession(save);
    } }, { key: "setToolEnabled", value: function setToolEnabled(

    enable) {
      this.markupsManager.setToolEnabled(enable);
    } }, { key: "isToolEnabled", value: function isToolEnabled()

    {
      return this.markupsManager.isToolEnabled();
    } }, { key: "editLayer", value: function editLayer(

    layer, focus, selectAllMarkups, immediate) {
      this.markupsManager.editLayer(layer, focus, selectAllMarkups, immediate);
    } }, { key: "changeMarkupCreationType", value: function changeMarkupCreationType(

    creationType, startSession) {
      if (this.markupsManager.isMarkupSessionOpen() || startSession) {
        this.markupsManager.changeMarkupCreationType(creationType);
      }
    }

    // Removes the markup for the canvas.
  }, { key: "deleteMarkup", value: function deleteMarkup(markup) {
      this.markupsManager.deleteMarkup(markup);
    } }, { key: "deleteInEditMarkups", value: function deleteInEditMarkups()

    {
      this.markupsManager.deleteInEditMarkups();
    } }, { key: "undo", value: function undo()

    {
      this.markupsManager.undo();
    } }, { key: "redo", value: function redo()

    {
      this.markupsManager.redo();
    } }, { key: "copy", value: function copy()

    {
      this.markupsManager.copy();
    } }, { key: "paste", value: function paste()

    {
      this.markupsManager.paste();
    } }, { key: "cut", value: function cut()

    {
      this.markupsManager.cut();
    } }, { key: "selectMarkup", value: function selectMarkup(

    markup) {
      this.markupsManager.selectMarkup(markup);
    } }, { key: "deselectMarkup", value: function deselectMarkup(

    markup) {
      this.markupsManager.deselectMarkup(markup);
    } }, { key: "deselectAllMarkups", value: function deselectAllMarkups(

    exclude) {
      this.markupsManager.deselectAllMarkups(exclude);
    } }, { key: "deselectAllLayers", value: function deselectAllLayers(

    exclude) {
      this.markupsManager.deselectAllLayers(exclude);
    } }, { key: "exitMarkupView", value: function exitMarkupView()

    {
      this.markupsManager.exitMarkupView();
    } }, { key: "getSelectedMarkups", value: function getSelectedMarkups()

    {
      return this.markupsManager.getSelectedMarkups();
    } }, { key: "getSelectedLayer", value: function getSelectedLayer()

    {
      return this.markupsManager.getSelectedLayer();
    } }, { key: "getVisibleMarkups", value: function getVisibleMarkups()

    {
      return this.markupsManager.getVisibleMarkups();
    } }, { key: "selectLayer", value: function selectLayer(

    layer, focus, immediate) {
      this.markupsManager.selectLayer(layer, focus, immediate);
    } }, { key: "deselectLayer", value: function deselectLayer(

    layer) {
      this.markupsManager.deselectLayer(layer);
    } }, { key: "getStyleProperty", value: function getStyleProperty(

    key) {
      return this.markupsManager.getStyleProperty(key);
    } }, { key: "changeStyleProperty", value: function changeStyleProperty(

    key, value, dontSubmit) {
      this.markupsManager.changeStyleProperty(key, value, dontSubmit);
    } }, { key: "loadLayers", value: function loadLayers()



    {var layersJson = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.markupsCache && this.markupsCache.getAsList();var ignoreFilters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var removeExistingLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.markupsManager.loadLayers(layersJson, ignoreFilters, removeExistingLayers);
    }

    // Remove layer from canvas.
  }, { key: "removeLayer", value: function removeLayer(layer) {
      this.markupsManager.removeLayer(layer);
    } }, { key: "changeCreationStatusType", value: function changeCreationStatusType(

    status) {
      this.markupsManager.changeCreationStatusType(status);
    } }, { key: "getCreationStatusType", value: function getCreationStatusType()

    {
      return this.markupsManager.getCreationStatusType();
    } }, { key: "updateFilters", value: function updateFilters(

    filters) {
      this.filterManager.updateFilters(filters);
    } }]);return MarkupsExtension;}(Autodesk.Viewing.Extension);


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.BIM360.Markups', MarkupsExtension);

namespace.Constants = Object.assign({}, _MarkupsConstants__WEBPACK_IMPORTED_MODULE_7__);
namespace.Events = Object.assign({}, _MarkupsEvents__WEBPACK_IMPORTED_MODULE_8__.MARKUPS_EVENTS);
namespace.markupsOverlayRenderer = _MarkupsCommon__WEBPACK_IMPORTED_MODULE_11__.markupsOverlayRenderer;
})();

Autodesk.Extensions.BimMarkups = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=BimMarkups.js.map