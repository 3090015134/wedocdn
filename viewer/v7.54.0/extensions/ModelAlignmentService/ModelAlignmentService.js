/*!
 * LMV v7.54.0
 *
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Forge Viewer Usage Limitations:
 *
 * The Autodesk Forge Viewer JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/ModelAlignmentService/AlignedItemNucleus.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignedItemNucleus.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignedItemNucleus)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;
var avp = av.Private;

// All data that is stored by the service per aligned item.
var AlignedItemNucleus = /*#__PURE__*/function () {

  function AlignedItemNucleus(alignedItemID) {_classCallCheck(this, AlignedItemNucleus);
    this.init(alignedItemID);
  }_createClass(AlignedItemNucleus, [{ key: "init", value: function init(

    alignedItemID) {
      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = undefined;

      // {LMVMatrix4} Initially assume null = "no alignment transform set".
      this.transform = null;

      // {bool} whether alignment is locked
      this.isLocked = false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = undefined;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = undefined;

      // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
      this.versionUrn = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.versionUrn;

      // viewable part id - name of the specific viewable, e.g. "Second Floor"
      this.viewablePartId = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.viewablePartId;

      // {Region[]} - optional array of 2D regions.
      this.regions = undefined;
    }

    // Returns true if alignment/lock state is the same as for new items that the backend doesn't know about.
  }, { key: "isDefaultState", value: function isDefaultState() {
      return !this.transform && !this.isLocked && !this.regions;
    } }, { key: "resetToDefaultState", value: function resetToDefaultState()

    {
      this.transform = null;
      this.isLocked = false;
      this.regions = null;
    }

    // Init new item before saving a transform for the first time
    //  @param {string}     versionUrn - base64-encoded versionUrn
    //  @param {LmvMatrix4} transform
  }, { key: "createNew", value: function createNew(alignedItemID, transform) {
      this.init();
      this.versionUrn = alignedItemID.versionUrn;
      this.viewablePartId = alignedItemID.viewablePartId;
      this.transform = transform;
      return this;
    }

    // Set from data that we got from alignment service
  }, { key: "load", value: function load(data) {

      // Note: The serivce works with unencoded versionUrns, e.g. 'urn:adsk.wipstg:fs.file:vf.vSenZnaYQAOAZqzHB54kLQ?version=1'.
      //       However, the rest of LMV usually uses encoded ones. So, we only use the decoded ones when receiving or sending service data.
      this.versionUrn = avp.toUrlSafeBase64(data.versionUrn);

      // {string} viewable part id - name of the specific viewable, e.g. "Second Floor"
      this.viewablePartId = data.viewablePartId;

      if (data.regions) {
        this.regions = data.regions.map(function (region) {
          // If region contains a matrix (and it should), convert it into LmvMatrix
          if (region.transform) {
            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);
          }

          // Convert array into THREE.Box2
          region.boundingBox = new THREE.Box2().set(
          { x: region.boundingBox[0], y: region.boundingBox[1] },
          { x: region.boundingBox[2], y: region.boundingBox[3] });


          return region;
        });
      }

      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = data.checksum;

      // {bool} whether alignment is locked
      this.isLocked = data.isLocked || false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = data.updatedAt;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = data.updatedBy;

      // Create LmvMatrix4 from float array
      this.transform = Array.isArray(data === null || data === void 0 ? void 0 : data.transform) ? new avp.LmvMatrix4(true).fromArray(data === null || data === void 0 ? void 0 : data.transform) : null;

      return this;
    }

    // If this item actually exists on the server, there must be a checksum provided by the backend.
    // If there is none, this indicates that the item does not exist on the server yet.
  }, { key: "existsOnServer", value: function existsOnServer() {
      return Boolean(this.checksum);
    }

    // Convert into object that we can serialize into a json request body
  }, { key: "toObject", value: function toObject() {
      return {
        checksum: this.checksum,
        isLocked: this.isLocked,
        transform: this.transform && Array.from(this.transform.elements),
        regions: this.regions ? this.regions.map(function (r) {
          var region = Object.assign({}, r);

          // If region contains a matrix (and it should), convert it to number array first
          if (region.transform) {
            region.transform = Array.from(region.transform.elements);
          }

          // Convert THREE.Box2 into a flat array.
          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];
          return region;
        }) : undefined,
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn), // alignmentService requires decoded urns
        viewablePartId: this.viewablePartId };

    } }]);return AlignedItemNucleus;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentCache.js":
/*!************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentCache.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignmentCache)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

// Helper class to implement batching and caching of alignment items (alignment transforms, locked-flags, and possible other service-specific data). 
//
// Main purpose is to provide implementation of loadTransform/saveTransform in a way that
// we don't fire a single request per call. Instead, all transforms can be prefetched in a single batch and loadTransform gets them from memory as soon as available.
var AlignmentCache = /*#__PURE__*/function () {

  // The actual content of cached items is left to the client. The cache cannot add items itself.
  //
  // @param {async function(string[])} fetchItems - Async function to make batch requests. On success it returns a map from versionUrn to data items.
  function AlignmentCache(fetchItems) {_classCallCheck(this, AlignmentCache);

    // Keep callback to fetch items
    this._fetchItems = fetchItems;

    // AlignmentItems in memory. Indexed by alignedItemId key.
    this.cache = {};

    // If the alignment for an urn is not in memory, but already requested, this[urnToRequestIndex] gives us the index
    // of the corresponding request in this.pendingRequests.
    this.urnToRequestIndex = {};

    // For each pending fetchItems-call, this array contains a promise that resolves when the request is finished.
    this.pendingRequests = [null];
  }_createClass(AlignmentCache, [{ key: "clear", value: function clear()

    {
      this.cache = {};
    }

    // Prefetch alignment items for a given list of urns and add them to the cache.
  }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIds) {var _this = this;var needsLoad, requestIndex, promise, result;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                // Skip urls that we already know
                needsLoad = function needsLoad(alignedItemId) {return !_this.cache[alignedItemId.toString()];};
                alignedItemIds = alignedItemIds.filter(needsLoad);

                // If all is in cache, we are done here
                if (alignedItemIds.length) {_context.next = 4;break;}return _context.abrupt("return");case 4:



                // find free request index
                requestIndex = 1;
                while (this.pendingRequests[requestIndex]) {requestIndex++;}

                // Mark all urns as pending and allow finding the request for a given urn
                alignedItemIds.forEach(function (alignedItemId) {return _this.urnToRequestIndex[alignedItemId.toString()] = requestIndex;});

                // Do the actual request
                promise = this._fetchItems(alignedItemIds);

                // Keep promise so that later fetchSingleItem() calls to any of the urns can return it.
                this.pendingRequests[requestIndex] = promise;

                // Wait for request result
                _context.next = 11;return promise;case 11:result = _context.sent;

                // remove promise from pendingRequests
                this.pendingRequests[requestIndex] = null;


                // If fetching succeeded, add results to cache.
                // Otherwise, do nothing: It's up to the client to deal with errors
                if (result) {
                  alignedItemIds.forEach(function (alignedItemId) {
                    var key = alignedItemId.toString();
                    _this.cache[key] = result[key];
                  });
                }

                // Mark urn as resolved and not pending anymore. Note that this always needs to happen, no matter whether successful or not.
                alignedItemIds.forEach(function (alignedItemId) {
                  // Use delete here to keep the dictionary cleaner. 
                  // Although it's a bit slower than setting to undefined, this doesn't matter here,
                  // because the the call frequency is not critically high.
                  delete _this.urnToRequestIndex[alignedItemId.toString()];
                });case 15:case "end":return _context.stop();}}}, _callee, this);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Return immediately whatever we have in cache
  }, { key: "getCachedItem", value: function getCachedItem(alignedItemId) {
      var key = alignedItemId.toString();
      return this.cache[key];
    } }, { key: "getItem", value: function () {var _getItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      alignedItemId) {var item, key, requestIndex;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                // Return from memory if possible
                item = this.getCachedItem(alignedItemId);if (!
                item) {_context2.next = 3;break;}return _context2.abrupt("return",
                item);case 3:


                // Ideally, this item should already be handled by a pending batch request.
                // If so, we just wait for it to finish.
                key = alignedItemId.toString();
                requestIndex = this.urnToRequestIndex[key];if (!
                requestIndex) {_context2.next = 10;break;}_context2.next = 8;return (

                  this.pendingRequests[requestIndex]);case 8:_context2.next = 12;break;case 10:_context2.next = 12;return (



                  this.fetchItems([alignedItemId]));case 12:return _context2.abrupt("return",

                this.getCachedItem(alignedItemId));case 13:case "end":return _context2.stop();}}}, _callee2, this);}));function getItem(_x2) {return _getItem.apply(this, arguments);}return getItem;}() }, { key: "setItem", value: function setItem(


    alignedItemId, item) {
      var key = alignedItemId.toString();
      this.cache[key] = item;
    } }]);return AlignmentCache;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentService.js":
/*!**************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentService.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignmentService)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var namespace = AutodeskNamespace('Autodesk.AlignmentService');

/* Interface for alignment service implementations. */var
AlignmentService = /*#__PURE__*/function () {

  function AlignmentService() {_classCallCheck(this, AlignmentService);}

  /**
                                                                          * Changes to false if any connection errors happened. As long as it returns true, you can safely assume that
                                                                          * any returned results from getTransform() reflect the latest service state. 
                                                                          */_createClass(AlignmentService, [{ key: "isWorking", value: function isWorking()
    {return true;} }, { key: "clearCache", value: function clearCache()

    {}

    /**
       * Fetch alignment data for a batch of urns. This can be used to avoid individual requests for individual loadTransform()/isAlignmentLocked() calls. 
       *  @param {string[]} urns
       *  @throws {Object} error
       */ }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      urns) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case "end":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()

    /**
                                                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                 * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                 * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
                                                                                                                                                                                                                                                                                 */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt("return",
                null);case 1:case "end":return _context2.stop();}}}, _callee2);}));function loadTransform(_x2, _x3) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                             * Direct access to cached transform in memory: If a transform was loaded by loadTransform or fetch() before, this function allows to get it directly
                                                                                                                                                                                             * within a sync function. However, note that it might return undefined if the transform state is not in memory yet.
                                                                                                                                                                                             *  
                                                                                                                                                                                             * NOTE: Once a transform was loaded, the AlignmentService implementation has to ensure that the result is cached and can be obtained again by this function.
                                                                                                                                                                                             * 
                                                                                                                                                                                             * @returns {LmvMatrix|null|undefined} - Null: "not set", undefined: "not in memory yet".
                                                                                                                                                                                             */ }, { key: "getTransform", value: function getTransform(
    versionUrn, viewablePartId) {
      return null;
    }

    /**
       * Direct access to cached isLocked flag.
       * @returns {bool|undefined} - undefined: "not in memory yet".
       */ }, { key: "getIsLocked", value: function getIsLocked(
    versionUrn, viewablePartId) {
      return false;
    }

    /**
       * @param {string} versionUrn            - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
       * @param {string} [viewablePartId]      - encoded viewableName of the model.
       * @param {LmvMatrix4|null} transform    - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
       * @throws {Object}         error        - some implementation may throw. error.msg should provide an error message.
       * @returns {boolean}                    - success / failed
       */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId, transform) {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:case "end":return _context3.stop();}}}, _callee3);}));function saveTransform(_x4, _x5, _x6) {return _saveTransform.apply(this, arguments);}return saveTransform;}()

    /**
                                                                                                                                                                                                                                                                                                                                            * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                            * @throws {Object}
                                                                                                                                                                                                                                                                                                                                            */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:case "end":return _context4.stop();}}}, _callee4);}));function lockAlignment(_x7, _x8) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()

    /**
                                                                                                                                                                                                                                                                                                                             * Remove alignment lock, so that aligning is possible. We don't expose it per UI.
                                                                                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                             * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                             * @throws {Object}
                                                                                                                                                                                                                                                                                                                             */ }, { key: "unlockAlignment", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:case "end":return _context5.stop();}}}, _callee5);}));function unlockAlignment(_x9, _x10) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}()

    /**
                                                                                                                                                                                                                                                                                                                                   * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                                   * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                   * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                   * @throws {Object}
                                                                                                                                                                                                                                                                                                                                   * @returns {boolean}
                                                                                                                                                                                                                                                                                                                                   */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:case "end":return _context6.stop();}}}, _callee6);}));function isAlignmentLocked(_x11, _x12) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()

    /**
                                                                                                                                                                                                                                                                                                                                          * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                          * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                          * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                          * @param {THREE.Box3} boundingBox  - bounding box of the region in model space.
                                                                                                                                                                                                                                                                                                                                          * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                                                                                                          * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                                                                                                          * @returns {boolean}               - success / failed
                                                                                                                                                                                                                                                                                                                                          */ }, { key: "saveRegion", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId, regionId, boundingBox, units) {return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:case "end":return _context7.stop();}}}, _callee7);}));function saveRegion(_x13, _x14, _x15, _x16, _x17) {return _saveRegion.apply(this, arguments);}return saveRegion;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                     * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                                                     * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                                                     * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                                                     * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                     * @returns {Object|null}           - Null means that no custom region was stored.
                                                                                                                                                                                                                                                                                                                                                                     */ }, { key: "loadRegion", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:return _context8.abrupt("return",
                null);case 1:case "end":return _context8.stop();}}}, _callee8);}));function loadRegion(_x18, _x19, _x20) {return _loadRegion.apply(this, arguments);}return loadRegion;}()


    /**
                                                                                                                                                                                           * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                           * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                           * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                           * @returns {object[]}               - Empty array means that no matching region was found.
                                                                                                                                                                                           */ }, { key: "loadRegions", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:return _context9.abrupt("return",
                []);case 1:case "end":return _context9.stop();}}}, _callee9);}));function loadRegions(_x21, _x22) {return _loadRegions.apply(this, arguments);}return loadRegions;}()


    /**
                                                                                                                                                                                      * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                      * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                      * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                      * @param {string} regionId         - unique region id.
                                                                                                                                                                                      * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                      */ }, { key: "deleteRegion", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(
      lineageUrn, versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:case "end":return _context10.stop();}}}, _callee10);}));function deleteRegion(_x23, _x24, _x25, _x26) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} modelLineageUrn       - encoded lineageUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} sheetLineageUrn       - encoded lineageUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} [regionId]            - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                                                                                                   * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                                                                                                                                   * @returns {boolean}                    - success / failed
                                                                                                                                                                                                                                                                                                                                                                   */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:case "end":return _context11.stop();}}}, _callee11);}));function saveRelationship(_x27, _x28, _x29, _x30, _x31) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                                                                         * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                                                                                                                                                         * 
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @returns {Object[]}
                                                                                                                                                                                                                                                                                                                                                                                                                         */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(
      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:return _context12.abrupt("return",
                null);case 1:case "end":return _context12.stop();}}}, _callee12);}));function getRelationships(_x32, _x33, _x34, _x35) {return _getRelationships.apply(this, arguments);}return getRelationships;}()


    /**
                                                                                                                                                                                                                      * @param {string} relationshipId - the UUID of the relationship to delete
                                                                                                                                                                                                                      */ }, { key: "deleteRelationship", value: function deleteRelationship(
    relationshipId) {} }]);return AlignmentService;}();


namespace.RelationshipEntityTypes = {
  Model3D: "viewpart3d",
  Region: "viewpartregion2d" };


namespace.RelationshipIdPrefix = {
  Name: 'viewablePart=',
  Region: '&region=' };

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceLS.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceLS.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignmentServiceLS)
/* harmony export */ });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var avp = Autodesk.Viewing.Private;

// Prefix used for LocalStorage entries for model-alignment
var keyPrefix = 'Autodesk.Viewing.ModelAlignment';
var APIs = {
  Transform: 'transform',
  Relationship: 'relationship' };


var RelationshipDomain = 'autodesk-construction-alignment';

var TokenSeparator = '__';

// get LocalStorage key from model version urn
var getKey = function getKey(api, urn) {var viewablePartId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "".concat(keyPrefix).concat(TokenSeparator).concat(api).concat(TokenSeparator).concat(urn).concat(viewablePartId.length ? "".concat(TokenSeparator).concat(viewablePartId) : "");
};

// An single alignment item stored as json in LocalStorage  
var newTransformItem = function newTransformItem(transform) {
  return {
    // Optional: Array of floats
    transform: transform ? transform.elements : null,

    // If true, we forbid changing
    isLocked: false };

};

// Relationship entity ID is defined by lineageUrn + viewablePart + region.
var getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {
  return "".concat(lineageUrn, "?").concat(Autodesk.AlignmentService.RelationshipIdPrefix.Name).concat(viewablePart).concat(region ? "".concat(Autodesk.AlignmentService.RelationshipIdPrefix.Region).concat(region) : '');
};

/* Implements model-alignment storage based on LocalStorage. */var
AlignmentServiceLS = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceLS, _AlignmentService);var _super = _createSuper(AlignmentServiceLS);

  function AlignmentServiceLS() {var _this;var localStorage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : avp.LocalStorage;_classCallCheck(this, AlignmentServiceLS);
    _this = _super.call(this);
    _this.localStorage = localStorage;return _this;
  }_createClass(AlignmentServiceLS, [{ key: "getTransform", value: function getTransform(

    versionUrn, viewablePartId) {
      // just read directly from localStorage
      // Note: It's essential to return null (not undefined) if no matrix is set,
      //       because "undefined" would indicate that the state is not in memory yet.
      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);
      return (item === null || item === void 0 ? void 0 : item.transform) || null;
    } }, { key: "getIsLocked", value: function getIsLocked(

    versionUrn, viewablePartId) {
      // item may be null if nothing was saved for this urn so far. In this case, isLocked is always false. 
      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);
      return Boolean(item === null || item === void 0 ? void 0 : item.isLocked);
    }

    /**
      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
      * @param {string} [viewablePartId] - encoded viewableName of the model.
      * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
      * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
      */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);return _context.abrupt("return",
                item === null || item === void 0 ? void 0 : item.transform);case 2:case "end":return _context.stop();}}}, _callee, this);}));function loadTransform(_x, _x2) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                                                                                     * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                     * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                     * @param {LmvMatrix4|null} transform  - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
                                                                                                                                                                                                                                                     * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                     */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId, transform) {var item;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.transform = transform;return _context2.abrupt("return",
                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function saveTransform(_x3, _x4, _x5) {return _saveTransform.apply(this, arguments);}return saveTransform;}()


    /**
                                                                                                                                                                                                                                                                  * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                  * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                  * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                  * @throws {Object}
                                                                                                                                                                                                                                                                  */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.isLocked = true;return _context3.abrupt("return",
                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 3:case "end":return _context3.stop();}}}, _callee3, this);}));function lockAlignment(_x6, _x7) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()


    /**
                                                                                                                                                                                                                                                             * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                             * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                             * @throws {Object}
                                                                                                                                                                                                                                                             * @returns {boolean}
                                                                                                                                                                                                                                                             */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:return _context4.abrupt("return",
                this.getIsLocked(versionUrn, viewablePartId));case 1:case "end":return _context4.stop();}}}, _callee4, this);}));function isAlignmentLocked(_x8, _x9) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()


    /**
                                                                                                                                                                                                                                                      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                      * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                      * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                      * @param {THREE.Box3} boundingBox         - bounding box of the viewport in model space.
                                                                                                                                                                                                                                                      * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                      * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                      */ }, { key: "saveRegion", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId, regionId, boundingBox, transform) {var item, index;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();

                if (!item.regions) {
                  item.regions = [];
                }

                // In case that this regionId already exists in the service, we'll override its content.
                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});

                if (index === -1) {
                  // Otherwise, we'll create a new entry to the array.
                  index = item.regions.length;
                }

                item.regions[index] = {
                  regionId: regionId,
                  boundingBox: boundingBox,
                  transform: transform };return _context5.abrupt("return",


                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 6:case "end":return _context5.stop();}}}, _callee5, this);}));function saveRegion(_x10, _x11, _x12, _x13, _x14) {return _saveRegion.apply(this, arguments);}return saveRegion;}()


    /**
                                                                                                                                                                                                                                                                        * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                        * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                        * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                        * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                        * @returns {Object|null}           - Null means that no custom viewport was stored.
                                                                                                                                                                                                                                                                        */ }, { key: "loadRegion", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId, regionId) {var regions, region;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return (
                  this.loadRegions(versionUrn, viewablePartId));case 2:regions = _context6.sent;

                region = regions.find(function (r) {return r.regionId === regionId;});return _context6.abrupt("return",

                region || null);case 5:case "end":return _context6.stop();}}}, _callee6, this);}));function loadRegion(_x15, _x16, _x17) {return _loadRegion.apply(this, arguments);}return loadRegion;}()


    /**
                                                                                                                                                                                                           * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                           * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                           * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                           * @returns {object[]}               - Empty array means that no matching viewport was found.
                                                                                                                                                                                                           */ }, { key: "loadRegions", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId) {var item, regions;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);

                regions = item === null || item === void 0 ? void 0 : item.regions;return _context7.abrupt("return",

                regions || []);case 3:case "end":return _context7.stop();}}}, _callee7, this);}));function loadRegions(_x18, _x19) {return _loadRegions.apply(this, arguments);}return loadRegions;}()


    /**
                                                                                                                                                                                                       * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                       * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                       * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                       * @param {string} regionId         - unique region id.
                                                                                                                                                                                                       * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                       */ }, { key: "deleteRegion", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      lineageUrn, versionUrn, viewablePartId, regionId) {var relationship, item, regions;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
                relationship = this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId);
                this.deleteRelationship(relationship.id);

                // get current item from cache
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);
                regions = item === null || item === void 0 ? void 0 : item.regions;if (
                regions) {_context8.next = 7;break;}
                console.warn('No regions to delete');return _context8.abrupt("return");case 7:



                if (region.length > 1) {
                  // Update the regions list. This will overwrite the item.
                  item.regions = regions.filter(function (r) {return r.regionId !== regionId;});
                  this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);
                } else {
                  // This is the only region in the item
                  this.deleteItem(APIs.Transform, versionUrn, viewablePartId);
                }case 8:case "end":return _context8.stop();}}}, _callee8, this);}));function deleteRegion(_x20, _x21, _x22, _x23) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}()



    ////////// Relationship Service //////////////

    /**
    * @param {string} modelLineageUrn       - encoded versionUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
    * @param {string} sheetLineageUrn       - encoded versionUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
    * @param {string} [regionId]            - A UUID of the sheet's region.
    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
    */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, relationshipId, item;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:

                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);
                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);

                relationshipId = (0,uuid__WEBPACK_IMPORTED_MODULE_1__.v4)();

                // this is how this structure that it is stored in real Relationship service.
                item = {
                  id: relationshipId,
                  entities: [
                  {
                    domain: RelationshipDomain,
                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,
                    id: sheetEntityId },

                  {
                    domain: RelationshipDomain,
                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,
                    id: modelEntityId }] };




                // In the mock service we save the relationship according to a unique key, just like it's gonna be saved in the relationship service.
                return _context9.abrupt("return", this.saveItem(APIs.Relationship, relationshipId, undefined, item));case 5:case "end":return _context9.stop();}}}, _callee9, this);}));function saveRelationship(_x24, _x25, _x26, _x27, _x28) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()


    /**
                                                                                                                                                                                                                                                                                                                              * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                                                              * 
                                                                                                                                                                                                                                                                                                                              * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                                                              * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                              * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                              * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                                                              * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                              * @returns {Object[]}
                                                                                                                                                                                                                                                                                                                              */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(
      type, lineageUrn, viewablePartId, regionId) {var results, entityId, keys, i, key, _candidate$entities, itemStr, candidate;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:
                results = [];

                entityId = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);

                keys = avp.LocalStorage.getAllKeys();

                // Simulates Relationship Service `search` API. The API can look for relationships according to `domain`, `type` & `entityId`.
                for (i = 0; i < keys.length; i++) {
                  key = keys[i];

                  if (key.indexOf(APIs.Relationship) !== -1) {
                    itemStr = avp.LocalStorage.getItem(key);
                    candidate = itemStr && JSON.parse(itemStr);

                    if (candidate === null || candidate === void 0 ? void 0 : (_candidate$entities = candidate.entities) === null || _candidate$entities === void 0 ? void 0 : _candidate$entities.some(function (entity) {return entity.id === entityId && entity.type === type;})) {
                      results.push(candidate);
                    }
                  }
                }return _context10.abrupt("return",

                results);case 5:case "end":return _context10.stop();}}}, _callee10);}));function getRelationships(_x29, _x30, _x31, _x32) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: "deleteRelationship", value: function deleteRelationship(


    relationshipId) {
      this.deleteItem(APIs.Relationship, relationshipId);
    } }, { key: "loadItem", value: function loadItem(

    api, urn, viewablePartId) {
      var key = getKey(api, urn, viewablePartId);
      var itemStr = this.localStorage.getItem(key);
      var item = itemStr && JSON.parse(itemStr);

      // Convert array elements into LmvMatrix
      if (item === null || item === void 0 ? void 0 : item.transform) {
        item.transform = new avp.LmvMatrix4(true).fromArray(item.transform);
      }

      if (item === null || item === void 0 ? void 0 : item.regions) {
        item.regions = item.regions.map(function (region) {
          // If region contains a matrix (and it should), convert it into LmvMatrix
          if (region.transform) {
            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);
          }

          // Convert array into THREE.Box2
          region.boundingBox = new THREE.Box2().set(
          { x: region.boundingBox[0], y: region.boundingBox[1] },
          { x: region.boundingBox[2], y: region.boundingBox[3] });


          return region;
        });
      }

      return item;
    } }, { key: "saveItem", value: function saveItem(

    api, urn, viewablePartId, item) {var _item, _item2;

      // If the item contains a matrix, convert it to number array first
      if ((_item = item) === null || _item === void 0 ? void 0 : _item.transform) {
        item = Object.assign({}, item);

        // Note that the Array.from(...) makes a difference here:
        // TypedArrays (like matrix.elements) are not saved as arrays by JSON-stringify, but as objects,
        // i.e., it would look like '{"0": 1, "1": 1, ... }' 
        // By converting to a JS array, the resulting json contains an actual array, i.e. "[1, 0, 0, ... ]"
        item.transform = Array.from(item.transform.elements);
      }

      if ((_item2 = item) === null || _item2 === void 0 ? void 0 : _item2.regions) {
        item = Object.assign({}, item);
        item.regions = item.regions.map(function (r) {
          var region = Object.assign({}, r);

          // If region contains a matrix (and it should), convert it to number array first
          if (region.transform) {
            region.transform = Array.from(region.transform.elements);
          }

          // Convert THREE.Box2 into a flat array.
          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];
          return region;
        });
      }

      var key = getKey(api, urn, viewablePartId);
      var itemStr = JSON.stringify(item);
      this.localStorage.setItem(key, itemStr);

      return true;
    } }, { key: "deleteItem", value: function deleteItem(

    api, urn, viewablePartId) {
      var key = getKey(api, urn, viewablePartId);
      this.localStorage.removeItem(key);
    } }]);return AlignmentServiceLS;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"]);


// Implement LocalStorage interface, but just using a plain JS object for storage instead of actual LocalStorage.
var ObjectLocalStorage = /*#__PURE__*/function () {

  function ObjectLocalStorage() {_classCallCheck(this, ObjectLocalStorage);
    this.data = {};
  }_createClass(ObjectLocalStorage, [{ key: "setItem", value: function setItem(

    key, item) {
      this.data[key] = item;
    } }, { key: "getItem", value: function getItem(

    key) {
      return this.data[key];
    } }]);return ObjectLocalStorage;}();


_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"].ObjectLocalStorage = ObjectLocalStorage;

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js":
/*!*********************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceNucleus.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignmentServiceNucleus)
/* harmony export */ });
/* harmony import */ var _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignedItemNucleus */ "./extensions/ModelAlignmentService/AlignedItemNucleus.js");
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlignmentCache */ "./extensions/ModelAlignmentService/AlignmentCache.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
/* harmony import */ var _NucleusRelationshipAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NucleusRelationshipAPI */ "./extensions/ModelAlignmentService/NucleusRelationshipAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


// Using the cache in the LocalCS implementation is primarily for testing and as a reference implementation
// for other (slower) services.





var isSameTransform = function isSameTransform(tfOld, tfNew) {

  // If both transforms were not set, conisder them equal
  if (!tfOld && !tfNew) {
    return true;
  }

  if (tfOld && tfNew) {
    return tfNew.equals(tfOld);
  }
  return false;
};

// Implements model-alignment storage based on Nucleus backend.
var AlignmentServiceNucleus = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceNucleus, _AlignmentService);var _super = _createSuper(AlignmentServiceNucleus);

  // @param {Object}           options               - Additional initialization options:
  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'
  // @param {string}           [serviceVersion="v1"]
  function AlignmentServiceNucleus() {var _this;var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, AlignmentServiceNucleus);
    _this = _super.call(this);

    // Activate error state if an error occurs
    var onError = _this.onError.bind(_assertThisInitialized(_this));
    options.onError = onError;
    _this.alignmentApi = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.NucleusAlignmentAPI(options);
    _this.relationshipApi = new _NucleusRelationshipAPI__WEBPACK_IMPORTED_MODULE_4__.NucleusRelationshipAPI(options);

    // Define function that the cache can use to perform batch requests 
    var fetchItems = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIDs) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  _this.alignmentApi.fetchItems(alignedItemIDs));case 2:return _context.abrupt("return", _context.sent);case 3:case "end":return _context.stop();}}}, _callee);}));return function fetchItems(_x) {return _ref.apply(this, arguments);};}();


    _this.cache = new _AlignmentCache__WEBPACK_IMPORTED_MODULE_2__["default"](fetchItems);return _this;
  }_createClass(AlignmentServiceNucleus, [{ key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      urns) {var itemIds;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                itemIds = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID.fromUrns(urns);_context2.next = 3;return (
                  this.cache.fetchItems(itemIds));case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function fetchItems(_x2) {return _fetchItems.apply(this, arguments);}return fetchItems;}() }, { key: "getTransform", value: function getTransform(


    versionUrn, viewablePartId) {
      // return transform - or undefined if not in cache
      var alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);
      var item = this.cache.getCachedItem(alignedItemID);

      // Note: It's important to distinguish undefined vs. null here:
      //  - If the item does not exists, we don't know the state => return undefined
      //  - If the item exists, but has no transform, we know that no alignment transform is set => return null.
      if (!item) {
        return undefined;
      } else if (!item.transform) {
        return null;
      }

      // Return a copy, so that clients cannot accidentally modify it.
      return item.transform.clone();
    } }, { key: "getIsLocked", value: function getIsLocked(

    versionUrn, viewablePartId) {
      // return transform - or undefined if not in cache
      var alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);
      var item = this.cache.getCachedItem(alignedItemID);
      return item ? Boolean(item.isLocked) : undefined;
    } }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      versionUrn, viewablePartId) {var _item$transform;var alignedItemID, item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:

                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);_context3.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context3.sent;return _context3.abrupt("return",
                (item === null || item === void 0 ? void 0 : (_item$transform = item.transform) === null || _item$transform === void 0 ? void 0 : _item$transform.clone()) || null);case 5:case "end":return _context3.stop();}}}, _callee3, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}() }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(


      versionUrn, viewablePartId, transform) {var _item;var alignedItemID, item;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);
                // get current item from cache
                _context4.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context4.sent;if (!



                isSameTransform((_item = item) === null || _item === void 0 ? void 0 : _item.transform, transform)) {_context4.next = 6;break;}return _context4.abrupt("return",
                true);case 6:


                // Update item in cache or create a new one
                if (item) {
                  item.transform = transform;
                } else {
                  // Transform was not saved before: Create a new item
                  item = new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().createNew(alignedItemID, transform);
                  this.cache.setItem(alignedItemID, item);
                }

                // Note: If the server has changed meanwhile, we will overwrite it.
                //       Ideally, we should have some conflict handling workflow for this case.
                _context4.next = 9;return this.alignmentApi.saveItem(item);case 9:return _context4.abrupt("return", _context4.sent);case 10:case "end":return _context4.stop();}}}, _callee4, this);}));function saveTransform(_x5, _x6, _x7) {return _saveTransform.apply(this, arguments);}return saveTransform;}() }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(


      versionUrn, viewablePartId) {var alignedItemID, item, isSaved;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);_context5.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context5.sent;if (!



                item.isLocked) {_context5.next = 6;break;}return _context5.abrupt("return");case 6:



                // Note that items may just exist locally. 
                isSaved = item.existsOnServer();

                // If there is no item, we have to create and save it to the service first.
                if (isSaved) {_context5.next = 10;break;}_context5.next = 10;return (
                  this.alignmentApi.saveItem(item));case 10:_context5.next = 12;return (



                  this.alignmentApi.setItemLocked(item, true));case 12:case "end":return _context5.stop();}}}, _callee5, this);}));function lockAlignment(_x8, _x9) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()


    // Only used for testing. In practice, alignment 
  }, { key: "unlockAlignment", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);_context6.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context6.sent;if (!(



                !item || !item.isLocked)) {_context6.next = 6;break;}return _context6.abrupt("return");case 6:_context6.next = 8;return (



                  this.alignmentApi.setItemLocked(item, false));case 8:case "end":return _context6.stop();}}}, _callee6, this);}));function unlockAlignment(_x10, _x11) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}() }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(


      versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);_context7.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context7.sent;return _context7.abrupt("return",
                Boolean(item === null || item === void 0 ? void 0 : item.isLocked));case 5:case "end":return _context7.stop();}}}, _callee7, this);}));function isAlignmentLocked(_x12, _x13) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: "saveRegion", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(


      versionUrn, viewablePartId, regionId, boundingBox, transform) {var alignedItemID, item, regionsBackup, index, res;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);
                // get current item from cache
                _context8.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context8.sent;

                // Update item in cache or create a new one
                if (!item) {
                  item = new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().createNew(alignedItemID, transform);
                  this.cache.setItem(alignedItemID, item);
                }

                // if (!item.regions) {
                //     item.regions = [];
                // }
                //TODO: BLMV-5813 - Multiple viewports are currently disabled, so always override the current regions
                item.regions = [];

                regionsBackup = item.regions.slice();

                // In case that this regionId already exists in the service, we'll override its content.
                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});

                if (index === -1) {
                  // Otherwise, we'll create a new entry to the array.
                  index = item.regions.length;
                }

                item.regions[index] = {
                  regionId: regionId,
                  boundingBox: boundingBox,
                  transform: transform };


                // Note: If the server has changed meanwhile, we will overwrite it.
                //       Ideally, we should have some conflict handling workflow for this case.
                _context8.next = 12;return this.alignmentApi.saveItem(item);case 12:res = _context8.sent;

                if (!res) {
                  // Remove from cache if save failed
                  item.regions = regionsBackup;
                }return _context8.abrupt("return",

                res);case 15:case "end":return _context8.stop();}}}, _callee8, this);}));function saveRegion(_x14, _x15, _x16, _x17, _x18) {return _saveRegion.apply(this, arguments);}return saveRegion;}() }, { key: "loadRegions", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(


      versionUrn, viewablePartId) {var alignedItemID, item, regions;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);
                // get current item from cache
                _context9.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context9.sent;

                regions = item === null || item === void 0 ? void 0 : item.regions;return _context9.abrupt("return",

                regions || []);case 6:case "end":return _context9.stop();}}}, _callee9, this);}));function loadRegions(_x19, _x20) {return _loadRegions.apply(this, arguments);}return loadRegions;}() }, { key: "loadRegion", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(


      versionUrn, viewablePartId, regionId) {var regions, region;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return (
                  this.loadRegions(versionUrn, viewablePartId));case 2:regions = _context10.sent;

                region = regions.find(function (r) {return r.regionId === regionId;});return _context10.abrupt("return",

                region || null);case 5:case "end":return _context10.stop();}}}, _callee10, this);}));function loadRegion(_x21, _x22, _x23) {return _loadRegion.apply(this, arguments);}return loadRegion;}() }, { key: "deleteRegion", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(


      lineageUrn, versionUrn, viewablePartId, regionId) {var _this2 = this;var alignedItemID, relationships, item, regions;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, viewablePartId);_context11.next = 3;return (

                  this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId));case 3:relationships = _context11.sent;if (
                relationships.length) {_context11.next = 6;break;}throw (
                  'No relationship to delete');case 6:_context11.prev = 6;_context11.next = 9;return (



                  Promise.all(relationships.map(function (r) {return _this2.deleteRelationship(r.id);})));case 9:_context11.next = 15;break;case 11:_context11.prev = 11;_context11.t0 = _context11["catch"](6);

                console.warn('Could not delete relationships');throw _context11.t0;case 15:_context11.next = 17;return (




                  this.cache.getItem(alignedItemID));case 17:item = _context11.sent;
                regions = item === null || item === void 0 ? void 0 : item.regions;if (
                regions) {_context11.next = 22;break;}
                console.warn('No regions to delete');return _context11.abrupt("return");case 22:if (!(



                regions.length > 1)) {_context11.next = 28;break;}
                // Update the regions list. This will overwrite the item.
                item.regions = regions.filter(function (r) {return r.regionId !== regionId;});_context11.next = 26;return (
                  this.alignmentApi.saveItem(item));case 26:_context11.next = 29;break;case 28:

                // This is the only region in the item
                this.deleteItem(versionUrn, viewablePartId);case 29:case "end":return _context11.stop();}}}, _callee11, this, [[6, 11]]);}));function deleteRegion(_x24, _x25, _x26, _x27) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}() }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(



      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:_context12.next = 2;return (

                  this.relationshipApi.getRelationships(type, lineageUrn, viewablePartId, regionId));case 2:return _context12.abrupt("return", _context12.sent);case 3:case "end":return _context12.stop();}}}, _callee12, this);}));function getRelationships(_x28, _x29, _x30, _x31) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(


      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:_context13.next = 2;return (

                  this.relationshipApi.saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId));case 2:return _context13.abrupt("return", _context13.sent);case 3:case "end":return _context13.stop();}}}, _callee13, this);}));function saveRelationship(_x32, _x33, _x34, _x35, _x36) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()


    // Delete item from backend.
  }, { key: "deleteRelationship", value: function () {var _deleteRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(relationshipId) {return regeneratorRuntime.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:_context14.next = 2;return (
                  this.relationshipApi.deleteRelationship(relationshipId));case 2:return _context14.abrupt("return", _context14.sent);case 3:case "end":return _context14.stop();}}}, _callee14, this);}));function deleteRelationship(_x37) {return _deleteRelationship.apply(this, arguments);}return deleteRelationship;}() }, { key: "onError", value: function onError()


    {
      // Report error state
      this.error = true;
    } }, { key: "isWorking", value: function isWorking()

    {
      return !this.error;
    } }, { key: "clearCache", value: function clearCache()

    {
      this.cache.clear();
    }

    // Delete item from backend.
  }, { key: "deleteItem", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(versionUrn, partId) {var itemId, item;return regeneratorRuntime.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:

                // If item doesn't exist server-side, do nothing to avoid request error
                itemId = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__.AlignedItemID(versionUrn, partId);_context15.next = 3;return (
                  this.cache.getItem(itemId));case 3:item = _context15.sent;if (
                item.existsOnServer()) {_context15.next = 6;break;}return _context15.abrupt("return");case 6:if (!





                item.isLocked) {_context15.next = 9;break;}_context15.next = 9;return (
                  this.unlockAlignment(versionUrn, partId));case 9:


                // Remove from cache
                this.cache.setItem(itemId, null);

                // Send delete request
                _context15.next = 12;return this.alignmentApi.deleteItem(itemId);case 12:return _context15.abrupt("return", _context15.sent);case 13:case "end":return _context15.stop();}}}, _callee15, this);}));function deleteItem(_x38, _x39) {return _deleteItem.apply(this, arguments);}return deleteItem;}() }]);return AlignmentServiceNucleus;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceNucleusOverridable.js":
/*!********************************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceNucleusOverridable.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignmentServiceNucleusOverridable)
/* harmony export */ });
/* harmony import */ var _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentServiceNucleus */ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


// Extended variant of AlignmentServiceNucleus needed by Model Coordination:
//
// It allows for recovering previous alignment states - decoupled from the latest changes.
//
// For this, you specify alignment transforms and checksum for each model. If the checksum of an override
// matches with the latest saved alignment state, the override is ignored and you can edit the model.
//
// If it doesn't (i.e. overriden state is outdated), the model is locked.
//
// Note that you must call (and await) the async function clearRedundantOverrides() to detect and unlock all overrides that
// matches latest state.
var AlignmentServiceNucleusOverridable = /*#__PURE__*/function (_AlignmentServiceNucl) {_inherits(AlignmentServiceNucleusOverridable, _AlignmentServiceNucl);var _super = _createSuper(AlignmentServiceNucleusOverridable);

  function AlignmentServiceNucleusOverridable(options) {var _this;_classCallCheck(this, AlignmentServiceNucleusOverridable);
    _this = _super.call(this, options);

    // OverrideItems, indexed by (encoded) modelUrn, see typedef below.
    _this.items = {};return _this;
  }_createClass(AlignmentServiceNucleusOverridable, [{ key: "getTransform", value: function getTransform(

    versionUrn, viewablePartId) {

      // If an override tf is defined, return this instead.
      var overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);
      if (overrideTf !== undefined) {
        return overrideTf ? overrideTf.clone() : null;
      }

      return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), "getTransform", this).call(this, versionUrn, viewablePartId);
    } }, { key: "getIsLocked", value: function getIsLocked(

    versionUrn, viewablePartId) {

      // If an override transform is used, the model is always locked for editing.
      var overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);
      if (overrideTf !== undefined) {
        return true;
      }

      return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), "getIsLocked", this).call(this, versionUrn, viewablePartId);
    } }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      versionUrn, viewablePartId) {var overrideTf;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                // If an override transform is used, the model is always locked for editing.
                overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);if (!(
                overrideTf !== undefined)) {_context.next = 3;break;}return _context.abrupt("return",
                true);case 3:_context.next = 5;return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), "isAlignmentLocked", this).call(this,


                versionUrn, viewablePartId);case 5:return _context.abrupt("return", _context.sent);case 6:case "end":return _context.stop();}}}, _callee, this);}));function isAlignmentLocked(_x, _x2) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(


      versionUrn, viewablePartId) {var overrideTf;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                // If an override tf is defined, return this instead.
                overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);if (!(
                overrideTf !== undefined)) {_context2.next = 3;break;}return _context2.abrupt("return",
                overrideTf);case 3:_context2.next = 5;return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), "loadTransform", this).call(this,


                versionUrn, viewablePartId);case 5:return _context2.abrupt("return", _context2.sent);case 6:case "end":return _context2.stop();}}}, _callee2, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    // An OverrideItem defines the override transform for a single model:
    //
    // @typedef {
    //    // must be 64-bit precision. Can be null to enforce original file transform.
    //    transform: LmvMatrix4,
    //
    //    // Used to check whether the override matches with the latest state
    //    // in alignmentService.
    //    checksum:  string
    //
    //  } OverrideItem

    // Set override transform for a set of models.
    //
    // Note:
    //  - Overrides must be set before model loading, i.e. cannot be changed at runtime after loading.
    //  - Alignment editing is only allowed if the checksum of the override matches with the latest state in alignment service.
    //    Otherwise, the alignment editing is locked.
    //
    //  @param {Object.<string, OverrideItem>} items- Keys are base-64-encoded version urns. Values are Items.
  }, { key: "setOverrideTransforms", value: function setOverrideTransforms(items) {
      this.items = items;
    }

    // Removes all overrides whose timestamp already matches with the latest
    // state in alignment service. When using overrides, this function must be called
    // (and waited for) before the editAPI can be used.
  }, { key: "clearRedundantOverrides", value: function () {var _clearRedundantOverrides = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var _this2 = this;var urns, newItems;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:

                // Make sure that we fetch all in a single request, not one by one
                urns = Object.keys(this.items);_context3.next = 3;return (
                  this.fetchItems(urns));case 3:

                // newItems is the subset of overrides that we have to keep active, because there is
                // already a newer transform saved in alignment service.
                newItems = {};

                urns.forEach(function (urn) {

                  // get latest item from cache
                  var itemId = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_1__.AlignedItemID(urn);
                  var latestItem = _this2.cache.getCachedItem(itemId);

                  // get corresponding override item
                  var overrideItem = _this2.items[urn];

                  // Compare checksums
                  //
                  // Note that both checksums may be null if no transform was saved at all.
                  // In this case, the overrideItem will usually not have a checksum either and
                  // we can consider it as being latest state.
                  var isLatest = latestItem.checksum == overrideItem.checksum;

                  // Note: https://jira.autodesk.com/browse/BIMCAS-13047
                  // Temporary workaround to check if latestItem.transform, override checksum & transform is null but the latest checksum is not null.
                  // If they're the same then this override alignment is the tip alignment, otherwise it is not the latest alignment.
                  // This resolves an issue in Model Coordination where Model Set service doesn't include checksum when alignment previously existed for a model.
                  // This can be removed when the Nucleus Model Set service includes the Alignment checksum for null alignment transforms where available.
                  var isLatestState =
                  overrideItem.checksum === null &&
                  overrideItem.transform === null &&
                  latestItem.transform === null ?
                  latestItem.versionUrn == urn :
                  isLatest;

                  // Only keep overrides for items that are not at latest state.
                  // For all latest ones, we drop the override, so that they can be edited.
                  if (!isLatestState) {
                    newItems[urn] = overrideItem;
                  }
                });

                this.items = newItems;case 6:case "end":return _context3.stop();}}}, _callee3, this);}));function clearRedundantOverrides() {return _clearRedundantOverrides.apply(this, arguments);}return clearRedundantOverrides;}()


    // Returns the override transform for the given urn (if specified).
    // Return value is:
    //  - undefined:  If no override is set
    //  - null:       If null is set as override (= use file transform)
    //  - LmvMatrix4: constant override transform
    //
    // @returns {LmvMatrix4|null|undefined}
  }, { key: "getOverrideTransform", value: function getOverrideTransform(versionUrn, viewablePartId) {

      // Overrides are only supported for 3D model alignment
      if (viewablePartId) {
        return undefined;
      }

      // Check if an override is defined for this urn.
      var item = this.items[versionUrn];
      if (!item) {
        // No override => AlignmentService will return the actual transform.
        return undefined;
      }

      // In case the returned matrix is modified for computations, this shouldn't accidentally
      // change internal data. Therefore, return a copy instead of the original.
      if (item.transform) {
        return item.transform.clone();
      }

      // Return null to enforce original file tranform
      return null;
    } }]);return AlignmentServiceNucleusOverridable;}(_AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js":
/*!*****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/NucleusAlignmentAPI.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlignedItemID": () => (/* binding */ AlignedItemID),
/* harmony export */   "NucleusAlignmentAPI": () => (/* binding */ NucleusAlignmentAPI)
/* harmony export */ });
/* harmony import */ var _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignedItemNucleus */ "./extensions/ModelAlignmentService/AlignedItemNucleus.js");
/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RequestUtils */ "./extensions/ModelAlignmentService/RequestUtils.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;
var avp = av.Private;

// We use the DefaultSpaceId for all requests
var DefaultSpaceId = 'default';

// For debugging: Display reports of fetched/posted transforms
var DEBUG_OUTPUT = false;

// Only for debugging: Find model name for given encoded urn
var urnToModelName = function urnToModelName(urn) {
  // eslint-disable-next-line no-undef
  var nodes = LMV_MAIN_VIEW.getVisibleNodes();
  var node = nodes.find(function (node) {return node.getRootNode().urn() == urn;});
  return (node === null || node === void 0 ? void 0 : node.getModelName()) || "Unknown urn: ".concat(urn);
};

// Todo: This should be shared at a more central place.
//
// returns an array of arrays each having at most chunkSize elements
// TypeScript version:
function chunk(array, chunkSize) {
  var chunks = [];
  for (var i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

// Combines strings to uniquely address an AlignedItem for 2D or 3D.
var AlignedItemID = /*#__PURE__*/function () {

  // @param {string} urn - base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
  // @param {string} viewablePartId - viewable part id - name of the specific viewable, e.g. "Second Floor"
  function AlignedItemID(versionUrn) {var viewablePartId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;_classCallCheck(this, AlignedItemID);

    // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
    this.versionUrn = versionUrn;

    // Only used for 2D: Id of view and region within the model
    this.viewablePartId = viewablePartId;
  }

  // Convert array of urn strings to AlignedItem (if no partIds are needed) 
  //  @param {string[]} 
  _createClass(AlignedItemID, [{ key: "toObject",



    // Convert into object that we can serialize into a json request body
    value: function toObject() {
      return {
        // Note that (unlike most LMV code) alignment service backend works with decoded urns.
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn),

        // Make sure they are set to undefined unless actually specified
        viewablePartId: this.viewablePartId || undefined };

    } }, { key: "toString", value: function toString()

    {
      return "".concat(this.versionUrn).concat(this.viewablePartId ? "__".concat(this.viewablePartId) : '');
    } }], [{ key: "fromUrns", value: function fromUrns(urns) {return urns && urns.map(function (urn) {return new AlignedItemID(urn);});} }]);return AlignedItemID;}();


// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/construction/alignment' for staging)
var getDefaultServiceUrl = function getDefaultServiceUrl(docsEnv) {
  var envConfig = av.EnvironmentConfigurations[av.getEnv()];
  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;
  var envSuffix = docsEnv === 'QA' ? '-dev' : '';
  return baseUrl + '/construction/alignment' + envSuffix;
};

var getDefaultToken = function getDefaultToken() {
  return av.token.accessToken;
};

// Helper class to communicate with Nucleus AlignmentService backend
//
// Note:
//  - All urns must belong to the same projectUrn
//  - Particularly, projectUrn must not change at runtime.
var NucleusAlignmentAPI = /*#__PURE__*/function () {

  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'
  // @param {string}           [serviceVersion="v1"]
  // @param {function()}       [onError]
  function NucleusAlignmentAPI()






  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$docsEnv = _ref.docsEnv,docsEnv = _ref$docsEnv === void 0 ? '' : _ref$docsEnv,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl(docsEnv) : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? "v1" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusAlignmentAPI);

    this.projectId = projectId;
    this.getAccessToken = getAccessToken;
    this.onError = onError;

    this.serviceUrl = "".concat(serviceBaseUrl, "/").concat(serviceVersion);

    // Endpoint to read/write alignment items
    this.itemsEndPoint = "/projects/".concat(projectId, "/spaces/").concat(DefaultSpaceId, "/items");

    this.url = this.serviceUrl + this.itemsEndPoint;
  }


  // Batch-request multiple items
  //
  // @param {AlignedItemID[]} items
  // @returns {Object|undefined} A dictionary of AlignedItems, indexed by (encoded) versionUrn. Undefined on failure. 
  _createClass(NucleusAlignmentAPI, [{ key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(items) {var _this = this;var result, MaxItems, chunks, promises;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                result = {};

                // Avoid sending a request if the list is empty anyway.
                if (items.length) {_context.next = 3;break;}return _context.abrupt("return",
                result);case 3:


                // Batch requests are limited to 20 items per request.
                // https://stoplight.autodesk.com/bim360/bim360-nucleus-alignment/version%2F1.0/bim360-nucleus-alignment.oas3.yaml?view=%2Falignment-aligned-items%2Fgetaligneditembatch
                // 
                // => Split if we have more.
                MaxItems = 20;
                chunks = chunk(items, MaxItems);
                promises = chunks.map(function (c) {return _this._doBatchRequest(c, result);});_context.next = 8;return (
                  Promise.all(promises));case 8:return _context.abrupt("return",
                result);case 9:case "end":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Internal function to do a single batch request to query up to 20 items.
    //
    // @param {AlignmentItemId[]) itmes  - Single chunk of items. Max 20 items to request!
    // @param {Object|undeinfed}  result - A dictionary of AlignedItems, indexed by (encoded) versionUrn. All obtained results are added to that dictionary. 
  }, { key: "_doBatchRequest", value: function () {var _doBatchRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(items, result) {var body, i, postFix, res, response, loadedItems, _i, alignedItemId, key, data, report, _i2, name, _data;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                // List items in request body
                body = {};
                for (i = 0; i < items.length; i++) {
                  body[i] = items[i].toObject();
                }

                postFix = ':getBatch';_context2.next = 5;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_1__.sendRequestWithRetry)(this.getAccessToken, this.url + postFix, 'POST', body));case 5:res = _context2.sent;if (


                res.success) {_context2.next = 9;break;}
                this.onError();return _context2.abrupt("return");case 9:



                // get response data (should exist)
                response = res.data;if (
                response) {_context2.next = 13;break;}
                // Even if there are no alignments at all, the return value should be an empty object at the minimum
                console.warn('Unepxected request response: items:getBatch should get an empty response');return _context2.abrupt("return");case 13:


                loadedItems = response.results;

                // get alignment data from each item.
                // Response is not an array, but the keys for indexing are the same as we used in the body,
                // so that they will just be indexed by array indices into the items array.
                for (_i = 0; _i < items.length; _i++) {

                  // get encoded versionUrn 
                  alignedItemId = new AlignedItemID(items[_i].versionUrn, items[_i].viewablePartId);
                  key = alignedItemId.toString();

                  // Add items to result map, indexed by versionUrn.
                  // data will be null if no data was saved for this item before.
                  // In this case, we return a new "blank" AlignedItem, i.e. no transform and isLocked = false.
                  data = loadedItems && loadedItems[_i];
                  result[key] = data ? new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().load(data) : new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"](alignedItemId);
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  report = {};
                  for (_i2 = 0; _i2 < items.length; _i2++) {
                    name = urnToModelName(items[_i2].versionUrn);
                    _data = loadedItems && loadedItems[_i2];
                    report[name] = _data || 'No alignment';
                  }
                  console.log('Fetch successful:', report);
                }return _context2.abrupt("return",

                result);case 17:case "end":return _context2.stop();}}}, _callee2, this);}));function _doBatchRequest(_x2, _x3) {return _doBatchRequest2.apply(this, arguments);}return _doBatchRequest;}()


    // Store alignment item or create a new one.
    //
    // Note: Saving an item doesn't include the isLocked-flag, because setting the locked flag within an item-save request is not supported by alignmentService.
    //       Setting the lockFlag requires a separate request to another endpoint.
  }, { key: "saveItem", value: function () {var _saveItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(item) {var body, operation, res, name, report;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:

                body = item.toObject();

                // Decide which operation to perform:
                //  - POST:   Item doesn't exist on alignment service yet => Create a new one.
                //  - PATCH:  Modify or remove transform of existing item.
                //
                // Note: Even when resetting the transform back to source file transform, we must never send DELETE. Deleting an item would not guarantee
                //       that the transform is always reset to the source file transform: If there is no alignment item for a versionUrn, the alignment transform
                //       is inherited from the previous versions. So, instead of reseting to source-file transform, deleting the item would just 
                //       "reset it to the state of the previous version".
                //
                //       Example:
                //         - Assume model v1 was aligned, then model was updated to v2, and finally v2 was aligned again.
                //         - If we delete the alignment of v2, v2 would then inherit the alignment from v1.
                //         - Expected behavior is: v1 keeps its alignment, but v2 is reset to source-file transform. 
                //           => We still have to store an alignment item, just with transform null. 
                //
                operation = item.existsOnServer() ? 'PATCH' : 'POST';_context3.next = 4;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_1__.sendRequestWithRetry)(this.getAccessToken, this.url, operation, body));case 4:res = _context3.sent;if (

                res.success) {_context3.next = 8;break;}
                this.onError();return _context3.abrupt("return",
                false);case 8:


                // On success, update item with response from AlignmentService. Transform should usually
                // keep the same, but checksum and timestamp will change.
                if (res.data) {
                  item.load(res.data);
                } else {
                  // item has been deleted from server. So, we must reset its checksum so that we don't try
                  // to send PATCH requests on next change.
                  item.checksum = undefined;

                  // If operation is delete, the response will be empty. In this case, we can keep the cache
                  // item as it is, because it already indicates that no transform is set.
                  operation == 'DELETE' || console.warn('Unexpected request result: POST or PATCH should always respond an update item state');
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  name = urnToModelName(item.versionUrn);
                  report = {
                    model: name,
                    response: res.data,
                    operation: operation };


                  console.log('Transform saved: ', report);
                }return _context3.abrupt("return",

                true);case 11:case "end":return _context3.stop();}}}, _callee3, this);}));function saveItem(_x4) {return _saveItem.apply(this, arguments);}return saveItem;}()


    // Note: Removing the alignment item will change the alignment to whatever state was defined by previous versions.
    //       Therefore, actual delete is currently only used for debugging purposes. Resetting alignment is done by
    //       changing the transform to null, but keeping the item live (see saveItem comments for details).
    //
    // @param {AlignedItemID} item
  }, { key: "deleteItem", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(item) {var body;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                body = item.toObject();_context4.next = 3;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_1__.sendRequestWithRetry)(this.getAccessToken, this.url, 'DELETE', body));case 3:case "end":return _context4.stop();}}}, _callee4, this);}));function deleteItem(_x5) {return _deleteItem.apply(this, arguments);}return deleteItem;}()


    // Send request to lock or unlock an item.
    //
    // Requirements:
    //  - Item must exist server-side and reflect latest state
    //  - It must be ensured that the same item isn't locked/unlocked twice.
    //  - Unlock only works with admin priviledges
    //
    // @param {AlignedItemNucleus} item
    // @param {bool}               lock - whether to lock or unlock
  }, { key: "setItemLocked", value: function () {var _setItemLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(item, lock) {var data, body, postFix, res;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:

                data = item.toObject();
                body = {
                  versionUrn: data.versionUrn,
                  viewablePartId: data.viewablePartId };


                postFix = lock ? ':lock' : ':unlock';_context5.next = 5;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_1__.sendRequestWithRetry)(this.getAccessToken, this.url + postFix, 'PATCH', body));case 5:res = _context5.sent;if (
                res.success) {_context5.next = 9;break;}
                this.onError();return _context5.abrupt("return");case 9:



                // update item from server response. This should set the lock flag and update the checksum. 
                item.load(res.data);case 10:case "end":return _context5.stop();}}}, _callee5, this);}));function setItemLocked(_x6, _x7) {return _setItemLocked.apply(this, arguments);}return setItemLocked;}() }]);return NucleusAlignmentAPI;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/NucleusRelationshipAPI.js":
/*!********************************************************************!*\
  !*** ./extensions/ModelAlignmentService/NucleusRelationshipAPI.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NucleusRelationshipAPI": () => (/* binding */ NucleusRelationshipAPI)
/* harmony export */ });
/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestUtils */ "./extensions/ModelAlignmentService/RequestUtils.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;

// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/bim360/relationship-dev' for QA)
var getDefaultServiceUrl = function getDefaultServiceUrl(docsEnv) {
  var envConfig = av.EnvironmentConfigurations[av.getEnv()];
  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;
  var envSuffix = docsEnv === 'QA' ? '-dev' : '';
  return baseUrl + '/bim360/relationship' + envSuffix;
};

var getDefaultToken = function getDefaultToken() {
  return av.token.accessToken;
};

// Relationship entity ID is defined by lineageUrn + viewablePart + region.
var getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {
  // https://wiki.autodesk.com/pages/viewpage.action?spaceKey=ACSB4C&title=Relationship+Service+Alignment+Authorizer
  return "".concat(lineageUrn, "?").concat(Autodesk.AlignmentService.RelationshipIdPrefix.Name).concat(encodeURIComponent(viewablePart)).concat(region ? "".concat(Autodesk.AlignmentService.RelationshipIdPrefix.Region).concat(region) : '');
};

var Domain = 'autodesk-construction-alignment';

// Helper class to communicate with Nucleus Relationship Service backend
//
// Note:
//  - All urns must belong to the same projectUrn
//  - Particularly, projectUrn must not change at runtime.
var NucleusRelationshipAPI = /*#__PURE__*/function () {

  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/bim360/relationship'
  // @param {string}           [serviceVersion="v2"]
  // @param {function()}       [onError]
  function NucleusRelationshipAPI()






  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$docsEnv = _ref.docsEnv,docsEnv = _ref$docsEnv === void 0 ? '' : _ref$docsEnv,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl(docsEnv) : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? "v2" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusRelationshipAPI);

    this.projectId = projectId;
    this.getAccessToken = getAccessToken;
    this.onError = onError;

    this.serviceUrl = "".concat(serviceBaseUrl, "/").concat(serviceVersion);

    // Endpoint to read/write alignment items
    this.itemsEndPoint = "/containers/".concat(projectId, "/relationships");

    this.url = this.serviceUrl + this.itemsEndPoint;
  }_createClass(NucleusRelationshipAPI, [{ key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      type, lineageUrn, viewablePartId, regionId) {var _res$data;var id, idEncoded, postFix, res, relationships;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                id = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);
                idEncoded = encodeURIComponent(id); // When using the search API, id must be URI encoded.

                postFix = ":search?domain=".concat(Domain, "&type=").concat(type, "&id=").concat(idEncoded);_context.next = 5;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_0__.sendRequestWithRetry)(this.getAccessToken, this.url + postFix, 'GET'));case 5:res = _context.sent;if (


                res.success) {_context.next = 9;break;}
                this.onError();return _context.abrupt("return",
                []);case 9:


                // get response data (should exist)
                relationships = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.relationships;if (

                relationships) {_context.next = 13;break;}
                // Even if there are no alignments at all, the return value should be an empty object at the minimum
                console.warn('Unepxected request response: relationships:search should get an empty array');return _context.abrupt("return",
                []);case 13:


                // Decode ID for each entity. Viewer should not care that the service requires that it should be encoded.
                relationships.forEach(function (relationship) {
                  relationship.entities.forEach(function (entity) {
                    entity.id = decodeURIComponent(entity.id);
                  });
                });return _context.abrupt("return",

                relationships);case 15:case "end":return _context.stop();}}}, _callee, this);}));function getRelationships(_x, _x2, _x3, _x4) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(


      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, item, body, res;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);
                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);

                // this is how this structure that it is stored in real Relationship service.
                item = {
                  entities: [
                  {
                    domain: Domain,
                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,
                    id: sheetEntityId },

                  {
                    domain: Domain,
                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,
                    id: modelEntityId }] };




                body = [item];_context2.next = 6;return (

                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_0__.sendRequestWithRetry)(this.getAccessToken, this.url, 'PUT', body));case 6:res = _context2.sent;if (

                res.success) {_context2.next = 10;break;}
                this.onError();return _context2.abrupt("return",
                false);case 10:return _context2.abrupt("return",


                true);case 11:case "end":return _context2.stop();}}}, _callee2, this);}));function saveRelationship(_x5, _x6, _x7, _x8, _x9) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}() }, { key: "deleteRelationship", value: function () {var _deleteRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(


      relationshipId) {var body, postFix, res;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                body = [relationshipId];

                postFix = ':delete';_context3.next = 4;return (
                  (0,_RequestUtils__WEBPACK_IMPORTED_MODULE_0__.sendRequestWithRetry)(this.getAccessToken, this.url + postFix, 'POST', body));case 4:res = _context3.sent;if (


                res.success) {_context3.next = 8;break;}
                this.onError();return _context3.abrupt("return");case 8:case "end":return _context3.stop();}}}, _callee3, this);}));function deleteRelationship(_x10) {return _deleteRelationship.apply(this, arguments);}return deleteRelationship;}() }]);return NucleusRelationshipAPI;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/RequestUtils.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignmentService/RequestUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Retry": () => (/* binding */ Retry),
/* harmony export */   "sendRequest": () => (/* binding */ sendRequest),
/* harmony export */   "sendRequestWithRetry": () => (/* binding */ sendRequestWithRetry)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper class for retrying requests
var Retry = /*#__PURE__*/function () {

  function Retry() {_classCallCheck(this, Retry);

    // Maximum number of attempts before giving up
    this.maxAttempts = 10;

    // Waiting time in ms for first retry
    this.startDelay = 100;

    // Exponential grow factor for the waiting time per attempt
    this.growFactor = 1.1;
  }

  // Returns the waiting time in ms before retrying.    
  _createClass(Retry, [{ key: "getWaitingTime", value: function getWaitingTime(numFailedAttempts) {
      return numFailedAttempts ? this.startDelay * Math.pow(this.growFactor, numFailedAttempts - 1) : 0;
    }

    // Try the given (async) callback until either successful or until maximum retry count is reached.
    //  - Return value is the last result of callback
    //  - Callback is considered successful if isSuccess(result) is true.
  }, { key: "run", value: function run(callback, isSuccess) {var _this = this;

      return new Promise(function (resolve) {

        // track number of attempts
        var numFailedAttempts = 0;

        var nextTry = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var result, delayInMs;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                      callback());case 2:result = _context.sent;if (!


                    isSuccess(result)) {_context.next = 5;break;}return _context.abrupt("return",
                    resolve(result));case 5:


                    // Give up if we reached the limit
                    numFailedAttempts++;if (!(
                    numFailedAttempts >= _this.maxAttempts)) {_context.next = 8;break;}return _context.abrupt("return",
                    resolve(result));case 8:


                    // schedule next attempt
                    delayInMs = _this.getWaitingTime(numFailedAttempts);
                    window.setTimeout(nextTry, delayInMs);case 10:case "end":return _context.stop();}}}, _callee);}));return function nextTry() {return _ref.apply(this, arguments);};}();

        nextTry();
      });
    } }]);return Retry;}();


// Result is an object { success, response }.
var sendRequest = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(getAccessToken, url, operation) {var body,result,token,_args2 = arguments;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:body = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;

            result = {
              success: false,
              data: null };_context2.next = 4;return (


              getAccessToken());case 4:token = _context2.sent;_context2.next = 7;return (

              new Promise(function (resolve) {

                var xhr = new XMLHttpRequest();
                xhr.open(operation, url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.setRequestHeader('accept', 'application/json');
                xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
                xhr.setRequestHeader('Authorization', 'Bearer ' + token);

                // On failure: resolve with result.success == false
                var onFailure = function onFailure() {
                  resolve(result);
                };

                // Parse response as json on success
                var onLoad = function onLoad() {

                  // Even if the request didn't trigger an error callback,
                  // the server response may still indicate an error (e.g. this happens on authorization failure) 
                  if (xhr.status < 200 || xhr.status >= 300) {
                    onFailure();
                    return;
                  }

                  try {
                    // If json parsing succeeds, return success
                    // Some requests (e.g. DELETE) may also get an empty string as result on success, but JSON.parse() would
                    // fail on those. Therefore, we accept empty responses as well and just set data to null for this case. 
                    result.data = xhr.response ? JSON.parse(xhr.response) : null;
                    result.success = true;
                    resolve(result);
                  } catch (e) {
                    // json parsing failed.
                    onFailure();
                  }
                };

                xhr.onload = onLoad;
                xhr.onerror = onFailure;
                xhr.ontimeout = onFailure;
                xhr.onabort = onFailure;

                xhr.send(body && JSON.stringify(body));
              }));case 7:return _context2.abrupt("return", _context2.sent);case 8:case "end":return _context2.stop();}}}, _callee2);}));return function sendRequest(_x, _x2, _x3) {return _ref2.apply(this, arguments);};}();


var sendRequestWithRetry = /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(getAccessToken, url, operation, body) {var doRequest, isSuccess;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
            doRequest = function doRequest() {return sendRequest(getAccessToken, url, operation, body);};
            isSuccess = function isSuccess(res) {return res.success;};_context3.next = 4;return (
              new Retry().run(doRequest, isSuccess));case 4:return _context3.abrupt("return", _context3.sent);case 5:case "end":return _context3.stop();}}}, _callee3);}));return function sendRequestWithRetry(_x4, _x5, _x6, _x7) {return _ref3.apply(this, arguments);};}();

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************************************************!*\
  !*** ./extensions/ModelAlignmentService/ModelAlignmentService.js ***!
  \*******************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ModelAlignmentService)
/* harmony export */ });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentServiceLS */ "./extensions/ModelAlignmentService/AlignmentServiceLS.js");
/* harmony import */ var _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlignmentServiceNucleus */ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js");
/* harmony import */ var _AlignmentServiceNucleusOverridable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlignmentServiceNucleusOverridable */ "./extensions/ModelAlignmentService/AlignmentServiceNucleusOverridable.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.ModelAlignmentService');
var myExtensionName = 'Autodesk.ModelAlignmentService';







/** 
                                                              * This extension defines the API for managing storage of model alignment transform
                                                              * on a backend or in local storage. It provides a local-storage based implementation for reference. 
                                                              * The extension id is: `Autodesk.ModelAlignmentServiceAPI`
                                                              */var
ModelAlignmentService = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentService, _av$Extension);var _super = _createSuper(ModelAlignmentService);
  function ModelAlignmentService(viewer, options) {_classCallCheck(this, ModelAlignmentService);return _super.call(this,
    viewer, options);
  }return ModelAlignmentService;}(av.Extension);


// Register the extension with the extension manager.
av.theExtensionManager.registerExtension(myExtensionName, ModelAlignmentService);

namespace.AlignmentService = _AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"];
namespace.AlignmentServiceLS = _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.NucleusAlignmentAPI = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_4__.NucleusAlignmentAPI;
namespace.AlignmentServiceNucleus = _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.AlignmentServiceNucleusOverridable = _AlignmentServiceNucleusOverridable__WEBPACK_IMPORTED_MODULE_3__["default"];
})();

Autodesk.Extensions.ModelAlignmentService = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=ModelAlignmentService.js.map