/*!
 * LMV v7.17.1
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.StandardSurface =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/StandardSurface/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/StandardSurface/StandardSurfaceMaterial.js":
/*!***************************************************************!*\
  !*** ./extensions/StandardSurface/StandardSurfaceMaterial.js ***!
  \***************************************************************/
/*! exports provided: StandardSurfaceShader, StandardSurfaceMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StandardSurfaceShader", function() { return StandardSurfaceShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StandardSurfaceMaterial", function() { return StandardSurfaceMaterial; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/wgs/render/ShaderChunks */ "./src/wgs/render/ShaderChunks.js");
/* harmony import */ var _src_wgs_render_PrismUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/wgs/render/PrismUtil */ "./src/wgs/render/PrismUtil.js");
/* harmony import */ var _std_surf_vert_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./std-surf-vert.glsl */ "./extensions/StandardSurface/std-surf-vert.glsl");
/* harmony import */ var _std_surf_vert_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_std_surf_vert_glsl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _std_surf_frag_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./std-surf-frag.glsl */ "./extensions/StandardSurface/std-surf-frag.glsl");
/* harmony import */ var _std_surf_frag_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_std_surf_frag_glsl__WEBPACK_IMPORTED_MODULE_4__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance");}function _iterableToArrayLimit(arr, i) {if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {return;}var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter) {if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;}}function isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _construct(Parent, args, Class) {if (isNativeReflectConstruct()) {_construct = Reflect.construct;} else {_construct = function _construct(Parent, args, Class) {var a = [null];a.push.apply(a, args);var Constructor = Function.bind.apply(Parent, a);var instance = new Constructor();if (Class) _setPrototypeOf(instance, Class.prototype);return instance;};}return _construct.apply(null, arguments);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}






var STANDARD_SURFACE_UNIFORMS = {
  u_base: { type: 'f', value: 0.8 },
  u_base_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_coat: { type: 'f', value: 0.0 },
  u_coat_affect_color: { type: 'f', value: 0.0 },
  u_coat_affect_roughness: { type: 'f', value: 0.0 },
  u_coat_anisotropy: { type: 'f', value: 0.0 },
  u_coat_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_coat_IOR: { type: 'f', value: 1.5 },
  u_coat_normal: { type: 'v3', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
  u_coat_rotation: { type: 'f', value: 0.0 },
  u_coat_roughness: { type: 'f', value: 0.1 },
  u_diffuse_roughness: { type: 'f', value: 0.0 },
  u_emission: { type: 'f', value: 0.0 },
  u_emission_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_metalness: { type: 'f', value: 0.0 },
  u_normal: { type: 'v3', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
  u_opacity: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_sheen: { type: 'f', value: 0.0 },
  u_sheen_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_sheen_roughness: { type: 'f', value: 0.3 },
  u_specular: { type: 'f', value: 1.0 },
  u_specular_anisotropy: { type: 'f', value: 0.0 },
  u_specular_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_specular_IOR: { type: 'f', value: 1.52 },
  u_specular_rotation: { type: 'f', value: 0.0 },
  u_specular_roughness: { type: 'f', value: 0.1 },
  u_subsurface: { type: 'f', value: 0.0 },
  u_subsurface_anisotropy: { type: 'f', value: 0.0 },
  u_subsurface_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_subsurface_radius: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_subsurface_scale: { type: 'f', value: 1.0 },
  u_thin_film_IOR: { type: 'f', value: 1.5 },
  u_thin_film_thickness: { type: 'f', value: 0.0 },
  u_thin_walled: { type: 'i', value: 0 },
  u_transmission: { type: 'f', value: 0.0 },
  u_transmission_color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
  u_transmission_depth: { type: 'f', value: 0.0 },
  u_transmission_dispersion: { type: 'f', value: 0.0 },
  u_transmission_extra_roughness: { type: 'f', value: 0.0 },
  u_transmission_scatter: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0x000000) },
  u_transmission_scatter_anisotropy: { type: 'f', value: 0.0 } };


var SHEEN_ALBEDO_DATA_TEXTURE = buildSheenTable([
1.6177, 0.978927, 0.618938, 0.391714, 0.245177, 0.150234, 0.0893475, 0.0511377, 0.0280191, 0.0144204, 0.00687674, 0.00295935, 0.00111049, 0.000336768, 7.07119e-5, 6.22646e-06,
1.1084, 0.813928, 0.621389, 0.479304, 0.370299, 0.284835, 0.21724, 0.163558, 0.121254, 0.0878921, 0.0619052, 0.0419894, 0.0270556, 0.0161443, 0.00848212, 0.00342323,
0.930468, 0.725652, 0.586532, 0.479542, 0.393596, 0.322736, 0.26353, 0.213565, 0.171456, 0.135718, 0.105481, 0.0800472, 0.0588117, 0.0412172, 0.0268329, 0.0152799,
0.833791, 0.671201, 0.558957, 0.471006, 0.398823, 0.337883, 0.285615, 0.240206, 0.200696, 0.16597, 0.135422, 0.10859, 0.0850611, 0.0644477, 0.0464763, 0.0308878,
0.771692, 0.633819, 0.537877, 0.461939, 0.398865, 0.344892, 0.297895, 0.256371, 0.219562, 0.186548, 0.156842, 0.130095, 0.10598, 0.0841919, 0.0645311, 0.04679,
0.727979, 0.606373, 0.52141, 0.453769, 0.397174, 0.348337, 0.305403, 0.267056, 0.232655, 0.201398, 0.17286, 0.146756, 0.122808, 0.100751, 0.0804254, 0.0616485,
0.695353, 0.585281, 0.508227, 0.44667, 0.394925, 0.350027, 0.310302, 0.274561, 0.242236, 0.212604, 0.185281, 0.16002, 0.13657, 0.114693, 0.0942543, 0.0750799,
0.669981, 0.568519, 0.497442, 0.440542, 0.392567, 0.350786, 0.313656, 0.280075, 0.249533, 0.221359, 0.195196, 0.170824, 0.148012, 0.126537, 0.106279, 0.0870713,
0.649644, 0.554855, 0.488453, 0.435237, 0.390279, 0.351028, 0.316036, 0.284274, 0.255266, 0.228387, 0.203297, 0.179796, 0.157665, 0.136695, 0.116774, 0.0977403,
0.632951, 0.543489, 0.480849, 0.430619, 0.388132, 0.350974, 0.317777, 0.287562, 0.259885, 0.234153, 0.210041, 0.187365, 0.165914, 0.145488, 0.125983, 0.10724,
0.61899, 0.533877, 0.47433, 0.426573, 0.386145, 0.35075, 0.319078, 0.290197, 0.263681, 0.238971, 0.215746, 0.193838, 0.173043, 0.153167, 0.134113, 0.115722,
0.607131, 0.52564, 0.468678, 0.423001, 0.38432, 0.35043, 0.320072, 0.292349, 0.266856, 0.243055, 0.220636, 0.199438, 0.179264, 0.159926, 0.141332, 0.123323,
0.596927, 0.518497, 0.463731, 0.419829, 0.382647, 0.350056, 0.320842, 0.294137, 0.269549, 0.246564, 0.224875, 0.204331, 0.18474, 0.165919, 0.147778, 0.130162,
0.588052, 0.512241, 0.459365, 0.416996, 0.381114, 0.349657, 0.321448, 0.295641, 0.271862, 0.24961, 0.228584, 0.208643, 0.189596, 0.171266, 0.153566, 0.136341,
0.580257, 0.506717, 0.455481, 0.41445, 0.379708, 0.34925, 0.321929, 0.296923, 0.273869, 0.252279, 0.231859, 0.212472, 0.193933, 0.176066, 0.158788, 0.141945,
0.573355, 0.5018, 0.452005, 0.412151, 0.378416, 0.348844, 0.322316, 0.298028, 0.275627, 0.254638, 0.234772, 0.215896, 0.197828, 0.180398, 0.163522, 0.147049]);


var SAMPLING_RANDOM_DATA_TEXTURE = buildRandomTable([
0, 128, 64, 191, 32, 160, 96, 223,
16, 143, 80, 207, 48, 175, 112, 239,
8, 135, 72, 199, 40, 167, 103, 231,
25, 151, 88, 215, 56, 183, 120, 250]);


function getMapUniforms(name) {var _ref;
  return _ref = {}, _defineProperty(_ref,
  name, { type: 't', value: null }), _defineProperty(_ref, "".concat(
  name, "_texMatrix"), { type: 'm3', value: null }), _defineProperty(_ref, "".concat(
  name, "_invert"), { type: 'i', value: 0 }), _defineProperty(_ref, "".concat(
  name, "_encoding"), { type: 'i', value: 0 }), _defineProperty(_ref, "".concat(
  name, "_valueScale"), { type: 'f', value: 1.0 }), _ref;

}

function getNormalMapUniforms(name) {var _ref2;
  return three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
  getMapUniforms(name), (_ref2 = {}, _defineProperty(_ref2, "".concat(

  name, "_isHeight"), { type: 'i', value: 0 }), _defineProperty(_ref2, "".concat(
  name, "_heightScale"), { type: 'v2', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1.0, 1.0) }), _ref2)]);


}

function makeDataTexture() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
  var tex = _construct(three__WEBPACK_IMPORTED_MODULE_0__["DataTexture"], args);
  tex.needsUpdate = true;
  return tex;
}

function buildRandomTable(array) {
  var size = array.length;
  var data = new Uint8Array(array);
  var tex = makeDataTexture(data, size, 1, three__WEBPACK_IMPORTED_MODULE_0__["LuminanceFormat"], three__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"], three__WEBPACK_IMPORTED_MODULE_0__["UVMapping"], three__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"], three__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"], three__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"], three__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"], 0);
  tex.generateMipmaps = false;
  return {
    tex: tex,
    size: size };

}

function buildSheenTable(array) {
  var size = Math.sqrt(array.length);
  var max = Math.max.apply(Math, _toConsumableArray(array));
  var min = Math.min.apply(Math, _toConsumableArray(array));
  var rng = max - min;
  var data = new Uint8Array(array.
  map(function (v) {return (v - min) / rng;}).
  map(function (v) {
    var enc = [1, 255, 65025, 16581375].map(function (k) {return k * v * 255 / 256 % 1;});
    return [enc[0] - enc[1] / 255, enc[1] - enc[2] / 255, enc[2] - enc[3] / 255, enc[3]].
    map(function (k) {return Math.floor(255 * k);});
  }).
  flat());
  var tex = makeDataTexture(data, size, size, three__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"], three__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"], three__WEBPACK_IMPORTED_MODULE_0__["UVMapping"], three__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"], three__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"], three__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"], three__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"], 0);
  tex.generateMipmaps = false;
  return {
    tex: tex,
    rng: rng,
    min: min,
    size: size,
    data: data };

}

function getTypeString(t) {
  switch (t) {
    case 'i':return 'int';
    case 'f':return 'float';
    case 'v3':
    case 'c':return 'vec3';
    default:throw new Error("unrecognized uniform type: ".concat(t));}

}

function buildFragmentShader(std_surf_frag) {
  var a = '';
  var b = '';

  for (var _i = 0, _Object$entries = Object.entries(STANDARD_SURFACE_UNIFORMS); _i < _Object$entries.length; _i++) {var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),k = _Object$entries$_i[0],v = _Object$entries$_i[1];
    var isNormal = /_normal$/.test(k);
    a += "uniform ".concat(getTypeString(v.type).padEnd(9, ' '), " ").concat(k, ";\n#if defined(USE_").concat(
    k.slice(2).toUpperCase(), "_MAP)\nuniform sampler2D ").concat(
    k, "_map;\nuniform mat3      ").concat(
    k, "_map_texMatrix;\nuniform int       ").concat(
    k, "_map_invert;\nuniform int       ").concat(
    k, "_map_encoding;\nuniform float     ").concat(
    k, "_map_valueScale;\n");
    if (isNormal) {
      a += "uniform int       ".concat(k, "_map_isHeight;\nuniform vec2      ").concat(
      k, "_map_heightScale;\n");
    }
    a += "#endif\n";
    if (isNormal) {
      b += "mat3 get_".concat(k.slice(2).replace(/normal$/, 'TBN'), "(in vec3 geoWorldNorm, in vec3 T, in vec3 B, in vec2 uv) {\n    vec3 N = ").concat(
      k, ";\n    if (length(N) <= M_FLOAT_EPS) {\n        N = geoWorldNorm;\n    }\n    N = normalize(N);\n    #if defined(USE_").concat(




      k.slice(2).toUpperCase(), "_MAP)\n    transform_basis(T, B, N, uv, ").concat(
      k, "_map, ").concat(k, "_map_texMatrix, ").concat(k, "_map_invert, ").concat(k, "_map_encoding, ").concat(k, "_map_valueScale, ").concat(k, "_map_isHeight, ").concat(k, "_map_heightScale);\n    #endif\n    return mat3(T, B, N);\n}\n\n");



    } else {
      var type = getTypeString(v.type);
      b += "".concat(type, " get_").concat(k.slice(2), "(in vec2 uv) {\n    ").concat(
      type, " val = ").concat(k, ";\n    #if defined(USE_").concat(
      k.slice(2).toUpperCase(), "_MAP)\n    val = ").concat(
      v.type === 'i' ? 'int(' : '', "sample_map((").concat(k, "_map_texMatrix * vec3(uv, 1.0)).xy, ").concat(k, "_map, ").concat(k, "_map_invert, ").concat(k, "_map_encoding, ").concat(k, "_map_valueScale).r").concat(v.type === 'c' ? 'gb' : v.type === 'i' ? ' > 0.5)' : '', ";\n    #endif\n    return val").concat(

      /rotation$/.test(k) ? " / ".concat(type, "(PI * 2.0)") : '', ";\n}\n\n");

    }
  }
  return std_surf_frag.replace(/^#inject<uniforms>$/m, a).replace(/^#inject<getters>$/m, b);
}

var StandardSurfaceShader = {
  uniforms: three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
  three__WEBPACK_IMPORTED_MODULE_0__["UniformsLib"].common,
  three__WEBPACK_IMPORTED_MODULE_0__["UniformsLib"].lights,
  three__WEBPACK_IMPORTED_MODULE_0__["UniformsLib"].fog,
  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__["ShaderChunks"].CutPlanesUniforms,
  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__["ShaderChunks"].IdUniforms,
  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__["ShaderChunks"].ThemingUniform,
  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__["ShaderChunks"].ShadowMapUniforms,
  STANDARD_SURFACE_UNIFORMS].concat(_toConsumableArray(
  Object.keys(STANDARD_SURFACE_UNIFORMS).map(function (k) {return /_normal$/.test(k) ? getNormalMapUniforms("".concat(k, "_map")) : getMapUniforms("".concat(k, "_map"));}).flat()), [
  Object(_src_wgs_render_PrismUtil__WEBPACK_IMPORTED_MODULE_2__["GetPrismMapUniforms"])('TilingMap'),
  Object(_src_wgs_render_PrismUtil__WEBPACK_IMPORTED_MODULE_2__["GetPrismMapUniforms"])('TilingNormalMap'),
  Object(_src_wgs_render_PrismUtil__WEBPACK_IMPORTED_MODULE_2__["GetPrismMapUniforms"])('TilingRandomMap'),
  {
    u_sheenAlbedo: { type: 't', value: null },
    u_samplingRandomMap: { type: 't', value: null },
    irradianceMap: { type: 't', value: null },
    envMap: { type: 't', value: null },
    exposureBias: { type: 'f', value: 1.0 },
    envMapExposure: { type: 'f', value: 1.0 },
    envRotationSin: { type: 'f', value: 0.0 },
    envRotationCos: { type: 'f', value: 1.0 },
    envExponentMin: { type: 'f', value: 1.0 },
    envExponentMax: { type: 'f', value: 512.0 },
    envExponentCount: { type: 'f', value: 10.0 },
    envMapMipLevels: { type: 'i', value: 1 },
    tilingOverallTransform: { type: 'm4', value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() },
    uv2tile: { type: 'v4', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](1.0, 0.0, 0.0, 1.0) },
    tile2uv: { type: 'v4', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](1.0, 0.0, 0.0, 1.0) },
    tileAlignOffset: { type: 'v2', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0.0, 0.0) },
    tilingUVTransform: { type: 'm4', value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() },
    tilingRandomAxisS: { type: 'v2', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0.0, 0.0) },
    tilingRandomAxisT: { type: 'v2', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0.0, 0.0) },
    tilingRandomAlignmentOffset: { type: 'v2', value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0.0, 0.0) } }])),


  vertexShader: _std_surf_vert_glsl__WEBPACK_IMPORTED_MODULE_3___default.a,
  fragmentShader: buildFragmentShader(_std_surf_frag_glsl__WEBPACK_IMPORTED_MODULE_4___default.a) };


function snakeToCamel(s) {
  return s.replace(/(_[a-z])/ig, function (m) {return m.toUpperCase().replace('_', '');});
}

var StandardSurfaceMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {_inherits(StandardSurfaceMaterial, _THREE$ShaderMaterial);

  function StandardSurfaceMaterial() {var _this;_classCallCheck(this, StandardSurfaceMaterial);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(StandardSurfaceMaterial).call(this, {
      uniforms: three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].clone(StandardSurfaceShader.uniforms),
      vertexShader: StandardSurfaceShader.vertexShader,
      fragmentShader: StandardSurfaceShader.fragmentShader }));

    _this.type = 'StandardSurfaceMaterial';
    _this.supportsMrtNormals = true;
    _this.lights = true;
    _this.uniforms.u_sheenAlbedo.value = SHEEN_ALBEDO_DATA_TEXTURE.tex;
    _this.uniforms.u_samplingRandomMap.value = SAMPLING_RANDOM_DATA_TEXTURE.tex;
    _this.uniforms.envMapMipLevels.value = 8; // for all presets
    _this.defines.SHEEN_ALBEDO_TABLE_SIZE = SHEEN_ALBEDO_DATA_TEXTURE.size;
    _this.defines.SHEEN_ALBEDO_TABLE_RANGE = SHEEN_ALBEDO_DATA_TEXTURE.rng;
    _this.defines.SHEEN_ALBEDO_TABLE_MIN = SHEEN_ALBEDO_DATA_TEXTURE.min;
    _this.defines.SAMPLING_RANDOM_TABLE_SIZE = SAMPLING_RANDOM_DATA_TEXTURE.size;
    _this.defines.NUM_SAMPLES = 8;
    _this.shading = three__WEBPACK_IMPORTED_MODULE_0__["FlatShading"]; // to turn on derivatives //todo: IS THIS NECESSARY IN LMV?
    _this.isStandardSurfaceMaterial = true;
    _this.needsUpdate = true;return _this;
  }_createClass(StandardSurfaceMaterial, [{ key: "refreshUniforms", value: function refreshUniforms(























































































    uniforms) {
      uniforms.exposureBias.value = this.exposureBias;
      // uniforms.opacity.value = mtl.opacity;

      for (var _i2 = 0, _Object$keys = Object.keys(STANDARD_SURFACE_UNIFORMS); _i2 < _Object$keys.length; _i2++) {var k = _Object$keys[_i2];
        var tex = this[snakeToCamel(k.slice(2))];
        if (tex instanceof three__WEBPACK_IMPORTED_MODULE_0__["Texture"]) {
          this.refreshTextureUniforms(k, tex, uniforms);
        }
      }

      // Refresh IBL uniforms, taken from WebGLRenderer.refreshUniformsIBL
      uniforms.envMap.value = this.envMap;
      //uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
      uniforms.irradianceMap.value = this.irradianceMap;
      uniforms.envMapExposure.value = this.envMapExposure;
      uniforms.envRotationSin.value = this.envRotationSin;
      uniforms.envRotationCos.value = this.envRotationCos;
    } }, { key: "refreshTextureUniforms", value: function refreshTextureUniforms(

    k, tex) {var uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.uniforms;
      uniforms["".concat(k, "_map")].value = tex;
      uniforms["".concat(k, "_map_texMatrix")].value = tex.matrix;
      uniforms["".concat(k, "_map_invert")].value = tex.invert ? 1 : 0;
      uniforms["".concat(k, "_map_encoding")].value = tex.encoding === 'linear' ? 1 : 0;
      uniforms["".concat(k, "_map_valueScale")].value = tex.rgbScale;
      if (/normal$/.test(k)) {
        uniforms["".concat(k, "_map_isHeight")].value = tex.isHeightMap ? 1 : 0;
        uniforms["".concat(k, "_map_heightScale")].value.set(tex.heightMapScale, tex.heightMapScale);
      }
    } }, { key: "_getter", value: function _getter(

    t, k) {
      if (this.defines.hasOwnProperty("USE_".concat(k.slice(2).toUpperCase(), "_MAP"))) {
        return this.uniforms["".concat(k, "_map")].value;
      }
      var val = this.uniforms[k].value;
      if (t === 'i') {
        return !!val;
      } else {
        return val;
      }
    } }, { key: "_setter", value: function _setter(

    t, k, v) {
      if (v instanceof three__WEBPACK_IMPORTED_MODULE_0__["Texture"]) {
        this.refreshTextureUniforms(k, v);
        if (!this.defines.hasOwnProperty("USE_".concat(k.slice(2).toUpperCase(), "_MAP"))) {
          this.defines["USE_".concat(k.slice(2).toUpperCase(), "_MAP")] = true;
          this.needsUpdate = true;
        }
        return true;
      } else if (v === undefined || v === null) {
        if (t === 'c' || t === 'v3') {
          v = STANDARD_SURFACE_UNIFORMS[k].clone();
        } else {
          v = STANDARD_SURFACE_UNIFORMS[k].value;
        }
      }
      switch (t) {
        case 'f':
          if (typeof v !== 'number') {
            console.warn("Invalid value for ".concat(snakeToCamel(k.slice(2)), "; expected number or texture"));
            return false;
          }
          break;
        case 'c':
          if (!(v instanceof three__WEBPACK_IMPORTED_MODULE_0__["Color"])) {
            if (typeof v === 'number' || typeof v === 'string') {
              v = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](v);
            } else {
              console.warn("Invalid value for ".concat(snakeToCamel(k.slice(2)), "; expected color or texture"));
              return false;
            }
          }
          break;
        case 'v3':
          if (!(v instanceof three__WEBPACK_IMPORTED_MODULE_0__["Vector3"])) {
            console.warn("Invalid value for ".concat(snakeToCamel(k.slice(2)), "; expected vec3 or texture"));
            return false;
          }
          break;
        case 'i':
          v = !!v;
          break;
        default:break; // should be unreachable
      }

      if (this.uniforms[k].value !== v) {
        this.uniforms[k].value = v;
      }
      if (this.defines.hasOwnProperty("USE_".concat(k.slice(2).toUpperCase(), "_MAP"))) {
        delete this.defines["USE_".concat(k.slice(2).toUpperCase(), "_MAP")];
        this.needsUpdate = true;
      }
      return true;
    } }, { key: "clone", value: function clone()

    {
      var mat = new StandardSurfaceMaterial();
      mat.standardSurface = this.standardSurface;
      mat.name = this.tag;
      mat.packedNormals = true;
      for (var _i3 = 0, _Object$keys2 = Object.keys(STANDARD_SURFACE_UNIFORMS); _i3 < _Object$keys2.length; _i3++) {var k = _Object$keys2[_i3];
        var key = snakeToCamel(k.slice(2));
        if (this[key] instanceof three__WEBPACK_IMPORTED_MODULE_0__["Vector3"] || this[key] instanceof three__WEBPACK_IMPORTED_MODULE_0__["Color"]) {
          mat[key] = this[key].clone();
        } else {
          mat[key] = this[key];
        }
      }
      mat.envMap = this.envMap;
      mat.irradianceMap = this.irradianceMap;
      mat.envMapExposure = this.envMapExposure;
      mat.envRotationSin = this.envRotationSin;
      mat.envRotationCos = this.envRotationCos;
      mat.exposureBias = this.exposureBias;
      mat.tonemapOutput = this.tonemapOutput;
      mat.cutplanes = this.cutplanes;
      mat.textureMaps = this.textureMaps;
      mat.texturesLoaded = this.texturesLoaded;
      return mat;
    } }, { key: "transparent", get: function get() {return this.uniforms.u_opacity.value.r < 1 || this.uniforms.u_opacity.value.g < 1 || this.uniforms.u_opacity.value.b < 1 || this.uniforms.u_transmission.value > 0 || this.uniforms.u_transmission_map.value !== null;}, set: function set(v) {// ignore set
      return true;} }, { key: "opacity", get: function get() {if (this.uniforms) {// opacity is set in super constructor before uniforms
        return (this.uniforms.u_opacity.value.r + this.uniforms.u_opacity.value.g + this.uniforms.u_opacity.value.b) / 3;} else {return 1;}}, set: function set(v) {if (this.uniforms) {// opacity is set in super constructor before uniforms
        if (typeof v === 'number') {v = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](v, v, v);}return this._setter('c', 'u_opacity', v);}return true;} }, { key: "envMap", get: function get() {return this.uniforms.envMap.value;}, set: function set(v) {if (this.uniforms.envMap.value !== v) {this.uniforms.envMap.value = v;}return true;} }, { key: "irradianceMap", get: function get() {return this.uniforms.irradianceMap.value;}, set: function set(v) {if (this.uniforms.irradianceMap.value !== v) {this.uniforms.irradianceMap.value = v;}return true;} }, { key: "envMapExposure", get: function get() {return this.uniforms.envMapExposure.value;}, set: function set(v) {if (this.uniforms.envMapExposure.value !== v) {this.uniforms.envMapExposure.value = v;}return true;} }, { key: "envRotationSin", get: function get() {return this.uniforms.envRotationSin.value;}, set: function set(v) {if (this.uniforms.envRotationSin.value !== v) {this.uniforms.envRotationSin.value = v;}return true;} }, { key: "envRotationCos", get: function get() {return this.uniforms.envRotationCos.value;}, set: function set(v) {if (this.uniforms.envRotationSin.value !== v) {this.uniforms.envRotationCos.value = v;}return true;} }]);return StandardSurfaceMaterial;}(three__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"]);
{var _loop = function _loop() {var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),

    k = _Object$entries2$_i[0],v = _Object$entries2$_i[1];
    var name = snakeToCamel(k.slice(2));
    if (!Object.hasOwnProperty.call(StandardSurfaceMaterial.prototype, name)) {
      Object.defineProperty(StandardSurfaceMaterial.prototype, name, {
        get: function get() {return this._getter(v.type, k);},
        set: function set(val) {return this._setter(v.type, k, val);} });

    }}; // Add getters and setters to protoype
  for (var _i4 = 0, _Object$entries2 = Object.entries(STANDARD_SURFACE_UNIFORMS); _i4 < _Object$entries2.length; _i4++) {_loop();}
}

/***/ }),

/***/ "./extensions/StandardSurface/index.js":
/*!*********************************************!*\
  !*** ./extensions/StandardSurface/index.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parseMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseMaterial */ "./extensions/StandardSurface/parseMaterial.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing;
var avp = av.Private;

//const namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.StandardSurface');
var

StandardSurfaceExtension = /*#__PURE__*/function (_av$Extension) {_inherits(StandardSurfaceExtension, _av$Extension);

  function StandardSurfaceExtension(viewer, options) {_classCallCheck(this, StandardSurfaceExtension);return _possibleConstructorReturn(this, _getPrototypeOf(StandardSurfaceExtension).call(this,
    viewer, options));
  }_createClass(StandardSurfaceExtension, [{ key: "load", value: function load()

    {
      return true;
    } }, { key: "unload", value: function unload()

    {
    }

    // There's no UI commands for this extension.
  }, { key: "activate", value: function activate() {return false;} }, { key: "deactivate", value: function deactivate()
    {return true;} }, { key: "isActive", value: function isActive()
    {return false;}

    /**
                     * Add custom UI when the Viewer have a toolbar.
                     * @param {Autodesk.Viewing.Toolbar} toolbar - The Viewer's toolbar instance.
                     */ }, { key: "onToolbarCreated", value: function onToolbarCreated(
    toolbar) {var _this = this;
      var ro = this.viewer.renderoptions;
      if (!ro)
      return;

      this._updateNumSamplesUI = debounce(this.updateNumSamples, 600);

      var OptionSlider = avp.OptionSlider;
      ro._numSamples = new OptionSlider('Num Samples', 1, 32, ro.tbody);
      ro._numSamples.setGlobalManager(this.globalManager);
      ro._numSamples.setValue(8); // See: StandardSurfaceMaterial.defines.NUM_SAMPLES
      ro._numSamples.sliderElement.step = 1;
      ro.addEventListener(ro._numSamples, 'change', function (e) {
        var val = parseInt(e.detail.value);
        avp.logger.debug('value: ' + val);
        _this._updateNumSamplesUI(val);
      });
      ro.uninitialize = function () {
        avp.RenderOptionsPanel.prototype.uninitialize.call(this);
        this._numSamples = null;
        this._updateNumSamplesUI = null;
      }.bind(ro);
    }

    /**
       * Process the standard materials in the model.
       * @param {Model} model The model to process
       */ }, { key: "processModel", value: function processModel(
    model) {
      avp.logger.info('SVF contains StandardSurface.json material definitions:');
      // Get the standard surfaces from the loaded model
      var svf = model.getData();
      var stdSurfMats = svf.stdSurfMats;
      this.processMaterials(model, stdSurfMats);
    }

    /**
       * Process the standard materials in the model.
       * @param {Model} model The model to process
       * @param {Object} stdSurfMats Standard Surface Json
       */ }, { key: "processMaterials", value: function processMaterials(
    model, stdSurfMats) {var _this2 = this;
      var materials = stdSurfMats.materials;
      var sceneUnit = stdSurfMats.scene.SceneUnit;
      var updated = false;

      // Process each material
      Object.keys(materials).forEach(function (key) {
        var data = materials[key];
        var mtl;
        try {
          // Convert the material
          mtl = Object(_parseMaterial__WEBPACK_IMPORTED_MODULE_0__["convertStandardSurface"])(data, sceneUnit);
        } catch (e) {
          var error = e;
          if (!(error instanceof Error))
          error = new Error("StandardSurface material ".concat(key, " parse failed: ").concat(e, "}"));
          avp.logger.error(error);
          return;
        }

        updated = true;
        avp.logger.info("StandardSurface material ".concat(key, " is valid"));

        // Update the material in the model
        var oldMtl = _this2._updateMaterial(model, key, mtl);

        // If the original material textures have not been loaded, then we don't
        // need to load the new material textures.
        if (oldMtl.texturesLoaded)
        avp.TextureLoader.loadMaterialTextures(model, mtl, _this2.viewer.impl);
      });

      // Update the scene if something changed
      if (updated)
      this.viewer.impl.sceneUpdated(false, false);
    }

    /**
       * Update an existing material in the model
       *
       * @param {RenderModel} model The model to update
       * @param {String} name The material name
       * @param {THREE.Material} mtl The new material
       * 
       * This could be done by the SceneBuilder, but the changes to get
       * the SceneBuilder to work with an existing model would be more
       * than this.
       *
       * @private
       */ }, { key: "_updateMaterial", value: function _updateMaterial(
    model, name, mtl) {
      var fragList = model.getFragmentList();
      var matman = this.viewer.impl.matman();
      var hash = matman._getMaterialHash(model, name);

      // Get the material we are replacing and dispose of it
      var oldMtl = matman._materials[hash];
      if (oldMtl)
      oldMtl.dispose();

      // Add the new material under the same name
      matman.addMaterial(hash, mtl, true);

      // Replace the material in the render lists
      if (fragList.useThreeMesh) {
        // Using meshes, need to replace the material in each mesh
        var meshes = fragList.vizmeshes;
        for (var i = 0; i < meshes.length; ++i) {
          if (meshes[i] && meshes[i].material === oldMtl)
          meshes[i].material = mtl;
        }
      } else {
        // This is easier, because we just need to update the material
        // at the right id
        var matId = fragList.materialmap[oldMtl.id];
        if (matId !== undefined) {
          fragList.materialmap[mtl.id] = matId;
          fragList.materialIdMap[matId] = mtl;
        }
      }

      return oldMtl;
    }

    /**
       * Updates the number of samples used by the shader code.
       * More samples results in more accurate visuals, at the cost of longer pixel shader processing times.
       *
       * @param {number} value - Default value is 8.
       */ }, { key: "updateNumSamples", value: function updateNumSamples(
    value) {
      var updateCount = 0;
      var matman = this.viewer.impl.matman();

      var exclude2d = true;
      var includeVariants = false;
      matman.forEach(onMaterial, exclude2d, includeVariants);

      function onMaterial(mat) {
        if (mat.isStandardSurfaceMaterial && mat.defines.NUM_SAMPLES !== value) {
          mat.defines.NUM_SAMPLES = value;
          mat.needsUpdate = true;
          updateCount++;
        }
      }

      if (updateCount > 0) {
        avp.logger.debug('NUM_SAMPLES: ' + value + ' / materials updated: ' + updateCount + ' | Wait for LMV to re-render.');
        this.viewer.impl.invalidate(false, true, false);
      }
    } }]);return StandardSurfaceExtension;}(av.Extension);



// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
  var timeout;

  return function executedFunction() {
    var context = this;
    var args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;

    clearTimeout(timeout);

    timeout = setTimeout(later, wait);

    if (callNow) func.apply(context, args);
  };
};

av.theExtensionManager.registerExtension('Autodesk.StandardSurface', StandardSurfaceExtension);

/***/ }),

/***/ "./extensions/StandardSurface/parseMaterial.js":
/*!*****************************************************!*\
  !*** ./extensions/StandardSurface/parseMaterial.js ***!
  \*****************************************************/
/*! exports provided: isStandardSurface, convertStandardSurface, convertStandardSurfaceTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStandardSurface", function() { return isStandardSurface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertStandardSurface", function() { return convertStandardSurface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertStandardSurfaceTexture", function() { return convertStandardSurfaceTexture; });
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adsk_standard_surface_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/standard-surface-json-schema */ "./node_modules/@adsk/standard-surface-json-schema/schemas/standard-surface.schema.json");
var _adsk_standard_surface_json_schema__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! @adsk/standard-surface-json-schema */ "./node_modules/@adsk/standard-surface-json-schema/schemas/standard-surface.schema.json", 1);
/* harmony import */ var _StandardSurfaceMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StandardSurfaceMaterial */ "./extensions/StandardSurface/StandardSurfaceMaterial.js");
function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance");}function _iterableToArrayLimit(arr, i) {if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {return;}var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}





var _validate;

function convertAngleUnit(v) {
  var unit = v.units || 'radian';
  return v.value *= unit === 'radian' ? 1 : Math.PI / 180; // always convert to radians
}

function textureScaleAngle() {
  return 2 * Math.PI;
}

function convertDistanceUnit(v, sceneUnit) {
  var unit = v.units || sceneUnit;
  return convertUnits(v.value, unit, sceneUnit);
}

function convertDistanceNano(v, sceneUnit) {
  var unit = v.units || sceneUnit;
  return convertUnits(v.value, unit, "nanometer");
}

function textureScaleDistance(v, sceneUnit) {
  var unit = v.units || sceneUnit;
  return convertUnits(1, unit, sceneUnit);
}

function textureScaleNano(v, sceneUnit) {
  var unit = v.units || sceneUnit;
  return convertUnits(1, unit, "nanometer");
}

function noConversion(v) {
  return v.value;
}

function noTextureScale() {
  return 1;
}

var convertValueUnit = {
  coat_rotation: convertAngleUnit,
  specular_rotation: convertAngleUnit,
  subsurface_scale: convertDistanceUnit,
  transmission_depth: convertDistanceUnit,
  thin_film_thickness: convertDistanceNano };


var textureValueScale = {
  coat_rotation: textureScaleAngle,
  specular_rotation: textureScaleAngle,
  subsurface_scale: textureScaleDistance,
  transmission_depth: textureScaleDistance,
  thin_film_thickness: textureScaleNano };


var normalMap = {
  coat_normal: true,
  normal: true };


var UNIT_CONVERSIONS = {
  nanometer: {
    millimeter: 1.00000e-06,
    centimeter: 1.00000e-07,
    inch: 3.93701e-08,
    decimeter: 1.00000e-08,
    foot: 3.28084e-09,
    yard: 1.09361e-09,
    meter: 1.00000e-09,
    kilometer: 1.00000e-12,
    mile: 6.21371e-13 },

  millimeter: {
    nanometer: 1.00000e+06,
    centimeter: 1.00000e-01,
    inch: 3.93701e-02,
    decimeter: 1.00000e-02,
    foot: 3.28084e-03,
    yard: 1.09361e-03,
    meter: 1.00000e-03,
    kilometer: 1.00000e-06,
    mile: 6.21371e-07 },

  centimeter: {
    nanometer: 1.00000e+07,
    millimeter: 1.00000e+01,
    inch: 3.93701e-01,
    decimeter: 1.00000e-01,
    foot: 3.28084e-02,
    yard: 1.09361e-02,
    meter: 1.00000e-02,
    kilometer: 1.00000e-05,
    mile: 6.21371e-06 },

  inch: {
    nanometer: 2.54000e+07,
    millimeter: 2.54000e+01,
    centimeter: 2.54000e+00,
    decimeter: 2.54000e-01,
    foot: 1.00 / 12.0,
    yard: 1.00 / 36.0,
    meter: 2.54000e-02,
    kilometer: 2.54000e-05,
    mile: 1.0 / 63360 },

  decimeter: {
    nanometer: 1.00000e+08,
    millimeter: 1.00000e+02,
    centimeter: 1.00000e+01,
    inch: 3.93701e+00,
    foot: 3.28084e-01,
    yard: 1.09361e-01,
    meter: 1.00000e-01,
    kilometer: 1.00000e-04,
    mile: 6.21371e-05 },

  foot: {
    nanometer: 3.04800e+08,
    millimeter: 3.04800e+02,
    centimeter: 3.04800e+01,
    inch: 1.20000e+01,
    decimeter: 3.04800e+00,
    yard: 1.00 / 3.00,
    meter: 3.04800e-01,
    kilometer: 3.04800e-04,
    mile: 1.00 / 5280 },

  yard: {
    nanometer: 9.14400e+08,
    millimeter: 9.14400e+02,
    centimeter: 9.14400e+01,
    inch: 3.60000e+01,
    decimeter: 9.14400e+00,
    foot: 3.00000e+00,
    meter: 9.14400e-01,
    kilometer: 9.14400e-04,
    mile: 1.00 / 1760 },

  meter: {
    nanometer: 1.00000e+09,
    millimeter: 1.00000e+03,
    cenimeter: 1.00000e+02,
    inch: 3.93701e+01,
    decimeter: 1.00000e+01,
    foot: 3.28084e+00,
    yard: 1.09361e+00,
    kilometer: 1.00000e-03,
    mile: 6.21371e-04 },

  kilometer: {
    nanometer: 1.00000e+12,
    millimeter: 1.00000e+06,
    centimeter: 1.00000e+05,
    inch: 3.93701e+04,
    decimeter: 1.00000e+04,
    foot: 3.28084e+03,
    yard: 1.09361e+03,
    meter: 1.00000e+03,
    mile: 6.21371e-01 },

  mile: {
    nanometer: 1.60934e+12,
    millimeter: 1.60934e+06,
    centimeter: 1.60934e+05,
    inch: 6.33600e+04,
    decimeter: 1.60934e+04,
    foot: 5.28000e+03,
    yard: 1.76000e+03,
    meter: 1.60934e+03,
    kilometer: 1.60934e+00 } };



// see here for a list of all the units LMVTK supports:
// https://git.autodesk.com/A360/LMVTK/blob/5eb5159142639f1074993adacff1f2c001b80dba/Components/Package/Metadata/Metadata.h#L64-L71
function normalizeUnits(units) {
  if (typeof units === 'number') {
    switch (units) {
      case 0x02 << 12 | 16:return 'nanometer';
      case 0x02 << 12 | 14:return 'millimeter';
      case 0x02 << 12 | 13:return 'centimeter';
      case 0x02 << 12 | 22:return 'inch';
      case 0x02 << 12 | 12:return 'decimeter';
      case 0x02 << 12 | 23:return 'foot';
      case 0x02 << 12 | 29:return 'yard';
      case 0x02 << 12 | 1:return 'meter';
      case 0x02 << 12 | 9:return 'kilometer';
      case 0x02 << 12 | 33:return 'mile';
      default:return units; // this will cause problems eventually
    }
  } else if (typeof units === 'string') {
    switch (units.toLowerCase()) {
      case 'nm':
      case 'nanometer':
      case 'nanometers':return 'nanometer';
      case 'mm':
      case 'millimeter':
      case 'millimeters':return 'millimeter';
      case 'cm':
      case 'centimeter':
      case 'centimeters':return 'centimeter';
      case 'in':
      case 'inch':
      case 'inches':return 'inch';
      case 'dm':
      case 'decimeter':
      case 'decimeters':return 'decimeter';
      case 'ft':
      case 'foot':
      case 'feet':return 'foot';
      case 'yd':
      case 'yard':
      case 'yards':return 'yard';
      case 'm':
      case 'meter':
      case 'meters':return 'meter';
      case 'km':
      case 'kilometer':
      case 'kilometers':return 'kilometer';
      case 'mi':
      case 'mile':
      case 'miles':return 'mile';
      default:return units; // this will cause problems eventually
    }
  }
  return units; /// this will eventually cause a problem
}

function convertUnits(v, from, to) {
  from = normalizeUnits(from);
  to = normalizeUnits(to);
  if (from === to) return v;
  if (!UNIT_CONVERSIONS[from]) throw new Error("unrecognized source units: ".concat(from));
  if (!UNIT_CONVERSIONS[from][to]) throw new Error("unrecognized destination units: ".concat(to));
  return v * UNIT_CONVERSIONS[from][to];
}

function getByPointer(data, ptr) {
  if (!ptr) return data;
  if (ptr === '/') return data;
  if (!/^#?\//.test(ptr)) throw new Error("bad pointer: ".concat(ptr));
  var tokens = ptr.split('/').filter(function (t) {return t && t !== '#';});
  while (tokens.length) {
    try {
      data = Array.isArray(data) ? data[parseInt(tokens.shift())] : data[tokens.shift()];
    } catch (e) {
      throw new Error("Unable to find by pointer: ".concat(ptr));
    }
  }
  return data;
}

function validateTextureRefs(root) {var ptr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var data = getByPointer(root, ptr);
  var errors = [];
  for (var key in data) {
    var val = data[key];
    if (key === '$ref') {
      var refPtr = val.slice(1); // remove leading '#'
      try {
        getByPointer(root, refPtr);
      } catch (e) {
        errors.push(new Error("Texture reference \"#".concat(refPtr, " does not exist (refereced from ").concat(ptr, "/").concat(key, ")")));
      }
    } else if (Array.isArray(val) || _typeof(val) === 'object') {
      errors = errors.concat(validateTextureRefs(root, ptr + '/' + key));
    }
  }
  return errors;
}

function isStandardSurface(data) {var suppressErrors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!_validate) {
    _validate = new ajv__WEBPACK_IMPORTED_MODULE_0__().compile(_adsk_standard_surface_json_schema__WEBPACK_IMPORTED_MODULE_1__);
  }
  _validate(data);
  var errors = [].concat(_validate.errors || [], validateTextureRefs(data));
  if (errors.length) {
    if (!suppressErrors) {
      console.error(["Standard Surface validation errors:"].concat(errors.map(function (e) {return JSON.stringify(e);})).join('\n'));
    }
    return false;
  }
  return true;
}

function convertStandardSurface(data, sceneUnit) {
  if (!isStandardSurface(data))
  throw new Error('Invalid Standard Surface definition');

  var mtl = new _StandardSurfaceMaterial__WEBPACK_IMPORTED_MODULE_2__["StandardSurfaceMaterial"]();

  mtl.standardSurface = data;
  mtl.name = mtl.tag = data.tag;
  mtl.transparent = data.transparent;
  mtl.packedNormals = true;
  mtl.needsUpdate = true;

  var maps = mtl.textureMaps = {};
  var uniforms = mtl.uniforms;
  var params = data.parameters;
  for (var _i = 0, _Object$entries = Object.entries(params); _i < _Object$entries.length; _i++) {var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),k = _Object$entries$_i[0],v = _Object$entries$_i[1];
    var uKey = "u_".concat(k);
    if (!uniforms[uKey]) throw new Error("unrecognized parameter: ".concat(k));
    var type = uniforms[uKey].type;
    if (v.hasOwnProperty('value')) {
      switch (type) {
        case 'c':
          mtl.uniforms[uKey].value = new THREE.Color(v.value.r, v.value.g, v.value.b);
          break;
        case 'v3':
          mtl.uniforms[uKey].value = new THREE.Vector3(v.value.x, v.value.y, v.value.z);
          break;
        case 'f':
          uniforms[uKey].value = (convertValueUnit[k] || noConversion)(v, sceneUnit);
          break;
        case 'i':
          mtl.uniforms[uKey].value = v.value ? 1 : 0;
          break;
        default:
          throw new Error(' unreachable ');}

    } else if (v.hasOwnProperty('texture')) {
      if (v.texture.hasOwnProperty('$ref') && typeof v.texture.$ref === 'string') {
        var mapName = snakeToCamel(uKey.slice(2));
        var texData = getByPointer(data, v.texture.$ref);
        var unitScale = type === 'f' ? (textureValueScale[k] || noTextureScale)(v, sceneUnit) : 1;
        maps[mapName] = {
          mapName: mapName,
          uri: texData.bitmap,
          textureObj: texData,
          converter: convertStandardSurfaceTexture,
          mtlSpecific: {
            sceneUnit: sceneUnit,
            unitScale: unitScale,
            isNormal: normalMap[k] } };


      } else {
        throw new Error('invalid ref');
      }
    }
  }
  mtl.needsUpdate = true;

  return mtl;
}

function snakeToCamel(s) {
  return s.replace(/(_[a-z])/ig, function (m) {return m.toUpperCase().replace('_', '');});
}

function convertStandardSurfaceTexture(texData, tex, sceneUnit, maxAnisotropy) {
  var data = texData.textureObj;
  sceneUnit = texData.mtlSpecific.sceneUnit || sceneUnit;
  tex.anisotropy = texData.mtlSpecific.isNormal ? 0 : maxAnisotropy || 0;
  tex.mapping = THREE.UVMapping;
  tex.wrapS = data.uRepeat === false ? THREE.ClampToEdgeWrapping : THREE.RepeatWrapping;
  tex.wrapT = data.vRepeat === false ? THREE.ClampToEdgeWrapping : THREE.RepeatWrapping;
  tex.magFilter = tex.minFilter = data.filtering === 'nearest' ? THREE.NearestFilter : THREE.LinearFilter;
  tex.encoding = data.encoding === 'linear' ? 'linear' : 'srgb';
  tex.isHeightMap = data.isHeightMap === true;
  tex.invert = data.invert === true;
  tex.heightMapScale = convertUnits((data.heightMapScale || {}).value || 1, (data.heightMapScale || {}).units || sceneUnit, sceneUnit);
  tex.rgbScale = ((data.rgbScale || {}).value || 1) * texData.mtlSpecific.unitScale;
  var realWorldOffsetX = convertUnits((data.realWorldOffsetX || {}).value || 0, (data.realWorldOffsetX || {}).units || sceneUnit, sceneUnit);
  var realWorldOffsetY = convertUnits((data.realWorldOffsetY || {}).value || 0, (data.realWorldOffsetY || {}).units || sceneUnit, sceneUnit);
  var realWorldScaleX = convertUnits((data.realWorldScaleX || {}).value || 1, (data.realWorldScaleX || {}).units || sceneUnit, sceneUnit);
  var realWorldScaleY = convertUnits((data.realWorldScaleY || {}).value || 1, (data.realWorldScaleY || {}).units || sceneUnit, sceneUnit);
  var uOffset = (data.uOffset || {}).value || 0;
  var uScale = (data.uScale || {}).value || 1;
  var vOffset = (data.vOffset || {}).value || 0;
  var vScale = (data.vScale || {}).value || 1;
  var wAngle = ((data.wAngle || {}).value || 0) * ((data.wAngle || {}).units === 'degree' ? Math.PI / 180 : 1);
  var c = Math.cos(wAngle);
  var s = Math.sin(wAngle);
  var cx = uScale / realWorldScaleX;
  var cy = vScale / realWorldScaleY;
  tex.matrix = new THREE.Matrix3();
  tex.matrix.elements = [
  c * cx, s * cx, 0,
  -s * cy, c * cy, 0,
  -c * cx * realWorldOffsetX + s * cy * realWorldOffsetY + uOffset, -s * cx * realWorldOffsetX - c * cy * realWorldOffsetY + vOffset, 1];

}



/***/ }),

/***/ "./extensions/StandardSurface/std-surf-frag.glsl":
/*!*******************************************************!*\
  !*** ./extensions/StandardSurface/std-surf-frag.glsl ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#include<common>\n#define M_PI_INV 1.0/PI\n#define M_GOLDEN_RATIO 1.6180339887498948482045868343656\n#define M_FLOAT_EPS 0.000001\n#define MAX_LIGHTS (MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS + MAX_DIR_LIGHTS)\n#define BSDF vec3\n#define EDF vec3\nstruct VDF { vec3 absorption; vec3 scattering; };\nstruct surfaceshader { vec3 color; vec3 transparency; };\nstruct volumeshader { VDF vdf; EDF edf; };\nstruct displacementshader { vec3 offset; float scale; };\nstruct lightshader { vec3 intensity; vec3 direction; };\nuniform sampler2D u_sheenAlbedo;\nuniform sampler2D u_samplingRandomMap;\n#inject<uniforms>\n#ifdef USE_TILING\nuniform mat4 tilingOverallTransform;\nuniform sampler2D TilingMap;\nuniform mat3 TilingMap_texMatrix;\nuniform vec4 uv2tile;\nuniform vec4 tile2uv;\nuniform vec2 tileAlignOffset;\nuniform mat4 tilingUVTransform;\n#ifdef USE_TILING_NORMAL\nuniform sampler2D TilingNormalMap;\nuniform mat3 TilingNormalMap_texMatrix;\n#endif\n#ifdef USE_TILING_RANDOM\nuniform sampler2D TilingRandomMap;\nuniform mat3 TilingRandomMap_texMatrix;\nuniform vec2 tilingRandomAxisS;\nuniform vec2 tilingRandomAxisT;\nuniform vec2 tilingRandomAlignmentOffset;\n#endif\n#endif\nuniform float envExponentMin;\nuniform float envExponentMax;\nuniform float envExponentCount;\n#include<env_sample>\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include<tonemap>\n#endif\nvarying vec3 vWorldPosition;\n#include<id_decl_frag>\n#include<theming_decl_frag>\n#include<shadowmap_decl_frag>\n#ifdef MRT_NORMALS\nvarying vec3 vGeomNormal;\n#endif\n#ifdef USE_FOG\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#if defined(USE_MAP) || defined(USE_BASE_MAP) || defined(USE_BASE_COLOR_MAP) || defined(USE_COAT_MAP) || defined(USE_COAT_AFFECT_COLOR_MAP) || defined(USE_COAT_AFFECT_ROUGHNESS_MAP) || defined(USE_COAT_ANISOTROPY_MAP) || defined(USE_COAT_COLOR_MAP) || defined(USE_COAT_IOR_MAP) || defined(USE_COAT_NORMAL_MAP) || defined(USE_COAT_ROTATION_MAP) || defined(USE_COAT_ROUGHNESS_MAP) || defined(USE_DIFFUSE_ROUGHNESS_MAP) || defined(USE_EMISSION_MAP) || defined(USE_EMISSION_COLOR_MAP) || defined(USE_METALNESS_MAP) || defined(USE_NORMAL_MAP) || defined(USE_OPACITY_MAP) || defined(USE_SHEEN_MAP) || defined(USE_SHEEN_COLOR_MAP) || defined(USE_SHEEN_ROUGHNESS_MAP) || defined(USE_SPECULAR_MAP) || defined(USE_SPECULAR_ANISOTROPY_MAP) || defined(USE_SPECULAR_COLOR_MAP) || defined(USE_SPECULAR_IOR_MAP) || defined(USE_SPECULAR_ROTATION_MAP) || defined(USE_SPECULAR_ROUGHNESS_MAP) || defined(USE_SUBSURFACE_MAP) || defined(USE_SUBSURFACE_ANISOTROPY_MAP) || defined(USE_SUBSURFACE_COLOR_MAP) || defined(USE_SUBSURFACE_RADIUS_MAP) || defined(USE_SUBSURFACE_SCALE_MAP) || defined(USE_THIN_FILM_IOR_MAP) || defined(USE_THIN_FILM_THICKNESS_MAP) || defined(USE_THIN_WALLED_MAP) || defined(USE_TRANSMISSION_MAP) || defined(USE_TRANSMISSION_COLOR_MAP) || defined(USE_TRANSMISSION_DEPTH_MAP) || defined(USE_TRANSMISSION_DISPERSION_MAP) || defined(USE_TRANSMISSION_EXTRA_ROUGHNESS_MAP) || defined(USE_TRANSMISSION_SCATTER_MAP) || defined(USE_TRANSMISSION_SCATTER_ANISOTROPY_MAP)\n#define USE_MAP\n#endif\nvarying vec2 vUv;\nfloat linear_to_srgb(in float v) {\n    float o = v;\n    if (o <= 0.0031308) {\n        o *= 12.92;\n    } else {\n        o = 1.055 * pow(o, 1.0 / 2.4) - 0.055;\n    }\n    return o;\n}\nvec3 linear_to_srgb(in vec3 v) {\n    vec3 o = v;\n    o.r = linear_to_srgb(o.r);\n    o.g = linear_to_srgb(o.g);\n    o.b = linear_to_srgb(o.b);\n    return o;\n}\nfloat srgb_to_linear(in float v) {\n    float o = v;\n    if (o <= 0.04045) {\n        o *= 0.07739938;\n    } else {\n        o = pow(abs((o + 0.055) * 0.947867298), 2.4);\n    }\n    return o;\n}\nvec3 srgb_to_linear(in vec3 v) {\n    vec3 o = v;\n    o.r = srgb_to_linear(o.r);\n    o.g = srgb_to_linear(o.g);\n    o.b = srgb_to_linear(o.b);\n    return o;\n}\n#if defined(USE_ENVMAP)\nuniform samplerCube envMap;\nuniform float envMapExposure;\nuniform int envMapMipLevels;\n#if defined(USE_IRRADIANCEMAP)\nuniform samplerCube irradianceMap;\n#endif\n#endif\nvarying vec3 vWorldNormal;\n#ifndef _LMVWEBGL2_\nint clamp(int x, int minVal, int maxVal) {\n    if (x < minVal) return minVal;\n    if (x > maxVal) return maxVal;\n    return x;\n}\n#endif\nvec3 sample_map(vec2 st, sampler2D map, int invert, int encoding, float valueScale) {\n    vec3 raw = texture2D(map, st).rgb;\n    if (encoding == 0) {\n        raw = srgb_to_linear(raw);\n    }\n    if (invert == 1) {\n        raw = vec3(1.0) - raw;\n    }\n    return raw * valueScale;\n}\nmat3 two_vector(in vec3 N, in vec3 Np) {\n    vec3 v = cross(N, Np);\n    float c = dot(N, Np);\n    mat3 vX = mat3(0.0, v.z, -v.y, -v.z, 0.0, v.x, v.y, -v.x, 0.0);\n    return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) + vX + (vX * vX) / (1.0 + c);\n}\nvoid transform_basis(inout vec3 T, inout vec3 B, inout vec3 N, in vec2 uv, in sampler2D map, in mat3 texMatrix, in int invert, in int encoding, in float valueScale, in int isHeight, in vec2 heightScale) {\n    vec2 st = (texMatrix * vec3(uv, 1.0)).xy;\n    mat3 rot;\n    if (isHeight == 1) {\n        mat3 TBN = mat3(T, B, N);\n        vec3 Tloc = normalize(TBN * (texMatrix * vec3(1.0, 0.0, 0.0)));\n        vec3 Bloc = normalize(TBN * (texMatrix * vec3(0.0, 1.0, 0.0)));\n        const float oneThird = 1.0 / 3.0;\n        vec3 avg = vec3(oneThird);\n        vec2 offset = fwidth(st);\n        float h0 = dot(sample_map(st, map, invert, encoding, valueScale).xyz, avg);\n        float hx = dot(sample_map(st + vec2(offset.x, 0.0), map, invert, encoding, valueScale).xyz, avg);\n        float hy = dot(sample_map(st + vec2(0.0, offset.y), map, invert, encoding, valueScale).xyz, avg);\n        vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n        vec3 Np = normalize(N + (diff.x * Tloc * heightScale.x + diff.y * Bloc * heightScale.y));\n        rot = two_vector(N, Np);\n    } else {\n        vec3 mapN = 2.0 * sample_map(st, map, invert, encoding, valueScale).xyz - 1.0;\n        vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n        float c = -mapN.z;\n        mat3 skewV = mat3(0.0, v.z, -v.y, -v.z, 0.0, v.x, v.y, -v.x, 0.0);\n        rot = mat3(1.0) + skewV + skewV * skewV * 1.0 / (1.0 - c);\n    }\n    T = normalize(T * rot);\n    B = normalize(B * rot);\n    N = normalize(N * rot);\n}\nvec3 sample_irradiance_map(vec3 dir) {\n    return applyEnvShadow(sampleIrradianceMap(dir, irradianceMap, envMapExposure), dir);\n}\nvec3 sample_radiance_map(vec3 dir, float lod) {\n    vec3 direction = adjustLookupVector(dir);\n#ifdef HAVE_TEXTURE_LOD\n    vec4 val = textureCubeLodEXT(envMap, direction, lod);\n#else\n    vec4 val = textureCube(envMap, direction, lod);\n#endif\n#ifdef ENV_GAMMA\n    return GammaDecode(val, envMapExposure);\n#elif defined(ENV_RGBM)\n    return RGBMDecode(val, envMapExposure);\n#else\n#ifdef GAMMA_INPUT\n    return val.xyz * val.xyz;\n#else\n    return val.xyz;\n#endif\n#endif\n}\n#include<hatch_pattern>\nfloat read_sheen_albedo_table(vec2 uv) {\n    vec4 tex = texture2D(u_sheenAlbedo, vec2(uv.x, 1.0 - uv.y));\n    float adj = 256.0 / 255.0;\n    float val = dot(tex, vec4(adj, adj / 255.0, adj / 65025.0, adj / 16581375.0));\n    return val * SHEEN_ALBEDO_TABLE_RANGE + SHEEN_ALBEDO_TABLE_MIN;\n}\n#if MAX_LIGHTS > 0\nfloat calc_light_attenuation(float distance, float cutoffDistance, float decayExp) {\n    if (decayExp > 0.0) {\n        return pow(clamp(1.0 - distance / cutoffDistance, 0.0, 1.0), decayExp);\n    }\n    return 1.0;\n}\n#if MAX_POINT_LIGHTS > 0\nuniform vec3  pointLightColor[MAX_POINT_LIGHTS];\nuniform vec3  pointLightPosition[MAX_POINT_LIGHTS];\nuniform float pointLightDistance[MAX_POINT_LIGHTS];\nuniform float pointLightDecay[MAX_POINT_LIGHTS];\nvoid sample_point_light(int idx, vec3 position, out lightshader result) {\n    for (int i = 0; i < MAX_POINT_LIGHTS; ++i) {\n        if (i == idx) {\n            vec3 lightWorldPosition = pointLightPosition[i];\n            vec3 lightWorldVector = lightWorldPosition - position;\n            float attenuation = calc_light_attenuation(length(lightWorldVector), pointLightDistance[i], pointLightDecay[i]);\n            result.direction = normalize(lightWorldVector);\n            result.intensity = pointLightColor[i] * attenuation;\n            return;\n        }\n    }\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3  spotLightColor[MAX_SPOT_LIGHTS];\nuniform vec3  spotLightPosition[MAX_SPOT_LIGHTS];\nuniform vec3  spotLightDirection[MAX_SPOT_LIGHTS];\nuniform float spotLightAngleCos[MAX_SPOT_LIGHTS];\nuniform float spotLightExponent[MAX_SPOT_LIGHTS];\nuniform float spotLightDistance[MAX_SPOT_LIGHTS];\nuniform float spotLightDecay[MAX_SPOT_LIGHTS];\nvoid sample_spot_light(int idx, vec3 position, out lightshader result) {\n    for (int i = 0; i < MAX_SPOT_LIGHTS; ++i) {\n        if (i == idx) {\n            vec3 lightWorldPosition = spotLightPosition[i];\n            vec3 lightWorldVector = lightWorldPosition + position;\n            float attenuation = calc_light_attenuation(length(lightWorldVector), spotLightDistance[i], spotLightDecay[i]);\n            float spotEffect = dot(spotLightDirection[i], normalize(spotLightPosition[i] - position));\n            result.direction = normalize(lightWorldVector);\n            if (spotEffect > spotLightAngleCos[i]) {\n                spotEffect = max(pow(max(spotEffect, 0.0), spotLightExponent[i]), 0.0);\n                result.intensity = spotLightColor[i] * attenuation * spotEffect;\n            } else {\n                result.intensity = vec3(0.0);\n            }\n            return;\n        }\n    }\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\nvoid sample_dir_light(int idx, vec3 position, out lightshader result) {\n    for (int i = 0; i < MAX_DIR_LIGHTS; ++i) {\n        if (i == idx) {\n            vec3 lightWorldVector = directionalLightDirection[i];\n            result.direction = normalize(lightWorldVector);\n            result.intensity = directionalLightColor[i];\n            return;\n        }\n    }\n}\n#endif\nvoid sample_light(int idx, vec3 position, out lightshader result) {\n#if MAX_POINT_LIGHTS > 0\n    if (idx < MAX_POINT_LIGHTS) {\n        sample_point_light(idx, position, result);\n        return;\n    }\n#endif\n#if MAX_SPOT_LIGHTS > 0\n    if (idx < MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS) {\n        sample_spot_light(idx - MAX_POINT_LIGHTS, position, result);\n        return;\n    }\n#endif\n#if MAX_DIR_LIGHTS > 0\n    if (idx < MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS + MAX_DIR_LIGHTS) {\n        sample_dir_light(idx - (MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS), position, result);\n        return;\n    }\n#endif\n    result.intensity = vec3(0.0);\n}\n#endif\n#inject<getters>\nvoid computeTangets(in vec3 pos, in vec2 uv, out vec3 T, out vec3 B) {\n    vec3 q0 = dFdx( pos );\n    vec3 q1 = dFdy( pos );\n    vec2 st0 = dFdx( uv );\n    vec2 st1 = dFdy( uv );\n    float scale = sign( st1.t * st0.s - st0.t * st1.s );\n    T = normalize(  q0 * st1.t - q1 * st0.t ) * scale;\n    B = (-q0 * st1.s + q1 * st0.s) * scale;\n}\nfloat mx_square(float x) { return x*x; }\nvec2 mx_square(vec2 x) { return x*x; }\nvec3 mx_square(vec3 x) { return x*x; }\nvec4 mx_square(vec4 x) { return x*x; }\nfloat mx_pow5(float x) { return mx_square(mx_square(x)) * x; }\nfloat mx_max_component(vec2 v) { return max(v.x, v.y); }\nfloat mx_max_component(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat mx_max_component(vec4 v) { return max(max(max(v.x, v.y), v.z), v.w); }\nbool mx_is_tiny(float v) { return abs(v) < EPSILON; }\nbool mx_is_tiny(vec3 v) { return all(lessThan(abs(v), vec3(EPSILON))); }\nfloat mx_mix(float v00, float v01, float v10, float v11, float x, float y) {\n    float v0_ = mix(v00, v01, x);\n    float v1_ = mix(v10, v11, x);\n    return mix(v0_, v1_, y);\n}\n#ifdef USE_LMV_SAMPLING\nvec2 hammersley(int index, int envSamples) {\n    float u = (float(index) + 0.5) / float(SAMPLING_RANDOM_TABLE_SIZE);\n    const float v = 0.5;\n    float noise = texture2D(u_samplingRandomMap, vec2(u, v), 0.0).r;\n    return vec2(float(index/envSamples), noise);\n}\n#else\nfloat mx_golden_ratio_sequence(int i) {\n    return fract((float(i) + 1.0) * M_GOLDEN_RATIO);\n}\nvec2 mx_spherical_fibonacci(int i, int numSamples) {\n    return vec2((float(i) + 0.5) / float(numSamples), mx_golden_ratio_sequence(i));\n}\n#endif\nfloat mx_orennayar(vec3 L, vec3 V, vec3 N, float NdotL, float roughness) {\n    float LdotV = dot(L, V);\n    float NdotV = dot(N, V);\n    float t = LdotV - NdotL * NdotV;\n    t = t > 0.0 ? t / max(NdotL, NdotV) : 0.0;\n    float sigma2 = mx_square(roughness * PI);\n    float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.33));\n    float B = 0.45 * sigma2 / (sigma2 + 0.09);\n    return A + B * t;\n}\nfloat mx_microfacet_ggx_NDF(vec3 X, vec3 Y, vec3 H, float NdotH, float alphaX, float alphaY) {\n    float XdotH = dot(X, H);\n    float YdotH = dot(Y, H);\n    float denom = mx_square(XdotH / alphaX) + mx_square(YdotH / alphaY) + mx_square(NdotH);\n    return 1.0 / (PI * alphaX * alphaY * mx_square(denom));\n}\nfloat mx_microfacet_ggx_PDF(vec3 X, vec3 Y, vec3 H, float NdotH, float LdotH, float alphaX, float alphaY) {\n    return mx_microfacet_ggx_NDF(X, Y, H, NdotH, alphaX, alphaY) * NdotH / (4.0 * LdotH);\n}\nvec3 mx_microfacet_ggx_IS(vec2 Xi, vec3 X, vec3 Y, vec3 N, float alphaX, float alphaY) {\n    float phi = 2.0 * PI * Xi.x;\n    float tanTheta = sqrt(Xi.y / (1.0 - Xi.y));\n    vec3 H = vec3(X * (tanTheta * alphaX * cos(phi)) +\n    Y * (tanTheta * alphaY * sin(phi)) +\n    N);\n    return normalize(H);\n}\nfloat mx_microfacet_ggx_G1(float cosTheta, float alpha) {\n    float cosTheta2 = cosTheta * cosTheta;\n    float tanTheta2 = (1.0 - cosTheta2) / cosTheta2;\n    return 2.0 / (1.0 + sqrt(1.0 + alpha * alpha * tanTheta2));\n}\nfloat mx_microfacet_ggx_smith_G(float NdotL, float NdotV, float alpha) {\n    return mx_microfacet_ggx_G1(NdotL, alpha) * mx_microfacet_ggx_G1(NdotV, alpha);\n}\nfloat mx_microfacet_sheen_NDF(float cosTheta, float roughness) {\n    float invRoughness = 1.0 / roughness;\n    float cos2 = cosTheta * cosTheta;\n    float sin2 = 1.0 - cos2;\n    return (2.0 + invRoughness) * pow(sin2, invRoughness * 0.5) / (2.0 * PI);\n}\nfloat mx_microfacet_sheen_albedo(float cosTheta, float roughness) {\n    return clamp(read_sheen_albedo_table(vec2(cosTheta, roughness)), 0.0, 1.0);\n}\nfloat mx_fresnel_schlick(float cosTheta, float F0, float F90, float exponent) {\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90, float exponent) {\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0) {\n    if (cosTheta < 0.0) return vec3(1.0);\n    float x = 1.0 - cosTheta;\n    float x2 = x*x;\n    float x5 = x2*x2*x;\n    return F0 + (1.0 - F0) * x5;\n}\nfloat mx_fresnel_schlick(float cosTheta, float ior) {\n    if (cosTheta < 0.0) return 1.0;\n    float F0 = (ior - 1.0) / (ior + 1.0);\n    F0 *= F0;\n    float x = 1.0 - cosTheta;\n    float x2 = x*x;\n    float x5 = x2*x2*x;\n    return F0 + (1.0 - F0) * x5;\n}\nfloat mx_fresnel_schlick_roughness(float cosTheta, float ior, float roughness) {\n    cosTheta = abs(cosTheta);\n    float F0 = (ior - 1.0) / (ior + 1.0);\n    F0 *= F0;\n    float x = 1.0 - cosTheta;\n    float x2 = x*x;\n    float x5 = x2*x2*x;\n    return F0 + (max(1.0 - roughness, F0) - F0) * x5;\n}\nfloat mx_fresnel_dielectric(float cosTheta, float ior) {\n    if (cosTheta < 0.0) return 1.0;\n    float g =  ior*ior + cosTheta*cosTheta - 1.0;\n    if (g < 0.0) return 1.0;\n    g = sqrt(g);\n    float gmc = g - cosTheta;\n    float gpc = g + cosTheta;\n    float x = gmc / gpc;\n    float y = (gpc * cosTheta - 1.0) / (gmc * cosTheta + 1.0);\n    return 0.5 * x * x * (1.0 + y * y);\n}\nvec3 mx_fresnel_conductor(float cosTheta, vec3 n, vec3 k) {\n    float c2 = cosTheta*cosTheta;\n    vec3 n2_k2 = n*n + k*k;\n    vec3 nc2 = 2.0 * n * cosTheta;\n    vec3 rs_a = n2_k2 + c2;\n    vec3 rp_a = n2_k2 * c2 + 1.0;\n    vec3 rs = (rs_a - nc2) / (rs_a + nc2);\n    vec3 rp = (rp_a - nc2) / (rp_a + nc2);\n    return 0.5 * (rs + rp);\n}\nfloat mx_burley_diffuse(vec3 L, vec3 V, vec3 N, float NdotL, float roughness) {\n    vec3 H = normalize(L + V);\n    float LdotH = max(dot(L, H), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float F90 = 0.5 + (2.0 * roughness * mx_square(LdotH));\n    float refL = mx_fresnel_schlick(NdotL, 1.0, F90, 5.0);\n    float refV = mx_fresnel_schlick(NdotV, 1.0, F90, 5.0);\n    return refL * refV * M_PI_INV;\n}\nfloat mx_burley_directional_albedo(vec3 V, vec3 N, float roughness) {\n    float x = dot(N, V);\n    float fit0 = 0.97619 - 0.488095 * mx_pow5(1.0 - x);\n    float fit1 = 1.55754 + (-2.02221 + (2.56283 - 1.06244 * x) * x) * x;\n    return mix(fit0, fit1, roughness);\n}\nfloat mx_compute_lod(vec3 dir, float pdf, int maxMipLevel, int envSamples) {\n    const float MIP_LEVEL_OFFSET = 1.5;\n    float effectiveMaxMipLevel = float(maxMipLevel) - MIP_LEVEL_OFFSET;\n    float distortion = sqrt(1.0 - mx_square(dir.y));\n    return max(effectiveMaxMipLevel - 0.5 * log2(float(envSamples) * pdf * distortion), 0.0);\n}\nvec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 roughness, int distribution) {\n    vec3 Y = normalize(cross(N, X));\n    X = cross(Y, N);\n    float NdotV = clamp(dot(N, V), 1e-8, 1.0);\n    vec3 radiance = vec3(0.0);\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n#ifdef USE_LMV_SAMPLING\n        vec2 Xi = hammersley(i, NUM_SAMPLES);\n#else\n        vec2 Xi = mx_spherical_fibonacci(i, NUM_SAMPLES);\n#endif\n        vec3 H = mx_microfacet_ggx_IS(Xi, X, Y, N, roughness.x, roughness.y);\n        vec3 L = -reflect(V, H);\n        float NdotH = clamp(dot(N, H), 1e-8, 1.0);\n        float NdotL = clamp(dot(N, L), 1e-8, 1.0);\n        float VdotH = clamp(dot(V, H), 1e-8, 1.0);\n        float LdotH = VdotH;\n        float pdf = mx_microfacet_ggx_PDF(X, Y, H, NdotH, LdotH, roughness.x, roughness.y);\n        float lod = mx_compute_lod(L, pdf, envMapMipLevels, NUM_SAMPLES);\n        vec3 sampleColor = sample_radiance_map(L, lod);\n        float G = mx_microfacet_ggx_smith_G(NdotL, NdotV, max(roughness.x, roughness.y));\n        const float F = 1.0;\n        radiance += sampleColor * G * F * VdotH / (NdotV * NdotH);\n    }\n    radiance /= float(NUM_SAMPLES);\n    return radiance;\n}\nvec3 mx_environment_irradiance(vec3 N) {\n    return sample_irradiance_map(N);\n}\nvoid mx_luminance_color3(vec3 _in, vec3 lumacoeffs, out vec3 result) {\n    result = vec3(dot(_in, lumacoeffs));\n}\nvoid mx_roughness_anisotropy(float roughness, float anisotropy, out vec2 result) {\n    float roughness_sqr = clamp(roughness*roughness, EPSILON, 1.0);\n    if (anisotropy > 0.0) {\n        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));\n        result.x = min(roughness_sqr / aspect, 1.0);\n        result.y = roughness_sqr * aspect;\n    } else {\n        result.x = roughness_sqr;\n        result.y = roughness_sqr;\n    }\n}\nvoid mx_fresnel_ior(float ior, vec3 N, vec3 V, out float result) {\n    float cosTheta = dot(N, -V);\n    result = mx_fresnel_dielectric(cosTheta, ior);\n}\nmat4 mx_rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvoid mx_rotate_vector3(vec3 v, float amount, vec3 axis, out vec3 result) {\n    float rotationRadians = radians(amount);\n    mat4 m = mx_rotationMatrix(axis, rotationRadians);\n    result = (m * vec4(v, 1.0)).xyz;\n}\nvoid mx_complex_to_artistic_ior(vec3 ior, vec3 extinction, out vec3 reflectivity, out vec3 edge_color) {\n    vec3 nm1 = ior - 1.0;\n    vec3 np1 = ior + 1.0;\n    vec3 k2  = extinction * extinction;\n    vec3 r = (nm1*nm1 + k2) / (np1*np1 + k2);\n    reflectivity = r;\n    vec3 r_sqrt = sqrt(r);\n    vec3 n_min = (1.0 - r) / (1.0 + r);\n    vec3 n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);\n    edge_color = (n_max - ior) / (n_max - n_min);\n}\nvoid mx_artistic_to_complex_ior(vec3 reflectivity, vec3 edge_color, out vec3 ior, out vec3 extinction) {\n    vec3 r = clamp(reflectivity, 0.0, 0.99);\n    vec3 r_sqrt = sqrt(r);\n    vec3 n_min = (1.0 - r) / (1.0 + r);\n    vec3 n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);\n    ior = mix(n_max, n_min, edge_color);\n    vec3 np1 = ior + 1.0;\n    vec3 nm1 = ior - 1.0;\n    vec3 k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);\n    k2 = max(k2, 0.0);\n    extinction = sqrt(k2);\n}\nvoid mx_conductor_brdf_reflection(vec3 L, vec3 V, float weight, vec3 reflectivity, vec3 edge_color, vec2 roughness, vec3 N, vec3 X, int distribution, out BSDF result) {\n    if (weight < EPSILON) {\n        result = BSDF(0.0);\n        return;\n    }\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if (NdotL <= 0.0 || NdotV <= 0.0) {\n        result = BSDF(0.0);\n        return;\n    }\n    vec3 Y = normalize(cross(N, X));\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float D = mx_microfacet_ggx_NDF(X, Y, H, NdotH, roughness.x, roughness.y);\n    float G = mx_microfacet_ggx_smith_G(NdotL, NdotV, max(roughness.x, roughness.y));\n    vec3 ior_n, ior_k;\n    mx_artistic_to_complex_ior(reflectivity, edge_color, ior_n, ior_k);\n    float VdotH = dot(V, H);\n    vec3 F = mx_fresnel_conductor(VdotH, ior_n, ior_k);\n    F *= weight;\n    result = F * D * G / (4.0 * NdotV);\n}\nvoid mx_conductor_brdf_indirect(vec3 V, float weight, vec3 reflectivity, vec3 edge_color, vec2 roughness, vec3 N, vec3 Li, out vec3 result) {\n    if (weight < EPSILON) {\n        result = vec3(0.0);\n        return;\n    }\n    vec3 ior_n, ior_k;\n    mx_artistic_to_complex_ior(reflectivity, edge_color, ior_n, ior_k);\n    vec3 F = mx_fresnel_conductor(dot(N, V), ior_n, ior_k);\n    F *= weight;\n    result = Li * F;\n}\nvoid mx_dielectric_btdf_transmission(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 normal, vec3 tangent, int distribution, VDF interior, out BSDF result) {\n    result = tint * weight;\n}\nvoid mx_diffuse_btdf_reflection(vec3 L, vec3 V, float weight, vec3 color, vec3 normal, out BSDF result) {\n    float NdotL = dot(L, -normal);\n    if (NdotL <= 0.0 || weight < EPSILON) {\n        result = BSDF(0.0);\n        return;\n    }\n    result = color * weight * NdotL * M_PI_INV;\n}\nvoid mx_diffuse_btdf_indirect(vec3 V, float weight, vec3 color, vec3 normal, out vec3 result) {\n    if (weight < EPSILON) {\n        result = vec3(0.0);\n        return;\n    }\n    vec3 Li = mx_environment_irradiance(-normal);\n    result = Li * color * weight;\n}\nvoid mx_subsurface_brdf_reflection(vec3 L, vec3 V, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, out BSDF result) {\n    float NdotL = dot(L, -normal);\n    if (NdotL <= 0.0 || weight < EPSILON) {\n        result = BSDF(0.0);\n        return;\n    }\n    result = color * weight * NdotL * M_PI_INV;\n}\nvoid mx_subsurface_brdf_indirect(vec3 V, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, out vec3 result) {\n    if (weight < EPSILON) {\n        result = vec3(0.0);\n        return;\n    }\n    vec3 Li = mx_environment_irradiance(-normal);\n    result = Li * color * weight;\n}\nvoid mx_diffuse_brdf_reflection(vec3 L, vec3 V, float weight, vec3 color, float roughness, vec3 normal, out BSDF result) {\n    float NdotL = dot(L, normal);\n    if (NdotL <= 0.0 || weight < EPSILON) {\n        result = BSDF(0.0);\n        return;\n    }\n    result = color * weight * NdotL * M_PI_INV;\n    if (roughness > 0.0) {\n        result *= mx_orennayar(L, V, normal, NdotL, roughness);\n    }\n}\nvoid mx_diffuse_brdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 normal, out vec3 result) {\n    if (weight < EPSILON) {\n        result = vec3(0.0);\n        return;\n    }\n    vec3 Li = mx_environment_irradiance(normal);\n    result = Li * color * weight;\n}\nvoid mx_mix_bsdf_reflection(vec3 L, vec3 V, BSDF fg, BSDF bg, float w, out BSDF result) {\n    result = mix(bg, fg, clamp(w, 0.0, 1.0));\n}\nvoid mx_mix_bsdf_transmission(vec3 V, BSDF fg, BSDF bg, float w, out BSDF result) {\n    result = mix(bg, fg, clamp(w, 0.0, 1.0));\n}\nvoid mx_mix_bsdf_indirect(vec3 V, vec3 fg, vec3 bg, float w, out vec3 result) {\n    result = mix(bg, fg, clamp(w, 0.0, 1.0));\n}\nvoid mx_sheen_brdf_reflection(vec3 L, vec3 V, float weight, vec3 color, float roughness, vec3 N, BSDF base, out BSDF result) {\n    if (weight < EPSILON) {\n        result = base;\n        return;\n    }\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if (NdotL <= 0.0 || NdotV <= 0.0) {\n        result = base;\n        return;\n    }\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float alpha = clamp(roughness, EPSILON, 1.0);\n    float D = mx_microfacet_sheen_NDF(NdotH, alpha);\n    vec3 F = color * weight;\n    vec3 fr = D * F / (4.0 * (NdotL + NdotV - NdotL*NdotV));\n    float albedo = weight * mx_microfacet_sheen_albedo(NdotV, alpha);\n    result = fr * NdotL + base * (1.0 - albedo);\n}\nvoid mx_sheen_brdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 N, BSDF base, out vec3 result) {\n    if (weight <= 0.0) {\n        result = base;\n        return;\n    }\n    float NdotV = abs(dot(N, V));\n    float alpha = clamp(roughness, EPSILON, 1.0);\n    float albedo = weight * mx_microfacet_sheen_albedo(NdotV, alpha);\n    vec3 Li = mx_environment_irradiance(N);\n    result = Li * color * albedo + base * (1.0 - albedo);\n}\nvoid mx_uniform_edf(vec3 N, vec3 L, vec3 color, out EDF result) {\n    result = color;\n}\nvoid mx_dielectric_brdf_reflection(vec3 L, vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, BSDF base, out BSDF result) {\n    if (weight < EPSILON) {\n        result = base;\n        return;\n    }\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if (NdotL <= 0.0 || NdotV <= 0.0) {\n        result = base;\n        return;\n    }\n    vec3 Y = normalize(cross(N, X));\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float D = mx_microfacet_ggx_NDF(X, Y, H, NdotH, roughness.x, roughness.y);\n    float G = mx_microfacet_ggx_smith_G(NdotL, NdotV, max(roughness.x, roughness.y));\n    float VdotH = dot(V, H);\n    float F = mx_fresnel_schlick(VdotH, ior);\n    F *= weight;\n    result = tint * D * G * F / (4.0 * NdotV) + base * (1.0 - F);\n}\nvoid mx_dielectric_brdf_transmission(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, BSDF base, out BSDF result) {\n    if (weight < EPSILON) {\n        result = base;\n        return;\n    }\n    float NdotV = abs(dot(N, V));\n    float F = mx_fresnel_schlick(NdotV, ior);\n    F *= weight;\n    result = base * (1.0 - F);\n}\nvoid mx_dielectric_brdf_indirect(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 Li, BSDF base, out BSDF result) {\n    if (weight < EPSILON) {\n        result = base;\n        return;\n    }\n    float NdotV = dot(N, V);\n    float F = mx_fresnel_schlick_roughness(NdotV, ior, max(roughness.x, roughness.y));\n    F *= weight;\n    result = Li * tint * F + base * (1.0 - F);\n}\nvoid mx_multiply_bsdf_color_reflection(vec3 L, vec3 V, BSDF in1, vec3 in2, out BSDF result) {\n    result = in1 * clamp(in2, 0.0, 1.0);\n}\nvoid mx_multiply_bsdf_color_transmission(vec3 V, BSDF in1, vec3 in2, out BSDF result) {\n    result = in1 * clamp(in2, 0.0, 1.0);\n}\nvoid mx_multiply_bsdf_color_indirect(vec3 V, vec3 in1, vec3 in2, out vec3 result) {\n    result = in1 * clamp(in2, 0.0, 1.0);\n}\nvoid IMPL_standard_surface_surfaceshader(float base, vec3 base_color, float diffuse_roughness, float metalness, float specular, vec3 specular_color, float specular_roughness, float specular_IOR, float specular_anisotropy, float specular_rotation, float transmission, vec3 transmission_color, float transmission_depth, vec3 transmission_scatter, float transmission_scatter_anisotropy, float transmission_dispersion, float transmission_extra_roughness, float subsurface, vec3 subsurface_color, vec3 subsurface_radius, float subsurface_scale, float subsurface_anisotropy, float sheen, vec3 sheen_color, float sheen_roughness, float coat, vec3 coat_color, float coat_roughness, float coat_anisotropy, float coat_rotation, float coat_IOR, vec3 coat_normal, float coat_affect_color, float coat_affect_roughness, float thin_film_thickness, float thin_film_IOR, float emission, vec3 emission_color, vec3 opacity, int thin_walled, vec3 normal, vec3 tangent, vec3 geomWorldPosition, vec3 geomWorldNormal, vec3 camWorldPosition, out surfaceshader out275) {\n    vec3 opacity_luminance_out = vec3(0.0);\n    const vec3 lum = vec3(0.272287, 0.674082, 0.053689);\n    mx_luminance_color3(opacity, lum, opacity_luminance_out);\n    vec3 emission_weight_out = emission_color * emission;\n    float subsurface_selector_out = float(thin_walled);\n    vec3 geomprop_Vworld_out = normalize(geomWorldPosition - camWorldPosition);\n    float coat_affect_roughness_multiply1_out = coat_affect_roughness * coat;\n    const float tangent_rotate_degree_in2_tmp = 360.0;\n    float tangent_rotate_degree_out = specular_rotation * tangent_rotate_degree_in2_tmp;\n    vec3 metal_edgecolor_out = specular_color * specular;\n    vec3 subsurface_radius_vector_out = vec3(subsurface_radius.x, subsurface_radius.y, subsurface_radius.z);\n    vec3 metal_reflectivity_out = base_color * base;\n    const float coat_tangent_rotate_degree_in2_tmp = 360.0;\n    float coat_tangent_rotate_degree_out = coat_rotation * coat_tangent_rotate_degree_in2_tmp;\n    float coat_clamped_out = clamp(coat, 0.0, 1.0);\n    vec3 coat_attenuation_out = mix(vec3(1.0), coat_color, coat);\n    vec2 coat_roughness_out = vec2(0.0);\n    mx_roughness_anisotropy(coat_roughness, coat_anisotropy, coat_roughness_out);\n    float coat_fresnel_out = 0.0;\n    mx_fresnel_ior(coat_IOR, coat_normal, geomprop_Vworld_out, coat_fresnel_out);\n    float coat_affect_roughness_multiply2_out = coat_affect_roughness_multiply1_out * coat_roughness;\n    vec3 tangent_rotate_out = vec3(0.0);\n    mx_rotate_vector3(tangent, tangent_rotate_degree_out, normal, tangent_rotate_out);\n    vec3 subsurface_radius_scaled_out = subsurface_radius_vector_out * subsurface_scale;\n    vec3 coat_tangent_rotate_out = vec3(0.0);\n    mx_rotate_vector3(tangent, coat_tangent_rotate_degree_out, coat_normal, coat_tangent_rotate_out);\n    float coat_gamma_multiply_out = coat_clamped_out * coat_affect_color;\n    float coat_fresnel_inv_out = 1.0 - coat_fresnel_out;\n    float coat_affected_roughness_out = mix(specular_roughness, 1.0, coat_affect_roughness_multiply2_out);\n    vec3 tangent_rotate_normalize_out = normalize(tangent_rotate_out);\n    vec3 coat_tangent_rotate_normalize_out = normalize(coat_tangent_rotate_out);\n    float coat_gamma_out = coat_gamma_multiply_out + 1.0;\n    vec3 coat_color_fresnel_out = coat_color * coat_fresnel_inv_out;\n    vec2 main_roughness_out = vec2(0.0);\n    mx_roughness_anisotropy(coat_affected_roughness_out, specular_anisotropy, main_roughness_out);\n    vec3 main_tangent_out = vec3(0.0);\n    if (specular_anisotropy > 0.0) {\n        main_tangent_out = tangent_rotate_normalize_out;\n    } else {\n        main_tangent_out = tangent;\n    }\n    vec3 coat_tangent_out = vec3(0.0);\n    if (coat_anisotropy > 0.0) {\n        coat_tangent_out = coat_tangent_rotate_normalize_out;\n    } else {\n        coat_tangent_out = tangent;\n    }\n    vec3 coat_affected_subsurface_color_out = pow(subsurface_color, vec3(coat_gamma_out));\n    vec3 coat_affected_diffuse_color_out = pow(base_color, vec3(coat_gamma_out));\n    vec3 coat_emission_attenuation_out = mix(vec3(1.0), coat_color_fresnel_out, coat);\n    vec3 emission_weight_attenuated_out = emission_weight_out * coat_emission_attenuation_out;\n    surfaceshader standard_surface_constructor_out = surfaceshader(vec3(0.0), vec3(0.0));\n    {\n        float surfaceOpacity = opacity_luminance_out.x;\n        if (surfaceOpacity < 0.001) discard;\n        vec3 N = normalize(geomWorldNormal);\n        vec3 V = normalize(camWorldPosition - geomWorldPosition);\n        lightshader lightShader;\n#if MAX_LIGHTS > 0\n        for (int lightIdx = 0; lightIdx < MAX_LIGHTS; ++lightIdx) {\n            sample_light(lightIdx, geomWorldPosition, lightShader);\n            vec3 L = lightShader.direction;\n            BSDF transmission_bsdf_out = BSDF(0.0);\n            BSDF metal_bsdf_out = BSDF(0.0);\n            mx_conductor_brdf_reflection(L, V, 1.0, metal_reflectivity_out, metal_edgecolor_out, main_roughness_out, normal, main_tangent_out, 0, metal_bsdf_out);\n            BSDF translucent_bsdf_out = BSDF(0.0);\n            mx_diffuse_btdf_reflection(L, V, 1.0, coat_affected_subsurface_color_out, normal, translucent_bsdf_out);\n            BSDF subsurface_bsdf_out = BSDF(0.0);\n            mx_subsurface_brdf_reflection(L, V, 1.0, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal, subsurface_bsdf_out);\n            BSDF diffuse_bsdf_out = BSDF(0.0);\n            mx_diffuse_brdf_reflection(L, V, base, coat_affected_diffuse_color_out, diffuse_roughness, normal, diffuse_bsdf_out);\n            BSDF selected_subsurface_bsdf_out = BSDF(0.0);\n            mx_mix_bsdf_reflection(L, V, translucent_bsdf_out, subsurface_bsdf_out, subsurface_selector_out, selected_subsurface_bsdf_out);\n            BSDF sheen_bsdf_out = BSDF(0.0);\n            mx_sheen_brdf_reflection(L, V, sheen, sheen_color, sheen_roughness, normal, diffuse_bsdf_out, sheen_bsdf_out);\n            BSDF subsurface_mix_out = BSDF(0.0);\n            mx_mix_bsdf_reflection(L, V, selected_subsurface_bsdf_out, sheen_bsdf_out, subsurface, subsurface_mix_out);\n            BSDF transmission_mix_out = BSDF(0.0);\n            mx_mix_bsdf_reflection(L, V, transmission_bsdf_out, subsurface_mix_out, transmission, transmission_mix_out);\n            BSDF specular_bsdf_out = BSDF(0.0);\n            mx_dielectric_brdf_reflection(L, V, specular, specular_color, specular_IOR, main_roughness_out, normal, main_tangent_out, 0, transmission_mix_out, specular_bsdf_out);\n            BSDF metalness_mix_out = BSDF(0.0);\n            mx_mix_bsdf_reflection(L, V, metal_bsdf_out, specular_bsdf_out, metalness, metalness_mix_out);\n            BSDF metalness_mix_attenuated_out = BSDF(0.0);\n            mx_multiply_bsdf_color_reflection(L, V, metalness_mix_out, coat_attenuation_out, metalness_mix_attenuated_out);\n            BSDF coat_bsdf_out = BSDF(0.0);\n            mx_dielectric_brdf_reflection(L, V, coat, vec3(1.0), coat_IOR, coat_roughness_out, coat_normal, coat_tangent_out, 0, metalness_mix_attenuated_out, coat_bsdf_out);\n            standard_surface_constructor_out.color += lightShader.intensity * coat_bsdf_out;\n        }\n#endif\n        {\n            EDF emission_edf_out = EDF(0.0);\n            mx_uniform_edf(N, V, emission_weight_attenuated_out, emission_edf_out);\n            standard_surface_constructor_out.color += emission_edf_out;\n        }\n        {\n            BSDF transmission_bsdf_out = BSDF(0.0);\n            BSDF metal_bsdf_out = BSDF(0.0);\n            vec3 Li = mx_environment_radiance(normal, V, main_tangent_out, main_roughness_out, 0);\n            mx_conductor_brdf_indirect(V, 1.0, metal_reflectivity_out, metal_edgecolor_out, main_roughness_out, normal, Li, metal_bsdf_out);\n            BSDF translucent_bsdf_out = BSDF(0.0);\n            mx_diffuse_btdf_indirect(V, 1.0, coat_affected_subsurface_color_out, normal, translucent_bsdf_out);\n            BSDF subsurface_bsdf_out = BSDF(0.0);\n            mx_subsurface_brdf_indirect(V, 1.0, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal, subsurface_bsdf_out);\n            BSDF diffuse_bsdf_out = BSDF(0.0);\n            mx_diffuse_brdf_indirect(V, base, coat_affected_diffuse_color_out, diffuse_roughness, normal, diffuse_bsdf_out);\n            BSDF selected_subsurface_bsdf_out = BSDF(0.0);\n            mx_mix_bsdf_indirect(V, translucent_bsdf_out, subsurface_bsdf_out, subsurface_selector_out, selected_subsurface_bsdf_out);\n            BSDF sheen_bsdf_out = BSDF(0.0);\n            mx_sheen_brdf_indirect(V, sheen, sheen_color, sheen_roughness, normal, diffuse_bsdf_out, sheen_bsdf_out);\n            BSDF subsurface_mix_out = BSDF(0.0);\n            mx_mix_bsdf_indirect(V, selected_subsurface_bsdf_out, sheen_bsdf_out, subsurface, subsurface_mix_out);\n            BSDF transmission_mix_out = BSDF(0.0);\n            mx_mix_bsdf_indirect(V, transmission_bsdf_out, subsurface_mix_out, transmission, transmission_mix_out);\n            BSDF specular_bsdf_out = BSDF(0.0);\n            mx_dielectric_brdf_indirect(V, specular, specular_color, specular_IOR, main_roughness_out, normal, Li, transmission_mix_out, specular_bsdf_out);\n            BSDF metalness_mix_out = BSDF(0.0);\n            mx_mix_bsdf_indirect(V, metal_bsdf_out, specular_bsdf_out, metalness, metalness_mix_out);\n            BSDF metalness_mix_attenuated_out = BSDF(0.0);\n            mx_multiply_bsdf_color_indirect(V, metalness_mix_out, coat_attenuation_out, metalness_mix_attenuated_out);\n            BSDF coat_bsdf_out = BSDF(0.0);\n            if (coat > EPSILON && (normal != coat_normal || main_tangent_out != coat_tangent_out || main_roughness_out != coat_roughness_out)) {\n                Li = mx_environment_radiance(coat_normal, V, coat_tangent_out, coat_roughness_out, 0);\n            }\n            mx_dielectric_brdf_indirect(V, coat, vec3(1.0), coat_IOR, coat_roughness_out, coat_normal, Li, metalness_mix_attenuated_out, coat_bsdf_out);\n            standard_surface_constructor_out.color += coat_bsdf_out;\n        }\n        {\n            BSDF transmission_bsdf_out = BSDF(0.0);\n            mx_dielectric_btdf_transmission(V, 1.0, transmission_color, specular_IOR, main_roughness_out, normal, main_tangent_out, 0, VDF(vec3(0.0),vec3(0.0)), transmission_bsdf_out);\n            BSDF metal_bsdf_out = BSDF(0.0);\n            BSDF translucent_bsdf_out = BSDF(0.0);\n            BSDF subsurface_bsdf_out = BSDF(0.0);\n            BSDF diffuse_bsdf_out = BSDF(0.0);\n            BSDF selected_subsurface_bsdf_out = BSDF(0.0);\n            mx_mix_bsdf_transmission(V, translucent_bsdf_out, subsurface_bsdf_out, subsurface_selector_out, selected_subsurface_bsdf_out);\n            BSDF sheen_bsdf_out = BSDF(0.0);\n            BSDF subsurface_mix_out = BSDF(0.0);\n            mx_mix_bsdf_transmission(V, selected_subsurface_bsdf_out, sheen_bsdf_out, subsurface, subsurface_mix_out);\n            BSDF transmission_mix_out = BSDF(0.0);\n            mx_mix_bsdf_transmission(V, transmission_bsdf_out, subsurface_mix_out, transmission, transmission_mix_out);\n            BSDF specular_bsdf_out = BSDF(0.0);\n            mx_dielectric_brdf_transmission(V, specular, specular_color, specular_IOR, main_roughness_out, normal, main_tangent_out, 0, transmission_mix_out, specular_bsdf_out);\n            BSDF metalness_mix_out = BSDF(0.0);\n            mx_mix_bsdf_transmission(V, metal_bsdf_out, specular_bsdf_out, metalness, metalness_mix_out);\n            BSDF metalness_mix_attenuated_out = BSDF(0.0);\n            mx_multiply_bsdf_color_transmission(V, metalness_mix_out, coat_attenuation_out, metalness_mix_attenuated_out);\n            BSDF coat_bsdf_out = BSDF(0.0);\n            mx_dielectric_brdf_transmission(V, coat, vec3(1.0), coat_IOR, coat_roughness_out, coat_normal, coat_tangent_out, 0, metalness_mix_attenuated_out, coat_bsdf_out);\n            standard_surface_constructor_out.transparency = coat_bsdf_out;\n        }\n        standard_surface_constructor_out.color *= surfaceOpacity;\n        standard_surface_constructor_out.transparency = mix(vec3(1.0), standard_surface_constructor_out.transparency, surfaceOpacity);\n    }\n    out275 = standard_surface_constructor_out;\n}\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec2 uv = vec2(0.0);\n    uv = vUv;\n#ifdef USE_TILING\n    vec3 tilingXform = tilingTransform(vUv, tilingOverallTransform);\n    vec4 tilingMap = tilingMapText(TilingMap, TilingMap_texMatrix, tilingXform, uv2tile, tile2uv);\n    uv = tilingSubMaterialRelocate(tilingXform, tilingMap, tile2uv) + tileAlignOffset;\n#ifdef USE_TILING_NORMAL\n    vec2 uvNorm = uv;\n#endif\n#ifdef USE_TILING_RANDOM\n    uv = tilingRandom(uv, tilingMap, TilingRandomMap, TilingRandomMap_texMatrix, tilingRandomAxisS, tilingRandomAxisT, tilingRandomAlignmentOffset);\n#endif\n    uv = tilingTransform(uv, tilingUVTransform).xy;\n#endif\n#ifdef USE_TILING_NORMAL\n    tilingNormalOffset(TilingNormalMap, uvNorm, TilingNormalMap_texMatrix, TBN[0], TBN[1], TBN[2]);\n#endif\n    vec3 T, B;\n    computeTangets(vWorldPosition, uv, T, B);\n    mat3 TBN = get_TBN(vWorldNormal, T, B, uv);\n    mat3 coat_TBN = get_coat_TBN(vWorldNormal, T, B, uv);\n    surfaceshader SR_out = surfaceshader(vec3(0.0), vec3(0.0));\n    IMPL_standard_surface_surfaceshader(\n        get_base(uv),\n        get_base_color(uv),\n        get_diffuse_roughness(uv),\n        get_metalness(uv),\n        get_specular(uv),\n        get_specular_color(uv),\n        get_specular_roughness(uv),\n        get_specular_IOR(uv),\n        get_specular_anisotropy(uv),\n        get_specular_rotation(uv),\n        get_transmission(uv),\n        get_transmission_color(uv),\n        get_transmission_depth(uv),\n        get_transmission_scatter(uv),\n        get_transmission_scatter_anisotropy(uv),\n        get_transmission_dispersion(uv),\n        get_transmission_extra_roughness(uv),\n        get_subsurface(uv),\n        get_subsurface_color(uv),\n        get_subsurface_radius(uv),\n        get_subsurface_scale(uv),\n        get_subsurface_anisotropy(uv),\n        get_sheen(uv),\n        get_sheen_color(uv),\n        get_sheen_roughness(uv),\n        get_coat(uv),\n        get_coat_color(uv),\n        get_coat_roughness(uv),\n        get_coat_anisotropy(uv),\n        get_coat_rotation(uv),\n        get_coat_IOR(uv),\n        coat_TBN[2],\n        get_coat_affect_color(uv),\n        get_coat_affect_roughness(uv),\n        get_thin_film_thickness(uv),\n        get_thin_film_IOR(uv),\n        get_emission(uv),\n        get_emission_color(uv),\n        get_opacity(uv),\n        get_thin_walled(uv),\n        TBN[2],\n        TBN[0],\n        vWorldPosition,\n        vWorldNormal,\n        cameraPosition,\n        SR_out);\n    float outAlpha = clamp(1.0 - dot(SR_out.transparency, vec3(0.3333)), 0.0, 1.0);\n    gl_FragColor = vec4(SR_out.color, outAlpha);\n#ifdef MRT_NORMALS\n    vec3 geomNormal = vGeomNormal;\n#endif\n#if TONEMAP_OUTPUT == 1\n    gl_FragColor.rgb = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.rgb);\n#elif TONEMAP_OUTPUT == 2\n    gl_FragColor.rgb = toneMapCanonFilmic_WithGamma(exposureBias * gl_FragColor.rgb);\n#endif\n#ifdef USE_FOG\n    float fogdepth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep(fogNear, fogFar, fogdepth);\n    gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.a), fogFactor);\n#endif\n#ifdef USE_TILING\n    gl_FragColor.a *= tilingMap.a;\n#endif\n#include<theming_frag>\n#include<final_frag>\n}\n";

/***/ }),

/***/ "./extensions/StandardSurface/std-surf-vert.glsl":
/*!*******************************************************!*\
  !*** ./extensions/StandardSurface/std-surf-vert.glsl ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "varying vec3 vWorldNormal;\nvarying vec3 vWorldPosition;\n#if defined(USE_MAP) || defined(USE_BASE_MAP) || defined(USE_BASE_COLOR_MAP) || defined(USE_COAT_MAP) || defined(USE_COAT_AFFECT_COLOR_MAP) || defined(USE_COAT_AFFECT_ROUGHNESS_MAP) || defined(USE_COAT_ANISOTROPY_MAP) || defined(USE_COAT_COLOR_MAP) || defined(USE_COAT_IOR_MAP) || defined(USE_COAT_NORMAL_MAP) || defined(USE_COAT_ROTATION_MAP) || defined(USE_COAT_ROUGHNESS_MAP) || defined(USE_DIFFUSE_ROUGHNESS_MAP) || defined(USE_EMISSION_MAP) || defined(USE_EMISSION_COLOR_MAP) || defined(USE_METALNESS_MAP) || defined(USE_NORMAL_MAP) || defined(USE_OPACITY_MAP) || defined(USE_SHEEN_MAP) || defined(USE_SHEEN_COLOR_MAP) || defined(USE_SHEEN_ROUGHNESS_MAP) || defined(USE_SPECULAR_MAP) || defined(USE_SPECULAR_ANISOTROPY_MAP) || defined(USE_SPECULAR_COLOR_MAP) || defined(USE_SPECULAR_IOR_MAP) || defined(USE_SPECULAR_ROTATION_MAP) || defined(USE_SPECULAR_ROUGHNESS_MAP) || defined(USE_SUBSURFACE_MAP) || defined(USE_SUBSURFACE_ANISOTROPY_MAP) || defined(USE_SUBSURFACE_COLOR_MAP) || defined(USE_SUBSURFACE_RADIUS_MAP) || defined(USE_SUBSURFACE_SCALE_MAP) || defined(USE_THIN_FILM_IOR_MAP) || defined(USE_THIN_FILM_THICKNESS_MAP) || defined(USE_THIN_WALLED_MAP) || defined(USE_TRANSMISSION_MAP) || defined(USE_TRANSMISSION_COLOR_MAP) || defined(USE_TRANSMISSION_DEPTH_MAP) || defined(USE_TRANSMISSION_DISPERSION_MAP) || defined(USE_TRANSMISSION_EXTRA_ROUGHNESS_MAP) || defined(USE_TRANSMISSION_SCATTER_MAP) || defined(USE_TRANSMISSION_SCATTER_ANISOTROPY_MAP)\n#define USE_MAP\n#endif\nvarying vec2 vUv;\n#ifdef MRT_NORMALS\nvarying float depth;\nvarying vec3 vGeomNormal;\n#endif\n#include<pack_normals>\n#include<instancing_decl_vert>\n#include<id_decl_vert>\n#include<shadowmap_decl_vert>\nvoid main() {\n#ifdef UNPACK_NORMALS\n    vec3 instNorm = decodeNormal(normal);\n#else\n    vec3 instNorm = normal;\n#endif\n    instNorm = getInstanceNormal(instNorm);\n    vec3 instPos = getInstancePos(position);\n#ifdef MRT_NORMALS\n    vGeomNormal = normalize(normalMatrix * instNorm);\n#endif\n    vec4 positionWorld = modelMatrix * vec4(instPos, 1.0);\n    mat3 worldInverseTransposeMatrix = mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n    vec4 mvPosition = modelViewMatrix * vec4(instPos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n    vWorldNormal = normalize(worldInverseTransposeMatrix * instNorm);\n    vWorldPosition = positionWorld.xyz;\n    vUv = uv;\n#ifdef MRT_NORMALS\n    depth = mvPosition.z;\n#endif\n#include<id_vert>\n#include<shadowmap_vert>\n}\n";

/***/ }),

/***/ "./node_modules/@adsk/standard-surface-json-schema/schemas/standard-surface.schema.json":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@adsk/standard-surface-json-schema/schemas/standard-surface.schema.json ***!
  \**********************************************************************************************/
/*! exports provided: definitions, $schema, $id, type, required, properties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"definitions\":{\"color\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"object\",\"required\":[\"r\",\"g\",\"b\"],\"properties\":{\"r\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1},\"g\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1},\"b\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}}}}},\"colorOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/color\"},{\"$ref\":\"#/definitions/textureReference\"}]},\"angleZeroToTwoPi\":{\"oneOf\":[{\"type\":\"object\",\"required\":[\"units\",\"value\"],\"properties\":{\"units\":{\"type\":\"string\",\"const\":\"radian\"},\"value\":{\"type\":\"number\",\"minimum\":0,\"maximum\":6.283185307179586}}},{\"type\":\"object\",\"required\":[\"units\",\"value\"],\"properties\":{\"units\":{\"type\":\"string\",\"const\":\"degree\"},\"value\":{\"type\":\"number\",\"minimum\":0,\"maximum\":360}}}]},\"angleZeroToTwoPiOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/angleZeroToTwoPi\"},{\"allOf\":[{\"type\":\"object\",\"required\":[\"units\"],\"properties\":{\"units\":{\"type\":\"string\",\"enum\":[\"degree\",\"radian\"]}}},{\"$ref\":\"#/definitions/textureReference\"}]}]},\"distanceUnits\":{\"type\":\"object\",\"required\":[\"units\"],\"properties\":{\"units\":{\"type\":\"string\",\"enum\":[\"nanometer\",\"millimeter\",\"decimeter\",\"centimeter\",\"meter\",\"kilometer\",\"inch\",\"foot\",\"mile\",\"yard\",\"\"]}}},\"distanceZeroToInfinityOrTextureReference\":{\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"oneOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinity\"},{\"$ref\":\"#/definitions/textureReference\"}]}]},\"scalarNegativeOneToOne\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"number\",\"minimum\":-1,\"maximum\":1}}},\"scalarNegativeOneToOneOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOne\"},{\"$ref\":\"#/definitions/textureReference\"}]},\"scalarUnlimited\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"number\"}}},\"scalarUnlimitedOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/scalarUnlimited\"},{\"$ref\":\"#/definitions/textureReference\"}]},\"scalarZeroToInfinity\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"number\",\"minimum\":0}}},\"scalarZeroToInfinityOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinity\"},{\"$ref\":\"#/definitions/textureReference\"}]},\"scalarZeroToOne\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}}},\"scalarZeroToOneOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/scalarZeroToOne\"},{\"$ref\":\"#/definitions/textureReference\"}]},\"textureReference\":{\"type\":\"object\",\"required\":[\"texture\"],\"properties\":{\"texture\":{\"description\":\"A reference to a texture; when using a texture for a scalar-valued parameter, the first channel of the sampled value (after scaling by 'rgbScale') is used.\",\"type\":\"object\",\"required\":[\"$ref\"],\"properties\":{\"$ref\":{\"description\":\"JSON reference to the texture; must be within the same JSON document.\",\"type\":\"string\",\"pattern\":\"^#/.+$\"}}}}},\"vector\":{\"type\":\"object\",\"required\":[\"value\"],\"properties\":{\"value\":{\"type\":\"object\",\"required\":[\"x\",\"y\",\"z\"],\"properties\":{\"x\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1},\"y\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1},\"z\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}}}}},\"vectorOrTextureReference\":{\"oneOf\":[{\"$ref\":\"#/definitions/vector\"},{\"$ref\":\"#/definitions/textureReference\"}]}},\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://autodesk.com/schemas/standard-surface.schema.json\",\"type\":\"object\",\"required\":[\"tag\",\"definition\",\"transparent\",\"parameters\"],\"properties\":{\"tag\":{\"description\":\"Unique name or identifier for the material. MUST NOT be empty. Could be displayed to users.\",\"type\":\"string\",\"pattern\":\"^.+$\"},\"definition\":{\"description\":\"Identifier for the type of this material. MUST be 'StandardSurface'.\",\"type\":\"string\",\"const\":\"StandardSurface\"},\"transparent\":{\"description\":\"Transparency hint. SHOULD be true if the material is transparent.\",\"type\":\"boolean\",\"default\":false},\"parameters\":{\"description\":\"Standard Surface material parameter values.\",\"type\":\"object\",\"properties\":{\"base\":{\"description\":\"Scalar multiplier for base_color; reflection weight of diffuse_brdf.\",\"default\":{\"value\":0.8},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"base_color\":{\"description\":\"Reflection color at normal incidence (i.e., surface seen from straight up); reflection color of diffuse_brdf.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"coat\":{\"description\":\"Coating reflection weight (coating reflection color is fixed to white).\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"coat_affect_color\":{\"description\":\"How much to additionally modulate diffuse reflection and subsurface scattering saturation.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"coat_affect_roughness\":{\"description\":\"How much to affect the roughness of the specular reflection layers below.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"coat_anisotropy\":{\"description\":\"Reflection anisotropy of coat_brdf.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"coat_color\":{\"description\":\"Tint color for the light coming from all layers below.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"coat_IOR\":{\"description\":\"Refractive index of coat_brdf.\",\"default\":{\"value\":1.5},\"allOf\":[{\"$ref\":\"#/definitions/scalarUnlimitedOrTextureReference\"}]},\"coat_normal\":{\"description\":\"Shading normal for the coating reflections; optional, overrides the default shading normal; has no effect on the closure combination weights; if present and of non-zero length, will be normalized.\",\"default\":{\"value\":{\"x\":0,\"y\":0,\"z\":0}},\"allOf\":[{\"$ref\":\"#/definitions/vectorOrTextureReference\"}]},\"coat_rotation\":{\"description\":\"Orientation of coating anisotropy. Units apply to this value and MUST be one of 'radian' or 'degree'.\",\"default\":{\"units\":\"radian\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/angleZeroToTwoPiOrTextureReference\"}]},\"coat_roughness\":{\"description\":\"Coat reflection roughness; squared internally before being passed to the BSDF to achieve a more linear perceptual response.\",\"default\":{\"value\":0.1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"diffuse_roughness\":{\"description\":\"Reflection roughness of diffuse_brdf; transmission roughness of diffuse_btdf.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"emission\":{\"description\":\"Emission color multiplier.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"emission_color\":{\"description\":\"Emission color.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"metalness\":{\"description\":\"Weight of metal_brdf vs the specular reflection layer.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"normal\":{\"description\":\"Shading normal for the base layer; optional, overrides the default shading normal; has no effect on the closure combination weights; if present and of non-zero length, will be normalized.\",\"default\":{\"value\":{\"x\":0,\"y\":0,\"z\":0}},\"allOf\":[{\"$ref\":\"#/definitions/vectorOrTextureReference\"}]},\"sheen\":{\"description\":\"Reflection weight of sheen_brdf.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"sheen_color\":{\"description\":\"Reflection color of sheen_brdf\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"sheen_roughness\":{\"description\":\"Reflection roughness of sheen_brdf.\",\"default\":{\"value\":0.3},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"specular\":{\"description\":\"Scalar multiplier to specular_color; specular reflection weight.\",\"default\":{\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"specular_anisotropy\":{\"description\":\"Reflection anisotropy of metal_brdf and specular_brdf.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"specular_color\":{\"description\":\"Reflection color at grazing incidence (i.e., around silhouettes); specular reflection color.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"specular_IOR\":{\"description\":\"Refractive index of specular_brdf and specular_btdf.\",\"default\":{\"value\":1.52},\"allOf\":[{\"$ref\":\"#/definitions/scalarUnlimitedOrTextureReference\"}]},\"specular_rotation\":{\"description\":\"Orientation of specular anisotropy. Units apply to this value and MUST be one of 'radian' or 'degree'.\",\"default\":{\"units\":\"radian\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/angleZeroToTwoPiOrTextureReference\"}]},\"specular_roughness\":{\"description\":\"Reflection roughness of specular_brdf; refraction roughness of specular_btdf; squared internally before being passed to the BxDFs to achieve a more uniform roughness look over the parameter range.\",\"default\":{\"value\":0.1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"subsurface\":{\"description\":\"Diffuse transmission weight; subsurface scattering weight.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"subsurface_anisotropy\":{\"description\":\"Anisotropy of the subsurface medium phase function.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOneOrTextureReference\"}]},\"subsurface_color\":{\"description\":\"Diffuse transmission color; subsurface color, used by subsurface(...) closure.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"subsurface_radius\":{\"description\":\"Subsurface radii (i.e., mean free paths) of the red, green, and blue channels\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"subsurface_scale\":{\"description\":\"Scalar scale for subsurface_radius. Units apply to this value and MUST be one of 'nanometer', 'millimeter', 'decimeter', 'centimeter', 'meter', 'kilometer', 'inch', 'foot', 'mile', 'yard', or '' (to use scene units).\",\"default\":{\"units\":\"\",\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/distanceZeroToInfinityOrTextureReference\"}]},\"thin_film_IOR\":{\"description\":\"Refractive index of the film.\",\"default\":{\"value\":1.5},\"allOf\":[{\"$ref\":\"#/definitions/scalarUnlimitedOrTextureReference\"}]},\"thin_film_thickness\":{\"description\":\"Thickness of the film. Units apply to this value and MUST be one of 'nanometer', 'millimeter', 'decimeter', 'centimeter', 'meter', 'kilometer', 'inch', 'foot', 'mile', 'yard', or '' (to use scene units).\",\"default\":{\"units\":\"nanometer\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/distanceZeroToInfinityOrTextureReference\"}]},\"thin_walled\":{\"description\":\"If true, the object is considered infinitely thin and the surface double-sided.\",\"type\":\"boolean\",\"default\":false},\"transmission\":{\"description\":\"Transmission weight.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToOneOrTextureReference\"}]},\"transmission_color\":{\"description\":\"Transmission color, i.e., tint.\",\"default\":{\"value\":{\"r\":1,\"g\":1,\"b\":1}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"transmission_depth\":{\"description\":\"The distance travelled inside the material by white light before its color becomes exactly transmission_color by Beer's law, determining the extinction coefficient of the interior medium; if zero, transmission_color acts as a constant (on-surface) transmission tint. Units apply to this value and MUST be one of 'nanometer', 'millimeter', 'decimeter', 'centimeter', 'meter', 'kilometer', 'inch', 'foot', 'mile', 'yard', or '' (to use scene units).\",\"default\":{\"units\":\"\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/distanceZeroToInfinityOrTextureReference\"}]},\"transmission_dispersion\":{\"description\":\"Dispersion Abbe number, describing how much the index of refraction varies across wavelengths.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinityOrTextureReference\"}]},\"transmission_extra_roughness\":{\"description\":\"Additional (positive or negative) roughness on top of specular_roughness. Values other than 0 are not physically correct.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOneOrTextureReference\"}]},\"transmission_scatter\":{\"description\":\"Scattering coefficient of the interior medium.\",\"default\":{\"value\":{\"r\":0,\"g\":0,\"b\":0}},\"allOf\":[{\"$ref\":\"#/definitions/colorOrTextureReference\"}]},\"transmission_scatter_anisotropy\":{\"description\":\"The anisotropy of the Henyey-Greenstein phase function of the interior medium.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOneOrTextureReference\"}]}}},\"textures\":{\"description\":\"Texture definitions; each texture key MUST begin with any number of digits followed by an underscore and one or more additional characters.\",\"type\":\"object\",\"additionalProperties\":{\"type\":\"object\",\"required\":[\"bitmap\"],\"properties\":{\"bitmap\":{\"description\":\"SVF path to the image file.\",\"type\":\"string\"},\"filtering\":{\"description\":\"Type of filtering to use when sampling the image; MUST be either 'linear' (linear interpolation) or 'nearest' (nearest pixel).\",\"default\":\"linear\",\"type\":\"string\",\"enum\":[\"linear\",\"nearest\"]},\"encoding\":{\"description\":\"Color space encoding of the supplied bitmap file; MUST be either 'linear' (linear RGB) or 'srgb' (sRGB); default is 'srgb'.\",\"default\":\"srgb\",\"type\":\"string\",\"enum\":[\"linear\",\"srgb\"]},\"isHeightMap\":{\"description\":\"Whether this texture represents a height (bump) map that should be converted to a normal map; this MUST be true when using a height (bump) map for a parameter that expects a vector (e.g., 'coat_normal').\",\"default\":false,\"type\":\"boolean\"},\"heightMapScale\":{\"description\":\"Real-world scale of the height (bump) map; ignored if 'isHeightMap' is not true; Units apply to this value and MUST be one of 'nanometer', 'millimeter', 'decimeter', 'centimeter', 'meter', 'kilometer', 'inch', 'foot', 'mile', 'yard', or '' (to use scene units).\",\"default\":{\"units\":\"\",\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"invert\":{\"description\":\"Whether the sampled texture values should be inverted; inversion of each channel is done independently.\",\"default\":false,\"type\":\"boolean\"},\"realWorldOffsetX\":{\"description\":\"Offset of the texture in the X/U direction in real-world units.\",\"default\":{\"units\":\"\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"$ref\":\"#/definitions/scalarUnlimited\"}]},\"realWorldOffsetY\":{\"description\":\"Offset of the texture in the Y/V direction in real-world units.\",\"default\":{\"units\":\"\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"$ref\":\"#/definitions/scalarUnlimited\"}]},\"realWorldScaleX\":{\"description\":\"Size of the texture in the X/U direction in real-world units.\",\"default\":{\"units\":\"\",\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"realWorldScaleY\":{\"description\":\"Size of the texture in the Y/V direction in real-world units.\",\"default\":{\"units\":\"\",\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/distanceUnits\"},{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"rgbScale\":{\"description\":\"Scalar multiplier for the sampled value.\",\"default\":{\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"uOffset\":{\"description\":\"Offset of the texture in the X/U direction in UV coordinate space; this offset is added after converting the real-world offset into UV space.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOne\"}]},\"uRepeat\":{\"description\":\"Whether the texture should repeat in the X/U direction; when false, out-of-range samples will be clamped to the nearest edge.\",\"default\":true,\"type\":\"boolean\"},\"uScale\":{\"description\":\"Size of the texture in the X/U direction in UV coordinate space; this scaling factor is added after converting the real-world scaling factor into UV space.\",\"default\":{\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"vOffset\":{\"description\":\"Offset of the texture in the Y/V direction in UV coordinate space; this offset is added after converting the real-world offset into UV space.\",\"default\":{\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/scalarNegativeOneToOne\"}]},\"vRepeat\":{\"description\":\"Whether the texture should repeat in the Y/V direction; when false, out-of-range samples will be clamped to the nearest edge.\",\"default\":true,\"type\":\"boolean\"},\"vScale\":{\"description\":\"Size of the texture in the Y/V direction in UV coordinate space; this scaling factor is added after converting the real-world scaling factor into UV space.\",\"default\":{\"value\":1},\"allOf\":[{\"$ref\":\"#/definitions/scalarZeroToInfinity\"}]},\"wAngle\":{\"description\":\"Rotation of the texture about its center.\",\"default\":{\"units\":\"radian\",\"value\":0},\"allOf\":[{\"$ref\":\"#/definitions/angleZeroToTwoPi\"}]}}}}}}");

/***/ }),

/***/ "./node_modules/ajv/lib/ajv.js":
/*!*************************************!*\
  !*** ./node_modules/ajv/lib/ajv.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js")
  , resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js")
  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js")
  , formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js")
  , rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js")
  , $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js")
  , util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}


/***/ }),

/***/ "./node_modules/ajv/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/lib/cache.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/async.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/async.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/error_classes.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/lib/compile/error_classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/formats.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/formats.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");

var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/ajv/node_modules/fast-deep-equal/index.js");

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/resolve.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/resolve.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js")
  , equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/ajv/node_modules/fast-deep-equal/index.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/rules.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/rules.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js")
  , toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/schema_obj.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/schema_obj.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/ucs2length.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/ucs2length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/util.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/compile/util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/ajv/node_modules/fast-deep-equal/index.js"),
  ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}


/***/ }),

/***/ "./node_modules/ajv/lib/data.js":
/*!**************************************!*\
  !*** ./node_modules/ajv/lib/data.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};


/***/ }),

/***/ "./node_modules/ajv/lib/definition_schema.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/definition_schema.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limit.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limit.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitLength.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/allOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/allOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/anyOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/anyOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/comment.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/comment.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/const.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/const.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/contains.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/contains.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/custom.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/custom.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/dependencies.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/dependencies.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/enum.js":
/*!********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/enum.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/format.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/format.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/if.js":
/*!******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/if.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
  allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
  anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
  '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
  const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
  contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
  dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
  'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
  format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
  'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
  items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
  maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
  not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
  oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
  pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
  properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
  propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
  required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
  uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
  validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/items.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/items.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/multipleOf.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/not.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/not.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/oneOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/oneOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/pattern.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/properties.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/properties.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/propertyNames.js":
/*!*****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/ref.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/required.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/required.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/validate.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/validate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/keyword.js":
/*!*****************************************!*\
  !*** ./node_modules/ajv/lib/keyword.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");
var definitionSchema = __webpack_require__(/*! ./definition_schema */ "./node_modules/ajv/lib/definition_schema.js");

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}


/***/ }),

/***/ "./node_modules/ajv/lib/refs/data.json":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/refs/data.json ***!
  \*********************************************/
/*! exports provided: $schema, $id, description, type, required, properties, additionalProperties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON Schema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}");

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \*************************************************************/
/*! exports provided: $schema, $id, title, definitions, type, properties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}");

/***/ }),

/***/ "./node_modules/ajv/node_modules/fast-deep-equal/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/node_modules/fast-deep-equal/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


/***/ }),

/***/ "./src/wgs/render/PrismUtil.js":
/*!*************************************!*\
  !*** ./src/wgs/render/PrismUtil.js ***!
  \*************************************/
/*! exports provided: GetPrismMapUniforms, GetPrismBumpMapUniforms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapUniforms", function() { return GetPrismMapUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismBumpMapUniforms", function() { return GetPrismBumpMapUniforms; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);


// This method sets up various uniforms for a given map, putting them
// in an array called "uniforms" which are accessed by the name, such
// as "uniforms[surface_albedo_map_texMatrix]".
function GetPrismMapUniforms(mapName) {
  var mtxName = mapName + "_texMatrix";
  var mapInvt = mapName + "_invert";

  var uniforms = {};
  uniforms[mapName] = { type: "t", value: null };
  uniforms[mtxName] = { type: "m3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]() };
  uniforms[mapInvt] = { type: "i", value: 0 };

  return uniforms;
}

function GetPrismBumpMapUniforms(mapName) {
  var mtxName = mapName + "_texMatrix";
  var mapScale = mapName + "_bumpScale";
  var mapType = mapName + "_bumpmapType";

  var uniforms = {};
  uniforms[mapName] = { type: "t", value: null };
  uniforms[mtxName] = { type: "m3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]() };
  uniforms[mapScale] = { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1, 1) };
  uniforms[mapType] = { type: "i", value: 0 };

  return uniforms;
}

/***/ }),

/***/ "./src/wgs/render/ShaderChunks.js":
/*!****************************************!*\
  !*** ./src/wgs/render/ShaderChunks.js ***!
  \****************************************/
/*! exports provided: CutPlanesUniforms, IdUniforms, ThemingUniform, ShadowMapCommonUniforms, ShadowMapUniforms, PointSizeUniforms, WideLinesUniforms, DepthTextureUniforms, GetPrismMapSampleChunk, GetPrismMapUniformChunk, resolve, PackDepthShaderChunk, TonemapShaderChunk, OrderedDitheringShaderChunk, CutPlanesShaderChunk, PackNormalsShaderChunk, HatchPatternShaderChunk, EnvSamplingShaderChunk, IdVertexDeclaration, IdVertexShaderChunk, IdFragmentDeclaration, IdOutputShaderChunk, FinalOutputShaderChunk, ThemingFragmentDeclaration, ThemingFragmentShaderChunk, InstancingVertexDeclaration, ShadowMapDeclareCommonUniforms, ShadowMapVertexDeclaration, ShadowMapVertexShaderChunk, ShadowMapFragmentDeclaration, PointSizeDeclaration, PointSizeShaderChunk, ShaderChunks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesUniforms", function() { return CutPlanesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdUniforms", function() { return IdUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingUniform", function() { return ThemingUniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapCommonUniforms", function() { return ShadowMapCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapUniforms", function() { return ShadowMapUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeUniforms", function() { return PointSizeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WideLinesUniforms", function() { return WideLinesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTextureUniforms", function() { return DepthTextureUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapSampleChunk", function() { return GetPrismMapSampleChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapUniformChunk", function() { return GetPrismMapUniformChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackDepthShaderChunk", function() { return PackDepthShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TonemapShaderChunk", function() { return TonemapShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedDitheringShaderChunk", function() { return OrderedDitheringShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesShaderChunk", function() { return CutPlanesShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackNormalsShaderChunk", function() { return PackNormalsShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HatchPatternShaderChunk", function() { return HatchPatternShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnvSamplingShaderChunk", function() { return EnvSamplingShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexDeclaration", function() { return IdVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexShaderChunk", function() { return IdVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdFragmentDeclaration", function() { return IdFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdOutputShaderChunk", function() { return IdOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FinalOutputShaderChunk", function() { return FinalOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentDeclaration", function() { return ThemingFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentShaderChunk", function() { return ThemingFragmentShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancingVertexDeclaration", function() { return InstancingVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapDeclareCommonUniforms", function() { return ShadowMapDeclareCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexDeclaration", function() { return ShadowMapVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexShaderChunk", function() { return ShadowMapVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapFragmentDeclaration", function() { return ShadowMapFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeDeclaration", function() { return PointSizeDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeShaderChunk", function() { return PointSizeShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunks", function() { return ShaderChunks; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/pack_depth.glsl */ "./src/wgs/render/chunks/pack_depth.glsl");
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/depth_texture.glsl */ "./src/wgs/render/chunks/depth_texture.glsl");
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunks/tonemap.glsl */ "./src/wgs/render/chunks/tonemap.glsl");
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/ordered_dither.glsl */ "./src/wgs/render/chunks/ordered_dither.glsl");
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/cutplanes.glsl */ "./src/wgs/render/chunks/cutplanes.glsl");
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunks/pack_normals.glsl */ "./src/wgs/render/chunks/pack_normals.glsl");
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunks/hatch_pattern.glsl */ "./src/wgs/render/chunks/hatch_pattern.glsl");
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunks/env_sample.glsl */ "./src/wgs/render/chunks/env_sample.glsl");
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunks/id_decl_vert.glsl */ "./src/wgs/render/chunks/id_decl_vert.glsl");
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunks/id_vert.glsl */ "./src/wgs/render/chunks/id_vert.glsl");
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunks/id_decl_frag.glsl */ "./src/wgs/render/chunks/id_decl_frag.glsl");
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunks/id_frag.glsl */ "./src/wgs/render/chunks/id_frag.glsl");
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chunks/final_frag.glsl */ "./src/wgs/render/chunks/final_frag.glsl");
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chunks/theming_decl_frag.glsl */ "./src/wgs/render/chunks/theming_decl_frag.glsl");
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chunks/theming_frag.glsl */ "./src/wgs/render/chunks/theming_frag.glsl");
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chunks/instancing_decl_vert.glsl */ "./src/wgs/render/chunks/instancing_decl_vert.glsl");
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chunks/shadowmap_decl_common.glsl */ "./src/wgs/render/chunks/shadowmap_decl_common.glsl");
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./chunks/shadowmap_decl_vert.glsl */ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl");
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./chunks/shadowmap_vert.glsl */ "./src/wgs/render/chunks/shadowmap_vert.glsl");
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./chunks/shadowmap_decl_frag.glsl */ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl");
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./chunks/float3_average.glsl */ "./src/wgs/render/chunks/float3_average.glsl");
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./chunks/line_decl_common.glsl */ "./src/wgs/render/chunks/line_decl_common.glsl");
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./chunks/prism_wood.glsl */ "./src/wgs/render/chunks/prism_wood.glsl");
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./chunks/prism_glazing.glsl */ "./src/wgs/render/chunks/prism_glazing.glsl");
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chunks/prism_transparency.glsl */ "./src/wgs/render/chunks/prism_transparency.glsl");
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./chunks/normal_map.glsl */ "./src/wgs/render/chunks/normal_map.glsl");
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./chunks/decl_point_size.glsl */ "./src/wgs/render/chunks/decl_point_size.glsl");
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./chunks/point_size.glsl */ "./src/wgs/render/chunks/point_size.glsl");
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./chunks/wide_lines_decl.glsl */ "./src/wgs/render/chunks/wide_lines_decl.glsl");
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./chunks/wide_lines_vert.glsl */ "./src/wgs/render/chunks/wide_lines_vert.glsl");
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./chunks/hsv.glsl */ "./src/wgs/render/chunks/hsv.glsl");
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__);
/*
 * Reusable sets of uniforms that can be merged with other uniforms in specific shaders.
 */



var CutPlanesUniforms = {
  "cutplanes": { type: "v4v", value: [] },
  "hatchParams": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1.0, 10.0) },
  "hatchTintColor": { type: "c", value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xFFFFFF) },
  "hatchTintIntensity": { type: "f", value: 1.0 } };


var IdUniforms = {
  "dbId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
  "modelId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) } };


var ThemingUniform = {
  "themingColor": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](0, 0, 0, 0) } };


// Uniforms shared by material shader chunks and ShadowMapShader
// Included by ShadowMapUniforms below.
var ShadowMapCommonUniforms = {
  "shadowESMConstant": { type: "f", value: 0.0 } };


// Uniforms needed by material shaders to apply shadow mapping.
var ShadowMapUniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
{
  "shadowMap": { type: "t", value: null },
  "shadowMapSize": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0, 0) },
  "shadowBias": { type: "f", value: 0.0 },
  "shadowDarkness": { type: "f", value: 0.0 },
  "shadowMatrix": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() },
  "shadowLightDir": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() } },

ShadowMapCommonUniforms]);


// Uniform for point-set point size
var PointSizeUniforms = {
  "point_size": { type: "f", value: 1.0 } };


// Uniform for wide lines shader
var WideLinesUniforms = {
  "view_size": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](640, 480) } };


// Uniforms used for reconstructing positions from depth-texture in post-passes. (depth_texture.glsl)
var DepthTextureUniforms = {
  "tDepth": { type: "t", value: null },
  "projInfo": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]() },
  "isOrtho": { type: "f", value: 0.0 },
  "worldMatrix_mainPass": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() } };


/*
                                                                         * Chunks are code snippets that can be included in specific shaders
                                                                         * using the three.js-style include directive:
                                                                         *
                                                                         *      #include<name_of_chunk>
                                                                         *
                                                                         * During runtime this directive can be expanded into the corresponding
                                                                         * code snippet using the `resolve` method available below.
                                                                         */
var chunks = {};

// We include default three.js chunks, too
for (var name in three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"]) {
  chunks[name] = three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"][name];
}

































chunks['pack_depth'] = _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default.a;
chunks['depth_texture'] = _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default.a;
chunks['tonemap'] = _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default.a;
chunks['ordered_dither'] = _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default.a;
chunks['cutplanes'] = _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default.a;
chunks['pack_normals'] = _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default.a;
chunks['hatch_pattern'] = _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default.a;
chunks['env_sample'] = _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default.a;
chunks['id_decl_vert'] = _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default.a;
chunks['id_vert'] = _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default.a;
chunks['id_decl_frag'] = _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default.a;
chunks['id_frag'] = _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default.a;
chunks['final_frag'] = _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default.a;
chunks['theming_decl_frag'] = _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default.a;
chunks['theming_frag'] = _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default.a;
chunks['instancing_decl_vert'] = _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default.a;
chunks['shadowmap_decl_common'] = _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default.a;
chunks['shadowmap_decl_vert'] = _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default.a;
chunks['shadowmap_vert'] = _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default.a;
chunks['shadowmap_decl_frag'] = _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default.a;
chunks['float3_average'] = _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default.a;
chunks['line_decl_common'] = _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default.a;
chunks['prism_wood'] = _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default.a;
chunks['prism_glazing'] = _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default.a;
chunks['prism_transparency'] = _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default.a;
chunks['normal_map'] = _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default.a;
chunks['decl_point_size'] = _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default.a;
chunks['point_size'] = _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default.a;
chunks['wide_lines_decl'] = _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default.a;
chunks['wide_lines_vert'] = _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default.a;
chunks['hsv'] = _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default.a;

/*
                      * Macros are simple JavaScript functions that can be evaluated from
                      * within the shader code using a similar syntax as the include directive:
                      *
                      *      #name_of_macro<first_param, second_param, third_param, ...>
                      *
                      * All parameters are simply passed to the JavaScript code as strings,
                      * i.e., they are not parsed in any way.
                      *
                      * We use this as a way to call the various Prism helper methods (such as
                      * GetPrismMapsDefinitionChunk below) without having to compose the shader
                      * code from lists of strings.
                      */
var macros = {};

// If any map type is defined, then do whatever "content" is;
// typically it's "#define USE_MAP". In other words, if any map
// is defined, then USE_MAP will also be defined. This constant
// is then checked and determines whether a UV variable is defined, etc.
function GetPrismMapsDefinitionChunk(flag) {
  var def = ["#if defined( USE_SURFACE_ALBEDO_MAP )" +
  " || defined( USE_SURFACE_ROUGHNESS_MAP )" +
  " || defined( USE_SURFACE_CUTOUT_MAP )" +
  " || defined( USE_SURFACE_ANISOTROPY_MAP )" +
  " || defined( USE_SURFACE_ROTATION_MAP )" +
  " || defined( USE_OPAQUE_ALBEDO_MAP )" +
  " || defined( USE_OPAQUE_F0_MAP )" +
  " || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )" +
  " || defined( USE_LAYERED_BOTTOM_F0_MAP )" +
  " || defined( USE_LAYERED_F0_MAP )" +
  " || defined( USE_LAYERED_DIFFUSE_MAP )" +
  " || defined( USE_LAYERED_FRACTION_MAP )" +
  " || defined( USE_LAYERED_ROUGHNESS_MAP )" +
  " || defined( USE_LAYERED_ANISOTROPY_MAP )" +
  " || defined( USE_LAYERED_ROTATION_MAP )" +
  " || defined( USE_METAL_F0_MAP )" +
  " || defined( USE_SURFACE_NORMAL_MAP )" +
  " || defined( USE_LAYERED_NORMAL_MAP )",
  "#define " + flag,
  "#endif"].
  join("\n");
  return def;
}

macros['prism_check'] = GetPrismMapsDefinitionChunk;

// Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.
// If it's not defined, then a simply copy occurs, e.g. "surfaceAlbedo = surface_albedo;" from the variableName and mapType.
function GetPrismMapSampleChunk(mapType, variableName, isFloat, linearize) {
  var suffix = isFloat ? "_v3" : "";
  var declare = isFloat ? "vec3 " : "";
  var average = isFloat ? variableName + " = average(" + variableName + suffix + ");" : "";
  var colorLinearization = linearize ? variableName + suffix + " = SRGBToLinear(" + variableName + suffix + ");" : "";
  var shader = [
  "#if defined( USE_" + mapType.toUpperCase() + "_MAP )",
  // note: the tiling system needs to modify the uv of the texture per tile, so we use the modified "uv" here, not vUv.
  "vec2 uv_" + mapType + "_map = (" + mapType + "_map_texMatrix * vec3(uv, 1.0)).xy;",
  mapType.toUpperCase() + "_CLAMP_TEST;",
  declare + variableName + suffix + " = texture2D(" + mapType + "_map, uv_" + mapType + "_map).xyz;",
  colorLinearization,
  "if(" + mapType + "_map_invert) " + variableName + suffix + " = vec3(1.0) - " + variableName + suffix + ";",
  average,
  "#else",
  variableName + " = " + mapType + ";",
  "#endif"].
  join("\n");

  return shader;
}

macros['prism_sample_texture'] = function (mapType, varName, isFloat, linearize) {
  return GetPrismMapSampleChunk(mapType, varName, isFloat === 'true', linearize === 'true');
};

function GetPrismMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapInvt = mapName + "_invert";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform bool " + mapInvt + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_uniforms'] = GetPrismMapUniformChunk;

function GetPrismBumpMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapScale = mapName + "_bumpScale";
  var mapType = mapName + "_bumpmapType";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform vec2 " + mapScale + ";",
  "uniform int " + mapType + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_bump_uniforms'] = GetPrismBumpMapUniformChunk;

// Precompile regexes for the macros
var _regExCache = {};
for (name in macros) {
  _regExCache[name] = new RegExp('#' + name + ' *<([\\w\\d., ]*)>', 'g');
}

/**
   * Recursively resolves include directives and macros.
   * @param {string} source Original shader code.
   * @returns {string} Shader code with all includes resolved.
   */
var resolve = function resolve(source) {
  for (var name in macros) {
    var re = _regExCache[name];
    source = source.replace(re, function (match, parens) {
      var params = parens.split(',').map(function (param) {return param.trim();});
      return macros[name].apply(null, params);
    });
  }

  var pattern = /#include *<([\w\d.]+)>/g;
  var func = function func(match, include) {
    if (!chunks[include]) {
      throw new Error('Cannot resolve #include<' + include + '>');
    }
    return resolve(chunks[include]);
  };
  return source.replace(pattern, func);
};

// The chunks don't have to be exported anymore, but we keep them
// for backwards compatibility (they're still referenced in LegacyNamespace.js)
var PackDepthShaderChunk = chunks['pack_depth'];
var TonemapShaderChunk = chunks['tonemap'];
var OrderedDitheringShaderChunk = chunks['ordered_dither'];
var CutPlanesShaderChunk = chunks['cutplanes'];
var PackNormalsShaderChunk = chunks['pack_normals'];
var HatchPatternShaderChunk = chunks['hatch_pattern'];
var EnvSamplingShaderChunk = chunks['env_sample'];
var IdVertexDeclaration = chunks['id_decl_vert'];
var IdVertexShaderChunk = chunks['id_vert'];
var IdFragmentDeclaration = chunks['id_decl_frag'];
var IdOutputShaderChunk = chunks['id_frag'];
var FinalOutputShaderChunk = chunks['final_frag'];
var ThemingFragmentDeclaration = chunks['theming_decl_frag'];
var ThemingFragmentShaderChunk = chunks['theming_frag'];
var InstancingVertexDeclaration = chunks['instancing_decl_vert'];
var ShadowMapDeclareCommonUniforms = chunks['shadowmap_decl_common'];
var ShadowMapVertexDeclaration = chunks['shadowmap_decl_vert'];
var ShadowMapVertexShaderChunk = chunks['shadowmap_vert'];
var ShadowMapFragmentDeclaration = chunks['shadowmap_decl_frag'];
var PointSizeDeclaration = chunks['decl_point_size'];
var PointSizeShaderChunk = chunks['point_size'];

var ShaderChunks = {
  IdUniforms: IdUniforms,
  ThemingUniform: ThemingUniform,
  CutPlanesUniforms: CutPlanesUniforms,
  ShadowMapCommonUniforms: ShadowMapCommonUniforms,
  ShadowMapUniforms: ShadowMapUniforms,
  PointSizeUniforms: PointSizeUniforms,
  WideLinesUniforms: WideLinesUniforms,
  DepthTextureUniforms: DepthTextureUniforms,

  PackDepthShaderChunk: PackDepthShaderChunk,
  TonemapShaderChunk: TonemapShaderChunk,
  OrderedDitheringShaderChunk: OrderedDitheringShaderChunk,
  CutPlanesShaderChunk: CutPlanesShaderChunk,
  PackNormalsShaderChunk: PackNormalsShaderChunk,
  HatchPatternShaderChunk: HatchPatternShaderChunk,
  EnvSamplingShaderChunk: EnvSamplingShaderChunk,
  IdVertexDeclaration: IdVertexDeclaration,
  IdVertexShaderChunk: IdVertexShaderChunk,
  IdFragmentDeclaration: IdFragmentDeclaration,
  IdOutputShaderChunk: IdOutputShaderChunk,
  FinalOutputShaderChunk: FinalOutputShaderChunk,
  ThemingFragmentDeclaration: ThemingFragmentDeclaration,
  ThemingFragmentShaderChunk: ThemingFragmentShaderChunk,
  InstancingVertexDeclaration: InstancingVertexDeclaration,
  ShadowMapDeclareCommonUniforms: ShadowMapDeclareCommonUniforms,
  ShadowMapVertexDeclaration: ShadowMapVertexDeclaration,
  ShadowMapVertexShaderChunk: ShadowMapVertexShaderChunk,
  ShadowMapFragmentDeclaration: ShadowMapFragmentDeclaration,
  PointSizeDeclaration: PointSizeDeclaration,
  PointSizeShaderChunk: PointSizeShaderChunk,

  GetPrismMapSampleChunk: GetPrismMapSampleChunk,
  GetPrismMapUniformChunk: GetPrismMapUniformChunk,

  resolve: resolve };

/***/ }),

/***/ "./src/wgs/render/chunks/cutplanes.glsl":
/*!**********************************************!*\
  !*** ./src/wgs/render/chunks/cutplanes.glsl ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/decl_point_size.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/decl_point_size.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform float point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/depth_texture.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/depth_texture.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/env_sample.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/env_sample.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/final_frag.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/final_frag.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#ifdef MRT_NORMALS\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n";

/***/ }),

/***/ "./src/wgs/render/chunks/float3_average.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/float3_average.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/hatch_pattern.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/hatch_pattern.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/hsv.glsl":
/*!****************************************!*\
  !*** ./src/wgs/render/chunks/hsv.glsl ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 rgb2hsv(vec3 color)\n{\n    float delta;\n    float colorMax, colorMin;\n    float h,s,v;\n    vec3 hsv;\n    colorMax = max(color.r,color.g);\n    colorMax = max(colorMax,color.b);\n    colorMin = min(color.r,color.g);\n    colorMin = min(colorMin,color.b);\n    v = colorMax;\n    if(colorMax != 0.0)\n    {\n        s = (colorMax - colorMin)/colorMax;\n    }\n    else\n    {\n        s = 0.0;\n    }\n    if(s != 0.0)\n    {\n        delta = colorMax-colorMin;\n        if (color.r == colorMax)\n        {\n            h = (color.g-color.b)/delta;\n        }\n        else if (color.g == colorMax)\n        {\n            h = 2.0 + (color.b-color.r) / delta;\n        }\n        else\n        {\n            h = 4.0 + (color.r-color.g)/delta;\n        }\n        h /= 6.0;\n        if( h < 0.0)\n        {\n            h +=1.0;\n        }\n    }\n    else\n    {\n        h = 0.0;\n    }\n    hsv = vec3(h,s,v);\n    return hsv;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 color;\n    float f,p,q,t;\n    float h,s,v;\n    float i,hi;\n    {\n        h = hsv.x*6.0;\n        s = hsv.y;\n        v = hsv.z;\n        i = floor(h);\n        f = h-i;\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n        float r,g,b;\n        if (i == 0.0)\n        {\n            r = v;\n            g = t;\n            b = p;\n        }\n        else if (i == 1.0)\n        {\n            r = q;\n            g = v;\n            b = p;\n        }\n        else if (i == 2.0)\n        {\n            r = p;\n            g = v;\n            b = t;\n        }\n        else if (i == 3.0)\n        {\n            r = p;\n            g = q;\n            b = v;\n        }\n        else if (i == 4.0)\n        {\n            r = t;\n            g = p;\n            b = v;\n        }\n        else\n        {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r,g,b);\n    }\n    return color;\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\n    varying highp float depth;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n    #ifdef USE_VERTEX_ID\n        varying vec3 vId;\n    #elif defined(LINE_2D_SHADER)\n        varying vec4 dbId;\n    #else\n        uniform vec3 dbId;\n    #endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\n    uniform vec3 modelId;\n#endif\n#ifdef _LMVWEBGL2_\n    #if defined(MRT_NORMALS)\n        layout(location = 1) out vec4 outNormal;\n        #if defined(MRT_ID_BUFFER)\n            layout(location = 2) out vec4 outId;\n            #if defined(MODEL_COLOR)\n                layout(location = 3) out vec4 outModelId;\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        layout(location = 1) out vec4 outId;\n        #if defined(MODEL_COLOR)\n            layout(location = 2) out vec4 outModelId;\n        #endif\n    #endif\n#else\n    #define gl_FragColor gl_FragData[0]\n    #if defined(MRT_NORMALS)\n        #define outNormal gl_FragData[1]\n        #if defined(MRT_ID_BUFFER)\n            #define outId gl_FragData[2]\n            #if defined(MODEL_COLOR)\n                #define outModelId gl_FragData[3]\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        #define outId gl_FragData[1]\n        #if defined(MODEL_COLOR)\n            #define outModelId gl_FragData[2]\n        #endif\n    #endif\n#endif";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_vert.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_vert.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_frag.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_frag.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\n    vec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n    #ifndef ENABLE_ID_DISCARD\n        const float writeId = 1.0;\n    #endif\n    outId = vec4(dbId.rgb, writeId);\n    #ifdef MODEL_COLOR\n        outModelId = vec4(modelId.rgb, writeId);\n    #endif\n#elif defined(ID_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_vert.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_vert.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/instancing_decl_vert.glsl":
/*!*********************************************************!*\
  !*** ./src/wgs/render/chunks/instancing_decl_vert.glsl ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/line_decl_common.glsl":
/*!*****************************************************!*\
  !*** ./src/wgs/render/chunks/line_decl_common.glsl ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define LINE_2D_SHADER 1\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\n#define LTSCALE 0.25\nvarying vec4 fsColor;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n#ifdef LOADING_ANIMATION\nvarying float loadingProgress;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/normal_map.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/normal_map.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\nvoid heightMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    N = normalize(\n        N + (\n            diff.x * T * bumpScale.x +\n            diff.y * B * bumpScale.y\n        )\n    );\n}\nvoid normalMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\n    mapN.xy *= bumpScale.x;\n    mapN.z *= bumpScale.y;\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n    float c = -mapN.z;\n    mat3 skewV = mat3(\n        0.0, v.z, -v.y,\n        -v.z, 0.0, v.x,\n        v.y, -v.x, 0.0\n    );\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\n    N *= rot;\n    T *= rot;\n    B *= rot;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/ordered_dither.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/ordered_dither.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_depth.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/pack_depth.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_normals.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/pack_normals.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/point_size.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/point_size.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_PointSize = point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_glazing.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/prism_glazing.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \n{ \n   vec3 limit = max(1.0 - f0, 0.00001); \n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \n} \nfloat ColorToIlluminance(in vec3 color) \n{ \n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \n   float illuminance = dot(rgb2grey, color); \n   return illuminance; \n} \nvoid applyPrismGlazingOpacity(\n    inout vec4 color,\n    vec3 transmissionF,\n    float transmissionAlpha,\n    float NdotV,\n    float glazingIlluminace) \n{\n    const float third = 1.0/3.0; \n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \n    opacity = clamp(opacity, 0.01, 0.99);\n    color.a *= opacity;\n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_transparency.glsl":
/*!*******************************************************!*\
  !*** ./src/wgs/render/chunks/prism_transparency.glsl ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "void applyPrismTransparency(\n    inout vec4 color,\n    vec3 transparentColor,\n    float transparentIor\n) {\n    float fsLevel = max(max(color.r, color.g), color.b);\n    color = vec4(color.rgb/fsLevel, fsLevel);\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\n    transLevel = min( (1.0 - surface_roughness), transLevel );\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\n    vec3 tr_g_color = sqrt(transparentColor);\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\n    color = mix(transColor, color, strength);\n    color.a = max(color.a, 0.05);\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\n        color.a = 0.0;\n    }\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_wood.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/prism_wood.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined( PRISMWOOD )\n#define ONE 0.00390625\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    return clamp(transPixels * 0.5, 0.0, 1.0);\n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\n                              float depthVar)\n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\n    return clamp(porePixels, 0.0, 1.0);\n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\n                          float depthVar)\n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{\n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#if defined(PRISMWOODBUMP)\nvoid getFinalWoodContext(\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\n) {\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n}\n#endif\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_common.glsl":
/*!**********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_common.glsl ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_frag.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_vert.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_vert.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_vert.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_decl_frag.glsl":
/*!******************************************************!*\
  !*** ./src/wgs/render/chunks/theming_decl_frag.glsl ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform vec4 themingColor;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/theming_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n";

/***/ }),

/***/ "./src/wgs/render/chunks/tonemap.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/tonemap.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_decl.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_decl.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_vert.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_vert.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n";

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=StandardSurface.js.map