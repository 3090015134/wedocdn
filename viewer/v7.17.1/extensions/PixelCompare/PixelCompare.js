/*!
 * LMV v7.17.1
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.PixelCompare =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/PixelCompare/PixelCompare.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/PixelCompare/PixelCompare.js":
/*!*************************************************!*\
  !*** ./extensions/PixelCompare/PixelCompare.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PixelCompare; });
/* harmony import */ var _src_wgs_render_ShaderPass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/wgs/render/ShaderPass */ "./src/wgs/render/ShaderPass.js");
/* harmony import */ var _shaders_DiffShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/DiffShader */ "./extensions/PixelCompare/shaders/DiffShader.js");
/* harmony import */ var _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PixelCompareConstants */ "./extensions/PixelCompare/PixelCompareConstants.js");
/* harmony import */ var _PixelCompareTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PixelCompareTool */ "./extensions/PixelCompare/PixelCompareTool.js");
/* harmony import */ var _PixelCompareUI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PixelCompareUI */ "./extensions/PixelCompare/PixelCompareUI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}



var

PixelCompare = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(PixelCompare, _Autodesk$Viewing$Ext);
  function PixelCompare(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PixelCompare);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PixelCompare).call(this, viewer, options));
    _this.viewer = viewer;
    _this.options = options;

    _this.mainModel = null;
    _this.secondaryModel = null;

    _this.secondaryRenderContext = null;
    _this.virtualCamera;
    _this.mainModelVisibilityBackup = false; // Save the visibility state of the main model.
    _this.secondaryModelVisibilityBackup = false; // Save the visibility state of the secondary model.

    _this.splitPosition = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DEFAULTS"].SPLIT_LINE_POSITION;
    _this.splitLineWidth = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DEFAULTS"].SPLIT_LINE_WIDTH;
    _this.splitLineColor = new THREE.Color(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DEFAULTS"].SPLIT_LINE_COLOR);
    _this.duration = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DEFAULTS"].ANIMATION_DURATION;
    _this.transitionVal = 0.0;

    _this.changeOffsetMode = false;

    _this.diffMode = options.diffMode;
    _this.defaultDiffMode = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DEFAULTS"].DEFAULT_DIFF_MODE;
    _this.colorIntensity = 1.0;
    _this.modelHiddenMap = {}; // Used for toggle model visibility.

    _this.tool = new _PixelCompareTool__WEBPACK_IMPORTED_MODULE_3__["default"](_assertThisInitialized(_this));

    if (!_this.viewer.config.headlessViewer) {
      _this.compareUI = new _PixelCompareUI__WEBPACK_IMPORTED_MODULE_4__["default"](_assertThisInitialized(_this));
    }

    _this.diffPass = new _src_wgs_render_ShaderPass__WEBPACK_IMPORTED_MODULE_0__["ShaderPass"](_shaders_DiffShader__WEBPACK_IMPORTED_MODULE_1__["DiffShader"]);
    _this.renderer = _this.viewer.impl.renderer();
    _this.pixelRatio = _this.viewer.impl.glrenderer().getPixelRatio();

    _this.frustum = new Autodesk.Viewing.Private.FrustumIntersector();

    _this.renderSecondaryModelBinded = _this.renderSecondaryModel.bind(_assertThisInitialized(_this));
    _this.initDiffBinded = _this.initDiff.bind(_assertThisInitialized(_this));
    _this.onResizeBinded = _this.onResize.bind(_assertThisInitialized(_this));return _this;
  }

  /**
     * @private
    */_createClass(PixelCompare, [{ key: "getModel", value: function getModel(
    model) {
      return typeof model === 'number' ? this.viewer.impl.findModel(model, true) : model;
    }

    /**
       * Compare two models.
       * @param {Autodesk.Viewing.Model|number} mainModel - Main model instance or id.
       * @param {Autodesk.Viewing.Model|number} secondaryModel - Secondary model instance or id.
       * @param {Object} mainModelInfo - Main model info. Info can contain 'title', 'version', 'creationTime' & 'creator'.
       * @param {Object} secondaryModelInfo - Secondary model info. Info can contain 'title', 'version', 'creationTime' & 'creator'.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#compareTwoModels
      */ }, { key: "compareTwoModels", value: function compareTwoModels(
    mainModel, secondaryModel) {var _this2 = this;var mainModelInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var secondaryModelInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      // If already comparing these two models, don't do anything.
      if (this.getModel(mainModel) === this.mainModel && this.getModel(secondaryModel) === this.secondaryModel) {
        return;
      }

      var promise = this.isActive() ? this.deactivate() : Promise.resolve();

      promise.then(function () {
        _this2.mainModel = _this2.getModel(mainModel);
        _this2.secondaryModel = _this2.getModel(secondaryModel);

        _this2.mainModelInfo = mainModelInfo;
        _this2.secondaryModelInfo = secondaryModelInfo;

        _this2.activate();
      });
    }

    /**
       * @private
      */ }, { key: "activate", value: function activate()
    {
      if (!this.mainModel || !this.secondaryModel) {
        console.warn('Pixel Compare requires two models. Use compareTwoModels and supply the models.');
        return false;
      }

      if (!this.isActive()) {
        this.initDiff();
        this.viewer.toolController.registerTool(this.tool);
        this.viewer.toolController.activateTool(this.tool.getName());
        return true;
      }
    }

    /**
       * Deactivate the comparison.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#deactivate
      */ }, { key: "deactivate", value: function deactivate()
    {var _this3 = this;
      return new Promise(function (resolve) {
        _this3.exitPreviousDiffMode(function () {
          _this3.activeStatus = false;
          _this3.diffMode = null;
          _this3.virtualCamera = null;

          if (!_this3.mainModelVisibilityBackup) {
            _this3.viewer.hideModel(_this3.mainModel);
          }

          if (_this3.secondaryModelVisibilityBackup) {
            _this3.viewer.showModel(_this3.secondaryModel);
          }

          _this3.viewer.toolController.deregisterTool(_this3.tool);

          _this3.viewer.removeEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, _this3.renderSecondaryModelBinded);
          _this3.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, _this3.onResizeBinded);

          if (_this3.clearColorTopBackup && _this3.clearColorBottomBackup) {
            _this3.viewer.setBackgroundColor(
            _this3.clearColorTopBackup.x, _this3.clearColorTopBackup.y, _this3.clearColorTopBackup.z,
            _this3.clearColorBottomBackup.x, _this3.clearColorBottomBackup.y, _this3.clearColorBottomBackup.z);

          }

          _this3.viewer.impl.toggleSwapBlackAndWhite(_this3.swapBlackAndWhiteBackup);

          _this3.cleanRenderContext();
          _this3.viewer.impl.invalidate(true);

          if (_this3.compareUI) {
            _this3.compareUI.destroyUI();
          }

          _this3.mainModel = null;
          _this3.secondaryModel = null;

          _this3.mainModelInfo = null;
          _this3.secondaryModelInfo = null;

          _this3.modelHiddenMap = {};

          _this3.viewer.dispatchEvent({ type: _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["EVENTS"].DIFF_TOOL_DEACTIVATED }),

          resolve();
        });
      });
    }

    /**
       * @private
      */ }, { key: "isModelVisible", value: function isModelVisible(
    model) {
      return !!this.viewer.impl.findModel(model.id);
    }

    /**
       * @private
      */ }, { key: "initDiff", value: function initDiff()
    {
      if (this.viewer.impl.modelQueue().getModels().concat(this.viewer.impl.modelQueue().getHiddenModels()).some(function (model) {return !model.isLoadDone();})) {
        this.viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, this.initDiffBinded, { once: true });
      } else {
        this.activeStatus = true;

        this.mainModelVisibilityBackup = this.isModelVisible(this.mainModel);
        this.secondaryModelVisibilityBackup = this.isModelVisible(this.secondaryModel);

        if (!this.mainModelVisibilityBackup) {
          this.viewer.showModel(this.mainModel); // Main model has to be visible when activating diff.
        }

        if (this.secondaryModelVisibilityBackup) {
          this.viewer.hideModel(this.secondaryModel); // Secondary model has to be hidden during diff.
        }

        this.clearColorTopBackup = this.viewer.impl.clearColorTop.clone().multiplyScalar(255);
        this.clearColorBottomBackup = this.viewer.impl.clearColorBottom.clone().multiplyScalar(255);

        // If one of the models has no background, we have to give it a white background - otherwise the diff will fail.
        if (this.mainModel.getMetadata('page_dimensions', 'hide_paper') || this.secondaryModel.getMetadata('page_dimensions', 'hide_paper')) {
          this.viewer.setBackgroundColor(255, 255, 255, 255, 255, 255);
        }

        this.initVirtualCamera();
        this.setDiffMode(this.diffMode || this.defaultDiffMode);

        this.swapBlackAndWhiteBackup = this.viewer.impl.swapBlackAndWhite;
        this.viewer.impl.toggleSwapBlackAndWhite(false);

        if (this.compareUI) {
          this.compareUI.createUI();
        }

        this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, this.renderSecondaryModelBinded);
        this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
      }
    }

    /**
       * @private
      */ }, { key: "renderDiff", value: function renderDiff()
    {
      var resolution = {
        x: 1 / (this.viewer.canvas.clientWidth * this.pixelRatio),
        y: 1 / (this.viewer.canvas.clientHeight * this.pixelRatio) };


      this.diffPass.uniforms['texture1'].value = this.renderer.getColorTarget();
      this.diffPass.uniforms['diffMode'].value = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DIFF_MODES_SHADER"][this.diffMode];
      this.diffPass.uniforms['splitPosition'].value = this.splitPosition;
      this.diffPass.uniforms['splitLineWidth'].value = this.splitLineWidth / this.viewer.getCamera().clientWidth;
      this.diffPass.uniforms['splitLineColor'].value = this.splitLineColor;
      this.diffPass.uniforms['t'].value = this.transitionVal;
      this.diffPass.uniforms['resolution'].value = resolution;
      this.diffPass.uniforms['colorIntensity'].value = this.colorIntensity;
      this.diffPass.uniforms['mainModelHidden'].value = this.modelHiddenMap[0];
      this.diffPass.uniforms['secondaryModelHidden'].value = this.modelHiddenMap[1];

      if (this.modelHiddenMap[1]) {
        this.diffPass.uniforms['visibleModelBounds'].value = this.getModelNormalizedProjectedBounds(this.mainModel, this.viewer.getCamera());
      } else if (this.modelHiddenMap[0]) {
        this.diffPass.uniforms['visibleModelBounds'].value = this.getModelNormalizedProjectedBounds(this.secondaryModel, this.virtualCamera);
      }

      this.renderer.presentBuffer(this.diffPass);
    }

    /**
       * @private
      */ }, { key: "hideAllModels", value: function hideAllModels()
    {var _this4 = this;
      var models = this.viewer.getVisibleModels();
      models.forEach(function (model) {
        _this4.viewer.hideModel(model.id);
      });
    }

    /**
       *  Needed when size of the canvas is changing.
       * @private
      */ }, { key: "cleanRenderContext", value: function cleanRenderContext()
    {
      this.secondaryRenderContext && this.secondaryRenderContext.cleanup();
      this.secondaryRenderContext = null;
    }

    /**
       * @private
      */ }, { key: "getModelTrimmedBounds", value: function getModelTrimmedBounds(
    model) {
      var bounds = model.getVisibleBounds();

      if (model.hasPageShadow()) {
        // Remove the shadow of F2D - This constant shadow size comes from LMV -> F2D.prototype.initSheet
        bounds = bounds.clone();
        var pageWidth = model.getMetadata('page_dimensions', 'page_width');
        bounds.max.x -= pageWidth * 0.0075;
        bounds.min.y += pageWidth * 0.0075;
      }

      return bounds;
    }

    /**
       * @private
      */ }, { key: "getModelNormalizedProjectedBounds", value: function getModelNormalizedProjectedBounds(
    model, camera) {
      var bounds = this.getModelTrimmedBounds(model);

      var min = this.worldToClient(bounds.min, camera);
      var max = this.worldToClient(bounds.max, camera);

      return new THREE.Vector4(min.x, min.y, max.x, max.y);
    }

    /**
       * @private
      */ }, { key: "worldToClient", value: function worldToClient(
    point, camera) {
      var p = point.clone().project(camera);
      return new THREE.Vector3((p.x + 1) / 2, (p.y + 1) / 2, 0);
    }

    /**
       * @private
      */ }, { key: "onResize", value: function onResize()
    {
      if (this.virtualCamera) {
        var mainCamera = this.viewer.getCamera();
        this.virtualCamera.aspect = mainCamera.aspect;
        this.virtualCamera.clientWidth = mainCamera.clientWidth;
        this.virtualCamera.clientHeight = mainCamera.clientHeight;
        this.virtualCamera.updateCameraMatrices();
      }

      this.cleanRenderContext();
    }

    /**
       * @private
      */ }, { key: "initVirtualCamera", value: function initVirtualCamera()
    {
      var mainBounds = this.getModelTrimmedBounds(this.mainModel);
      var secondaryBounds = this.getModelTrimmedBounds(this.secondaryModel);

      var mainFittedCamera = Autodesk.Viewing.ScreenShot.getCameraWithFitBounds(this.viewer, mainBounds);
      this.virtualCamera = Autodesk.Viewing.ScreenShot.getCameraWithFitBounds(this.viewer, secondaryBounds);

      this.virtualCamera.scaleZ = this.virtualCamera.position.z / mainFittedCamera.position.z;

      var offset = new THREE.Vector3(secondaryBounds.size().x / 2, secondaryBounds.size().y / 2, 0);

      // Special treatment for Leaflet coordinates.
      if (this.mainModel.getData().isLeaflet && this.secondaryModel.getData().isLeaflet) {
        offset.y = -offset.y;
      } else if (this.mainModel.getData().isLeaflet && !this.secondaryModel.getData().isLeaflet) {
        offset.y -= 1 - mainBounds.size().y;
      }

      this.virtualCamera.position.sub(offset);
      this.virtualCamera.target.sub(offset);
      this.virtualCamera.lastX = this.virtualCamera.position.x;
      this.virtualCamera.lastY = this.virtualCamera.position.y;
    }

    /**
       * @private
      */ }, { key: "updateVirtualCamera", value: function updateVirtualCamera()
    {
      var mainViewerCamera = this.viewer.getCamera();

      var noZoomChange = Math.abs(this.virtualCamera.lastZoom - mainViewerCamera.position.z) < 0.001;

      if (this.changeOffsetMode && noZoomChange) {
        this.virtualCamera.lastX = mainViewerCamera.position.x;
        this.virtualCamera.lastY = mainViewerCamera.position.y;
      }

      var deltaX = (mainViewerCamera.position.x - this.virtualCamera.lastX) * this.virtualCamera.scaleZ;
      var deltaY = (mainViewerCamera.position.y - this.virtualCamera.lastY) * this.virtualCamera.scaleZ;

      var newPosition = new THREE.Vector3(this.virtualCamera.position.x + deltaX, this.virtualCamera.position.y + deltaY, mainViewerCamera.position.z * this.virtualCamera.scaleZ);
      var newTarget = new THREE.Vector3(this.virtualCamera.target.x + deltaX, this.virtualCamera.target.y + deltaY, this.virtualCamera.target.z);

      this.virtualCamera.position.copy(newPosition);
      this.virtualCamera.target.copy(newTarget);
      this.virtualCamera.up.copy(this.viewer.getCamera().up);
      this.virtualCamera.updateCameraMatrices();

      var bounds = this.secondaryModel.getVisibleBounds();
      this.viewer.impl.updateNearFarValues(this.virtualCamera, bounds);

      this.virtualCamera.lastX = mainViewerCamera.position.x;
      this.virtualCamera.lastY = mainViewerCamera.position.y;
      this.virtualCamera.lastZoom = mainViewerCamera.position.z;
    }

    /**
       * @private
      */ }, { key: "renderSecondaryModel", value: function renderSecondaryModel()
    {var _this5 = this;
      var canvasBounds = this.viewer.impl.getCanvasBoundingClientRect();
      var width = canvasBounds.width * this.pixelRatio;
      var height = canvasBounds.height * this.pixelRatio;

      var onFinished = function onFinished(ctx, target) {
        _this5.diffPass.uniforms['texture2'].value = target;
        _this5.secondaryRenderContext = ctx;
        _this5.renderDiff();
      };

      this.updateVirtualCamera();

      var options = {
        returnAsTarget: true,
        models: [this.secondaryModel],
        renderContext: this.secondaryRenderContext,
        camera: this.virtualCamera,
        dontWaitForLeafletTiles: true };


      // In case that the secondary model is leaflet - we do want that the diff will be rendered even if
      // The tiles are not fully refined. This is why we use `dontWaitForLeafletTiles`.
      // However, in order for them to get refined eventually, we need to call invalidate, so even if the main model
      // is fully loaded, the secondary model will continue loading.
      if (this.secondaryModel.getData().isLeaflet) {
        this.frustum.reset(this.virtualCamera);

        if (!this.secondaryModel.getIterator().reset(this.frustum, this.virtualCamera)) {
          this.viewer.impl.invalidate(true);
        }
      }

      Autodesk.Viewing.ScreenShot.getScreenShot(width, height, onFinished, options, this.viewer.impl);
    }

    /**
       * Change split line position.
       * @param {number} value - Value between 0 to 1.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#setSplitPosition
      */ }, { key: "setSplitPosition", value: function setSplitPosition(
    value) {
      this.splitPosition = value;
      this.renderDiff();
    }

    /**
       * Get split line position.
       * @returns {number}
       * @alias Autodesk.Viewing.Extensions.PixelCompare#getSplitPosition
      */ }, { key: "getSplitPosition", value: function getSplitPosition()
    {
      return this.splitPosition;
    }

    /**
       * Change diff mode. Options are split mode & color mode.
       * @param {number} value - Autodesk.PixelCompare.DIFF_MODES.OVERLAY | Autodesk.PixelCompare.DIFF_MODES.SIDE_BY_SIDE
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#setDiffMode
      */ }, { key: "setDiffMode", value: function setDiffMode(
    value) {var _this6 = this;
      if (!this.isActive()) {
        console.warn('Pixel Compare is not active.');
        return;
      }

      if (this.diffMode === value && this.transitionVal !== 0) {
        return;
      }

      this.exitPreviousDiffMode(function () {
        _this6.enterNewDiffMode(value);
      });
    }

    /**
       * @private
      */ }, { key: "exitPreviousDiffMode", value: function exitPreviousDiffMode(
    cb, immediate) {var _this7 = this;
      if (immediate || this.diffMode === null || this.diffMode === undefined) {
        this.transitionVal = 0.0;
        cb();
      } else {
        Autodesk.Viewing.Private.fadeValue(this.transitionVal, 0.0, this.duration, function (value) {
          _this7.transitionVal = value;
          _this7.renderDiff();
        }, cb);
      }
    }

    /**
       * @private
      */ }, { key: "enterNewDiffMode", value: function enterNewDiffMode(
    diffMode, immediate) {var _this8 = this;
      this.diffMode = diffMode;

      this.viewer.dispatchEvent({
        type: _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["EVENTS"].DIFF_TOOL_DIFF_MODE_CHANGED,
        newDiffMode: this.diffMode });


      if (immediate) {
        this.transitionVal = 1.0;
        this.renderDiff();
      }

      // Don't allow hiding models on side by side mode.
      if (diffMode === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DIFF_MODES"].SIDE_BY_SIDE) {
        this.changeMainModelVisibility(true);
        this.changeSecondaryModelVisibility(true);
      }

      Autodesk.Viewing.Private.fadeValue(this.transitionVal, 1.0, this.duration, function (value) {
        _this8.transitionVal = value;
        _this8.renderDiff();
      });
    }

    /**
       * Get diff mode.
       * @returns {number}
       * @alias Autodesk.Viewing.Extensions.PixelCompare#getDiffMode
      */ }, { key: "getDiffMode", value: function getDiffMode()
    {
      return this.diffMode;
    }

    /**
       * Change split line width.
       * @param {number} value - width in pixels.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#setSplitLineWidth
      */ }, { key: "setSplitLineWidth", value: function setSplitLineWidth(
    value) {
      this.splitLineWidth = value;
      this.renderDiff();
    }

    /**
       * Change split line color.
       * @param {number} value - color in hex.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#setSplitLineColor
      */ }, { key: "setSplitLineColor", value: function setSplitLineColor(
    value) {
      this.splitLineColor = new THREE.Color(value);
      this.renderDiff();
    }

    /**
       * Enable / Disable offfset mode.
       * @param {boolean} value - enable / disable.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#setChangeOffsetMode
      */ }, { key: "setChangeOffsetMode", value: function setChangeOffsetMode(
    enable) {
      this.changeOffsetMode = enable;
    }

    /**
       * Reset offset to initial position.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#resetOffset
      */ }, { key: "resetOffset", value: function resetOffset()
    {
      this.initVirtualCamera();
    }

    /**
       * Change color intensity value of overlay mode.
       * @param {number} value - number between 0 to 1.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#changeColorIntensity
      */ }, { key: "changeColorIntensity", value: function changeColorIntensity(
    value) {
      this.colorIntensity = value;
      this.renderDiff();
    }

    /**
       * @private
      */ }, { key: "changeModelVisibility", value: function changeModelVisibility(
    index, visible) {
      // Don't allow hiding models on side by side mode.
      if (!visible && this.getDiffMode() === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DIFF_MODES"].SIDE_BY_SIDE) {
        return;
      }

      this.modelHiddenMap[index] = !visible;

      // Make sure at least one model stays visible.
      if (!visible && this.modelHiddenMap[1 - index]) {
        this.changeModelVisibility(1 - index, true);
      }

      this.viewer.dispatchEvent({
        type: _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["EVENTS"].DIFF_TOOL_MODEL_VISIBILITY_CHANGED });


      this.renderDiff();
    }

    /**
       * Show / Hide main model inside diff mode.
       * @param {boolean} value - visible / invisible.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#changeMainModelVisibility
      */ }, { key: "changeMainModelVisibility", value: function changeMainModelVisibility(
    visible) {
      this.changeModelVisibility(0, visible);
    }

    /**
       * Show / Hide secondary model inside diff mode.
       * @param {boolean} value - visible / invisible.
       * 
       * @alias Autodesk.Viewing.Extensions.PixelCompare#changeSecondaryModelVisibility
      */ }, { key: "changeSecondaryModelVisibility", value: function changeSecondaryModelVisibility(
    visible) {
      this.changeModelVisibility(1, visible);
    }

    /**
       * Get main model visibility.
       * @returns {boolean}
       * @alias Autodesk.Viewing.Extensions.PixelCompare#getMainModelVisibility
      */ }, { key: "getMainModelVisibility", value: function getMainModelVisibility()
    {
      return !this.modelHiddenMap[0];
    }

    /**
       * Get secondary model visibility.
       * @returns {boolean}
       * @alias Autodesk.Viewing.Extensions.PixelCompare#getMainModelVisibility
      */ }, { key: "getSecondaryModelVisibility", value: function getSecondaryModelVisibility()
    {
      return !this.modelHiddenMap[1];
    } }]);return PixelCompare;}(Autodesk.Viewing.Extension);


var namespace = AutodeskNamespace('Autodesk.Viewing.PixelCompare');
namespace.DIFF_MODES = Object.assign({}, _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["DIFF_MODES"]);
namespace.EVENTS = Object.assign({}, _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_2__["EVENTS"]);

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.PixelCompare', PixelCompare);

/***/ }),

/***/ "./extensions/PixelCompare/PixelCompareConstants.js":
/*!**********************************************************!*\
  !*** ./extensions/PixelCompare/PixelCompareConstants.js ***!
  \**********************************************************/
/*! exports provided: DIFF_MODES, DIFF_MODES_SHADER, EVENTS, DEFAULTS, DIFF_CONTROL_GROUP_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIFF_MODES", function() { return DIFF_MODES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIFF_MODES_SHADER", function() { return DIFF_MODES_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENTS", function() { return EVENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULTS", function() { return DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIFF_CONTROL_GROUP_ID", function() { return DIFF_CONTROL_GROUP_ID; });
var _DIFF_MODES_SHADER;function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;} // Values correspond to the ones inside Design-Diff
var DIFF_MODES = {
  OVERLAY: 'overlay',
  SIDE_BY_SIDE: 'sidebyside' };


// Values correspond to the the diff fragment shader.
var DIFF_MODES_SHADER = (_DIFF_MODES_SHADER = {}, _defineProperty(_DIFF_MODES_SHADER,
DIFF_MODES.OVERLAY, 0), _defineProperty(_DIFF_MODES_SHADER,
DIFF_MODES.SIDE_BY_SIDE, 1), _DIFF_MODES_SHADER);


var EVENTS = {
  DIFF_TOOL_DIFF_MODE_CHANGED: 'diff.tool.diff.mode.changed',
  DIFF_TOOL_DEACTIVATED: 'diff.tool.deactivated',
  DIFF_TOOL_MODEL_VISIBILITY_CHANGED: 'diff.tool.model.visibility.changed' };


var DEFAULTS = {
  SPLIT_LINE_MARGIN: 50,
  SPLIT_LINE_POSITION: 0.5,
  SPLIT_LINE_WIDTH: 1,
  SPLIT_LINE_COLOR: 0x73a9e8,
  ANIMATION_DURATION: 0.3,
  DEFAULT_DIFF_MODE: DIFF_MODES.OVERLAY };


var DIFF_CONTROL_GROUP_ID = 'pixel_compare_control_group';

/***/ }),

/***/ "./extensions/PixelCompare/PixelCompareTool.js":
/*!*****************************************************!*\
  !*** ./extensions/PixelCompare/PixelCompareTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PixelCompareTool; });
/* harmony import */ var _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PixelCompareConstants */ "./extensions/PixelCompare/PixelCompareConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;var

PixelCompareTool = /*#__PURE__*/function () {
  function PixelCompareTool(extension) {_classCallCheck(this, PixelCompareTool);
    this.extension = extension;
    this.viewer = extension.viewer;
    this.options = extension.options;

    this.setGlobalManager(this.viewer.globalManager);

    this.names = ['pixelCompare'];

    this.splitLineMinTouchArea = Autodesk.Viewing.isMobileDevice() ? 44 : 10; // Amount of minimum touch area pixels for the split line.
    this.splitLineLimit = _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DEFAULTS"].SPLIT_LINE_MARGIN; // Limit of pixels from each side of the canvas.
  }_createClass(PixelCompareTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.lastMouseEvent) {
        if (this.extension.diffMode === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE && this.intersectSplitLine(this.lastMouseEvent) && !this.rightClickDragging) {
          return 'col-resize';
        }
      }

      if (this.extension.changeOffsetMode) {
        return 'move';
      }

      return null;
    } }, { key: "isActive", value: function isActive()

    {
      return this.isActive;
    } }, { key: "activate", value: function activate(

    name) {
      if (name === this.getName() && !this.isActive) {
        this.isActive = true;

      }
    } }, { key: "deactivate", value: function deactivate(

    name) {
      if (name === this.getName() && this.isActive) {
        this.isActive = false;

      }
    } }, { key: "getRelativeX", value: function getRelativeX(

    event) {
      var rect = this.viewer.impl.getCanvasBoundingClientRect();
      var posRatio = event.canvasX / rect.width;
      return posRatio;
    } }, { key: "intersectSplitLine", value: function intersectSplitLine(

    event) {
      var pos = this.getRelativeX(event);var _this$viewer$impl$get =
      this.viewer.impl.getCanvasBoundingClientRect(),width = _this$viewer$impl$get.width;

      return Math.abs(pos - this.extension.splitPosition) * width < Math.max(this.extension.splitLineWidth, this.splitLineMinTouchArea);
    } }, { key: "clientToWorld", value: function clientToWorld(

    x, y) {
      var worldPos = this.viewer.impl.clientToViewport(x, y);
      worldPos.unproject(this.viewer.getCamera());

      return worldPos;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      var consume = false;

      if (this.extension.diffMode === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE && this.intersectSplitLine(event)) {
        this.draggingSplitLine = true;

        return true;
      }

      if (this.extension.changeOffsetMode && Autodesk.Viewing.Private.isRightClick(event, this.viewer.navigation)) {
        this.extension.changeOffsetMode = false;
        this.rightClickDragging = true;
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      var consume = false;

      if (this.extension.diffMode === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE) {
        consume = this.draggingSplitLine;
        this.draggingSplitLine = false;
      }

      if (this.rightClickDragging) {
        this.extension.changeOffsetMode = true;
        this.rightClickDragging = false;
      }

      return consume;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      this.lastMouseEvent = event;

      if (this.draggingSplitLine && this.extension.diffMode === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE) {
        var relativePos = this.getRelativeX(event);var _this$viewer$impl$get2 =

        this.viewer.impl.getCanvasBoundingClientRect(),width = _this$viewer$impl$get2.width;
        var absolutePos = relativePos * width;

        if (absolutePos >= this.splitLineLimit && absolutePos <= width - this.splitLineLimit) {
          this.extension.setSplitPosition(relativePos);
        }

        return true;
      }

      return false;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (!this.extension.changeOffsetMode) {
        return;
      }

      var translation;

      switch (keyCode) {
        case Autodesk.Viewing.KeyCode.LEFT:
        case Autodesk.Viewing.KeyCode.a:
          translation = new THREE.Vector3(1, 0, 0);
          break;
        case Autodesk.Viewing.KeyCode.RIGHT:
        case Autodesk.Viewing.KeyCode.d:
          translation = new THREE.Vector3(-1, 0, 0);
          break;
        case Autodesk.Viewing.KeyCode.UP:
        case Autodesk.Viewing.KeyCode.w:
          translation = new THREE.Vector3(0, 1, 0);
          break;
        case Autodesk.Viewing.KeyCode.DOWN:
        case Autodesk.Viewing.KeyCode.s:
          translation = new THREE.Vector3(0, -1, 0);
          break;}


      // When pressing the arrows, move the main camera by one pixel.
      if (translation) {
        var mainCamera = this.viewer.getCamera();
        var worldTranslation = this.clientToWorld(translation.x, translation.y).sub(this.clientToWorld(0, 0));

        mainCamera.position.add(worldTranslation);
        mainCamera.target.add(worldTranslation);
        mainCamera.dirty = true;
        mainCamera.updateCameraMatrices();

        return true;
      }

      return false;
    } }, { key: "handleGesture", value: function handleGesture(

    event) {
      switch (event.type) {

        case 'dragstart':
          return this.handleButtonDown(event);

        case 'dragmove':
          return this.handleMouseMove(event);

        case 'dragend':
          return this.handleButtonUp(event);}

      return false;
    } }]);return PixelCompareTool;}();


av.GlobalManagerMixin.call(PixelCompareTool.prototype);

/***/ }),

/***/ "./extensions/PixelCompare/PixelCompareUI.js":
/*!***************************************************!*\
  !*** ./extensions/PixelCompare/PixelCompareUI.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PixelCompareUI; });
/* harmony import */ var _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PixelCompareConstants */ "./extensions/PixelCompare/PixelCompareConstants.js");
/* harmony import */ var _PixelCompareUI_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PixelCompareUI.scss */ "./extensions/PixelCompare/PixelCompareUI.scss");
/* harmony import */ var _PixelCompareUI_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_PixelCompareUI_scss__WEBPACK_IMPORTED_MODULE_1__);
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;var

PixelCompareUI = /*#__PURE__*/function () {
  function PixelCompareUI(extension) {_classCallCheck(this, PixelCompareUI);
    this.extension = extension;
    this.viewer = extension.viewer;
    this.options = extension.options;
    this.viewerContainer = this.viewer.container;
    this.setGlobalManager(this.viewer.globalManager);
  }_createClass(PixelCompareUI, [{ key: "createUI", value: function createUI()

    {var _this = this;
      var _document = this.getDocument();
      this.documents = [this.extension.mainModelInfo, this.extension.secondaryModelInfo];

      var title = Autodesk.Viewing.i18n.translate('Compared Documents');
      this.panel = new Autodesk.Viewing.UI.DockingPanel(this.viewerContainer, 'ComparePanel', title, { addFooter: false });

      this.panel.container.classList.add('ComparePanel');

      var scrollContainer = this.panel.createScrollContainer();
      this.mainContainer = _document.createElement('div');
      this.mainContainer.className = 'ComparePanel__main-container';

      this.createButtonsContainer();

      this.itemsContainer = _document.createElement('div');
      this.itemsContainer.className = 'ComparePanel__items-container';
      this.mainContainer.appendChild(this.itemsContainer);

      this.colorStrips = [];
      this.documentContainers = [];
      this.visibilityButtons = [];
      this.labels = [];
      this.colorButtonStateBackup = undefined;

      this.documents.forEach(function (doc, i) {
        _this.createDocumentContainer(doc, i);
      });

      this.onDiffModeChanged();

      scrollContainer.appendChild(this.mainContainer);

      this.panel.setVisible(true);

      this.toolbarVisibilityBackup = {};

      this.addToolbar();

      this.toggleColorStrips(true);

      this.panel.addVisibilityListener(function (visible) {
        var state = visible ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE;
        _this.toolbarControls.showPanelButton.setState(state);

        var tooltip = visible ? 'Close Panel' : 'Open Panel';
        _this.toolbarControls.showPanelButton.setToolTip(Autodesk.Viewing.i18n.t(tooltip));
      });

      this.onDiffModeChangedBinded = this.onDiffModeChanged.bind(this);
      this.updateVisibilityButtonsBinded = this.updateVisibilityButtons.bind(this);

      this.viewer.addEventListener(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].DIFF_TOOL_DIFF_MODE_CHANGED, this.onDiffModeChangedBinded);
      this.viewer.addEventListener(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].DIFF_TOOL_MODEL_VISIBILITY_CHANGED, this.updateVisibilityButtonsBinded);
    } }, { key: "destroyUI", value: function destroyUI()

    {
      this.panel.uninitialize();

      if (!this.hadToolbar) {
        this.viewerContainer.removeChild(this.toolbar.container);
        this.viewer.toolbar = undefined;
      } else {
        this.toolbar.removeControl(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_CONTROL_GROUP_ID"]);
      }

      this.toolbar = null;
      this.clearLabels();
      this.colorStrips = null;
      this.documentContainer = null;
      this.documents = null;
      this.colorButtonStateBackup = undefined;

      this.restoreLMVToolbar();

      this.toolbarVisibilityBackup = {};

      this.viewer.removeEventListener(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].DIFF_TOOL_DIFF_MODE_CHANGED, this.onDiffModeChangedBinded);
      this.viewer.removeEventListener(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].DIFF_TOOL_MODEL_VISIBILITY_CHANGED, this.updateVisibilityButtonsBinded);
    } }, { key: "hideLMVToolbar", value: function hideLMVToolbar()

    {var _this2 = this;
      var lmvToolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (lmvToolbar) {
        lmvToolbar._controls.forEach(function (control) {
          _this2.toolbarVisibilityBackup[control.getId()] = control.isVisible();

          // keep only navigation tools
          if (control.getId() !== Autodesk.Viewing.TOOLBAR.NAVTOOLSID) {
            control.setVisible(false);
          }
        });
      }
    } }, { key: "restoreLMVToolbar", value: function restoreLMVToolbar()

    {var _this3 = this;
      var lmvToolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (lmvToolbar) {
        lmvToolbar._controls.forEach(function (control) {
          control.setVisible(_this3.toolbarVisibilityBackup[control.getId()]);
        });
      }
    } }, { key: "createButtonsContainer", value: function createButtonsContainer()

    {
      var _document = this.getDocument();
      var buttonsContainer = _document.createElement('div');
      buttonsContainer.className = 'ComparePanel__buttons-container';
      this.mainContainer.appendChild(buttonsContainer);

      this.colorButton = this.createColorButton();
      buttonsContainer.appendChild(this.colorButton.container);

      this.moveButton = this.createMoveButton();
      buttonsContainer.appendChild(this.moveButton.container);
    } }, { key: "toggleColorStrips", value: function toggleColorStrips(

    show) {
      this.colorStrips.forEach(function (colorStrip) {
        if (show) {
          colorStrip.classList.add('active');
        } else {
          colorStrip.classList.remove('active');
        }
      });

      this.extension.changeColorIntensity(show ? 1.0 : 0.0);
    } }, { key: "colorButtonOnClick", value: function colorButtonOnClick()

    {
      var currentState = this.colorButton.getState();
      if (currentState === Autodesk.Viewing.UI.Button.State.ACTIVE) {
        this.toggleColorStrips(false);
        this.colorButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        this.colorButton.setIcon('pixelCompareFont-show-colors-btn');
        this.colorButton.setToolTip(Autodesk.Viewing.i18n.translate('Show colors'));
      } else {
        this.toggleColorStrips(true);
        this.colorButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        this.colorButton.setIcon('pixelCompareFont-hide-colors-btn');
        this.colorButton.setToolTip(Autodesk.Viewing.i18n.translate('Hide colors'));
      }
    } }, { key: "createColorButton", value: function createColorButton()

    {
      var colorButton = new Autodesk.Viewing.UI.Button('compare-panel-color-button');
      colorButton.setIcon('pixelCompareFont-show-colors-btn');
      colorButton.setToolTip(Autodesk.Viewing.i18n.translate('Show colors'));
      colorButton.addEventListener('click', this.colorButtonOnClick.bind(this));
      colorButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);

      return colorButton;
    } }, { key: "isMoveActive", value: function isMoveActive()

    {
      return this.moveButton && this.moveButton.getState() === Autodesk.Viewing.UI.Button.State.ACTIVE;
    } }, { key: "moveButtonOnClick", value: function moveButtonOnClick()

    {
      var currentState = this.moveButton.getState();
      if (currentState === Autodesk.Viewing.UI.Button.State.INACTIVE) {
        this.moveButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        this.documentContainers[0].classList.add('align');
        this.extension.setChangeOffsetMode(true);
        this.moveButton.setToolTip(Autodesk.Viewing.i18n.translate('Finish align'));
      } else if (currentState === Autodesk.Viewing.UI.Button.State.ACTIVE) {
        this.moveButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        this.extension.setChangeOffsetMode(false);
        this.documentContainers[0].classList.remove('align');
        this.moveButton.setToolTip(Autodesk.Viewing.i18n.translate('Align'));
      }
    } }, { key: "createMoveButton", value: function createMoveButton()

    {
      var moveButton = new Autodesk.Viewing.UI.Button('compare-panel-move-button');
      moveButton.setIcon('pixelCompareFont-move-btn');
      moveButton.setToolTip(Autodesk.Viewing.i18n.translate('Align'));
      moveButton.addEventListener('click', this.moveButtonOnClick.bind(this));

      return moveButton;
    } }, { key: "createDocumentContainer", value: function createDocumentContainer(

    doc, index) {var _this4 = this;

      var _document = this.getDocument();
      var documentContainer = _document.createElement('div');
      documentContainer.className = 'ComparePanel__document-container';
      this.itemsContainer.appendChild(documentContainer);
      this.documentContainers.push(documentContainer);

      var title = _document.createElement('div');
      title.className = 'ComparePanel__doc-title';
      title.textContent = doc.title || "".concat(Autodesk.Viewing.i18n.translate('Document'), " ").concat(index + 1);
      documentContainer.appendChild(title);

      var descriptionContainer = _document.createElement('div');
      descriptionContainer.className = 'ComparePanel__doc-description treeview';
      documentContainer.appendChild(descriptionContainer);

      var versionContainer = _document.createElement('div');
      versionContainer.className = 'ComparePanel__doc-version';
      descriptionContainer.appendChild(versionContainer);

      var colors = ['red', 'blue'];

      var colorStrip = _document.createElement('div');
      colorStrip.className = 'ComparePanel__doc-color';
      colorStrip.classList.add(colors[index]);
      versionContainer.appendChild(colorStrip);

      this.colorStrips.push(colorStrip);

      var versionText = _document.createElement('div');
      versionText.className = 'ComparePanel__doc-version-text';
      versionText.textContent = doc.version ? "v".concat(doc.version) : index + 1;
      versionContainer.appendChild(versionText);

      var descriptionData = _document.createElement('div');
      descriptionData.className = 'ComparePanel__doc-description-data';
      descriptionContainer.appendChild(descriptionData);

      if (doc.creator && doc.creationTime) {
        var creator = _document.createElement('div');
        creator.textContent = "".concat(Autodesk.Viewing.i18n.translate('Uploaded By'), ": ").concat(doc.creator);
        descriptionData.appendChild(creator);

        var date = _document.createElement('div');
        var formattedDate = doc.creationTime;
        date.textContent = "".concat(Autodesk.Viewing.i18n.translate('At'), ": ").concat(formattedDate);
        descriptionData.appendChild(date);
      }

      var visibilityButton = _document.createElement('div');
      visibilityButton.className = 'visibility';
      visibilityButton.addEventListener('click', function () {
        if (index === 0) {
          _this4.extension.changeMainModelVisibility(!_this4.extension.getMainModelVisibility());
        } else {
          _this4.extension.changeSecondaryModelVisibility(!_this4.extension.getSecondaryModelVisibility());
        }
      });

      var visibilityButtonContainer = _document.createElement('div');
      visibilityButtonContainer.appendChild(visibilityButton);

      this.visibilityButtons.push(visibilityButtonContainer);
      descriptionContainer.appendChild(visibilityButtonContainer);
    } }, { key: "clearLabels", value: function clearLabels()

    {var _this5 = this;
      this.labels.forEach(function (label) {
        _this5.viewerContainer.removeChild(label);
      });

      this.labels = [];
    } }, { key: "onDiffModeChanged", value: function onDiffModeChanged()

    {var _this6 = this;
      var getDocText = function getDocText(index) {
        if (_this6.documents[index].title) {
          var version = "v".concat(_this6.documents[index].version) || false;
          return "".concat(_this6.documents[index].title, " ").concat(version);
        } else {
          return "".concat(Autodesk.Viewing.i18n.translate('Document'), " ").concat(index + 1);
        }
      };

      var positions = ['left', 'right'];

      this.clearLabels();

      if (this.extension.getDiffMode() === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE) {
        this.documents.forEach(function (doc, i) {
          _this6.createLabel(getDocText(i), positions[i]);
        });

        this.colorButtonStateBackup = this.colorButton.getState();

        if (this.colorButtonStateBackup === Autodesk.Viewing.UI.Button.State.ACTIVE) {
          this.colorButtonOnClick();
        }

        this.colorButton.setState(Autodesk.Viewing.UI.Button.State.DISABLED);
      } else {
        this.createLabel("".concat(getDocText(0), " vs. ").concat(getDocText(1)), 'left');

        if (this.colorButtonStateBackup !== undefined) {
          if (this.colorButtonStateBackup === Autodesk.Viewing.UI.Button.State.ACTIVE) {
            this.colorButtonOnClick();
          }

          this.colorButton.setState(this.colorButtonStateBackup);
        }
      }

      this.updateVisibilityButtons();
    } }, { key: "updateVisibilityButtons", value: function updateVisibilityButtons()

    {
      for (var i = 0; i <= 1; i++) {
        this.visibilityButtons[i].className = this.extension.modelHiddenMap[i] ? 'dim' : '';
        this.visibilityButtons[i].style.opacity = this.extension.getDiffMode() === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE ? 0.3 : 1.0;
      }
    } }, { key: "createLabel", value: function createLabel(

    text, pos) {
      var _document = this.getDocument();
      var label = _document.createElement('div');
      label.className = 'CompareUI__label';
      label.textContent = text;

      if (pos === 'left') {
        label.style.left = '0px';
      } else {
        label.style.right = '0px';
      }

      this.viewerContainer.appendChild(label);
      this.labels.push(label);
    } }, { key: "sideBySideButtonOnClick", value: function sideBySideButtonOnClick()

    {
      var state = this.toolbarControls.sideBySideButton.getState();
      if (state === Autodesk.Viewing.UI.Button.State.INACTIVE) {
        this.toolbarControls.sideBySideButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        this.showDiffButton.setIcon('pixelCompareFont-sidebyside-btn');
        this.extension.setDiffMode(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE);

        if (this.isMoveActive()) {
          this.moveButtonOnClick();
        }
      }

      this.showDiffButton.onClick = this.showDiffButton.arrowButton.onClick;
    } }, { key: "overlayButtonOnClick", value: function overlayButtonOnClick()

    {
      var state = this.toolbarControls.overlayButton.getState();
      if (state === Autodesk.Viewing.UI.Button.State.INACTIVE) {
        this.toolbarControls.overlayButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        this.showDiffButton.setIcon('pixelCompareFont-overlay-btn');
        this.extension.setDiffMode(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].OVERLAY);
      }

      this.showDiffButton.onClick = this.showDiffButton.arrowButton.onClick;
    } }, { key: "showPanelOnClick", value: function showPanelOnClick()

    {
      var isVisible = this.panel.isVisible();
      this.panel.setVisible(!isVisible);
    } }, { key: "exitButtonOnClick", value: function exitButtonOnClick()

    {
      var state = this.toolbarControls.exitButton.getState();
      if (state === Autodesk.Viewing.UI.Button.State.INACTIVE) {
        this.toolbarControls.exitButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        this.extension.deactivate();
      } else {
        this.toolbarControls.exitButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
      }
    } }, { key: "addToolbar", value: function addToolbar()

    {
      this.hadToolbar = !!this.viewer.getToolbar();

      if (!this.hadToolbar) {
        this.viewer._createToolbar();
        this.viewer.loadExtension('Autodesk.DefaultTools.NavTools', this.viewer.config);
      }

      this.hideLMVToolbar();

      this.toolbar = this.viewer.getToolbar();

      this.toolbarControls = {};

      this.viewerToolbarDiffGroup = new Autodesk.Viewing.UI.ControlGroup(_PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_CONTROL_GROUP_ID"]);
      this.toolbar.addControl(this.viewerToolbarDiffGroup);
      this.toolbar.container.classList.add('CompareUI__toolbar');
      this.viewerContainer.appendChild(this.toolbar.container);

      this.showDiffButton = new Autodesk.Viewing.UI.ComboButton('diff-tool-button-combo');
      this.showDiffButton.setIcon('pixelCompareFont-overlay-btn');
      this.showDiffButton.setToolTip(Autodesk.Viewing.i18n.translate('Show Differences'));
      this.showDiffButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
      this.showDiffButton.setDisplay('block');
      this.viewerToolbarDiffGroup.addControl(this.showDiffButton);

      this.toolbarControls.sideBySideButton = new Autodesk.Viewing.UI.Button('diff-tool-button-sidebyside-diff');
      this.toolbarControls.sideBySideButton.setIcon('pixelCompareFont-sidebyside-btn');
      this.toolbarControls.sideBySideButton.setToolTip(Autodesk.Viewing.i18n.translate('Side by Side'));
      this.toolbarControls.sideBySideButton.onClick = this.sideBySideButtonOnClick.bind(this);

      this.showDiffButton.addControl(this.toolbarControls.sideBySideButton);

      this.toolbarControls.overlayButton = new Autodesk.Viewing.UI.Button('diff-tool-button-overlay-diff');
      this.toolbarControls.overlayButton.setIcon('pixelCompareFont-overlay-btn');
      this.toolbarControls.overlayButton.setToolTip(Autodesk.Viewing.i18n.translate('Overlay'));
      this.toolbarControls.overlayButton.onClick = this.overlayButtonOnClick.bind(this);

      this.showDiffButton.addControl(this.toolbarControls.overlayButton);

      if (this.extension.getDiffMode() === _PixelCompareConstants__WEBPACK_IMPORTED_MODULE_0__["DIFF_MODES"].SIDE_BY_SIDE) {
        this.toolbarControls.sideBySideButton.onClick();
      } else {
        this.toolbarControls.overlayButton.onClick();
      }

      this.toolbarControls.showPanelButton = new Autodesk.Viewing.UI.Button('diff-tool-button-changes');
      this.toolbarControls.showPanelButton.setIcon('pixelCompareFont-panel-btn');
      this.toolbarControls.showPanelButton.onClick = this.showPanelOnClick.bind(this);

      this.toolbarControls.showPanelButton.setToolTip(Autodesk.Viewing.i18n.translate('Close Panel'));
      this.toolbarControls.showPanelButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
      this.viewerToolbarDiffGroup.addControl(this.toolbarControls.showPanelButton);

      this.toolbarControls.exitButton = new Autodesk.Viewing.UI.Button('diff-tool-button-exit');
      this.toolbarControls.exitButton.setIcon('pixelCompareFont-exit-compare-btn');
      this.toolbarControls.exitButton.setToolTip(Autodesk.Viewing.i18n.translate('Exit comparing'));

      this.toolbarControls.exitButton.onClick = this.exitButtonOnClick.bind(this);

      this.viewerToolbarDiffGroup.addControl(this.toolbarControls.exitButton);
    } }]);return PixelCompareUI;}();


av.GlobalManagerMixin.call(PixelCompareUI.prototype);

/***/ }),

/***/ "./extensions/PixelCompare/PixelCompareUI.scss":
/*!*****************************************************!*\
  !*** ./extensions/PixelCompare/PixelCompareUI.scss ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./PixelCompareUI.scss */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PixelCompare/PixelCompareUI.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/PixelCompare/shaders/DiffShader.js":
/*!*******************************************************!*\
  !*** ./extensions/PixelCompare/shaders/DiffShader.js ***!
  \*******************************************************/
/*! exports provided: DiffShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiffShader", function() { return DiffShader; });
/* harmony import */ var _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/wgs/render/ShaderChunks */ "./src/wgs/render/ShaderChunks.js");
/* harmony import */ var _diff_vert_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diff_vert.glsl */ "./extensions/PixelCompare/shaders/diff_vert.glsl");
/* harmony import */ var _diff_vert_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_diff_vert_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _diff_frag_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diff_frag.glsl */ "./extensions/PixelCompare/shaders/diff_frag.glsl");
/* harmony import */ var _diff_frag_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_diff_frag_glsl__WEBPACK_IMPORTED_MODULE_2__);




var DiffShader = {

  uniforms: THREE.UniformsUtils.merge([

  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_0__["ShaderChunks"].DepthTextureUniforms,

  {
    diff_threshold: { type: 'f', value: 0.1 },
    texture1: { type: 't', value: null },
    texture2: { type: 't', value: null },
    resolution: { type: "v2", value: new THREE.Vector2(1 / 1024, 1 / 512) },
    splitPosition: { type: 'f', value: 0.0 },
    splitLineColor: { type: 'c', value: null },
    diffMode: { type: 'i', value: 0 },
    splitLineWidth: { type: 'f', value: 1.0 },
    colorIntensity: { type: 'f', value: 1.0 },
    t: { type: 'f', value: 1.0 },
    mainModelHidden: { type: 'i', value: 0 },
    secondaryModelHidden: { type: 'i', value: 0 },
    visibleModelBounds: { type: 'v4', value: new THREE.Vector4() } }]),



  vertexShader: _diff_vert_glsl__WEBPACK_IMPORTED_MODULE_1___default.a,
  fragmentShader: _diff_frag_glsl__WEBPACK_IMPORTED_MODULE_2___default.a };

/***/ }),

/***/ "./extensions/PixelCompare/shaders/diff_frag.glsl":
/*!********************************************************!*\
  !*** ./extensions/PixelCompare/shaders/diff_frag.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define OVERLAY 0\n#define SIDE_BY_SIDE 1\n#define FXAA_EDGE_SHARPNESS (8.0)\n#define FXAA_EDGE_THRESHOLD (0.125)\n#define FXAA_EDGE_THRESHOLD_MIN (0.05)\n#define FXAA_RCP_FRAME_OPT (0.5)\n#define FXAA_RCP_FRAME_OPT2 (2.0)\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float diff_threshold;\nuniform highp vec2 resolution;\nuniform int diffMode;\nuniform float colorIntensity;\nuniform bool mainModelHidden;\nuniform bool secondaryModelHidden;\nuniform vec4 visibleModelBounds;\nvarying vec2 vUv;\nuniform float splitPosition;\nuniform highp float splitLineWidth;\nuniform vec3 splitLineColor;\nuniform highp float t;\nfloat toGrayscale(vec4 v) {\n    return dot(v.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat getGrayAt(sampler2D texInput, float i, float j) {\n    vec4 tex = texture2D(texInput, vUv + resolution*vec2(i, j));\n    float gray = toGrayscale(tex);\n    return gray;\n}\nfloat getDarkestGray(float i, float j) {\n    float gray1 = mainModelHidden ? 1.0 : getGrayAt(texture1, i, j);\n    float gray2 = secondaryModelHidden ? 1.0 : getGrayAt(texture2, i, j);\n    return min(gray1, gray2);\n}\nfloat getDeltaAt(float i, float j) {\n    float gray1 = mainModelHidden ? 1.0 : getGrayAt(texture1, i, j);\n    float gray2 = secondaryModelHidden ? 1.0 : getGrayAt(texture2, i, j);\n    return gray1 - gray2;\n}\nvec4 getColorAt(float i, float j) {\n    if (mainModelHidden || secondaryModelHidden) {\n        if (vUv.x <= visibleModelBounds.x || vUv.y <= visibleModelBounds.y || vUv.x >= visibleModelBounds.z || vUv.y >= visibleModelBounds.w) {\n            if (mainModelHidden) {\n                return texture2D(texture2, vUv);\n            } else {\n                return texture2D(texture1, vUv);\n            }            \n        }\n    }\n    float maxGray = getDarkestGray(i, j);\n    float delta = getDeltaAt(i, j);\n    if (abs(delta) > diff_threshold) {\n        if (delta < 0.0) {\n            return vec4(colorIntensity, 0.0, 0.0, 1.0);\n        }\n        return vec4(0.0, 0.0, colorIntensity, 1.0);\n    }\n    return vec4(vec3(maxGray), 1.0);\n}\n#ifdef ANTI_ALIASING\n    void applyAntiAliasing() {\n        \n        float lumaNw = toGrayscale(getColorAt(-0.5, -0.5));\n        float lumaSw = toGrayscale(getColorAt(0.5, -0.5));\n        float lumaNe = toGrayscale(getColorAt(-0.5, 0.5)) + 1.0/384.0;\n        float lumaSe = toGrayscale(getColorAt(0.5, 0.5));\n        vec4 rgbaM = getColorAt(0.0, 0.0);\n        float lumaM = toGrayscale(rgbaM);\n        float lumaMax = max(max(lumaNe, lumaSe), max(lumaNw, lumaSw));\n        float lumaMin = min(min(lumaNe, lumaSe), min(lumaNw, lumaSw));\n        float lumaMaxSubMinM = max(lumaMax, lumaM) - min(lumaMin, lumaM);\n        float lumaMaxScaledClamped = max(FXAA_EDGE_THRESHOLD_MIN, lumaMax * FXAA_EDGE_THRESHOLD);\n        if (lumaMaxSubMinM < lumaMaxScaledClamped) {\n            gl_FragColor = rgbaM;\n            return;\n        }\n        float dirSwMinusNe = lumaSw - lumaNe;\n        float dirSeMinusNw = lumaSe - lumaNw;\n        vec2 dir1 = normalize(vec2(dirSwMinusNe + dirSeMinusNw, dirSwMinusNe - dirSeMinusNw));\n        vec3 rgbN1 = getColorAt((-dir1 * FXAA_RCP_FRAME_OPT).x ,(-dir1 * FXAA_RCP_FRAME_OPT).y).rgb;\n        vec3 rgbP1 = getColorAt((dir1 * FXAA_RCP_FRAME_OPT).x ,(dir1 * FXAA_RCP_FRAME_OPT).y).rgb;\n        float dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * FXAA_EDGE_SHARPNESS;\n        vec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\n        \n        vec3 rgbN2 = getColorAt((-dir2 * FXAA_RCP_FRAME_OPT2).x ,(-dir2 * FXAA_RCP_FRAME_OPT2).y).rgb;\n        vec3 rgbP2 = getColorAt((dir2 * FXAA_RCP_FRAME_OPT2).x ,(dir2 * FXAA_RCP_FRAME_OPT2).y).rgb;\n        vec3 rgbA = rgbN1 + rgbP1;\n        vec3 rgbB = ((rgbN2 + rgbP2) * 0.25) + (rgbA * 0.25);\n        float lumaB = toGrayscale(vec4(rgbB, 1.0));\n        float alpha = rgbaM.a;\n        \n        if ((lumaB < lumaMin) || (lumaB > lumaMax))\n            gl_FragColor = vec4(rgbA * 0.5, rgbaM.a);\n        else\n            gl_FragColor = vec4(rgbB, rgbaM.a);\n    }\n#endif\nvoid main() {\n    vec4 tex1 = texture2D(texture1, vUv);\n    \n    if (diffMode == SIDE_BY_SIDE) {\n        if (abs(vUv.x - splitPosition) <= splitLineWidth) {\n            gl_FragColor = vec4(mix(tex1.rgb, splitLineColor, t), 1.0);\n        } else {\n            vec4 tex = vUv.x < splitPosition ? tex1 : texture2D(texture2, vUv);\n            gl_FragColor = vec4(mix(tex1.rgb, tex.rgb, t), 1.0);\n        }\n    } else if (diffMode == OVERLAY) {\n        gl_FragColor = vec4(mix(tex1.rgb, getColorAt(0.0, 0.0).rgb, t), 1.0);\n        \n        #ifdef ANTI_ALIASING\n            float delta = getDeltaAt(0.0, 0.0);\n            if (abs(delta) > diff_threshold) {\n                return;\n            }\n            for (int i = -1; i <= 1; i++) {\n                for (int j = -1; j <= 1; j++) {\n                    if (i != 0 && j!= 0) {\n                        float delta = getDeltaAt(float(i), float(j));\n                        if (abs(delta) > diff_threshold) {\n                            applyAntiAliasing();\n                            return;\n                        }\n                    }\n                }\n            }\n        #endif\n    }\n}";

/***/ }),

/***/ "./extensions/PixelCompare/shaders/diff_vert.glsl":
/*!********************************************************!*\
  !*** ./extensions/PixelCompare/shaders/diff_vert.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "varying vec2 vUv;\nuniform vec2 resolution;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PixelCompare/PixelCompareUI.scss":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/PixelCompare/PixelCompareUI.scss ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".pixelCompareFont-compare-btn:before {\n  content: \"\\E93C\"; }\n\n.pixelCompareFont-overlay-btn:before {\n  content: \"\\E93E\"; }\n\n.pixelCompareFont-sidebyside-btn:before {\n  content: \"\\E93F\"; }\n\n.pixelCompareFont-exit-compare-btn:before {\n  content: \"\\E93D\"; }\n\n.pixelCompareFont-panel-btn:before {\n  content: \"\\E940\"; }\n\n.pixelCompareFont-show-colors-btn:before {\n  content: \"\\E941\"; }\n\n.pixelCompareFont-hide-colors-btn:before {\n  content: \"\\E942\"; }\n\n.pixelCompareFont-move-btn:before {\n  content: \"\\E943\"; }\n\n.CompareUI__toolbar {\n  z-index: 5; }\n\n.CompareUI__label {\n  position: absolute;\n  display: block;\n  border-radius: 5px;\n  background-color: rgba(78, 78, 78, 0.95);\n  top: 0px;\n  font-size: 12px;\n  color: #FFFFFF;\n  text-align: center;\n  margin: 10px;\n  padding: 10px;\n  white-space: pre;\n  pointer-events: none;\n  z-index: 5; }\n\n.docking-panel.ComparePanel {\n  top: 25%;\n  left: 10%;\n  width: 340px;\n  height: initial;\n  resize: none;\n  z-index: 5; }\n  .docking-panel.ComparePanel .adsk-button {\n    box-sizing: content-box; }\n  .docking-panel.ComparePanel .adsk-control-tooltip {\n    bottom: auto;\n    top: 120%; }\n  .docking-panel.ComparePanel .ComparePanel__main-container {\n    display: flex;\n    flex-direction: column; }\n    .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__buttons-container {\n      background-color: rgba(0, 0, 0, 0.05);\n      padding: 10px;\n      text-align: center; }\n      .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__buttons-container .adsk-button.inactive {\n        border: 1px solid #cccccc;\n        border-radius: 3px; }\n    .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container {\n      padding: 10px;\n      padding-top: 0px;\n      display: flex;\n      flex-direction: column; }\n      .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container {\n        padding-left: 5px;\n        margin-left: -2px;\n        padding-bottom: 5px;\n        margin-top: 10px;\n        border: 1px solid rgba(0, 0, 0, 0); }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container.align {\n          border: 1px solid #cccccc;\n          border-radius: 3px;\n          background-color: rgba(0, 0, 0, 0.05); }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-version {\n          display: flex;\n          width: 42px;\n          min-height: 30px;\n          border: 1px solid #cccccc;\n          border-radius: 3px;\n          background-color: rgba(0, 0, 0, 0.05);\n          margin-right: 10px;\n          font-weight: bold; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-visibility {\n          display: flex;\n          width: 42px;\n          min-height: 30px;\n          border: 1px solid #cccccc;\n          border-radius: 3px;\n          background-color: rgba(0, 0, 0, 0.05);\n          margin-right: 10px;\n          font-weight: bold; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-description-data {\n          margin-right: 40px; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-version-text {\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          width: 30px;\n          padding-left: 2px; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-color {\n          border-radius: 3px 0 0 3px;\n          width: 5px;\n          height: 100%; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-color.blue.active {\n          background-color: #0696D7; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-color.red.active {\n          background-color: #FF0000; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-title {\n          font-size: 15px;\n          font-weight: bold;\n          padding-bottom: 5px;\n          word-break: break-all; }\n        .docking-panel.ComparePanel .ComparePanel__main-container .ComparePanel__items-container .ComparePanel__document-container .ComparePanel__doc-description {\n          font-size: 13px;\n          line-height: 1.2;\n          font-weight: 300;\n          display: flex;\n          flex-direction: row; }\n\n@font-face {\n  font-family: 'pixelCompareFont';\n  src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAlUAA0AAAAADOwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAJOAAAABwAAAAcgdOIaEdERUYAAAkcAAAAHAAAAB4AJwAXT1MvMgAAAaAAAAA/AAAAYA8TBkpjbWFwAAACBAAAAGAAAAFuAJHDXGdhc3AAAAkUAAAACAAAAAgAAAAQZ2x5ZgAAAogAAAVHAAAGuDC/sv9oZWFkAAABMAAAADUAAAA2EOq202hoZWEAAAFoAAAAIAAAACQH0wPGaG10eAAAAeAAAAAiAAAALgxlAspsb2NhAAACZAAAACQAAAAkCv4MnG1heHAAAAGIAAAAGAAAACAAGABabmFtZQAAB9AAAADlAAABv5krYsVwb3N0AAAIuAAAAFwAAACzVE7OgXicY2BkYGAA4g+t7hzx/DZfGbhZGEDgiucOSxB9s3CXLAPD/wMsAswHgFwOBiaQKAAgRwpEAAAAeJxjYGRgYD7w/wADAwsDA8P//ywCDEARFMAGAHhdBKF4nGNgZGBgEGSIYGBjAAEmBjQAAAtOAHN4nGNgZr7NOIGBlYGBaSbTGQYGhn4IzfiawZiRkwEVMAqgCTA4MDC+dGE+8P8AgwMzEIPUIMkqMDACAHGjC2gAeJxjYYAAxlAIzQTELBDmMiDuZggFw1cMaQxRDAwANtcEOwAAeJxjYGBgZoBgGQZGBhDIAPIYwXwWBh8gzcfAwcDEwAYUU3jJ+NLkpcv/v///g1UqvGQA8m0g/P9PxFnFLoudAevmY0AGjCDzGdmAmBkqwAQkmBgY0FQBLRzeAABnkBOjAAAAAAAIAAgAEAAYAJgA7AEyAYIBugHSAfACIAJYAsADGgNceJyFVE1sE0cUnrfj7DZO1s7au3ZsiO21sV2cYCde2xvnx3ECUVMof42dlqhBIUGEkFaAKghVC7htqIQgFbTKgYJS0UpUSiiQW2+hTShp1UiVKirEBfUQVEEPPZUe7E3frgk9VV3tm503773Z75v5ZgiQtYchJM2Q//NNhKw+NRF6kawjcdJOXiMEQn4rRCHgtzBckwecHCs6HXEVUokwJDKMEnc4uQiGWWk9SFwilHTGU8lEKMx5QAlGQf9KooUJ+MtD8QyjNtFp3s8vhrdH+qbPjPjqBtJTPI8jdAvPl6bk5q2RmgCvmlja0ttsWm7pZelNXjQzxDeaLZir9bi7QRzYuLfRKKcTPL9oronnj2bThyJTOA/P0+5qP6956repPpZTc2nKUdUerJnMpc0if5Oyk9kjkYK90aknVJv31tiasBpXgaKNmQjzgEikgaSRvU5bNnh6GEmOUrvBJcokZQ81yMgBkUVyyUQKl0JiiIEJFB1lZGuzDIpv5Mz0+JqrLetun5GkLWd7W1p6dWMe6PB1NHpi9mg+ri3pnk/dVo9ekw6vnNnbou+WiVwjr9BJeo3wxEZqST0hQRlBCIhCdgoiC4IshJ2yoEgKfRZoBSkgyElFElma01Iun88FnhWfVgc/LjzUVtNLS5rq9nrd0Sj8kPb+7XUzbS7finbE7WWOlRbhnYUVgKXSOZ+baXV706U7mza5fc+UQwZQM6PEiZohwLEeiHegPmIQsoDDC7KfFR0KyLhaKIyArGYMTbGiFxzxDITp9UscWERugcNXsgB3uTRvtlrN2iMmU1HJmazm0vxlzJDKGSJmgO8z/HKLnMQuGLWXrDicN3GVFWbLJU60ct9xIrf4AkZwT8+RbbRAs4RDhDIh9kBSScqCTFGzAiKTUbACAqOyJHPODpTst6kUc7Y0XmVzuWzM53r7pxaCB6dC1+3zIei/f780zsy7bKV9awna1VQ5aKxHnrjpFB0iFaQS10NSBEUA/B98UXxavM04So/p0BPtE2ZP8Rsmomsuj80sLRj5PCGyItSDENQr0BgiSZJ2CApaAX7VW1ooFiTaV5yhfYTFWglrx3AWjlQRK7EjRwKKEABZ51g2w0ejZHa2lC/Xlg36Zma0mdlZJgv1WiyvPclrj/rgHjpoOpfHpJ7W0mEikA04r4c1TrKKurdQiXXoJyBKYwBFV2N6U8TOrk8Mdp0eBdi9LxDclVNh4uP97zdyDc0729cJtM6/daB/eE+uW6kben37L1+Nx05Nf909+l5q8MT5iYk3NjiQxYHVIj1M95P1JEq24B/VGHB4BFkP43Rg3wL+cBTUlE11qmtgEhlQLaY1NBWI5p7QJQhNI6M1VXy4L1ubBmCFhoqD3YL06a74eQOqWLEuOdh1ahR2D/nrMj1qCM5M7n67zWN2K4n2mENgnvB5hyPz5cpAYnhnuspkkhwAYDt98DjUvtnRHtgxNHhwb3+P6jkw8Opvc++Ghz768GLrWx+ENu8ZOzI+NvKyx6mfDZb0oxau0QO4t1biIl6ykSjIKiC0gsA5VVRbDKxgRzZe/MbwimkH2amGVX3YC8GwGu4APWTI4Jhtxw6bbdB413p/Mb+Xak9UHz9eXX3B7b4Afzzv0hdLjczP/4Y08Xm3+B+TkfIduHrbVENvG5rCXa+kQYQKHmA5C170YRUXOqUfYtyJgBRWpbgDWqBVu6N9Dy1zc3MwlWtry2Wu5g8P92x+qetkU2c02tl0smt5OX+VuaXd1e5C+tYtzIvmHj7MZTpTPR6lsfPGjc7G+JXln650EvIPpdRymQB4nI2QMQrCQBBFfzQqRrASC6v1AkHBxgsIFiJYWNjFOISA7EqMingMD+AN7Ow9lbU/y/S6MMvbP//PLgugiycCVCtAhL5yDS2MlevUl8oh+aDcQAd35Sb1l3KEAT5MBWGbSs9PqLjGu4bKdepT5ZC8UW7wBTflJvWHcoQJ3jgjh+DCKkgpHCxwzuUiRZ468oqtDCfskdCClWSnfUL4GfxpWPvWkc2qZfg5MUaUpTjmzppxPPpjyMxLJeMZTdYbE54FO2pbXLnPfXDBqrwxQ86WJhMrRVLKzmyvZp66hXM2xhcXcEmzAAAAeJx9y7kOQGAUhNE7v32PN7m4jdryKkhENApvL2Fq05xM8YmT/9UicOLgiQcfAUJEiJEgRYYcBUpU4bLf59pE17Gp6uvUq1L+zuhARzrR+dPYGTtraUftATY7H90AAQAB//8AD3icY2BkYGDgAWIxIGZiYARCASBmAfMYAAROAD8AAAABAAAAANQYFhEAAAAA1Em4OQAAAADZcbod) format(\"woff\");\n  font-weight: normal;\n  font-style: normal; }\n\n[class^=\"pixelCompareFont-\"], [class*=\" pixelCompareFont-\"] {\n  font-family: 'pixelCompareFont';\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  line-height: 1;\n  padding-top: 2px;\n  speak: none;\n  text-transform: none;\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/wgs/render/ShaderChunks.js":
/*!****************************************!*\
  !*** ./src/wgs/render/ShaderChunks.js ***!
  \****************************************/
/*! exports provided: CutPlanesUniforms, IdUniforms, ThemingUniform, ShadowMapCommonUniforms, ShadowMapUniforms, PointSizeUniforms, WideLinesUniforms, DepthTextureUniforms, GetPrismMapSampleChunk, GetPrismMapUniformChunk, resolve, PackDepthShaderChunk, TonemapShaderChunk, OrderedDitheringShaderChunk, CutPlanesShaderChunk, PackNormalsShaderChunk, HatchPatternShaderChunk, EnvSamplingShaderChunk, IdVertexDeclaration, IdVertexShaderChunk, IdFragmentDeclaration, IdOutputShaderChunk, FinalOutputShaderChunk, ThemingFragmentDeclaration, ThemingFragmentShaderChunk, InstancingVertexDeclaration, ShadowMapDeclareCommonUniforms, ShadowMapVertexDeclaration, ShadowMapVertexShaderChunk, ShadowMapFragmentDeclaration, PointSizeDeclaration, PointSizeShaderChunk, ShaderChunks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesUniforms", function() { return CutPlanesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdUniforms", function() { return IdUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingUniform", function() { return ThemingUniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapCommonUniforms", function() { return ShadowMapCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapUniforms", function() { return ShadowMapUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeUniforms", function() { return PointSizeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WideLinesUniforms", function() { return WideLinesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTextureUniforms", function() { return DepthTextureUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapSampleChunk", function() { return GetPrismMapSampleChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapUniformChunk", function() { return GetPrismMapUniformChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackDepthShaderChunk", function() { return PackDepthShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TonemapShaderChunk", function() { return TonemapShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedDitheringShaderChunk", function() { return OrderedDitheringShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesShaderChunk", function() { return CutPlanesShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackNormalsShaderChunk", function() { return PackNormalsShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HatchPatternShaderChunk", function() { return HatchPatternShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnvSamplingShaderChunk", function() { return EnvSamplingShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexDeclaration", function() { return IdVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexShaderChunk", function() { return IdVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdFragmentDeclaration", function() { return IdFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdOutputShaderChunk", function() { return IdOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FinalOutputShaderChunk", function() { return FinalOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentDeclaration", function() { return ThemingFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentShaderChunk", function() { return ThemingFragmentShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancingVertexDeclaration", function() { return InstancingVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapDeclareCommonUniforms", function() { return ShadowMapDeclareCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexDeclaration", function() { return ShadowMapVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexShaderChunk", function() { return ShadowMapVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapFragmentDeclaration", function() { return ShadowMapFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeDeclaration", function() { return PointSizeDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeShaderChunk", function() { return PointSizeShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunks", function() { return ShaderChunks; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/pack_depth.glsl */ "./src/wgs/render/chunks/pack_depth.glsl");
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/depth_texture.glsl */ "./src/wgs/render/chunks/depth_texture.glsl");
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunks/tonemap.glsl */ "./src/wgs/render/chunks/tonemap.glsl");
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/ordered_dither.glsl */ "./src/wgs/render/chunks/ordered_dither.glsl");
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/cutplanes.glsl */ "./src/wgs/render/chunks/cutplanes.glsl");
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunks/pack_normals.glsl */ "./src/wgs/render/chunks/pack_normals.glsl");
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunks/hatch_pattern.glsl */ "./src/wgs/render/chunks/hatch_pattern.glsl");
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunks/env_sample.glsl */ "./src/wgs/render/chunks/env_sample.glsl");
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunks/id_decl_vert.glsl */ "./src/wgs/render/chunks/id_decl_vert.glsl");
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunks/id_vert.glsl */ "./src/wgs/render/chunks/id_vert.glsl");
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunks/id_decl_frag.glsl */ "./src/wgs/render/chunks/id_decl_frag.glsl");
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunks/id_frag.glsl */ "./src/wgs/render/chunks/id_frag.glsl");
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chunks/final_frag.glsl */ "./src/wgs/render/chunks/final_frag.glsl");
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chunks/theming_decl_frag.glsl */ "./src/wgs/render/chunks/theming_decl_frag.glsl");
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chunks/theming_frag.glsl */ "./src/wgs/render/chunks/theming_frag.glsl");
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chunks/instancing_decl_vert.glsl */ "./src/wgs/render/chunks/instancing_decl_vert.glsl");
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chunks/shadowmap_decl_common.glsl */ "./src/wgs/render/chunks/shadowmap_decl_common.glsl");
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./chunks/shadowmap_decl_vert.glsl */ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl");
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./chunks/shadowmap_vert.glsl */ "./src/wgs/render/chunks/shadowmap_vert.glsl");
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./chunks/shadowmap_decl_frag.glsl */ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl");
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./chunks/float3_average.glsl */ "./src/wgs/render/chunks/float3_average.glsl");
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./chunks/line_decl_common.glsl */ "./src/wgs/render/chunks/line_decl_common.glsl");
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./chunks/prism_wood.glsl */ "./src/wgs/render/chunks/prism_wood.glsl");
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./chunks/prism_glazing.glsl */ "./src/wgs/render/chunks/prism_glazing.glsl");
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chunks/prism_transparency.glsl */ "./src/wgs/render/chunks/prism_transparency.glsl");
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./chunks/normal_map.glsl */ "./src/wgs/render/chunks/normal_map.glsl");
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./chunks/decl_point_size.glsl */ "./src/wgs/render/chunks/decl_point_size.glsl");
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./chunks/point_size.glsl */ "./src/wgs/render/chunks/point_size.glsl");
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./chunks/wide_lines_decl.glsl */ "./src/wgs/render/chunks/wide_lines_decl.glsl");
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./chunks/wide_lines_vert.glsl */ "./src/wgs/render/chunks/wide_lines_vert.glsl");
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./chunks/hsv.glsl */ "./src/wgs/render/chunks/hsv.glsl");
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__);
/*
 * Reusable sets of uniforms that can be merged with other uniforms in specific shaders.
 */



var CutPlanesUniforms = {
  "cutplanes": { type: "v4v", value: [] },
  "hatchParams": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1.0, 10.0) },
  "hatchTintColor": { type: "c", value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xFFFFFF) },
  "hatchTintIntensity": { type: "f", value: 1.0 } };


var IdUniforms = {
  "dbId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
  "modelId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) } };


var ThemingUniform = {
  "themingColor": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](0, 0, 0, 0) } };


// Uniforms shared by material shader chunks and ShadowMapShader
// Included by ShadowMapUniforms below.
var ShadowMapCommonUniforms = {
  "shadowESMConstant": { type: "f", value: 0.0 } };


// Uniforms needed by material shaders to apply shadow mapping.
var ShadowMapUniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
{
  "shadowMap": { type: "t", value: null },
  "shadowMapSize": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0, 0) },
  "shadowBias": { type: "f", value: 0.0 },
  "shadowDarkness": { type: "f", value: 0.0 },
  "shadowMatrix": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() },
  "shadowLightDir": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() } },

ShadowMapCommonUniforms]);


// Uniform for point-set point size
var PointSizeUniforms = {
  "point_size": { type: "f", value: 1.0 } };


// Uniform for wide lines shader
var WideLinesUniforms = {
  "view_size": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](640, 480) } };


// Uniforms used for reconstructing positions from depth-texture in post-passes. (depth_texture.glsl)
var DepthTextureUniforms = {
  "tDepth": { type: "t", value: null },
  "projInfo": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]() },
  "isOrtho": { type: "f", value: 0.0 },
  "worldMatrix_mainPass": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() } };


/*
                                                                         * Chunks are code snippets that can be included in specific shaders
                                                                         * using the three.js-style include directive:
                                                                         *
                                                                         *      #include<name_of_chunk>
                                                                         *
                                                                         * During runtime this directive can be expanded into the corresponding
                                                                         * code snippet using the `resolve` method available below.
                                                                         */
var chunks = {};

// We include default three.js chunks, too
for (var name in three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"]) {
  chunks[name] = three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"][name];
}

































chunks['pack_depth'] = _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default.a;
chunks['depth_texture'] = _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default.a;
chunks['tonemap'] = _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default.a;
chunks['ordered_dither'] = _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default.a;
chunks['cutplanes'] = _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default.a;
chunks['pack_normals'] = _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default.a;
chunks['hatch_pattern'] = _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default.a;
chunks['env_sample'] = _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default.a;
chunks['id_decl_vert'] = _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default.a;
chunks['id_vert'] = _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default.a;
chunks['id_decl_frag'] = _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default.a;
chunks['id_frag'] = _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default.a;
chunks['final_frag'] = _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default.a;
chunks['theming_decl_frag'] = _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default.a;
chunks['theming_frag'] = _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default.a;
chunks['instancing_decl_vert'] = _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default.a;
chunks['shadowmap_decl_common'] = _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default.a;
chunks['shadowmap_decl_vert'] = _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default.a;
chunks['shadowmap_vert'] = _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default.a;
chunks['shadowmap_decl_frag'] = _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default.a;
chunks['float3_average'] = _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default.a;
chunks['line_decl_common'] = _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default.a;
chunks['prism_wood'] = _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default.a;
chunks['prism_glazing'] = _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default.a;
chunks['prism_transparency'] = _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default.a;
chunks['normal_map'] = _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default.a;
chunks['decl_point_size'] = _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default.a;
chunks['point_size'] = _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default.a;
chunks['wide_lines_decl'] = _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default.a;
chunks['wide_lines_vert'] = _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default.a;
chunks['hsv'] = _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default.a;

/*
                      * Macros are simple JavaScript functions that can be evaluated from
                      * within the shader code using a similar syntax as the include directive:
                      *
                      *      #name_of_macro<first_param, second_param, third_param, ...>
                      *
                      * All parameters are simply passed to the JavaScript code as strings,
                      * i.e., they are not parsed in any way.
                      *
                      * We use this as a way to call the various Prism helper methods (such as
                      * GetPrismMapsDefinitionChunk below) without having to compose the shader
                      * code from lists of strings.
                      */
var macros = {};

// If any map type is defined, then do whatever "content" is;
// typically it's "#define USE_MAP". In other words, if any map
// is defined, then USE_MAP will also be defined. This constant
// is then checked and determines whether a UV variable is defined, etc.
function GetPrismMapsDefinitionChunk(flag) {
  var def = ["#if defined( USE_SURFACE_ALBEDO_MAP )" +
  " || defined( USE_SURFACE_ROUGHNESS_MAP )" +
  " || defined( USE_SURFACE_CUTOUT_MAP )" +
  " || defined( USE_SURFACE_ANISOTROPY_MAP )" +
  " || defined( USE_SURFACE_ROTATION_MAP )" +
  " || defined( USE_OPAQUE_ALBEDO_MAP )" +
  " || defined( USE_OPAQUE_F0_MAP )" +
  " || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )" +
  " || defined( USE_LAYERED_BOTTOM_F0_MAP )" +
  " || defined( USE_LAYERED_F0_MAP )" +
  " || defined( USE_LAYERED_DIFFUSE_MAP )" +
  " || defined( USE_LAYERED_FRACTION_MAP )" +
  " || defined( USE_LAYERED_ROUGHNESS_MAP )" +
  " || defined( USE_LAYERED_ANISOTROPY_MAP )" +
  " || defined( USE_LAYERED_ROTATION_MAP )" +
  " || defined( USE_METAL_F0_MAP )" +
  " || defined( USE_SURFACE_NORMAL_MAP )" +
  " || defined( USE_LAYERED_NORMAL_MAP )",
  "#define " + flag,
  "#endif"].
  join("\n");
  return def;
}

macros['prism_check'] = GetPrismMapsDefinitionChunk;

// Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.
// If it's not defined, then a simply copy occurs, e.g. "surfaceAlbedo = surface_albedo;" from the variableName and mapType.
function GetPrismMapSampleChunk(mapType, variableName, isFloat, linearize) {
  var suffix = isFloat ? "_v3" : "";
  var declare = isFloat ? "vec3 " : "";
  var average = isFloat ? variableName + " = average(" + variableName + suffix + ");" : "";
  var colorLinearization = linearize ? variableName + suffix + " = SRGBToLinear(" + variableName + suffix + ");" : "";
  var shader = [
  "#if defined( USE_" + mapType.toUpperCase() + "_MAP )",
  // note: the tiling system needs to modify the uv of the texture per tile, so we use the modified "uv" here, not vUv.
  "vec2 uv_" + mapType + "_map = (" + mapType + "_map_texMatrix * vec3(uv, 1.0)).xy;",
  mapType.toUpperCase() + "_CLAMP_TEST;",
  declare + variableName + suffix + " = texture2D(" + mapType + "_map, uv_" + mapType + "_map).xyz;",
  colorLinearization,
  "if(" + mapType + "_map_invert) " + variableName + suffix + " = vec3(1.0) - " + variableName + suffix + ";",
  average,
  "#else",
  variableName + " = " + mapType + ";",
  "#endif"].
  join("\n");

  return shader;
}

macros['prism_sample_texture'] = function (mapType, varName, isFloat, linearize) {
  return GetPrismMapSampleChunk(mapType, varName, isFloat === 'true', linearize === 'true');
};

function GetPrismMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapInvt = mapName + "_invert";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform bool " + mapInvt + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_uniforms'] = GetPrismMapUniformChunk;

function GetPrismBumpMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapScale = mapName + "_bumpScale";
  var mapType = mapName + "_bumpmapType";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform vec2 " + mapScale + ";",
  "uniform int " + mapType + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_bump_uniforms'] = GetPrismBumpMapUniformChunk;

// Precompile regexes for the macros
var _regExCache = {};
for (name in macros) {
  _regExCache[name] = new RegExp('#' + name + ' *<([\\w\\d., ]*)>', 'g');
}

/**
   * Recursively resolves include directives and macros.
   * @param {string} source Original shader code.
   * @returns {string} Shader code with all includes resolved.
   */
var resolve = function resolve(source) {
  for (var name in macros) {
    var re = _regExCache[name];
    source = source.replace(re, function (match, parens) {
      var params = parens.split(',').map(function (param) {return param.trim();});
      return macros[name].apply(null, params);
    });
  }

  var pattern = /#include *<([\w\d.]+)>/g;
  var func = function func(match, include) {
    if (!chunks[include]) {
      throw new Error('Cannot resolve #include<' + include + '>');
    }
    return resolve(chunks[include]);
  };
  return source.replace(pattern, func);
};

// The chunks don't have to be exported anymore, but we keep them
// for backwards compatibility (they're still referenced in LegacyNamespace.js)
var PackDepthShaderChunk = chunks['pack_depth'];
var TonemapShaderChunk = chunks['tonemap'];
var OrderedDitheringShaderChunk = chunks['ordered_dither'];
var CutPlanesShaderChunk = chunks['cutplanes'];
var PackNormalsShaderChunk = chunks['pack_normals'];
var HatchPatternShaderChunk = chunks['hatch_pattern'];
var EnvSamplingShaderChunk = chunks['env_sample'];
var IdVertexDeclaration = chunks['id_decl_vert'];
var IdVertexShaderChunk = chunks['id_vert'];
var IdFragmentDeclaration = chunks['id_decl_frag'];
var IdOutputShaderChunk = chunks['id_frag'];
var FinalOutputShaderChunk = chunks['final_frag'];
var ThemingFragmentDeclaration = chunks['theming_decl_frag'];
var ThemingFragmentShaderChunk = chunks['theming_frag'];
var InstancingVertexDeclaration = chunks['instancing_decl_vert'];
var ShadowMapDeclareCommonUniforms = chunks['shadowmap_decl_common'];
var ShadowMapVertexDeclaration = chunks['shadowmap_decl_vert'];
var ShadowMapVertexShaderChunk = chunks['shadowmap_vert'];
var ShadowMapFragmentDeclaration = chunks['shadowmap_decl_frag'];
var PointSizeDeclaration = chunks['decl_point_size'];
var PointSizeShaderChunk = chunks['point_size'];

var ShaderChunks = {
  IdUniforms: IdUniforms,
  ThemingUniform: ThemingUniform,
  CutPlanesUniforms: CutPlanesUniforms,
  ShadowMapCommonUniforms: ShadowMapCommonUniforms,
  ShadowMapUniforms: ShadowMapUniforms,
  PointSizeUniforms: PointSizeUniforms,
  WideLinesUniforms: WideLinesUniforms,
  DepthTextureUniforms: DepthTextureUniforms,

  PackDepthShaderChunk: PackDepthShaderChunk,
  TonemapShaderChunk: TonemapShaderChunk,
  OrderedDitheringShaderChunk: OrderedDitheringShaderChunk,
  CutPlanesShaderChunk: CutPlanesShaderChunk,
  PackNormalsShaderChunk: PackNormalsShaderChunk,
  HatchPatternShaderChunk: HatchPatternShaderChunk,
  EnvSamplingShaderChunk: EnvSamplingShaderChunk,
  IdVertexDeclaration: IdVertexDeclaration,
  IdVertexShaderChunk: IdVertexShaderChunk,
  IdFragmentDeclaration: IdFragmentDeclaration,
  IdOutputShaderChunk: IdOutputShaderChunk,
  FinalOutputShaderChunk: FinalOutputShaderChunk,
  ThemingFragmentDeclaration: ThemingFragmentDeclaration,
  ThemingFragmentShaderChunk: ThemingFragmentShaderChunk,
  InstancingVertexDeclaration: InstancingVertexDeclaration,
  ShadowMapDeclareCommonUniforms: ShadowMapDeclareCommonUniforms,
  ShadowMapVertexDeclaration: ShadowMapVertexDeclaration,
  ShadowMapVertexShaderChunk: ShadowMapVertexShaderChunk,
  ShadowMapFragmentDeclaration: ShadowMapFragmentDeclaration,
  PointSizeDeclaration: PointSizeDeclaration,
  PointSizeShaderChunk: PointSizeShaderChunk,

  GetPrismMapSampleChunk: GetPrismMapSampleChunk,
  GetPrismMapUniformChunk: GetPrismMapUniformChunk,

  resolve: resolve };

/***/ }),

/***/ "./src/wgs/render/ShaderPass.js":
/*!**************************************!*\
  !*** ./src/wgs/render/ShaderPass.js ***!
  \**************************************/
/*! exports provided: ShaderPass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderPass", function() { return ShaderPass; });
/* harmony import */ var _ShaderUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderUtils */ "./src/wgs/render/ShaderUtils.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);



var ShaderPass = function ShaderPass(shader, textureID) {

  this.textureID = textureID !== undefined ? textureID : "tDiffuse";

  this.material = Object(_ShaderUtils__WEBPACK_IMPORTED_MODULE_0__["createShaderMaterial"])(shader);

  // share uniforms with material
  this.uniforms = this.material.uniforms;

  this.renderToScreen = false;

  this.enabled = true;
  this.clear = false;

  this.camera = new three__WEBPACK_IMPORTED_MODULE_1__["OrthographicCamera"](-1, 1, 1, -1, 0, 1);

  //this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.material );

  //Instead of using a screen quad we use a large triangle -- this is slightly
  //faster (~6% measured in our specific case), due to better cache coherency. See this article:
  //http://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
  var triangle = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
  var p = new Float32Array(9);
  p[0] = -1;p[1] = -1;p[2] = 0;
  p[3] = 3;p[4] = -1;p[5] = 0;
  p[6] = -1;p[7] = 3;p[8] = 0;

  var uv = new Float32Array(6);
  uv[0] = 0;uv[1] = 0;
  uv[2] = 2;uv[3] = 0;
  uv[4] = 0;uv[5] = 2;

  var n = new Float32Array(9);
  n[0] = 0;n[1] = 0;n[2] = 1;
  n[3] = 0;n[4] = 0;n[5] = 1;
  n[6] = 0;n[7] = 0;n[8] = 1;


  triangle.addAttribute("position", new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](p, 3));
  triangle.addAttribute("normal", new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](n, 3));
  triangle.addAttribute("uv", new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](uv, 2));

  this.quad = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](triangle, this.material);


  this.scene = new three__WEBPACK_IMPORTED_MODULE_1__["Scene"]();
  this.scene.add(this.quad);
};

ShaderPass.prototype = {

  // note: delta is not used
  render: function render(renderer, writeBuffer, readBuffer, delta) {

    if (this.uniforms[this.textureID]) {

      this.uniforms[this.textureID].value = readBuffer.texture || readBuffer;

    }

    if (this.renderToScreen || !writeBuffer) {

      renderer.render(this.scene, this.camera);

    } else {

      renderer.render(this.scene, this.camera, writeBuffer, this.clear);

    }

  } };

/***/ }),

/***/ "./src/wgs/render/ShaderUtils.js":
/*!***************************************!*\
  !*** ./src/wgs/render/ShaderUtils.js ***!
  \***************************************/
/*! exports provided: createShaderMaterial, setMacro, removeMacro */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShaderMaterial", function() { return createShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMacro", function() { return setMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeMacro", function() { return removeMacro; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);


/** Create ShaderMaterial instance using a given shader specification
                                 *
                                 *   @param {Object} shader - Shader specification E.g., CopyShader. Must provide vertexShader and fragmentShader.
                                 *                            May provide uniforms, defines, and attributes. See CopyShader for example.
                                 *   @returns {THREE.ShaderMaterial}
                                 */
var createShaderMaterial = function createShaderMaterial(shader) {
  var params = {
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader };


  // only add these fields if the shader actually needs them, because keys with undefined values
  // would cause errors in THREE.Material
  if (shader.uniforms) params.uniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].clone(shader.uniforms);
  if (shader.defines) params.defines = Object.assign({}, shader.defines);
  if (shader.extensions) params.extensions = Object.assign({}, shader.extensions);

  // Note that these are shared, because they are usually not modified afterwards
  if (shader.attributes) params.attributes = shader.attributes;

  return new three__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"](params);
};

/** Add custom macro to given material. Note that macro modification requires expensive shader recompile.
    *   @param {THREE.Material} material
    *   @param {string}         macroName
    *   @param {string}         [macroValue=""]
    **/
var setMacro = function setMacro(material, macroName, macroValue) {

  // default to "" (for simple toggles)
  macroValue = macroValue || "";

  // create defines object if needed
  if (!material.defines) {
    material.defines = {};
  }

  // change macro and trigger update if needed
  if (material.defines[macroName] != macroValue) {
    material.defines[macroName] = macroValue;
    material.needsUpdate = true;
  }
};

/** Remove custom macro to given material. Note that macro modification requires expensive shader recompile.
    *   @param {THREE.Material} material
    *   @param {string}         macroName
    **/
var removeMacro = function removeMacro(material, macroName) {

  // skip material update if nothing changed
  if (material.defines || material.defines[macroName]) {

    // Note that we cannot just assign undefined here, because this would
    // produce a "#define <MACRONAME> undefined" string in the shader (see FireFlyWebGlProgram.js)
    // Fortunately, removing macros doesn't happen per-frame, and it requires shader-recompile anyway.
    delete material.defines[macroName];

    material.needsUpdate = true;
  }
};

/***/ }),

/***/ "./src/wgs/render/chunks/cutplanes.glsl":
/*!**********************************************!*\
  !*** ./src/wgs/render/chunks/cutplanes.glsl ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/decl_point_size.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/decl_point_size.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform float point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/depth_texture.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/depth_texture.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/env_sample.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/env_sample.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/final_frag.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/final_frag.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#ifdef MRT_NORMALS\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n";

/***/ }),

/***/ "./src/wgs/render/chunks/float3_average.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/float3_average.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/hatch_pattern.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/hatch_pattern.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/hsv.glsl":
/*!****************************************!*\
  !*** ./src/wgs/render/chunks/hsv.glsl ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 rgb2hsv(vec3 color)\n{\n    float delta;\n    float colorMax, colorMin;\n    float h,s,v;\n    vec3 hsv;\n    colorMax = max(color.r,color.g);\n    colorMax = max(colorMax,color.b);\n    colorMin = min(color.r,color.g);\n    colorMin = min(colorMin,color.b);\n    v = colorMax;\n    if(colorMax != 0.0)\n    {\n        s = (colorMax - colorMin)/colorMax;\n    }\n    else\n    {\n        s = 0.0;\n    }\n    if(s != 0.0)\n    {\n        delta = colorMax-colorMin;\n        if (color.r == colorMax)\n        {\n            h = (color.g-color.b)/delta;\n        }\n        else if (color.g == colorMax)\n        {\n            h = 2.0 + (color.b-color.r) / delta;\n        }\n        else\n        {\n            h = 4.0 + (color.r-color.g)/delta;\n        }\n        h /= 6.0;\n        if( h < 0.0)\n        {\n            h +=1.0;\n        }\n    }\n    else\n    {\n        h = 0.0;\n    }\n    hsv = vec3(h,s,v);\n    return hsv;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 color;\n    float f,p,q,t;\n    float h,s,v;\n    float i,hi;\n    {\n        h = hsv.x*6.0;\n        s = hsv.y;\n        v = hsv.z;\n        i = floor(h);\n        f = h-i;\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n        float r,g,b;\n        if (i == 0.0)\n        {\n            r = v;\n            g = t;\n            b = p;\n        }\n        else if (i == 1.0)\n        {\n            r = q;\n            g = v;\n            b = p;\n        }\n        else if (i == 2.0)\n        {\n            r = p;\n            g = v;\n            b = t;\n        }\n        else if (i == 3.0)\n        {\n            r = p;\n            g = q;\n            b = v;\n        }\n        else if (i == 4.0)\n        {\n            r = t;\n            g = p;\n            b = v;\n        }\n        else\n        {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r,g,b);\n    }\n    return color;\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\n    varying highp float depth;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n    #ifdef USE_VERTEX_ID\n        varying vec3 vId;\n    #elif defined(LINE_2D_SHADER)\n        varying vec4 dbId;\n    #else\n        uniform vec3 dbId;\n    #endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\n    uniform vec3 modelId;\n#endif\n#ifdef _LMVWEBGL2_\n    #if defined(MRT_NORMALS)\n        layout(location = 1) out vec4 outNormal;\n        #if defined(MRT_ID_BUFFER)\n            layout(location = 2) out vec4 outId;\n            #if defined(MODEL_COLOR)\n                layout(location = 3) out vec4 outModelId;\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        layout(location = 1) out vec4 outId;\n        #if defined(MODEL_COLOR)\n            layout(location = 2) out vec4 outModelId;\n        #endif\n    #endif\n#else\n    #define gl_FragColor gl_FragData[0]\n    #if defined(MRT_NORMALS)\n        #define outNormal gl_FragData[1]\n        #if defined(MRT_ID_BUFFER)\n            #define outId gl_FragData[2]\n            #if defined(MODEL_COLOR)\n                #define outModelId gl_FragData[3]\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        #define outId gl_FragData[1]\n        #if defined(MODEL_COLOR)\n            #define outModelId gl_FragData[2]\n        #endif\n    #endif\n#endif";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_vert.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_vert.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_frag.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_frag.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\n    vec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n    #ifndef ENABLE_ID_DISCARD\n        const float writeId = 1.0;\n    #endif\n    outId = vec4(dbId.rgb, writeId);\n    #ifdef MODEL_COLOR\n        outModelId = vec4(modelId.rgb, writeId);\n    #endif\n#elif defined(ID_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_vert.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_vert.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/instancing_decl_vert.glsl":
/*!*********************************************************!*\
  !*** ./src/wgs/render/chunks/instancing_decl_vert.glsl ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/line_decl_common.glsl":
/*!*****************************************************!*\
  !*** ./src/wgs/render/chunks/line_decl_common.glsl ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define LINE_2D_SHADER 1\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\n#define LTSCALE 0.25\nvarying vec4 fsColor;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n#ifdef LOADING_ANIMATION\nvarying float loadingProgress;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/normal_map.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/normal_map.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\nvoid heightMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    N = normalize(\n        N + (\n            diff.x * T * bumpScale.x +\n            diff.y * B * bumpScale.y\n        )\n    );\n}\nvoid normalMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\n    mapN.xy *= bumpScale.x;\n    mapN.z *= bumpScale.y;\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n    float c = -mapN.z;\n    mat3 skewV = mat3(\n        0.0, v.z, -v.y,\n        -v.z, 0.0, v.x,\n        v.y, -v.x, 0.0\n    );\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\n    N *= rot;\n    T *= rot;\n    B *= rot;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/ordered_dither.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/ordered_dither.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_depth.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/pack_depth.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_normals.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/pack_normals.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/point_size.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/point_size.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_PointSize = point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_glazing.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/prism_glazing.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \n{ \n   vec3 limit = max(1.0 - f0, 0.00001); \n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \n} \nfloat ColorToIlluminance(in vec3 color) \n{ \n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \n   float illuminance = dot(rgb2grey, color); \n   return illuminance; \n} \nvoid applyPrismGlazingOpacity(\n    inout vec4 color,\n    vec3 transmissionF,\n    float transmissionAlpha,\n    float NdotV,\n    float glazingIlluminace) \n{\n    const float third = 1.0/3.0; \n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \n    opacity = clamp(opacity, 0.01, 0.99);\n    color.a *= opacity;\n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_transparency.glsl":
/*!*******************************************************!*\
  !*** ./src/wgs/render/chunks/prism_transparency.glsl ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "void applyPrismTransparency(\n    inout vec4 color,\n    vec3 transparentColor,\n    float transparentIor\n) {\n    float fsLevel = max(max(color.r, color.g), color.b);\n    color = vec4(color.rgb/fsLevel, fsLevel);\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\n    transLevel = min( (1.0 - surface_roughness), transLevel );\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\n    vec3 tr_g_color = sqrt(transparentColor);\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\n    color = mix(transColor, color, strength);\n    color.a = max(color.a, 0.05);\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\n        color.a = 0.0;\n    }\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_wood.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/prism_wood.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined( PRISMWOOD )\n#define ONE 0.00390625\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    return clamp(transPixels * 0.5, 0.0, 1.0);\n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\n                              float depthVar)\n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\n    return clamp(porePixels, 0.0, 1.0);\n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\n                          float depthVar)\n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{\n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#if defined(PRISMWOODBUMP)\nvoid getFinalWoodContext(\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\n) {\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n}\n#endif\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_common.glsl":
/*!**********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_common.glsl ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_frag.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_vert.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_vert.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_vert.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_decl_frag.glsl":
/*!******************************************************!*\
  !*** ./src/wgs/render/chunks/theming_decl_frag.glsl ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform vec4 themingColor;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/theming_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n";

/***/ }),

/***/ "./src/wgs/render/chunks/tonemap.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/tonemap.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_decl.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_decl.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_vert.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_vert.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n";

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=PixelCompare.js.map