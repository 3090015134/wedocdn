/*!
 * LMV v7.17.1
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Edit2D =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Edit2D/Edit2D.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Edit2D/Actions.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Actions.js ***!
  \**************************************/
/*! exports provided: Actions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return Actions; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.
//
// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. 
// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)


var

Action = /*#__PURE__*/function () {
  function Action(layer) {_classCallCheck(this, Action);
    this.layer = layer;
  }_createClass(Action, [{ key: "undo", value: function undo()

    {
      throw new Error('Abstract method invoked');
    } }, { key: "redo", value: function redo()

    {
      throw new Error('Abstract method invoked');
    } }]);return Action;}();var


AddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);
  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddShape).call(this, layer));
    _this.shape = shape;return _this;
  }_createClass(AddShape, [{ key: "undo", value: function undo()

    {
      this.layer.removeShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.addShape(this.shape);
    } }]);return AddShape;}(Action);var


AddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);

  // @param {Shape[]} shapes
  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddShapes).call(this, layer));
    _this2.shapes = shapes;return _this2;
  }_createClass(AddShapes, [{ key: "undo", value: function undo()

    {var _this3 = this;
      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this4 = this;
      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});
    } }]);return AddShapes;}(Action);var


MoveShape = /*#__PURE__*/function (_Action3) {_inherits(MoveShape, _Action3);
  function MoveShape(layer, shape, dx, dy) {var _this5;_classCallCheck(this, MoveShape);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MoveShape).call(this, layer));
    _this5.shape = shape;
    _this5.delta = { x: dx, y: dy };

    // Note that transforming back and forth is not always exactly 1:1. 
    _this5.beforeState = _this5.shape.clone();
    _this5.afterState = _this5.shape.clone();

    _this5.afterState.move(dx, dy);return _this5;
  }_createClass(MoveShape, [{ key: "undo", value: function undo()

    {
      this.shape.copy(this.beforeState);
    } }, { key: "redo", value: function redo()

    {
      this.shape.copy(this.afterState);
    } }]);return MoveShape;}(Action);var


RemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);
  function RemoveShape(layer, shape) {var _this6;_classCallCheck(this, RemoveShape);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShape).call(this, layer));
    _this6.shape = shape;return _this6;
  }_createClass(RemoveShape, [{ key: "undo", value: function undo()

    {
      this.layer.addShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.removeShape(this.shape);
    } }]);return RemoveShape;}(Action);var



RemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);
  function RemoveShapes(layer, shapes) {var _this7;_classCallCheck(this, RemoveShapes);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShapes).call(this, layer));
    _this7.shapes = shapes.slice();return _this7;
  }_createClass(RemoveShapes, [{ key: "undo", value: function undo()

    {var _this8 = this;
      this.shapes.forEach(function (s) {return _this8.layer.addShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this9 = this;
      this.shapes.forEach(function (s) {return _this9.layer.removeShape(s);});
    } }]);return RemoveShapes;}(Action);var


AddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);
  function AddVertex(layer, poly, vIndex, p) {var _this10;_classCallCheck(this, AddVertex);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(AddVertex).call(this, layer));
    _this10.poly = poly;
    _this10.vIndex = vIndex;
    _this10.point = p.clone();return _this10;
  }_createClass(AddVertex, [{ key: "undo", value: function undo()

    {
      this.poly.removePoint(this.vIndex);
    } }, { key: "redo", value: function redo()

    {
      this.poly.insertPoint(this.vIndex, this.point);
    } }]);return AddVertex;}(Action);


// Only for polygons and polylines
var MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);
  function MoveVertex(layer, poly, vIndex, newPos) {var _this11;_classCallCheck(this, MoveVertex);
    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(MoveVertex).call(this, layer));
    _this11.poly = poly;
    _this11.vIndex = vIndex;
    _this11.posBefore = poly.getPoint(vIndex);
    _this11.posAfter = newPos.clone();return _this11;
  }_createClass(MoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.vIndex, this.posBefore.x, this.posBefore.y);
    } }, { key: "redo", value: function redo()
    {
      this.poly.updatePoint(this.vIndex, this.posAfter.x, this.posAfter.y);
    } }]);return MoveVertex;}(Action);


// Returns an object that allows for recovering all arc params assoicated with a vertex
var copyArcParams = function copyArcParams(poly, index) {
  if (!poly.isPath() || !poly.edgeIndexValid(index)) {
    return null;
  }

  var type = poly.getEdgeType(index);
  switch (type) {
    // Note that the getter already returns a copy
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:return poly.getEllipseArcParams(index);
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:return {
        cp1: poly.getControlPoint(index, 1),
        cp2: poly.getControlPoint(index, 2) };

    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:return null;
    default:console.warn('unexpected edge type');}

};

// Recover an arc based on the result returned by copyArcParam
var restoreArc = function restoreArc(poly, index, arcParams) {
  if (!arcParams) {
    // nothing to restore
    return;
  }

  if (arcParams instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]) {
    // recover ellipse arc
    poly.setEllipseArc(index, arcParams);
  } else if (arcParams.cp1) {
    // recover bezier arc
    var cp1 = arcParams.cp1;
    var cp2 = arcParams.cp2;
    poly.setBezierArc(index, cp1.x, cp1.y, cp2.x, cp2.y);
  }
};var

RemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);
  function RemoveVertex(layer, poly, vIndex) {var _this12;_classCallCheck(this, RemoveVertex);
    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveVertex).call(this, layer));
    _this12.poly = poly;
    _this12.vIndex = vIndex;
    _this12.point = poly.getPoint(vIndex);

    // For consistency and simplicity, we remove arcs if start or end vertex is removed.
    _this12.arcBefore = copyArcParams(poly, poly.edgeBeforeVertex(vIndex));
    _this12.arcAfter = copyArcParams(poly, poly.edgeAfterVertex(vIndex));return _this12;
  }_createClass(RemoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.insertPoint(this.vIndex, this.point);

      // recover arc params
      restoreArc(this.poly, this.poly.edgeBeforeVertex(this.vIndex), this.arcBefore);
      restoreArc(this.poly, this.poly.edgeAfterVertex(this.vIndex), this.arcAfter);
    } }, { key: "redo", value: function redo()

    {
      // remove arcs at edges starting/ending at the vertex
      if (this.poly.isPath()) {
        this.poly.removeArc(this.poly.edgeBeforeVertex(this.vIndex));
        this.poly.removeArc(this.poly.edgeAfterVertex(this.vIndex));
      }

      this.poly.removePoint(this.vIndex);
    } }]);return RemoveVertex;}(Action);



// Moves an edge to a new position specified by new positions for start and end vertex.
// Optionally, start and end vertex may be duplicated before moving the edge. In this case, the neighbar edges keep unchanged and
// we introduce new intermediate edges to connect the old start/end position with the new one.
var MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);

  // @param {EditLayer} layer
  // @param {Polybase}  poly      - must be at start before the change
  // @param {number}    edgeIndex - edge to be modified
  // @param {Vector3}   newPosA, newPosB
  // @param {bool}      duplicateStartVertex, duplicateEndVertex - Optional, start and end vertex of the edge may be duplicated.
  function MoveEdge(layer, poly, edgeIndex, newPosA, newPosB, duplicateStartVertex, duplicateEndVertex) {var _this13;_classCallCheck(this, MoveEdge);
    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(MoveEdge).call(this, layer));
    _this13.poly = poly;

    // store edge index
    _this13.edgeIndex = edgeIndex;

    // store duplicate flags
    _this13.duplicateStartVertex = duplicateStartVertex;
    _this13.duplicateEndVertex = duplicateEndVertex;

    var ia = edgeIndex;
    var ib = poly.nextIndex(ia);

    // get edge 
    var a = poly.getPoint(ia);
    var b = poly.getPoint(ib);

    _this13.edgeBefore = {
      a: a,
      b: b };

    _this13.edgeAfter = {
      a: newPosA.clone(),
      b: newPosB.clone() };return _this13;

  }_createClass(MoveEdge, [{ key: "undo", value: function undo()

    {
      // get current edgeIndex (after duplicating vertices)
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia);

      // Restore original edge positions
      this.poly.updatePoint(ia, this.edgeBefore.a.x, this.edgeBefore.a.y);
      this.poly.updatePoint(ib, this.edgeBefore.b.x, this.edgeBefore.b.y);

      // Remove extra vertices
      MoveEdge.revertDuplicateVertices(this.poly, this.edgeIndex, this.duplicateStartVertex, this.duplicateEndVertex);
    } }, { key: "redo", value: function redo()

    {
      // Duplicate start/end vertex if wanted
      MoveEdge.duplicateVertices(this.poly, this.edgeIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get edgeIndex after duplicating vertices
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia);

      // apply new positions
      this.poly.updatePoint(ia, this.edgeAfter.a.x, this.edgeAfter.a.y);
      this.poly.updatePoint(ib, this.edgeAfter.b.x, this.edgeAfter.b.y);
    }

    // Insert a duplicate of vertex i to position i+1. Note that vertex i only copies
    // the position. If vertex i contained arc params, these will be at vertex i+1.
  }], [{ key: "duplicateVertex", value: function duplicateVertex(poly, index) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var p = poly.getPoint(index, null, loopIndex);
      poly.insertPoint(index, { x: p.x, y: p.y });
    }

    // Duplicates start and/or end vertex of a given edge in a polyline/polygon.
  }, { key: "duplicateVertices", value: function duplicateVertices(poly, edgeIndex, duplicateStartVertex, duplicateEndVertex) {

      var startVertex = edgeIndex;

      if (duplicateStartVertex) {
        MoveEdge.duplicateVertex(poly, startVertex);

        // After duplicating, the actual edge start vertex has shifted by 1.
        startVertex++;
      }

      if (duplicateEndVertex) {
        var vNext = poly.nextIndex(startVertex);
        MoveEdge.duplicateVertex(poly, vNext);
      }
    } }, { key: "revertDuplicateVertices",

    // Reverts the extra vertices inserted by duplicateVertices. Note that edgeIndex refers
    // to the polygon before duplicating the vertices, i.e., should be identical with 
    // the one used in the duplicateVertices(..) to be reverted.
    value: function revertDuplicateVertices(poly, edgeIndex, duplicateStartVertex, duplicateEndVertex) {

      // get edge index after considering vertex duplication
      var curEdgeIndex = MoveEdge.getNewEdgeIndex(poly, edgeIndex, duplicateStartVertex, duplicateEndVertex);

      // If the end vertex was duplicated, revert that now
      if (duplicateStartVertex) {

        // Note that it is important to remove the vertex BEFORE edge start instead of the edge start itself.
        // Although both have identical positions, the edge start vertex may contain additional arc params.
        var iPrev = curEdgeIndex - 1;
        poly.removePoint(iPrev);

        // This shifts the edgeIndex back by 1
        curEdgeIndex--;
      }

      if (duplicateEndVertex) {
        // Always remove the first of the two duplicate vertices. The first one is the copy that just contains
        // the position, while the second (=original) one may contain additional arc params.
        var iNext = poly.nextIndex(curEdgeIndex);
        poly.removePoint(iNext);
      }
    } }, { key: "getNewEdgeIndex",

    // If we duplicate start/end vertex of an edge, the index of that edge may change.
    // This function returns the new index of the edge after duplicating start/end vertex.
    //
    // Note: poly is assumed to contain the duplicated vertices.
    value: function getNewEdgeIndex(poly, edgeIndex, duplicateStartVertex, duplicateEndVertex) {

      var newIndex = edgeIndex;

      // Duplicating the start vertex always shift the edgeIndex by 1
      if (duplicateStartVertex) {
        newIndex++;
      }

      // get vertexCount of the polygon before insertion of duplicated vertices.
      var vertexCountBefore = poly.vertexCount - (duplicateStartVertex ? 1 : 0) - (duplicateEndVertex ? 1 : 0);

      // Check if edge was the 'closing edge' of the original polygon, i.e., the edge that 
      // connects the last vertex with vertex 0
      var isClosingEdge = edgeIndex === vertexCountBefore - 1;

      // Duplicating the end vertex may also shift the edgeIndex. This happens if the edge start
      // vertex is the last one in a polygon.
      if (duplicateEndVertex && isClosingEdge) {
        newIndex++;
      }
      return newIndex;
    } }]);return MoveEdge;}(Action);


// Change arc type of a Path edge. It can also be used to change arc params without changing the actual type.
var ChangeEdgeType = /*#__PURE__*/function (_Action10) {_inherits(ChangeEdgeType, _Action10);

  // @param {EditLayer} layer
  // @param {Path}      path  - must be in "before" state of the action
  // @param {number}    edgeIndex
  // @param {EdgeType}  edgeType
  // @param {Vector2}   [cp1] - Control points. Only needed when changing to Bezier
  // @param {Vector2}   [cp2]
  // @param {EllipseArcParams} [arcParams] - only needed when changing to EllipseArc
  function ChangeEdgeType(layer, path, edgeIndex, edgeType, cp1, cp2, arcParams) {var _this14;_classCallCheck(this, ChangeEdgeType);
    _this14 = _possibleConstructorReturn(this, _getPrototypeOf(ChangeEdgeType).call(this, layer));

    _this14.path = path;
    _this14.edgeIndex = edgeIndex;

    // Store previous edge props
    var isBezier = path.isBezierArc(edgeIndex);
    _this14.oldEdgeType = path.getEdgeType(edgeIndex);
    _this14.oldCp1 = isBezier && path.getControlPoint(edgeIndex, 1);
    _this14.oldCp2 = isBezier && path.getControlPoint(edgeIndex, 2);
    _this14.oldEllipseArcParams = path.getEllipseArcParams(edgeIndex);

    // Store new control points (if any)
    _this14.newEdgeType = edgeType;
    _this14.newCp1 = cp1;
    _this14.newCp2 = cp2;
    _this14.newEllipseArcParams = arcParams;return _this14;
  }_createClass(ChangeEdgeType, [{ key: "redo", value: function redo()

    {
      switch (this.newEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.newEllipseArcParams);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.newCp1.x, this.newCp1.y, this.newCp2.x, this.newCp2.y);break;}

    } }, { key: "undo", value: function undo()

    {
      switch (this.oldEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.oldCp1.x, this.oldCp1.y, this.oldCp2.x, this.oldCp2.y);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.oldEllipseArcParams);break;}

    } }]);return ChangeEdgeType;}(Action);var


ApplyCutOut = /*#__PURE__*/function (_Action11) {_inherits(ApplyCutOut, _Action11);

  function ApplyCutOut(layer, cutPath) {var _this15;_classCallCheck(this, ApplyCutOut);
    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(ApplyCutOut).call(this, layer));

    // collect all other polygons and closed paths in the layer that overlap the cutPath bbox
    var cutBox = cutPath.getBBox();
    _this15.paths = layer.shapes.filter(function (s) {

      if (s === cutPath) {
        return false;
      }

      // cutout is only be applied on Polygons and closed Paths
      var isClosed = s instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && s.isClosed;
      if (!isClosed) {
        return false;
      }

      var box = s.getBBox();
      return cutBox.isIntersectionBox(box);
    });

    // subtract cutPath from all overlapping shapes
    _this15.clippedPaths = _this15.paths.map(function (p) {
      return _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].apply(p, cutPath, _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].Operator.Difference);
    });

    // create backups of original paths before cutout
    _this15.originalShapes = _this15.paths.map(function (p) {return p.clone();});return _this15;
  }_createClass(ApplyCutOut, [{ key: "redo", value: function redo()

    {var _this16 = this;
      // replace all shapes by clipped versions
      this.paths.forEach(function (p, i) {return p.copy(_this16.clippedPaths[i]);});
      this.layer.update();
    } }, { key: "undo", value: function undo()

    {var _this17 = this;
      // replace all shapes by original versions
      this.paths.forEach(function (p, i) {return p.copy(_this17.originalShapes[i]);});
    } }]);return ApplyCutOut;}(Action);


var Actions = {
  Action: Action,
  AddShape: AddShape,
  AddShapes: AddShapes,
  MoveShape: MoveShape,
  RemoveShape: RemoveShape,
  RemoveShapes: RemoveShapes,
  AddVertex: AddVertex,
  MoveVertex: MoveVertex,
  RemoveVertex: RemoveVertex,
  MoveEdge: MoveEdge,
  ChangeEdgeType: ChangeEdgeType,
  ApplyCutOut: ApplyCutOut };

/***/ }),

/***/ "./extensions/Edit2D/AngleSnapper.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleSnapper.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleSnapper; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. 
//
// If pMov is the vertex being moved, the snapping behavior includes:
//
//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.
//
//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.
//
//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.
//
//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.
//

// A SnapLine is a line that we consider for snapping. 
var SnapLine = /*#__PURE__*/function () {

  function SnapLine(a, b) {_classCallCheck(this, SnapLine);

    // start and end point
    this.a = a.clone();
    this.b = b.clone();

    // normalized edge direction
    this.dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);
  }

  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.
  // @returns {bool} true on success
  _createClass(SnapLine, [{ key: "intersect", value: function intersect(line, outPoint) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(this.a, this.dir, line.a, line.dir, outPoint);
    }

    // project point to SnapLine
  }, { key: "snapToLine", value: function snapToLine(p) {
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(p, this.a, this.dir);
    }

    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.
  }, { key: "isUsable", value: function isUsable(p, snapRadius) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointLineDistance(p, this.a, this.dir) < snapRadius;
    }

    // Checks if a SnapLine is (approx.) identical with another one
  }, { key: "isEqual", value: function isEqual(snapLine, precision) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].collinear(this.a, this.dir, snapLine.a, snapLine.dir, precision);
    } }]);return SnapLine;}();
;

// Snap position based on 1 or 2 SnapLines.
//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place
//  @param {SnapLine} snapLine1   - First line to snap to
//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.
// Preconditions:
//  - SnapLine1: Is close to pos (wrt. to snap tolerance)
//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  
var snapToLines = function snapToLines(pos, snapLine1, snapLine2) {

  // No snaplines => keep original pos
  if (!snapLine1 && !snapLine2) {
    return;
  }

  // If only SnapLine1 exists
  if (!snapLine2) {
    // project pos to snapLine1
    snapLine1.snapToLine(pos);
    return;
  }

  // If only snapLine2 exists
  if (!snapLine1) {
    // project pos to snapLine2
    snapLine2.snapToLine(pos);
    return;
  }

  // Snap pos to line intersection.
  snapLine1.intersect(snapLine2, pos);
};

// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.
// Accepts negative indices up to -this.poly.length.
var getPointMod = function getPointMod(poly, index) {
  index = (index + poly.vertexCount) % poly.vertexCount;
  return poly.getPoint(index);
};

// Returns an array of SnapLines used to align with each edge of the given polygon.
//  @param {Polygon} poly
//  @param {vIndex}  vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.
var findSnapLines = function findSnapLines(poly, vIndex) {

  // tmp vectors
  var normal = new THREE.Vector2();
  var center = new THREE.Vector2();
  var pEnd = new THREE.Vector2();

  var snapLines = [];

  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.
  // and adds it to snapLines.
  // Generated snapLines are:
  //  - Line spanned by the edge
  //  - Orthogonal lines at start, center, and end point.
  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {

    // add line spanned by the edge
    snapLines.push(new SnapLine(a, b));

    // get edge normal and center point
    normal = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b, normal));
    center = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeCenter(a, b, center);

    // add orthogonal line add edge start
    pEnd.copy(a).add(normal); // pEnd = p1 + normal
    snapLines.push(new SnapLine(a, pEnd));

    // add orthogonal line at edge center
    pEnd.copy(center).add(normal); // pEnd = center + normal
    snapLines.push(new SnapLine(center, pEnd));

    // add orthogonal line at edge end
    pEnd.copy(b).add(normal); // pEnd = p2 + normal
    snapLines.push(new SnapLine(b, pEnd));
  };

  poly.enumEdges(function (a, b, ia, ib) {

    // Exclude edges containing the moved vertex: These edges are not fixed yet and should not
    // be used for alignment.
    if (ia == vIndex || ib == vIndex) {
      return;
    }

    // skip edge if degenerate
    if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(a, b)) {
      return;
    }

    addEdgeSnapLines(a, b);
  });
  return snapLines;
};

// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.
// A candidate is only suitable if...
//  1. The intersection with snapLine1 is within snapping tolerance
//  2. The angle formed with snapLine1 is as closer to 90° than all other candidates. This makes sure that we rather 
//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.
// 
//  @param {SnapLine} candidate       - SnapLine candidates to be compared    
//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)
//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.
//  @param {Vector2}  pos             - position to be snapped
//  @param {number}   snapRadius      - in layer coords
//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate
var checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {

  // If candidate does not intersect snapLine1, we cannot use it.
  var pIntersect = new THREE.Vector2();
  if (!snapLine1.intersect(candidate, pIntersect)) {
    return bestCandidate;
  }

  // If intersection point is outside snapRadius, discard candidate
  if (pIntersect.distanceTo(pos) > snapRadius) {
    return bestCandidate;
  }

  // If there is no competitor, the candidate made it.
  if (!bestCandidate) {
    return candidate;
  }

  // Check which of the candidates is "less parallel" to snapLine1
  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));
  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));
  return dp1 > dp2 ? candidate : bestCandidate;
};

var xAxis = new THREE.Vector2(1, 0);

var av = Autodesk.Viewing;
// AngleSnapper helps to draw right angles, parallel lines etc.
var AngleSnapper = /*#__PURE__*/function () {

  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);
    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.
    this.poly = null;

    // Index of the vertex in this.poly that is beging moved.
    this.vIndex = -1;

    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle
    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];

    // We consider an angle "close to" another one if they differ by this value or less.
    this.snapAngleTolerance = 2; // in degrees

    // Allow snapping to lines within x pixels.
    this.snapRadius = 10;

    this.gizmoLayer = gizmoLayer;
    this.setGlobalManager(gizmoLayer.globalManager);

    // reused tmp points
    this.movedPoint = new THREE.Vector2(); // the vertex being moved
    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint
    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint

    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint
    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis

    // Array of snapLines to align a vertex position with other edges
    this.edgeSnapLines = [];

    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.
    this.snapLine1 = null;
    this.snapLine2 = null;

    // Optional: External line constraint. This is used if we already snapped to a line geometry and
    //           want to combine the snap with angle snapping.
    this.snapLineExt = null;

    // Gizmos to display the lines considered for snapping
    this.snapLineStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineColor: 'rgb(255, 0, 0)',
      lineWidth: 1.0,
      lineStyle: 10 });

    this.snapLineGizmos = [];
    this.snapLineGizmosUsed = 0;
  }_createClass(AngleSnapper, [{ key: "onSetGlobalManager", value: function onSetGlobalManager(

    globalManager) {
      this.globalManager = globalManager;
      this.snapLineGizmos.forEach(function (g) {return g.setGloblaManager(globalManager);});
    } }, { key: "acquireSnapLineGizmo", value: function acquireSnapLineGizmo()

    {
      var gizmo = this.snapLineGizmos[this.snapLineGizmosUsed];
      if (!gizmo) {
        // Create new line gizmo
        gizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
        gizmo.setGlobalManager(this.globalManager);
        this.snapLineGizmos[this.snapLineGizmosUsed] = gizmo;
      }
      this.snapLineGizmosUsed++;
      return gizmo;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {var _this = this;
      var removeGizmo = function removeGizmo(g) {return _this.gizmoLayer.removeShape(g);};
      this.snapLineGizmos.forEach(removeGizmo);
      this.snapLineGizmosUsed = 0;
    }

    // Configures snapping to align to edges of the given polygon/polyline
    //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.
    //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.
  }, { key: "startSnapping", value: function startSnapping(poly, vIndex) {
      this.poly = poly;
      this.vIndex = vIndex;

      // precompute snapLines for alignment. These don't change while moving a vertex.
      this.edgeSnapLines = findSnapLines(poly, vIndex);
    } }, { key: "stopSnapping", value: function stopSnapping()

    {

      this.poly = null;
      this.vIndex = -1;

      // Discard any outdated results and hide gizmos
      this.snapLine1 = null;
      this.snapLine2 = null;
      this.clearSnappingGizmos();
    }

    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when
    // snapping while snapping is bypassed.
  }, { key: "clearSnappingResult", value: function clearSnappingResult() {
      this.snapLine1 = null;
      this.snapLine2 = null;
    } }, { key: "getPrevSnapLine",





    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the previous edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
    value: function getPrevSnapLine(pMov) {

      // Get vertices one and two indices before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1);
      var pPrev2 = getPointMod(this.poly, this.vIndex - 2);

      // Check angle between (pPrev, pMov) and its predecessor edge (pPrev2, pPrev)
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pPrev2, pPrev);
      return this.computeAngleSnapLine(pMov, pPrev, alignAxis);
    }

    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the next edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
  }, { key: "getNextSnapLine", value: function getNextSnapLine(pMov) {

      // When moving one of the last two vertices of a polyline, there is actually no "next edge", because start and end
      // vertex are not connected. Therefore, we skip snapping to "next edge" for this case.
      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.vertexCount - 2;
      if (ignoreNextEdge) {
        return null;
      }

      var pNext = getPointMod(this.poly, this.vIndex + 1);
      var pNext2 = getPointMod(this.poly, this.vIndex + 2);

      // Snap to angle wrt. to next edge: (only for polygons)
      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pNext, pNext2, alignAxis);
      return this.computeAngleSnapLine(pMov, pNext, alignAxis);
    }

    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved
    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.
    //  @param {Vector2} pMov - Position to be snapped
    //  @param {Object}  [lineConstraint] - Optional: External line-constraint {a,b}. If specified, we only allow snapping to
    //                                                intersections with angle snapLines and the line (lineConstraint.a, lineConstraint.b).
  }, { key: "snapToAngle", value: function snapToAngle(pMov, lineConstraint) {var _this2 = this;

      // Reset the two lines that we consider for snapping.
      this.snapLine1 = null;
      this.snapLine2 = null;

      // Create snapLine from external line constraint (if specified)
      this.snapLineExt = lineConstraint && new SnapLine(lineConstraint.a, lineConstraint.b);

      if (!this.active || this.poly.vertexCount <= 1) {
        return;
      }

      // Get point before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1);

      // If we just have a single edge, we can only snap to angles relative to x-axis
      var isFirstEdge = this.poly.vertexCount == 2;
      if (isFirstEdge) {
        // Get closest angle-snap line relative to mainAxis (or null if no snapAngle is close enough)
        var snapAxis = this.computeAngleSnapLine(pMov, pPrev, xAxis);

        if (snapAxis && this.snapLineExt) {
          // If an external line constraint is set, snapAxis can only be considered as a secondary snap.
          // This means, we can only consider if it intersects with the costraint line and the intersection is close to pMov
          this.snapLine1 = checkSecondSnapCandidate(snapAxis, null, this.snapLineExt, pMov, snapRadiusLC);
        } else {
          // No other constraints. Just use the snapAxis (or no axis at all if snapAxis is null)
          this.snapLine1 = snapAxis;
        }

        snapToLines(pMov, this.snapLine1, this.snapLineExt);
        return;
      }

      var prevSnapLine = this.getPrevSnapLine(pMov);
      var nextSnapLine = this.getNextSnapLine(pMov);

      // get snapRadius in layer-coords. This is the maximum distance that we allow
      // between mouse pos and the final snap position that we obtain by projecting
      // to a SnapLine or by intersecting two SnapLines.
      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();

      // Filter to lines that are close enough to pMov
      var snapLineUsable = function snapLineUsable(snapLine) {

        if (!snapLine) {
          return false;
        }

        if (_this2.snapLineExt) {
          // Consider line-constraint: Only accept snapLine if...
          //  1. ...it intersects constraint line
          //  2. ...intersection point is within snapRadius.
          return Boolean(checkSecondSnapCandidate(snapLine, null, _this2.snapLineExt, pMov, snapRadiusLC));
        }

        // No constraint: Accept any snapLines within snapRadius
        return snapLine.isUsable(pMov, snapRadiusLC);
      };

      var candidates = this.edgeSnapLines.filter(snapLineUsable);

      // Reject prevSnapLine/nextSnapLine if they are not usable
      prevSnapLine = snapLineUsable(prevSnapLine) && prevSnapLine;
      nextSnapLine = snapLineUsable(nextSnapLine) && nextSnapLine;

      // choose first snapLine
      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];

      // Stop here if there is no snapping candidate at all
      if (!this.snapLine1) {
        return;
      }

      // If we have an external line constraint, we can only choose a single snapLine, because we already
      // have to intersect it with the external constraint line.
      if (this.snapLineExt) {
        return snapToLines(pMov, this.snapLine1, this.snapLineExt);
      }

      // If prev and next edge allow angle snapping, check if we can snap to both
      if (prevSnapLine && nextSnapLine) {
        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);
      }

      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,
      // check if we can snap to another edge to be aligned with other edges.
      if (!this.snapLine2) {
        for (var i = 0; i < candidates.length; i++) {
          var c = candidates[i];
          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);
        }
      }

      // We selected one or two SnapLines. Now, use them to decide snapped position
      return snapToLines(pMov, this.snapLine1, this.snapLine2);
    } }, { key: "isSnapped", value: function isSnapped()

    {
      return Boolean(this.snapLine1 || this.snapLine2);
    } }, { key: "updateSnapLineGizmos", value: function updateSnapLineGizmos(

    snappedPos) {var _this3 = this;

      // First, clear any outdated gizmos
      this.clearSnappingGizmos();

      if (!this.poly) {
        return;
      }

      // Collect all snapLines that we want to display
      //
      // Note that we don't just want to indicate SnapLines that actively affected the position,
      // but also the "accidentally" matched ones. E.g., if we snapped to a geometry intersection,
      // the actual snapping was not affected by angle snapping, but the resulting position may still
      // match with angle snapLines as well.
      var snapLinesToShow = [];

      // We consider the snapped position p to be "on a snapLine L" if the distance d(p,L) is within the tolerance below.
      var tolerance = 0.0001;
      var shouldBeShown = function shouldBeShown(sl) {return sl && sl.isUsable(snappedPos, tolerance);}; // Decides whether a SnapLine should be displayed

      // If we only have a single edge, angle snapping is only possible wrt. to main axes
      var isFirstEdge = this.poly.vertexCount == 2;

      // Collect SnapLines to display
      if (isFirstEdge) {
        // Just a single edge: Only snap if this first edge forms a snapping angle with x- or y-axis.
        var pPrev = getPointMod(this.poly, this.vIndex - 1);
        var snapAxis = this.computeAngleSnapLine(snappedPos, pPrev, xAxis);

        // Display snapAxis if the p is on this line
        if (snapAxis && shouldBeShown(snapAxis)) {
          snapLinesToShow.push(snapAxis);
        }
      } else {
        // Consider all edge snaplines that contain pSnappedPos
        snapLinesToShow = this.edgeSnapLines.filter(shouldBeShown);

        // Consider angles to previous and next edge
        var prevSnapLine = this.getPrevSnapLine(snappedPos);
        var nextSnapLine = this.getNextSnapLine(snappedPos);
        shouldBeShown(prevSnapLine) && snapLinesToShow.push(prevSnapLine);
        shouldBeShown(nextSnapLine) && snapLinesToShow.push(nextSnapLine);
      }

      // Eliminate duplicates: If a SnapLine is collinear with another one, displaying it would just cause artifacts.
      // Note: This is a brute-force n^2 loop. The number of SnapLines to display is usually small, so that this shouldn't be a problem.
      var isRelevant = function isRelevant(sl, index) {
        // Check if sl is a duplicate of any previous SnapLine
        var isDuplicate = false;
        for (var i = 0; i < index; i++) {
          var sl2 = snapLinesToShow[i];
          if (sl.isEqual(sl2, tolerance)) {
            isDuplicate = true;
            break;
          }
        }
        return !isDuplicate;
      };
      snapLinesToShow = snapLinesToShow.filter(isRelevant);

      // Choose SnapLineLength large enough to fill whole canvas
      var canvas = this.gizmoLayer.viewer.canvas;
      var diag = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
      var snapLineLength = this.gizmoLayer.getUnitsPerPixel() * diag;

      // A SnapLine indicator is constructed as follows:
      //  - It starts at the snapLine start point, which "explains where the SnapLine comes from". 
      //    This may be start/center/end of another edge.
      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)
      //  - It is enlarged to overshoot pMov 
      var showSnapLine = function showSnapLine(line, gizmo) {
        if (!line) {
          return;
        }

        var a = line.a;

        // Let line start at a, point towards dir, and be long enough to leave screen
        gizmo.makeLine(
        a.x - snapLineLength * line.dir.x,
        a.y - snapLineLength * line.dir.y,
        a.x + snapLineLength * line.dir.x,
        a.y + snapLineLength * line.dir.y);

        _this3.gizmoLayer.addShape(gizmo);
      };

      // Add lineGizmo for each SnapLine to be displayed
      for (var i = 0; i < snapLinesToShow.length; i++) {
        var snapLine = snapLinesToShow[i];
        var gizmo = this.acquireSnapLineGizmo();
        showSnapLine(snapLine, gizmo);
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.clearSnapping();
    }

    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.
    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.
    //  @param {Vector2} p              - vertex being moved
    //  @param {Vector2} pPrev          - vertex connected to p
    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.
  }, { key: "computeAngleSnapLine", value: function computeAngleSnapLine(p, pPrev, alignAxis) {

      // Don't try angle snapping with degenerated edges
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(pPrev, p)) {
        return null;
      }

      // get direction of new edge (ending at pMov)
      var edgeDir = p.clone().sub(pPrev);

      // Compute angle between new edge and alignment direction
      var angle = THREE.Math.radToDeg(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(edgeDir, alignAxis));

      // Check if angle matches with any index in snapAngles array
      var snapIndex = -1;
      for (var i = 0; i < this.snapAngles.length; i++) {
        var _snapAngle = this.snapAngles[i];

        var dif = Math.abs(_snapAngle - angle);
        if (dif < this.snapAngleTolerance) {
          snapIndex = i;
          break;
        }
      }

      // Stop here if no snapAngle is found
      if (snapIndex == -1) {
        return null;
      }

      // Rotate alignment axis by selected snapAngle
      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);
      var snapDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].rotateAround(alignAxis.clone(), snapAngle);

      // scale snapLine direction to the same length as (pPrev, p)
      var dist = pPrev.distanceTo(p);
      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);

      // Return snapline from pPrev pointing towards snapped direction
      return new SnapLine(pPrev, snapLineEnd);
    } }, { key: "active", get: function get() {return this.poly;} }]);return AngleSnapper;}();


av.GlobalManagerMixin.call(AngleSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/BooleanOps.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/BooleanOps.js ***!
  \*****************************************/
/*! exports provided: BooleanOps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanOps", function() { return BooleanOps; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");





var Operator = {
  Intersect: 1, // only keep regions where path1 and path2 are overlapping
  Union: 2, // unify both shapes
  Difference: 3, // path1 after removing all regions that are overlapped by path2
  Xor: 4 // only keep regions that are either covered by path1 or path2, but not both
};

// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop
// @param {Edges[]}            loopEdges    - edges of the loop that we test against.
// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.
var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {

  // Get all faces that we obtained by intersecting all edges against each other
  var regionFaces = solver.getFaces();

  // Get ordered array of loop edges within solver that correspond to the cutLoop
  var cutRegionEdges = SolidDef.getRegionEdges(solver, loopEdges);

  // Find all faces that are 
  return SolidDef.getBoundedRegionFaces(regionFaces, cutRegionEdges);
};

// Returns all faces that are "inside the given wireBody", whereby:
//  - All wires in wireBody must be closed loops without branching
//  - A face is considered as "inside" if it is enclosed by an odd number of wires ("Even-Odd-Rule")
//
// @param {SketchRegionSolver} solver   - initialized with all edges of subject and cutLoop
// @param {SolidDef.WireBody}  wireBody - must contain closed loops.
// Returns the subset of region faces that is inside the given wireBody. 
var getFacesInside = function getFacesInside(solver, wireBody) {

  // Mark all faces as rank 0, indicating that we did not find an enclosing loop yet
  // Note: It's not perfectly clean to add extra attributes, but...
  //  a) Since faces don't have unique ids, we don't have proper way to index them without modifying
  //  b) All faces here are only temporary.
  var regionFaces = solver.getFaces();
  regionFaces.forEach(function (f) {return f.rank = 0;});

  // for each wire
  var wires = wireBody.getWires();
  wires.forEach(function (w) {

    // get faces inside this loop
    var loopEdges = w.getEdges();
    var facesInside = getFacesInsideLoop(solver, loopEdges);

    // increase rank for all faces inside this loop
    facesInside.forEach(function (f) {return f.rank++;});
  });

  // Return all faces whose rank is not a multiple of 2
  var hasOddRank = function hasOddRank(f) {return Boolean(f.rank & 1);};
  return regionFaces.filter(hasOddRank);
};

// Apply boolean operation on two SolidDef paths (must be closed).
//
// @param {SolidDef.Path2D} path1 - the path to be clipped.
// @param {SolidDef.Path2D} path2 - to be cut away. Must be a single loop.
// @param {Operator}        operator
// @returns {SolidDef.Face[]} 
var applyOperation = function applyOperation(path1, path2, operator) {

  // get paths as wires
  var wireBody1 = path1.getWireBody();
  var wireBody2 = path2.getWireBody();

  // get both paths as edge arrays
  var edges1 = wireBody1.getEdges();
  var edges2 = wireBody2.getEdges();

  // get unified array with edges of both parts 
  var allEdges = edges1.concat(edges2);

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new SolidDef.SketchRegionSolver();
  solver.compute(allEdges);

  // check which of the faces are within path and cutPath
  var allFaces = solver.getFaces();
  var facesInPath1 = getFacesInside(solver, wireBody1);
  var facesInPath2 = getFacesInside(solver, wireBody2);

  // Filter faces based on operation type.
  // Note: We have a O(numEdges^2) runtime here, which might be an issue for number of faces. 
  //       If needed, this could be optimized by tagging the edges with unique IDs in advance and indexing
  //       the faces by id.
  var filter = function filter(f, index) {

    var inPath1 = facesInPath1.includes(f);
    var inPath2 = facesInPath2.includes(f);
    switch (operator) {
      case Operator.Intersect:return inPath1 && inPath2;
      case Operator.Union:return true;
      case Operator.Difference:return inPath1 && !inPath2;
      case Operator.Xor:return inPath1 !== inPath2;}

  };
  var selectedFaces = allFaces.filter(filter);

  // Finally, merge these faces to obtain result
  return SolidDef.mergeConnectedFaces(selectedFaces);
};

var apply = function apply(path1, path2, operator) {
  // Convert to SolidDef
  var path1Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path1);
  var path2Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path2);

  // Run operation
  var faces = applyOperation(path1Sd, path2Sd, operator);

  // Convert SolidDef faces back to Edit2D paths
  return _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].facesToShape(faces);
};

var BooleanOps = {
  Operator: Operator,
  apply: apply };

/***/ }),

/***/ "./extensions/Edit2D/CanvasGizmo.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/CanvasGizmo.js ***!
  \******************************************/
/*! exports provided: AlignX, AlignY, CanvasGizmoBase, CanvasGizmo, ShapeLabel, LengthLabel, AreaLabel, EdgeGizmo, EdgeMoveGizmo, EdgeLabel, VertexGizmo, LabelFilter, DefaultLabelFilter, LabelStyleRule, FadeOutStyleRule, ShapeLabelRule, ShapeToolTip, GizmoManager, ArcEdgeGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignX", function() { return AlignX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignY", function() { return AlignY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmoBase", function() { return CanvasGizmoBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmo", function() { return CanvasGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabel", function() { return ShapeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LengthLabel", function() { return LengthLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLabel", function() { return AreaLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeGizmo", function() { return EdgeGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeMoveGizmo", function() { return EdgeMoveGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeLabel", function() { return EdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexGizmo", function() { return VertexGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelFilter", function() { return LabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLabelFilter", function() { return DefaultLabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelStyleRule", function() { return LabelStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FadeOutStyleRule", function() { return FadeOutStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabelRule", function() { return ShapeLabelRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeToolTip", function() { return ShapeToolTip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GizmoManager", function() { return GizmoManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcEdgeGizmo", function() { return ArcEdgeGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var AlignX = {
  Left: 1,
  Center: 2,
  Right: 3 };


var AlignY = {
  Top: 1,
  Center: 2,
  Bottom: 3 };


var av = Autodesk.Viewing;

// Base class for any gizmo that needs to be synchronized with the shapes of an EditLayer.
var CanvasGizmoBase = /*#__PURE__*/function () {
  function CanvasGizmoBase() {_classCallCheck(this, CanvasGizmoBase);}

  // Called whenever the layer or camera changes.
  _createClass(CanvasGizmoBase, [{ key: "update", value: function update() {} }]);return CanvasGizmoBase;}();


av.GlobalManagerMixin.call(CanvasGizmoBase.prototype);

// A CanvasGizmo is an html div anchored at a position in layer-coords
var CanvasGizmo = /*#__PURE__*/function (_CanvasGizmoBase) {_inherits(CanvasGizmo, _CanvasGizmoBase);
  function CanvasGizmo(layer) {var _this;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, CanvasGizmo);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasGizmo).call(this));

    _this.layer = layer;
    _this.setGlobalManager(layer.globalManager);

    // position in layer-coords. The transform origin of the div will appear at this position.
    _this.layerPos = new THREE.Vector2();

    // position in canvas-coords (updated based on this.layerPos and camera)
    _this.canvasPos = new THREE.Vector2();

    // html content to be shown
    var _document = _this.getDocument();
    _this.container = _document.createElement('div');

    // Make sure that label is displayed on top of the canvas and not "pushed away" by it.
    _this.container.style.position = 'absolute';

    // Rotate around gizmo center
    _this.container.style.transformOrigin = '50% 50%';

    // Show immediately if wanted
    _this.visible = false;

    _this.alignX = AlignX.Center;
    _this.alignY = AlignY.Center;

    // Clockwise rotation angle in degrees. Rotates around center.
    _this.angle = 0;

    if (visible) {
      _this.setVisible(true, false);
    }

    // By default, just delegate to viewer context menu. Edit2DContextMenu will take care
    // that it is properly configured.
    _this.container.addEventListener('contextmenu', function (e) {
      _this.layer.viewer.triggerContextMenu(e);
    });return _this;
  }_createClass(CanvasGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
    } }, { key: "setVisible", value: function setVisible(

    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (visible == this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:
        //       ToolController listens to events on canvasWrap. Therefore, if we would add
        //       it to viewer.container, all mouse events captured would never reach the ToolController
        //       no matter whether the gizmo handles them or not.
        this.layer.viewer.canvasWrap.appendChild(this.container);
        this.layer.addCanvasGizmo(this);

        // Make sure that position is correct
        if (autoUpdate) {
          this.update();
        }
      } else
      {
        this.layer.viewer.canvasWrap.removeChild(this.container);
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "setAlignX", value: function setAlignX(

    alignX) {
      this.alignX = alignX;
      this.update();
    } }, { key: "setAlignY", value: function setAlignY(

    alignY) {
      this.alignY = alignY;
      this.update();
    }

    // @param {number} angle - Clockwise angle in degrees
    // 
    // Note: Do not use 'position:absolute' in child html elements.
    //       Otherwise, the content box will be empty and it will not rotate around anymore.
  }, { key: "setRotation", value: function setRotation(angle) {
      this.angle = angle;
      this.update();
    } }, { key: "update", value: function update()

    {
      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));

      var p = this.canvasPos;
      var style = this.container.style;

      // set left/top to gizmo position
      style.left = toPixels(p.x);
      style.top = toPixels(p.y);

      // Choose translation offset in % based on X-alignment
      var tx;
      switch (this.alignX) {
        case AlignX.Left:tx = '0%';break;
        case AlignX.Center:tx = '-50%';break;
        case AlignX.Right:tx = '-100%';break;}


      var ty;
      switch (this.alignY) {
        case AlignY.Top:ty = '0%';break;
        case AlignY.Center:ty = '-50%';break;
        case AlignY.Bottom:ty = '-100%';break;}


      // Update transform based on rotation angle and alignment
      style.transform = "translate(".concat(tx, ", ").concat(ty, ") rotate(").concat(this.angle, "deg)");
    }

    // Set position in layer coords
  }, { key: "setPosition", value: function setPosition(x, y) {
      this.layerPos.set(x, y);
      this.update();
    } }, { key: "setClassEnabled", value: function setClassEnabled(

    className, enabled) {
      if (enabled) {
        this.container.classList.add(className);
      } else {
        this.container.classList.remove(className);
      }
    }

    // Selection state is managed using a css-class 'selected'. 
    // Note that this only has an effect if the css style used for the gizmo supports it.
  }, { key: "setSelected", value: function setSelected(selected) {
      this.setClassEnabled('selected', selected);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.container.classList.contains('selected');
    }

    // Optional: Hover-effect for gizmos that can be clicked or dragged.
  }, { key: "setHoverEnabled", value: function setHoverEnabled(enabled) {
      this.setClassEnabled('enable-hover', enabled);
    }

    // Optional: Assign a name to gizmo and div element to facilitate debugging and testing.
  }, { key: "setName", value: function setName(name) {
      this.name = name;
      this.container.id = name ? name : '';
    } }]);return CanvasGizmo;}(CanvasGizmoBase);


// Configure CanvasGizmo as a text label.
var initTextLabel = function initTextLabel(gizmo) {

  // Use measure-tool styles by default
  gizmo.container.classList.add('measure-length');
  gizmo.container.classList.add('visible');

  // Create textDiv child div
  var _document = gizmo.getDocument();
  gizmo.textDiv = _document.createElement('div');
  gizmo.textDiv.classList.add('measure-length-text');
  gizmo.container.appendChild(gizmo.textDiv);

  // Add setText convenience function
  gizmo.setText = function (str) {
    this.textDiv.textContent = str;
  }.bind(gizmo);
};

// A ShapeLabel is a text label whose anchor position is synchronized with the bbox center of a shape in a layer.
var ShapeLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(ShapeLabel, _CanvasGizmo);

  function ShapeLabel(shape, layer) {var _this2;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, ShapeLabel);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeLabel).call(this, layer, visible));

    initTextLabel(_assertThisInitialized(_this2));

    _this2.shape = shape;

    // Can be set to hidden to temporarily hide the label
    _this2.valueValid = true;

    // Optional: Shift label by a couple of pixels.
    _this2.pixelOffset = new THREE.Vector2();

    _this2.update();return _this2;
  }_createClass(ShapeLabel, [{ key: "update", value: function update()

    {
      if (this.shape && this.valueValid) {
        // Set it to visible (in case polygon was null before)
        this.container.style.visibility = 'visible';

        if (this.shape.isPolyline()) {
          var edgeCount = this.shape.getEdgeCount();
          // For a start, simply position the label on the segment roughly in the middle of the polyline
          var edgeToLabel = Math.floor(edgeCount / 2);
          if (this.shape.edgeIndexValid(edgeToLabel)) {
            // Set layer position to center point of the segment.
            this.shape.getPointOnEdge(edgeToLabel, 0.5, this.layerPos);
          }
        } else
        {
          // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the
          // polygon, so we may consider something smarter later.
          this.shape.computeBBox();
          this.shape.bbox.center(this.layerPos);
        }

        // Optional: Shift by a few pixels
        if (this.pixelOffset) {
          var toUnits = this.layer.getUnitsPerPixel();
          var shiftX = this.pixelOffset.x * toUnits;
          var shiftY = this.pixelOffset.y * toUnits;
          this.layerPos.x += shiftX;
          this.layerPos.y += shiftY;
        }

        _get(_getPrototypeOf(ShapeLabel.prototype), "update", this).call(this);
      } else {
        this.container.style.visibility = 'hidden';
      }
    } }, { key: "setShape", value: function setShape(

    shape) {
      this.shape = shape;
      this.update();
    } }]);return ShapeLabel;}(CanvasGizmo);


// Only works for shapes with getLength() function
var LengthLabel = /*#__PURE__*/function (_ShapeLabel) {_inherits(LengthLabel, _ShapeLabel);

  // @param {Polyline}    polyline
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function LengthLabel(polyline, layer, unitHandler) {var _this3;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, LengthLabel);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(LengthLabel).call(this, polyline, layer, visible));
    _this3.unitHandler = unitHandler;return _this3;
  }_createClass(LengthLabel, [{ key: "update", value: function update()

    {
      // Get shape length (if shape supports it)
      var hasLength = this.shape && this.shape.getLength;
      var length = hasLength && this.shape.getLength(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined length.
      // We also hide it if length is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(length);

      if (this.valueValid) {
        var text = this.unitHandler.lengthToString(length);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(LengthLabel.prototype), "update", this).call(this);
    } }]);return LengthLabel;}(ShapeLabel);


// Only works for shapes with getArea() function
var AreaLabel = /*#__PURE__*/function (_ShapeLabel2) {_inherits(AreaLabel, _ShapeLabel2);

  // @param {Polygon}     polygon
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function AreaLabel(polygon, layer, unitHandler) {var _this4;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(AreaLabel).call(this, polygon, layer, visible));
    _this4.unitHandler = unitHandler;return _this4;
  }_createClass(AreaLabel, [{ key: "update", value: function update()

    {
      // Get shape area (if shape supports it)
      var hasArea = this.shape && this.shape.getArea;
      var area = hasArea && this.shape.getArea(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined area.
      // We also hide it if area is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(area);

      if (this.valueValid) {
        var text = this.unitHandler.areaToString(area);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);
    } }]);return AreaLabel;}(ShapeLabel);


// A html element for which position and rotation is aligned with an edge
var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(EdgeGizmo, _CanvasGizmo2);

  // @param {EditLayer} layer
  // @param {bool} visible
  function EdgeGizmo(layer) {var _this5;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeGizmo);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeGizmo).call(this, layer, visible));

    _this5.posA = new THREE.Vector2();
    _this5.posB = new THREE.Vector2();

    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is
    // attached to an edge, this flag is set automatically.
    _this5.posValid = false;

    // Temp vectors used in update
    _this5.edgeDir = new THREE.Vector2();

    // Optional: Positions can be synchronized with an edge of a polygon or polyline
    _this5.poly = null;
    _this5.edgeIndex = 0;

    // Use measure-length css style by default
    _this5.container.classList.add('edge-gizmo');

    // Optional: By default, an EdgeGizmo is always placed on a segment, i.e., the gizmo will follow a curve for arc segments.
    //           If this flag is true, the gizmo is always placed on the direct line connection. 
    _this5.ignoreArcs = false;

    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:
    // We hide the gizmo if it exceeds x * edgeLength on screen.
    _this5.maxRelativeLength = undefined; // in [0,1]
    return _this5;}

  // If a poly is set, the gizmo is automatically synchronized with the edge.
  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.
  //
  //  @param {PolyBase} poly     - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.
  //  @param {number} edgeIndex  - edgeIndex in poly. If not valid, gizmo is hidden.
  //  @param {bool} [autoUpdate] - update position immediately
  _createClass(EdgeGizmo, [{ key: "attachToEdge", value: function attachToEdge(poly, edgeIndex) {
      this.poly = poly;
      this.edgeIndex = edgeIndex;
      this.update();
    } }, { key: "detachFromEdge", value: function detachFromEdge()

    {
      this.poly = null;
      this.edgeIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "edgeValid", value: function edgeValid()

    {
      return this.poly && this.poly.edgeIndexValid(this.edgeIndex);
    } }, { key: "update", value: function update()

    {

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore
      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex)) {
        this.poly.getEdge(this.edgeIndex, this.posA, this.posB);
        this.posValid = true;
      }

      // If edge is invalid or too small on screen, just hide the gizmo
      var show = this._shouldBeShown();
      this.container.style.visibility = show ? 'visible' : 'hidden';
      if (!show) {
        return;
      }

      // Center gizmo at edge center
      if (this.ignoreArcs) {
        // Place on the line segment
        _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"].prototype.getPointOnEdge.call(this.poly, this.edgeIndex, 0.5, this.layerPos);
      } else {
        // Place on line segment or arc - depending on actual edge type
        this.poly.getPointOnEdge(this.edgeIndex, 0.5, this.layerPos);
      }

      // Set rotation angle
      this._updateRotation();

      _get(_getPrototypeOf(EdgeGizmo.prototype), "update", this).call(this);
    }

    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.
  }, { key: "_shouldBeShown", value: function _shouldBeShown() {

      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()
      if (!this.posValid) {
        return false;
      }

      // Show/Hide gizmo depending on zoom:
      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.
      if (this.maxRelativeLength) {
        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);
        var edgeLengthScreen = aScreen.distanceTo(bScreen);
        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;
        var _window = this.getWindow();
        var width = parseFloat(_window.getComputedStyle(this.container).width);
        return width < maxAllowedPixels;
      }
      return true;
    }

    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge
  }, { key: "_updateRotation", value: function _updateRotation() {

      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b
      var dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(this.posA, this.posB, this.edgeDir);
      var angle = Math.atan2(dir.y, dir.x);

      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.
      if (dir.x < 0) {
        angle += Math.PI;
      }

      // Convert angle to clockwise degrees and apply it to style
      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.
      this.angle = -THREE.Math.radToDeg(angle);
    } }]);return EdgeGizmo;}(CanvasGizmo);


var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);

  function EdgeMoveGizmo(layer, name) {var _this6;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, EdgeMoveGizmo);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeMoveGizmo).call(this, layer, visible));

    _this6.setName(name);
    _this6.container.classList.add('edge-move-gizmo');

    // We place EdgeMoveGizmos always directly on the straight lines. In this way, edge moving
    // will work in the same way - no matter whether a segment is an arc or not.
    _this6.ignoreArcs = true;

    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength
    _this6.maxRelativeLength = 0.3; // in [0,1]
    return _this6;}return EdgeMoveGizmo;}(EdgeGizmo);


// An EdgeGizmo to display text
var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);

  function EdgeLabel(layer) {var _this7;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeLabel).call(this, layer, visible));
    initTextLabel(_assertThisInitialized(_this7));

    // Hide label if it would exceed the edge length
    _this7.maxRelativeLength = 1.0;return _this7;
  }return EdgeLabel;}(EdgeGizmo);


var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(VertexGizmo, _CanvasGizmo3);

  // @param {number}  x,y       - Position in layer coords
  // @param {string}  id        - id string used to tag shapes that represent this gizmo
  function VertexGizmo(layer, x, y, name) {var _this8;_classCallCheck(this, VertexGizmo);
    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(VertexGizmo).call(this, layer, true));
    _this8.setPosition(x, y);
    _this8.setName(name);

    _this8.container.classList.add('vertex-gizmo');return _this8;
  }return VertexGizmo;}(CanvasGizmo);


// A Label filter decides for which shapes we display a label
var LabelFilter = /*#__PURE__*/function () {

  function LabelFilter() {_classCallCheck(this, LabelFilter);}

  // If false, we don't need to acquire a label at all.
  _createClass(LabelFilter, [{ key: "accepts", value: function accepts(shape, text) {
      return true;
    } }]);return LabelFilter;}();
;

// Get shape width in screen-pixels
var getShapeWidth = function getShapeWidth(shape, layer) {
  // get shape size in screen-pixels
  shape.updateBBox();
  var bbox = shape.bbox;
  var shapeWidth = bbox.max.x - bbox.min.x;
  return shapeWidth * layer.getPixelsPerUnit() * shapeWidth;
};

// By default, we hide labels if text is empty or if the shape size on screen falls beyond a pixel threshold
var DefaultLabelFilter = /*#__PURE__*/function (_LabelFilter) {_inherits(DefaultLabelFilter, _LabelFilter);

  // @param {number} minWidth - minimum pixel width a shape must have to receive a label
  function DefaultLabelFilter() {var _this9;var minWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;_classCallCheck(this, DefaultLabelFilter);
    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(DefaultLabelFilter).call(this));
    _this9.minWidth = minWidth;return _this9;
  }

  // Accept shape if text is not empty and its screen-width is big enough.
  _createClass(DefaultLabelFilter, [{ key: "accepts", value: function accepts(shape, text, layer) {
      var width = getShapeWidth(shape, layer);
      return Boolean(text) && width >= this.minWidth;
    } }]);return DefaultLabelFilter;}(LabelFilter);


// A LabelStyle rule allows to apply css style modifications on a label, e.g., depending on screen size
var LabelStyleRule = /*#__PURE__*/function () {

  function LabelStyleRule() {_classCallCheck(this, LabelStyleRule);}

  // Note: Labels may be reused for different shapes. So, make sure that the style parameters are 
  //       not just modified for some subset of shapes, but reset for others.
  _createClass(LabelStyleRule, [{ key: "apply", value: function apply(label, shape, text, layer) {} }]);return LabelStyleRule;}();
;

// Fades out based on label size
var FadeOutStyleRule = /*#__PURE__*/function (_LabelStyleRule) {_inherits(FadeOutStyleRule, _LabelStyleRule);

  // @param {number} rangeStart - shape width in screen-pixels at which the label starts to fade-in
  // @param {number} rangeEnd   - shape width in screen-pixels at which the label is fully opaque.
  function FadeOutStyleRule() {var _this10;var rangeStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;var rangeEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;_classCallCheck(this, FadeOutStyleRule);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(FadeOutStyleRule).call(this));
    _this10.rangeStart = rangeStart;
    _this10.rangeEnd = rangeEnd;return _this10;
  }_createClass(FadeOutStyleRule, [{ key: "apply", value: function apply(

    label, shape, layer) {

      // compute opacity from shape screen-width
      var width = getShapeWidth(shape, layer);
      var t = (width - this.rangeStart) / (this.rangeEnd - this.rangeStart);
      var opacity = THREE.Math.clamp(t, 0, 1);

      label.container.style.opacity = opacity;
    } }]);return FadeOutStyleRule;}(LabelStyleRule);
;

// A ShapeLabelRule maintains a set of labels that is automatically synced with the shapes in a layer.
// It implements the CanvasGizmoBase to update the set of maintained labels.
var ShapeLabelRule = /*#__PURE__*/function () {

  // @param {EditLayer}               layer            - Labels are shown (and synchronized) with the content of this layer.
  // @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  // @param {LabelFilter}             [filter]         - Defines which labels to show. See DefaultLabelFilter for default behavior.
  // @param {LabelStyleRule}          [styleRule]      - Defines how label style is modified dynamically. (By default, we fade-out based on label size)
  function ShapeLabelRule(layer, shapeToLabelText) {var labelFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DefaultLabelFilter();var styleRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FadeOutStyleRule();_classCallCheck(this, ShapeLabelRule);
    this.layer = layer;
    this.shapeToLabelText = shapeToLabelText;

    // All labels that we created. 
    this.labels = []; // {ShapeLabel[]}
    this.labelsUsed = 0; // All remaining labels in this.labels are hidden and just cached for later reuse.

    this.layer.addCanvasGizmo(this);
    this.visible = true;
    this.layer.update();

    this.filter = labelFilter;
    this.styleRule = styleRule;
  }

  // Replace the rule to define label texts.
  //   @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  _createClass(ShapeLabelRule, [{ key: "setTextRule", value: function setTextRule(shapeToLabelText) {
      this.shapeToLabelText = shapeToLabelText;
      this.update();
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible === this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add 'this' first and all maintained labels behind. In this way, this gizmo is updated first to
        //       configure all labels - followed by the update calls for all active labels in use.
        this.layer.addCanvasGizmo(this);
        this.update();
      } else {
        this.clearLabels();
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "dtor", value: function dtor()

    {
      // Make sure that we don't leave any of our labels in the layer
      this.setVisible(false);
    }

    // Hide + release all current labels, so that we can re-acquire them based on latest Layer state.
  }, { key: "clearLabels", value: function clearLabels() {
      for (var i = 0; i < this.labelsUsed; i++) {
        this.labels[i].setShape(null);
        this.labels[i].setVisible(false);
      }
      this.labelsUsed = 0;
    }

    // Create new label or get it from cache
  }, { key: "acquireLabel", value: function acquireLabel() {
      // create new label if necessary
      if (this.labelsUsed === this.labels.length) {
        this.labels.push(new ShapeLabel(null, this.layer));
      }

      return this.labels[this.labelsUsed++];
    } }, { key: "update", value: function update()

    {

      this.clearLabels();

      var shapes = this.layer.shapes;
      for (var i = 0; i < shapes.length; i++) {

        var shape = shapes[i];

        // Get label text 
        var text = this.shapeToLabelText(shape);

        // Check if we want to display a label for this shape
        if (this.filter && !this.filter.accepts(shape, text, this.layer)) {
          continue;
        }

        // Configure label
        var label = this.acquireLabel();
        label.setShape(shape);
        label.setText(text);
        label.setVisible(true);

        // Apply optional custom style rule
        this.styleRule && this.styleRule.apply(label, shape, this.layer);
      }
    } }]);return ShapeLabelRule;}();


// A ShapeToolTip is a label that shows up when hovering a shape.
// By default, it appears a few pixels above the top-right corner of a shape's bbox.
var ShapeToolTip = /*#__PURE__*/function (_CanvasGizmoBase2) {_inherits(ShapeToolTip, _CanvasGizmoBase2);

  // @param {EditLayer}               layer - Tooltip will appear for all shapes in the given layer.
  // @param {function(shape)=>string} getText - Function to define the text for a given shape
  function ShapeToolTip(layer) {var _this11;var getText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;_classCallCheck(this, ShapeToolTip);
    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeToolTip).call(this));

    _this11.layer = layer;
    _this11.textCb = getText;
    _this11.viewer = _this11.layer.viewer;

    // track latest mouse position in layer coords (init on first mouse move)
    _this11.mousePos = null;

    // distance between tooltip and shape bbox
    _this11.distanceToBox = 5; // in pixels

    // Create tooltip div
    _this11.container = _this11.getDocument().createElement('div');
    _this11.container.classList.add('adsk-control-tooltip');

    // Add div to viewer canvas container and layer
    _this11.viewer.canvasWrap.appendChild(_this11.container);

    // Update if layer changed
    _this11.layer.addCanvasGizmo(_assertThisInitialized(_this11));

    // Update if mouse moved
    _this11.onMouseMoved = _this11.onMouseMoved.bind(_assertThisInitialized(_this11));
    _this11.viewer.canvasWrap.addEventListener('mousemove', _this11.onMouseMoved);

    _this11.layer.updateCanvasGizmos();return _this11;
  }_createClass(ShapeToolTip, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeCanvasGizmo();
      this.viewer.canvasWrap.removeEventListener('mousemove', this.onMouseMoved);
      this.viewer.canvasWrap.removeChild(this.container);
    }

    // Set callback that defines which text to display for each shape. Returning '' or null will hide the tooltip.
    // @param {function(shape)=>string} getText - Function to define the text for a given shape
  }, { key: "setTextCallback", value: function setTextCallback(getText) {
      this.textCb = getText;
      this.update();
    } }, { key: "onMouseMoved", value: function onMouseMoved(

    event) {

      // Add canvas coords to event
      this.viewer.toolController.__clientToCanvasCoords(event);

      // Track mouse position
      this.mousePos = this.layer.canvasToLayer(event.canvasX, event.canvasY);

      this.update();
    } }, { key: "update", value: function update()

    {

      // If a textCb is set, check shape under mouse
      var shape = this.mousePos && this.textCb && this.layer.hitTest(this.mousePos.x, this.mousePos.y);

      // Choose label text
      var text = shape && this.textCb(shape);

      // Apply text
      this.container.textContent = text || '';

      // Stop here if nothing to display
      if (!text) {
        this.container.style.visibility = 'hidden';
        return;
      }

      // Show label
      this.container.style.visibility = 'visible';

      // Get top-right corner of bbox
      shape.updateBBox(); // Make sure bbox is up-to-date
      var corner = shape.bbox.max;

      // Get anchor in canvas coords
      var anchor = this.layer.layerToCanvas(corner.x, corner.y);

      // Add some pixels y-offset
      anchor.y -= this.distanceToBox;

      // get canvas size
      var width = this.viewer.canvas.width;
      var height = this.viewer.canvas.height;

      // Update tooltip position
      this.container.style.right = width - anchor.x + 'px';
      this.container.style.bottom = height - anchor.y + 'px';

      this.container.style.left = 'auto';
      this.container.style.top = 'auto';
    } }]);return ShapeToolTip;}(CanvasGizmoBase);


// Purpose:
// There is no efficient and simple way to ask a div whether it is under mouse or not.
// The most reliable way is document.elementFromPoint(), but it is rather expensive.
// Therefore, we don't want to do it for each and every gizmo. Instead, GizmoManager tracks
// which object is under mouse and is generally used to check which gizmo is at mouse position.
var GizmoManager = /*#__PURE__*/function () {

  function GizmoManager() {_classCallCheck(this, GizmoManager);
    // div element at mouse position
    this.elemUnderMouse = null;
  }

  // Must be triggered on mouse events.
  // @param {MouseEvent}
  _createClass(GizmoManager, [{ key: "update", value: function update(e) {
      this.elemUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
    }

    // @param {CanvasGizmo}
  }, { key: "isUnderMouse", value: function isUnderMouse(gizmo) {
      return gizmo.container && gizmo.container === this.elemUnderMouse;
    }

    // Returns the index of the gizmo that matches with the element under mouse.
    // Result is -1 if none of the gizmos matches.
    //  @param {CanvasGizmo[]} gizmo
  }, { key: "getGizmoIndex", value: function getGizmoIndex(gizmos) {var _this12 = this;
      return gizmos.findIndex(function (g) {return _this12.isUnderMouse(g);});
    } }]);return GizmoManager;}();


// Display dashed lines to connect start/end of arc segments. Used by PolygonEditTool.
// It updates itself automatically whenever the shape changed.
var ArcEdgeGizmo = /*#__PURE__*/function () {
  function ArcEdgeGizmo(layer, gizmoLayer) {_classCallCheck(this, ArcEdgeGizmo);

    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // One Line shape per arc segment in the host shape
    this.shapes = [];

    this.visibility = false;
    this.setVisible(true);

    // Optional: Display one edge in another color
    this.highlightColor = undefined;
    this.highlightIndex = 0; // must be a valid edge index in this.poly
  }_createClass(ArcEdgeGizmo, [{ key: "dtor", value: function dtor()

    {
      // Just make sure it is invisible, so that shapes are cleared and
      // gizmo is removed from GizmoLayer.
      this.setVisible(false);
    }

    // Set the shape for which we display lines
  }, { key: "setPoly", value: function setPoly(poly) {
      if (poly !== this.poly) {
        this.poly = poly;
        this.clearEdgeHighlighting();
        this.update();
      }
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      // Do nothing if there's no change
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;

      // add/remove from layer
      if (visible) {
        this.layer.addCanvasGizmo(this);
      } else {
        this.layer.removeCanvasGizmo(this);
      }
      this.update();
    } }, { key: "clearShapes", value: function clearShapes()

    {var _this13 = this;
      this.shapes.forEach(function (s) {return _this13.gizmoLayer.removeShape(s);});
      this.shapes = [];
    } }, { key: "edgeShapeName", value: function edgeShapeName(

    index) {
      return 'ArcEdgeGizmo_' + index;
    }

    // Create a line shape that connects start/end vertex of segment i in poly.
  }, { key: "_addEdge", value: function _addEdge(index) {

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(index, a, b);

      // Create a line from it
      var line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]([a, b]);
      line.name = this.edgeShapeName(index);

      // Configure line style
      line.style.lineStyle = 11; // short dashes
      line.style.lineWidth = this.poly.style.lineWidth / 2.0;
      line.style.lineAlpha = this.poly.style.lineAlha / 2.0;

      // Apply optional edge highlighting color
      if (index == this.highlightIndex && this.highlightColor) {
        line.style.lineColor = this.highlightColor;
      }

      this.gizmoLayer.addShape(line);
      this.shapes.push(line);
    } }, { key: "clearEdgeHighlighting", value: function clearEdgeHighlighting()

    {

      if (this.highlightIndex === -1) {
        return;
      }

      this.highlightColor = null;
      this.highlightIndex = -1;
      this.update();
    }

    // Assign different
  }, { key: "setEdgeHighlighted", value: function setEdgeHighlighted(index, color) {

      // Only do work if needed
      if (index === this.highlightIndex && color === this.highlightColor) {
        return;
      }

      this.highlightColor = color;
      this.highlightIndex = index;
      this.update();
    }

    // Updates the edges for the given Path shape
  }, { key: "update", value: function update() {

      this.clearShapes();

      // Stop if there are no arcs
      if (!this.visible || !this.poly || !this.poly.isPath()) {
        return;
      }

      var edgeCount = this.poly.getEdgeCount();
      for (var i = 0; i < edgeCount; i++) {

        // Consider only arcs
        var isArc = this.poly.isArc(i);
        if (isArc) {
          this._addEdge(i);
        }
      }
    } }]);return ArcEdgeGizmo;}();

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.css":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Edit2D.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Edit2D.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DExtension; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Edit2DSnapper.js */ "./extensions/Edit2D/Edit2DSnapper.js");
/* harmony import */ var _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Edit2DContextMenu.js */ "./extensions/Edit2D/Edit2DContextMenu.js");
/* harmony import */ var _UnitHandler_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UnitHandler.js */ "./extensions/Edit2D/UnitHandler.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
/* harmony import */ var _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tools/MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tools/PolygonTool.js */ "./extensions/Edit2D/tools/PolygonTool.js");
/* harmony import */ var _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tools/PolygonEditTool.js */ "./extensions/Edit2D/tools/PolygonEditTool.js");
/* harmony import */ var _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tools/InsertSymbolTool.js */ "./extensions/Edit2D/tools/InsertSymbolTool.js");
/* harmony import */ var _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tools/RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tools/UndoTool.js */ "./extensions/Edit2D/tools/UndoTool.js");
/* harmony import */ var _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tools/CopyTool.js */ "./extensions/Edit2D/tools/CopyTool.js");
/* harmony import */ var _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tools/LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./Edit2D.css */ "./extensions/Edit2D/Edit2D.css");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_Edit2D_css__WEBPACK_IMPORTED_MODULE_24__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}


























 // IMPORTANT!!

var myExtensionName = 'Autodesk.Edit2D';
var namespace = AutodeskNamespace('Autodesk.Edit2D');
var av = Autodesk.Viewing;

var OverlayName = 'Edit2D';var

ToolSet =
function ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);
  this.name = name;
  this.autoReactivate = autoReactivate;
  this.context = null;
  this.tools = {};
};


/** 
    * Edit2D extension provides API for implementing 2D vector editing. 
    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only
    * to provide a basis for other extensions and client applications.
    * 
    * The extension id is: `Autodesk.Edit2D`
    * 
    * @example
    *   viewer.loadExtension('Autodesk.Edit2D')
    *
    * @memberof Autodesk.Viewing.Extensions
    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
    * @alias Autodesk.Viewing.Extensions.Edit2DExtension
    * @class
    */var
Edit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);
  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Edit2DExtension).call(this, viewer, options));

    _this.undoStack = new _UndoStack_js__WEBPACK_IMPORTED_MODULE_6__["default"]();

    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)
    _this._registeredTools = new Map();
    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_this));
    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_this));
    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(Edit2DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:



                // The overlay "Edit2D" contains subscenes for each edit layer.
                this.viewer.impl.createOverlayScene(OverlayName);

                // We require Snapping and Autodesk.CompGeom (already a dependency of Autodesk.Snapping)
                _context.next = 3;return this.viewer.loadExtension('Autodesk.Snapping');case 3:

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools
                this.undoTool = new _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_18__["default"](this.undoStack);
                this.viewer.toolController.registerTool(this.undoTool);
                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
        for (var _iterator = this._registeredTools.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var toolSetName = _step.value;
          this.unregisterTools(toolSetName);
        }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return != null) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

      this.viewer.toolController.deregisterTool(this.undoTool);
      this.undoTool = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

      return true;
    } }, { key: "_onModelAdded", value: function _onModelAdded()

    {var _this2 = this;
      if (this.viewer.getVisibleModels().length !== 1) {
        // Do the reactivation only when the first model got loaded.
        return;
      }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {

        for (var _iterator2 = this._registeredTools.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var toolSet = _step2.value;
          if (toolSet.autoReactivate) {
            toolSet.toolsToReactivate.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});
          }
        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2.return != null) {_iterator2.return();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
    } }, { key: "_onModelRemoved", value: function _onModelRemoved()

    {
      if (this.viewer.getVisibleModels().length !== 0) {
        // Only deactivate tools when no model is active anymore.
        return;
      }

      var controller = this.viewer.toolController;var _iteratorNormalCompletion3 = true;var _didIteratorError3 = false;var _iteratorError3 = undefined;try {
        for (var _iterator3 = this._registeredTools.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {var toolSet = _step3.value;
          if (toolSet.autoReactivate) {
            // The next statement gets all possible names of all tools of a toolSet,
            // flatten the resulting array
            // and returns a list tool names that are active.
            toolSet.toolsToReactivate = Object.values(toolSet.tools).
            map(function (t) {return t.getNames();}).
            reduce(function (res, names) {return res.concat(names);}, []) // flatten
            .filter(function (name) {return controller.isToolActivated(name);});

            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});
          }
        }} catch (err) {_didIteratorError3 = true;_iteratorError3 = err;} finally {try {if (!_iteratorNormalCompletion3 && _iterator3.return != null) {_iterator3.return();}} finally {if (_didIteratorError3) {throw _iteratorError3;}}}
    }

    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.
  }, { key: "_onSelectionChanged", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iteratorNormalCompletion4 = true;var _didIteratorError4 = false;var _iteratorError4 = undefined;try {
        for (var _iterator4 = this._registeredTools.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {var toolSet = _step4.value;
          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {
            toolSet.context.selection.clear();
          }
        }} catch (err) {_didIteratorError4 = true;_iteratorError4 = err;} finally {try {if (!_iteratorNormalCompletion4 && _iterator4.return != null) {_iterator4.return();}} finally {if (_didIteratorError4) {throw _iteratorError4;}}}
    } }, { key: "registerDefaultTools", value: function registerDefaultTools()

    {
      this.defaultContext = this.registerTools('default');
    }

    // Get default tools. registerDefaultTools() must be called first, otherwise it returns null.
  }, { key: "getToolSet",




    // returns a given toolset, or null if none with the given name have been registered.
    value: function getToolSet(toolSetName) {
      return this._registeredTools.get(toolSetName);
    } }, { key: "registerTools", value: function registerTools(

    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var toolSet = this._registeredTools.get(toolSetName);
      if (toolSet) {
        console.warn("Edit 2D tools are already registered for tool set '".concat(toolSetName, "'"));
        return toolSet.context;
      }

      toolSet = new ToolSet(toolSetName, autoReactivate);
      this._registeredTools.set(toolSetName, toolSet);

      // create context
      var context = toolSet.context = new Edit2DContext(this, toolSetName);
      context.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // create tools
      toolSet.tools.polygonTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__["default"].Mode.Polygon);
      toolSet.tools.polylineTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__["default"].Mode.Polyline);
      toolSet.tools.moveTool = new _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_13__["default"](context);
      toolSet.tools.polygonEditTool = new _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_15__["default"](context);
      toolSet.tools.insertSymbolTool = new _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_16__["default"](context);
      toolSet.tools.copyTool = new _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_19__["default"](context);

      // Enable all new shapes to be Paths, so that you can turn line segments into arc segments
      var enableArcs = Boolean(this.options.enableArcs);
      toolSet.tools.polygonTool.setArcsEnabled(enableArcs);
      toolSet.tools.polylineTool.setArcsEnabled(enableArcs);

      // Allow converting segments to ellipse arcs if wanted
      if (this.options.enableEllipseArcs) {
        toolSet.tools.polygonEditTool.enableEllipseArcs = true;
      }

      // register them
      var controller = this.viewer.toolController;
      controller.registerTool(toolSet.tools.polygonTool);
      controller.registerTool(toolSet.tools.polylineTool);
      controller.registerTool(toolSet.tools.moveTool);
      controller.registerTool(toolSet.tools.polygonEditTool);
      controller.registerTool(toolSet.tools.insertSymbolTool);
      controller.registerTool(toolSet.tools.copyTool);

      // activate CopyTool immediately, because they run parallel to other tools
      controller.activateTool(toolSet.tools.copyTool.getName());

      // create and register context mneu
      toolSet.contextMenu = new _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_8__["default"](this.viewer, toolSet);
      toolSet.contextMenu.register();

      return context;
    } }, { key: "unregisterDefaultTools", value: function unregisterDefaultTools()

    {
      this.unregisterTools('default');
      this.defaultContext = null;
    } }, { key: "unregisterTools", value: function unregisterTools(

    toolSetName) {
      var toolSet = this._registeredTools.get(toolSetName);
      if (!toolSet) {
        return;
      }

      var controller = this.viewer.toolController;
      controller.deregisterTool(toolSet.tools.polygonTool);
      controller.deregisterTool(toolSet.tools.polylineTool);
      controller.deregisterTool(toolSet.tools.moveTool);
      controller.deregisterTool(toolSet.tools.polygonEditTool);
      controller.deregisterTool(toolSet.tools.insertSymbolTool);
      controller.deregisterTool(toolSet.tools.copyTool);

      toolSet.context.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // Unregister and delete context menu
      toolSet.contextMenu.unregister();
      toolSet.contextMenu = null;

      this._registeredTools.delete(toolSetName);
    } }, { key: "createLayer", value: function createLayer()

    {

      var model = this.viewer.model;
      if (!model) {
        console.error("A 2D model is needed to adjust viewport");
      }

      // create new overlay scene to show
      var layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer);

      // add layer scene to our overlay scene
      this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);

      return layer;
    } }, { key: "defaultTools", get: function get() {var toolSet = this._registeredTools.get('default');return toolSet && toolSet.tools;} }]);return Edit2DExtension;}(av.Extension);


// Common set of objects usually needed by tools
var Edit2DContext = /*#__PURE__*/function () {

  // @param {Edit2D} ext - Edit2d extension
  function Edit2DContext(ext, toolSetName) {var _this3 = this;_classCallCheck(this, Edit2DContext);
    this.toolSetName = toolSetName;
    this.viewer = ext.viewer;
    this.layer = ext.createLayer();
    this.gizmoLayer = ext.createLayer();
    this.undoStack = ext.undoStack;
    this.selection = new _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.layer, this.undoStack);
    this.snapper = new _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.viewer, this.layer, this.gizmoLayer);
    this.unitHandler = new _UnitHandler_js__WEBPACK_IMPORTED_MODULE_9__["DefaultUnitHandler"](this.viewer);

    // Update all visible labels if display units are changed
    var onUnitChange = function onUnitChange() {
      _this3.layer.updateCanvasGizmos();
      _this3.gizmoLayer.updateCanvasGizmos();
    };
    this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, onUnitChange);
  }

  // Set matrix that is applied to all displayed geometry
  _createClass(Edit2DContext, [{ key: "setMatrix", value: function setMatrix(matrix) {
      this.layer.setMatrix(matrix);
      this.gizmoLayer.setMatrix(matrix);
      this.layer.update();
      this.gizmoLayer.update();
    }

    // Clears current layer in a way that undo-stack keeps consistent.
    // 
    //  @param {bool} enableUndo - If false, the undoStack is cleared.
  }, { key: "clearLayer", value: function clearLayer() {var enableUndo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (enableUndo) {
        var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_5__["Actions"].RemoveShapes(this.layer, this.layer.shapes);
        this.undoStack.run(action);
      } else {
        this.layer.clear();
        this.undoStack.clear();
      }
    } }, { key: "addShape", value: function addShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_5__["Actions"].AddShape(this.layer, shape);
      this.undoStack.run(action);
    } }, { key: "removeShape", value: function removeShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_5__["Actions"].AddShape(this.layer, shape);
      this.undoStack.run(action);
    } }]);return Edit2DContext;}();


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);

namespace.Shape = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Shape"];
namespace.Polygon = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polygon"];
namespace.Polyline = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"];
namespace.PolyBase = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"];
namespace.Path = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Path"];
namespace.PolygonPath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolygonPath"];
namespace.PolylinePath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolylinePath"];
namespace.Circle = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Circle"];
namespace.Style = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Style"];
namespace.EllipseArcParams = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["EllipseArcParams"];
namespace.PolygonTool = _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_14__["default"];
namespace.Selection = _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.MoveTool = _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_13__["default"];
namespace.PolygonEditTool = _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_15__["default"];
namespace.InsertSymbolTool = _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_16__["default"];
namespace.Math2D = _Math2D_js__WEBPACK_IMPORTED_MODULE_3__["Math2D"];
namespace.VertexGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["VertexGizmo"];
namespace.RectangleTool = _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_17__["default"];
namespace.LineTool = _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_20__["default"];
namespace.CopyTool = _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_19__["default"];
namespace.Actions = _Actions_js__WEBPACK_IMPORTED_MODULE_5__["Actions"];
namespace.UndoStack = _UndoStack_js__WEBPACK_IMPORTED_MODULE_6__["default"];
namespace.UndoTool = _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_18__["default"];
namespace.Edit2DContext = Edit2DContext;
namespace.CanvasGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["CanvasGizmo"];
namespace.CanvasGizmoBase = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["CanvasGizmoBase"];
namespace.ShapeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["ShapeLabel"];
namespace.AlignX = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["AlignX"];
namespace.AlignY = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["AlignY"];
namespace.AreaLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["AreaLabel"];
namespace.EdgeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["EdgeLabel"];
namespace.UnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_9__["UnitHandler"];
namespace.SimpleUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_9__["SimpleUnitHandler"];
namespace.DefaultUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_9__["DefaultUnitHandler"];
namespace.ShapeLabelRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["ShapeLabelRule"];
namespace.ShapeWrapper = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["ShapeWrapper"];
namespace.SegmentTree = _SegmentTree_js__WEBPACK_IMPORTED_MODULE_12__["default"];
namespace.TangentGizmo = _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_11__["default"];
namespace.MeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_21__["MeasureTransform"];
namespace.DefaultMeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_21__["DefaultMeasureTransform"];
namespace.ShapeToolTip = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_10__["ShapeToolTip"];
namespace.Svg = _Svg_js__WEBPACK_IMPORTED_MODULE_4__["Svg"];
namespace.SolidDefConvert = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_22__["SolidDefConvert"];
namespace.BooleanOps = _BooleanOps_js__WEBPACK_IMPORTED_MODULE_23__["BooleanOps"];

/***/ }),

/***/ "./extensions/Edit2D/Edit2DContextMenu.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/Edit2DContextMenu.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DContextMenu; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

Edit2DContextMenu = /*#__PURE__*/function () {

  // @param {ToolSet} toolSet (see Edit2D.js)
  function Edit2DContextMenu(viewer, toolSet) {_classCallCheck(this, Edit2DContextMenu);

    this.viewer = viewer;
    this.toolSet = toolSet;

    // Define ContextMenu callback
    this.callbackId = "Edit2D_".concat(toolSet.name);
    this.callback = this.onContextMenu.bind(this);
  }_createClass(Edit2DContextMenu, [{ key: "register", value: function register()

    {
      this.viewer.registerContextMenuCallback(this.callbackId, this.callback);
    } }, { key: "unregister", value: function unregister()

    {
      this.viewer.unregisterContextMenuCallback(this.callbackId);
    } }, { key: "findGizmoUnderMouse", value: function findGizmoUnderMouse(

    gizmos, clientX, clientY) {
      // Check element under mouse
      var elem = document.elementFromPoint(clientX, clientY);

      // Check if it matches with any vertex gizmo
      return gizmos.findIndex(function (g) {return g.container === elem;});
    }

    // Note that editTool.getVertexIndex() does not work if a context menu is already open.
    // Reason is that the evens are all consumed by an invisible full-screen-div, so that a
    // gizmos cannot detect anymore if the mouse is on it.
  }, { key: "vertexGizmoUnderMouse", value: function vertexGizmoUnderMouse(clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.vertexGizmos;
      return this.findGizmoUnderMouse(gizmos, clientX, clientY);
    } }, { key: "edgeGizmoUnderMouse", value: function edgeGizmoUnderMouse(

    clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.edgeGizmos;
      return this.findGizmoUnderMouse(gizmos, clientX, clientY);
    }

    // Define callback to modify the viewer context menu
    //  @param {Object[]} menuItems - items to be modified
    //  @param {Object}   status    - ObjectContextMenu.js
  }, { key: "onContextMenu", value: function onContextMenu(menu, status) {var _this = this;

      var editTool = this.toolSet.tools.polygonEditTool;
      var layer = this.toolSet.context.layer;
      var event = status.event;

      // Check if a shape is selected for editing
      var shapeSelected = Boolean(editTool.poly);
      if (!shapeSelected) {
        // If not, keep original viewer context menu
        return;
      }

      // get mouse pos in layer coords
      var mousePos = layer.canvasToLayer(status.canvasX, status.canvasY);

      // Check if we hit a vertex gizmo. Note that a VertexGizmo exceeds the actual shape.
      var vertex = this.vertexGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnVertexGizmo = vertex !== -1;

      // Check if we hit an edge gizmo.
      var edgeGizmoIndex = this.edgeGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnEdgeGizmo = edgeGizmoIndex !== -1;

      // Check if "insert vertex" is possible at the current position
      var edgeIndex = editTool.findEdgeUnderMouse(mousePos);
      var newVertexPos = editTool.getNewVertexPosition(mousePos, edgeIndex);
      var mouseCloseToEdge = Boolean(newVertexPos);

      // If the mouse is neither on a shape nor on a vertex gizmo, exist here.
      // Note that the gizmos exceed the actual shape by a few pixels, so we may hit one without hitting the shape.
      var mouseOnShape = layer.hitTest(mousePos.x, mousePos.y);
      if (!mouseOnShape && !mouseOnVertexGizmo && !mouseCloseToEdge) {
        // When clicking somewhere else, leave default context menu
        return;
      }

      // If a polygon is selected for editing, we hijack the menu completely and remove the 
      // viewer default stuff (Show all layers etc.) - assuming that the user is focusing on 2D editing.
      menu.length = 0;

      // TODO: This item can be enabled by default when we integrated SolidDef
      if (window.SolidDef) {
        // add cutout menu item
        var selected = editTool.poly;
        var isClosed = selected instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && selected.isClosed;
        if (isClosed) {
          menu.push({
            title: 'Apply as Cutout',
            target: function target() {
              var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ApplyCutOut(layer, selected);
              _this.toolSet.context.undoStack.run(action);
            } });

        }
      }

      // If so, add RemoveVertex item
      if (mouseOnVertexGizmo) {
        menu.push({
          title: 'Remove Vertex',
          target: function target() {
            editTool.removePoint(vertex);
          } });

      } else if (newVertexPos) {
        // Add "Insert Vertex" menu item
        menu.push({
          title: 'Insert Vertex',
          target: function target() {
            // insert new vertex after edge starting point
            var newVertex = edgeIndex + 1;
            editTool.insertPoint(newVertex, newVertexPos);
          } });

      }

      // Consider mouse as "onEdge" if it is hovering the edge gizmo or close to the edge itself.
      var onEdge = mouseOnEdgeGizmo || mouseCloseToEdge;

      // Check if Create/Remove arc is possible
      var enableArc = editTool.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];

      // If mouse is close to an edge or on an edge gizmo, add edge operations
      if (!mouseOnVertexGizmo && onEdge && enableArc) {

        var currentType = editTool.poly.getEdgeType(edgeIndex);

        // Add "Change-To" operations for all edge types except the current...

        // Change-to-Line
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
          menu.push({
            title: 'Change to Line Segment',
            target: function target() {
              editTool.changeEdgeToLine(edgeIndex);
            } });

        }

        // Change-to-Bezier
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier) {
          menu.push({
            title: 'Change to Arc Segment',
            target: function target() {
              editTool.changeEdgeToBezier(edgeIndex);
            } });

        }

        // Change-to-Ellipse
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse && editTool.enableEllipseArcs) {
          menu.push({
            title: 'Change to Ellipse Segment',
            target: function target() {
              editTool.changeEdgeToEllipse(edgeIndex);
            } });

        }
      }
    } }]);return Edit2DContextMenu;}();

/***/ }),

/***/ "./extensions/Edit2D/Edit2DSnapper.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/Edit2DSnapper.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DSnapper; });
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var SnapType = Autodesk.Viewing.MeasureCommon.SnapType;

// Edit2DSnapper combines 3 different types of snapping:
//  1. Snapping to sheet geometry
//  2. Snapping to other geometry in the same layer
//  3. Snapping to angles and alignments

var av = Autodesk.Viewing;var

Edit2DSnapper = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {Layer} layer
  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)
  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);
    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // Snapper for sheet geometry and layer geometry.
    // Note: SnapResults are always stored in LMV world-coords (!=layer coords). Otherwise, SnapperIndicator would not display correctly.
    this.sheetSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);
    this.layerSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);

    // Used for snapping to angles and alignments
    this.angleSnapper = new _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__["default"](gizmoLayer);

    // tmp box reused for snapping
    this.snapBox = new THREE.Box2();

    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.
    this.sheetSnapper.activate();
    this.layerSnapper.activate();

    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)
    this.onCameraChangeCb = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);

    // If there is a model already, compute SegmentTree right now
    this.initSegmentTrees();

    // Reused tmp vector
    this.tmpVec = new THREE.Vector3();

    // If we snapped to a line segment, this member contains
    // this line segment in layer coords. See _getGeomSnapLine().
    this.geomSnapLine = {
      a: new THREE.Vector3(),
      b: new THREE.Vector3() };

  }_createClass(Edit2DSnapper, [{ key: "dtor", value: function dtor()

    {
      this.sheetSnapper.deactivate();
      this.layerSnapper.deactivate();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updateSnapperIndicators();
    }

    // Make sure that all visible models have a SegmentTree
  }, { key: "initSegmentTrees", value: function initSegmentTrees() {
      var models = this.viewer.getVisibleModels();
      models.forEach(function (model) {
        // Note: We have to wait until the model finished loading. Otherwise, we may end up with a segmentTree that only
        //       contains a subset of the segments.
        //       In addition, make sure to skip the segment building in case it's a leaflet (e.g. a raster PDF).
        var isLeaflet = !!(model.myData && model.myData.isLeaflet);
        if (model.is2d() && !isLeaflet && !model.segmentTree && model.isLoadDone()) {
          model.segmentTree = new _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
          model.segmentTree.buildFromModel(model);
        }
      });
    } }, { key: "updateSnapperIndicators", value: function updateSnapperIndicators()

    {
      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper
      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear 
      // the sheet-snapping indicator again.
      if (this.sheetSnapper.isSnapped()) {
        this.sheetSnapper.indicator.render();
      } else {
        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.
        this.layerSnapper.indicator.render();
      }
    }

    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.
    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.
  }, { key: "getSnapPosition", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);

      // keep snapping gizmos up to date
      this.angleSnapper.updateSnapLineGizmos(p);

      this.updateSnapperIndicators();

      return p;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.angleSnapper.clearSnappingGizmos();
      this.sheetSnapper.clearSnapped();
      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();
      this.layerSnapper.clearSnapped();
      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();
    }

    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.
    // Otherwise, it has no effect.
  }, { key: "startAngleSnapping", value: function startAngleSnapping(poly, draggedVertex) {
      this.angleSnapper.startSnapping(poly, draggedVertex);
    }

    // Stop snapping to angles. (No effect if angleSnapping is already off).
  }, { key: "stopAngleSnapping", value: function stopAngleSnapping() {
      this.angleSnapper.stopSnapping();
    }

    // Like getSnapPosition, but excluding Snapping gizmo updates.
  }, { key: "_getSnapPosition", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {

      // Discard any outdated snapping results
      this.angleSnapper.clearSnappingResult();
      this.sheetSnapper.clearSnapped();
      this.layerSnapper.clearSnapped();

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Check if geom-snapping is possible (pGeom is in layer-coords)
      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);

      // Check if we snapped to line geometry. If so, we can still allow angle-snapping - as long as we constrain it to the geometry snapLine.
      var geomSnapLine = this._getGeomSnapLine();

      if (pGeom && !geomSnapLine) {
        // We snapped to geometry and the snapType does not allow us to combine it with angle snapping
        // => Just return result of geometry snapping
        return pGeom;
      }

      // Apply angle-snapping. If we snapped to line geometry already, constrain angleSnapping to this line.
      this.angleSnapper.snapToAngle(p, geomSnapLine);

      // If there is no angle-snap, just apply the geometry snap
      if (geomSnapLine && !this.angleSnapper.isSnapped()) {
        return pGeom;
      }

      // By default, SnapperIndicator only considers the geometry snapping result. If we corrected the snap point and used the intersection with an
      // angle snapLine, we have to update the SnapResult so that the snapPoint is correctly reflected by the SnapperIndicator.
      if (geomSnapLine && this.angleSnapper.isSnapped()) {
        var result = this._getGeomSnapResult();

        // p is in 2D layer coords, but LMV Snapper snapResults are always stored in LMV world coords
        var pWorld = new THREE.Vector3(p.x, p.y, 0.0).applyMatrix4(this.layer.layerToWorld);

        result.geomType = SnapType.SNAP_INTERSECTION;
        result.snapPoint = pWorld;
        result.geomVertex = result.snapPoint; // Otherwise, snapResult.isEmpty() returns true
      }

      return p;
    }

    // Gets snap position from mouse event. 
    //  @returns {Vector2|null} Snapped position or null if not snapped.
  }, { key: "_getGeomSnapPosition", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Compute snap position for model geom and edit layer. 
      // Both may be undefined if there was nothing to snap to.
      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);
      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);

      // If nothing is snapped, don't snap
      if (!pSheet && !pLayer) {
        return null;
      }

      // If only one snap point was found, use it
      if (!pLayer) {
        return pSheet;
      } else if (!pSheet) {
        return pLayer;
      }

      // Get distances of snapPoints to accurate position
      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);
      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);

      // Choose the closer snap. If equal, prefer edit layer snap.
      // We discard unused snap results here, so that snapper indicator keeps correct
      if (distSheet < distLayer) {
        // Use sheet snap and discard the other snap result
        this.layerSnapper.clearSnapped();
        return pSheet;
      } else {
        // Use layer snap and discard the other snap result
        this.sheetSnapper.clearSnapped();
        return pLayer;
      }
    }

    // Returns the SnapResult of sheetSnapper or layerSnapper if any of them is currently snapped. Returns null otherwise.
    // Note that LMV snapResults contain values in lmv world coords.
  }, { key: "_getGeomSnapResult", value: function _getGeomSnapResult() {

      // Check which of the snappers has snapped
      var sheetSnap = this.sheetSnapper.isSnapped();
      var layerSnap = this.layerSnapper.isSnapped();
      if (!sheetSnap && !layerSnap) {
        return null;
      }

      // Get latest SnapResult
      var geomSnapper = sheetSnap ? this.sheetSnapper : this.layerSnapper;
      return geomSnapper.getSnapResult();
    }

    // If the last geometry snapping successfully snapped to a line segment, this function returns this line segment.
    // Result is in layer-coords.
    //  @returns {Object} - If we snapped to a line segment, we return r={a, b} where r.a and r.b are line start/end as Vector2.
  }, { key: "_getGeomSnapLine", value: function _getGeomSnapLine() {

      var result = this._getGeomSnapResult();
      if (!result) {
        return null;
      }

      // If we snapped to an edge, return this edge. Note that SnapType may be SNAP_EDGE, but may also be SNAP_VERTEX
      var edgeGeom = result.geomEdge;
      if (edgeGeom) {
        var verts = result.geomEdge.vertices;

        // Copy edge start/end to this.geomSnapLine
        this.geomSnapLine.a.copy(verts[0]);
        this.geomSnapLine.b.copy(verts[1]);

        // SnapResults are in world coords. We want the geomSnapLine in layer coords.
        this.geomSnapLine.a.applyMatrix4(this.layer.worldToLayer);
        this.geomSnapLine.b.applyMatrix4(this.layer.worldToLayer);

        return this.geomSnapLine;
      }

      // Another SnapType => No line constraint.
      return null;
    }

    // Snaps to 2D edit layer geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
    //  @returns {Vector2} - snap position in layer coords.
  }, { key: "_getEditLayerSnapPosition", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {

      // Note that snapper needs a Vector3 to work.
      var point = this.layer.canvasToLayer(canvasX, canvasY, this.tmpVec);

      // compute snap radius in layer coords
      var radius = this.layerSnapper.detectRadiusInPixels * this.layer.getUnitsPerPixel();

      // create bbox centered at the point and expanded by snapRadius in each direction
      this.snapBox.min.set(point.x - radius, point.y - radius);
      this.snapBox.max.set(point.x + radius, point.y + radius);

      // Build dictionary of dbIds of all shapes intersecting the snapBox
      var dbIds = {};
      this.layer.enumShapes(this.snapBox, function (shape) {
        // Collect dbId - unless shape is excluded from snapping
        if (!snappingFilter || snappingFilter(shape)) {
          dbIds[shape.id] = true;
        }
      });

      // Collect all triangulated meshes intersecting the snapBox
      var meshes = [];
      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});

      // Only consider edges/arcs/vertices within snapRadius
      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};

      // Run snapper on the given meshes/dbIds. Note that we run snapping in layer coords.
      this.layerSnapper.clearSnapped();
      this.layerSnapper.snapping2DOverlay(point, meshes, filter, radius);

      // Stop here if nothing was snapped
      if (!this.layerSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position in layer-coords
      var res = this.layerSnapper.getSnapResult();
      var snapPos = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);

      // snapPos points to a vector inside snapResult. SnapResult will finally be converted to 
      // LMV world coords to make SnapperIndicator work. So, we copy it to a 2D vector first.
      snapPos = new THREE.Vector2().copy(snapPos);

      // SnapperIndicator requires world-coords in getSnapResult() to display correctly. 
      // Since we computed snapping in layer-coords, we finally convert it to LMV world coords.
      res.applyMatrix4(this.layer.layerToWorld);

      // Return snap position in layer coords
      return snapPos;
    }

    // Snaps to sheet geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
  }, { key: "_getSheetSnapPosition", value: function _getSheetSnapPosition(canvasX, canvasY) {var _this = this;

      // Make sure that SegmentTree exists for all visible 2D models
      this.initSegmentTrees();

      // Callback to enum segments of all visible models
      var enumSegments = function enumSegments() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        var models = _this.viewer.getVisibleModels();
        models.forEach(function (model) {
          // NOTE: SegmentTree may not be available yet if a model is still loading.
          //       In this case, we exclude it from snapping until loading is done.
          if (model.is2d() && model.segmentTree) {var _model$segmentTree;
            (_model$segmentTree = model.segmentTree).enumSegments.apply(_model$segmentTree, args);
          }
        });
      };

      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var pos = this.viewer.impl.intersectGround(canvasX, canvasY);
      this.sheetSnapper.snapping2DWithSegmentEnum(pos, enumSegments);

      // If not snapped, just return current position
      if (!this.sheetSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position
      var res = this.sheetSnapper.getSnapResult();
      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3

      // convert result from LMV world coords to layer coords
      // Note that we have to copy first, because p3D is a reference into the SnapResult. 
      // The SnapResult itself must remain in world coords to keep SnapperIndicator correct.
      p3D = this.tmpVec.copy(p3D).applyMatrix4(this.layer.worldToLayer);

      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()
      return new THREE.Vector2().copy(p3D);
    } }]);return Edit2DSnapper;}();


av.GlobalManagerMixin.call(Edit2DSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/EditLayer.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/EditLayer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditLayer; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var nextLayerId = 1;

// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.
var DefaultLineHitRadius = 10;

var av = Autodesk.Viewing;

// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.
var EditLayer = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer - Viewer instance needed to create materials
  function EditLayer(viewer) {var _this = this;_classCallCheck(this, EditLayer);

    av.EventDispatcher.prototype.apply(this);

    // Contains the triangulated geometry ready for rendering.
    this.scene = new THREE.Scene();

    // @param {Shape[]}
    this.shapes = [];

    // @param {CanvasGizmoBase[]}
    this.canvasGizmos = [];

    this.id = nextLayerId++;

    // We don't use font rendering so far
    var fontEngine = null;

    // Always use client coords for drawing
    var toPageUnits = 1.0;

    // LMVCanvasContext doesn't really need a viewport - unless it's used with Pdf.js
    var dummyViewport = { width: 0, height: 0 };
    this.context = new Autodesk.Extensions.CompGeom.LmvCanvasContext(dummyViewport, toPageUnits, this._processMesh.bind(this), fontEngine);

    // When using LMVCanvasContext for PDF, this is not needed because PDF.js takes care that mozCurrentTransform exists.
    // In our case, we must make LMVCanvasContext create it.
    this.context.addContextCurrentTransform();

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);

    // By default, we always update on modification operations. But it can (and should) be temporarily disabled 
    // for batch operations. 
    this.autoUpdate = true;

    this.toPageUnits = toPageUnits;

    this.styleModifiers = [];

    // Update gizmo positions on camera changes
    this.onCameraChange = function () {return _this.updateCanvasGizmos();};
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // Use custom tesselation accuracy for Bezier arcs. We use a bit finer values than PDF does right now.
    this.context.setTessParams({
      numIterations: 100,
      minSegLenFraction: 0.01 });


    // Optional transform between layer geometry and LMV world coords (default: identity)
    this.layerToWorld = new THREE.Matrix4();
    this.worldToLayer = new THREE.Matrix4();

    // Reused tmp values
    this.tmp_pWorld = new THREE.Vector3();
    this.tmp_p0 = new THREE.Vector2();
    this.tmp_p1 = new THREE.Vector2();
    this.tmp_ray = new THREE.Ray();
    this.tmp_box = new THREE.Box2();

    // For editing on planes in 3D
    this.is3d = false;
    this.plane = new THREE.Plane();
    this._updatePlane();
  }_createClass(EditLayer, [{ key: "dtor", value: function dtor()

    {
      this._clearScene();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    }

    // @param {Shape} shape
    // @returns {number} - The id of the shape. Used to access this shape later.
  }, { key: "addShape", value: function addShape(shape) {
      this.shapes.push(shape);

      this.dispatchEvent({ type: EditLayer.SHAPE_ADDED, shape: shape });

      this._onModified();
    }

    // @param {Shape[]} shapes
  }, { key: "addShapes", value: function addShapes(shapes) {var _this2 = this;
      shapes.forEach(function (s) {return _this2.addShape(s);});
    }

    // Removes the given shape. 
    //  @returns {bool} true if shape was found and removed, otherwise false.
  }, { key: "removeShape", value: function removeShape(shape) {
      var index = this.shapes.indexOf(shape);
      if (index === -1) {
        return false;
      }
      this.shapes.splice(index, 1);

      this.dispatchEvent({ type: EditLayer.SHAPE_REMOVED, shape: shape });

      this._onModified();
      return true;
    } }, { key: "clear", value: function clear()

    {
      this.shapes.length = 0;

      this.dispatchEvent({ type: EditLayer.LAYER_CLEARED });

      this._onModified();
    }

    // Must be called after modifications to update the scene.
  }, { key: "update", value: function update() {

      // clear scene
      this._clearScene();

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // apply override style if specified
        var overrideStyle = this._getOverrideStyle(shape);

        shape.draw(this.context, overrideStyle);
      }

      // Make sure that all shapes are processed
      this.context.flushBuffer(0, true);

      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.
      this.viewer.impl.invalidate(false, false, true);

      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed
      this.updateCanvasGizmos();
    } }, { key: "updateCanvasGizmos", value: function updateCanvasGizmos()

    {
      for (var i = 0; i < this.canvasGizmos.length; i++) {
        this.canvasGizmos[i].update();
      }
    }

    // @param {CanvasGizmoBase} gizmo - Must implement gizmo.update() to respond to changes.
  }, { key: "addCanvasGizmo", value: function addCanvasGizmo(gizmo) {
      this.canvasGizmos.push(gizmo);
    }

    // @param {CanvasGizmoBase} gizmo
  }, { key: "removeCanvasGizmo", value: function removeCanvasGizmo(gizmo) {
      var index = this.canvasGizmos.indexOf(gizmo);
      if (index === -1) {
        return false;
      }
      this.canvasGizmos.splice(index, 1);
      return true;
    } }, { key: "getViewport", value: function getViewport()

    {
      return this.viewport;
    }

    // Returns the topmost shape containing the point (x,y)
    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.
  }, { key: "hitTest", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;

      // process shapes backwards to find topmost first
      for (var i = this.shapes.length - 1; i >= 0; i--) {
        var shape = this.shapes[i];
        var radiusLC = this.getLineHitRadius(shape, hitRadius);

        // Compute box centered at (x,y) with given hitRadius
        var hitBox = this.tmp_box.makeEmpty();
        hitBox.min.set(x - radiusLC, y - radiusLC);
        hitBox.max.set(x + radiusLC, y + radiusLC);

        // get (latest) shape bbox
        shape.updateBBox();

        // Skip if shape bounds and hitBounds don't intersect
        if (!shape.bbox.isIntersectionBox(hitBox)) {
          continue;
        }

        if (shape.hitTest(x, y, radiusLC)) {
          return shape;
        }
      }
    }

    // Used for line-feature hit tests: 
    // We consider a point p to be "on edge e" if p is within a certain radius around e.
    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.
  }, { key: "getLineHitRadius", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;

      var unitsPerPixel = this.getUnitsPerPixel();

      // Get line-width in layer coords
      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;

      // For thin lines, consider hits as long as they are within minPixels radius
      return Math.max(lineWidth, hitRadius * unitsPerPixel);
    }

    // Optional: Sets a callback to override the style for either all or a subset of shapes.
    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.
  }, { key: "addStyleModifier", value: function addStyleModifier(modifier) {
      this.styleModifiers.push(modifier);
      this._onModified();
    } }, { key: "removeStyleModifier", value: function removeStyleModifier(

    modifier) {
      var index = this.styleModifiers.indexOf(modifier);
      if (index == -1) {
        return false;
      }
      this.styleModifiers.splice(index, 1);
      this._onModified();
      return true;
    }

    // Convert layer coordinates to canvas coords.
    //  @param {Vector2|Vector3} [target]
  }, { key: "layerToCanvas", value: function layerToCanvas(x, y) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // get point in LMV world coords
      var pWorld = this.tmp_pWorld.set(x, y, 0).applyMatrix4(this.layerToWorld);

      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.
      var res = this.viewer.impl.worldToClient(pWorld);
      return target.set(res.x, res.y, 0.0); // Set z to 0 if target is Vector3. Otherwise, the param has no effect
    }

    // Note: This function currently assumes a uniform unitPerPixel ratio. This may change if we add support for projected
    //       planes in 3D, where pixelRatio may vary across the layer and may require different values in x/y direction.
  }, { key: "getPixelsPerUnit", value: function getPixelsPerUnit() {
      var _window = this.getWindow();

      // get screen projections of two points in layer-coords that have unit-distance
      var p0 = this.layerToCanvas(0, 0, this.tmp_p0);
      var p1 = this.layerToCanvas(1, 0, this.tmp_p1);
      return p0.distanceTo(p1) / _window.devicePixelRatio;
    } }, { key: "getUnitsPerPixel", value: function getUnitsPerPixel()

    {
      return 1.0 / this.getPixelsPerUnit();
    }

    // Convert canvas coordinates (from input events) to layer viewport coordinates
    //  @param {Vector2|Vector3} [target]
  }, { key: "canvasToLayer", value: function canvasToLayer(canvasX, canvasY)
    {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      // Compute "ray through pixel" in world-coords.
      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);
      var ray = this.viewer.impl.viewportToRay(vpVec, this.tmp_ray);

      // Intersect ray with plane that we edit on
      var intersect = ray.intersectPlane(this.plane, this.tmp_pWorld);

      if (!intersect) {
        // TODO: For 3D scenarios, we must properly support the case that canvasToLayer fails.
        return target.set(0, 0);
      }

      // Convert from world to layer coords
      intersect.applyMatrix4(this.worldToLayer);

      // Set 3rd-component to 0 for Vector3 targets. For 2D, the z param is ignored
      return target.set(intersect.x, intersect.y, 0);
    }

    // Runs the callback for all shapes in the layer that overlap the given bbox
    //  @param {Box2} bbox
    //  @param {function(Shape)} cb
  }, { key: "enumShapes", value: function enumShapes(bbox, cb) {
      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Make sure that bbox is up-to-date
        shape.updateBBox();

        if (bbox.isIntersectionBox(shape.bbox)) {
          cb(shape);
        }
      }
    }

    // Runs the callback for all triangulated 2D meshes created in the last update() call.
  }, { key: "enumMeshes", value: function enumMeshes(bbox, cb) {
      for (var i = 0; i < this.scene.children.length; i++) {
        var mesh = this.scene.children[i];
        var meshBox = mesh.geometry.boundingBox;

        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,
        //       we would need to compute a world-box using applyMatrixWorld() here.

        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,
        // it's important to call intersectsBox on the input box and not on the mesh.
        if (bbox.isIntersectionBox(meshBox)) {
          cb(mesh);
        }
      }
    } }, { key: "findShapeById", value: function findShapeById(

    id) {
      return this.shapes.find(function (s) {return s.id == id;});
    } }, { key: "setMatrix", value: function setMatrix(

    layerToWorld) {
      this.layerToWorld.copy(layerToWorld);
      this.worldToLayer.getInverse(layerToWorld);

      // Update projection plane
      this._updatePlane();
    }

    // 
    // --- Internal functions ---
    //

    // process meshData produced by LmvCanvasContext
  }, { key: "_processMesh", value: function _processMesh(meshData) {

      // create GeometryBuffer
      var mdata = { mesh: meshData, is2d: true, packId: "0", meshIndex: 0 };
      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      // create 2D material
      // Note that it is essential not to associate the material witha model. Otherwise,
      // the EditShapes will disappear if model layer 0 is switched off.
      var matman = this.viewer.impl.getMaterials();
      var matName = matman.create2DMaterial(null, meshData.material);
      var material = matman.findMaterial(null, matName);

      var mesh = new THREE.Mesh(geom, material);

      // Set mesh matrix
      mesh.matrix = this.layerToWorld;
      mesh.matrixAutoUpdate = false; // make sure matrix is not overwritten within updateMatrixWorld() later

      this.scene.children.push(mesh);
    } }, { key: "_onModified", value: function _onModified()

    {
      if (this.autoUpdate) {
        this.update();
      }
    }

    // Apply one or more style modifiers
  }, { key: "_getOverrideStyle", value: function _getOverrideStyle(shape) {
      var style = shape.style;
      for (var i = 0; i < this.styleModifiers.length; i++) {
        var mod = this.styleModifiers[i];
        style = mod(shape, style) || style;
      }
      return style;
    }

    // Dispose all shapes generated by this layer.
  }, { key: "_clearScene", value: function _clearScene() {

      // Dispose any GPU resources for previous output geometry
      // Note that we construct the scene as a flat list of meshes (see _processMesh). So, we don't need a generic traversal here.
      var meshes = this.scene.children;
      for (var i = 0; i < meshes.length; i++) {
        var mesh = meshes[i];
        mesh.geometry.dispose();

        // TODO: We have to take care to dispose materials here as well. However, just disposing materials here as well would produce a couple of issues:
        //
        //  1. MaterialManager caches materials based on properties. So, we cannot safely assume that the materials are solely used by ourselves.
        //     => MaterialManager currently only allows models to own 2D materials. We have to generalize it to support "ownerIDs" so
        //        that we can ensure that the materials are owned by this layer.
        //  2. Recompiling shaders on each update would be a waste. So we will need some caching.
      }
      this.scene.children.length = 0;
    }

    // Only needed for 3D scenes
  }, { key: "_updatePlane", value: function _updatePlane() {
      // The layer geometry itself is in the {z=0} plane
      this.plane.normal.set(0, 0, 1);
      this.plane.constant = 0.0;

      // Transform plane to world-coords
      this.plane.applyMatrix4(this.layerToWorld);
    } }]);return EditLayer;}();


av.GlobalManagerMixin.call(EditLayer.prototype);

EditLayer.SHAPE_ADDED = 'shapeAdded';
EditLayer.SHAPE_REMOVED = 'shapeRemoved';
EditLayer.LAYER_CLEARED = 'layerCleared';

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, PolyBase, Polygon, Polyline, EdgeType, EllipseArcParams, Path, PolygonPath, PolylinePath, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeType", function() { return EdgeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcParams", function() { return EllipseArcParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonPath", function() { return PolygonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylinePath", function() { return PolylinePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var nextShapeId = 1;

var av = Autodesk.Viewing;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

var tmpVec3 = new THREE.Vector3();
var tmpVec3_2 = new THREE.Vector3();
var tmpBox2 = new THREE.Box2();

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,128)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,128)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Add all points to given bbox.
var addPointsToBBox = function addPointsToBBox(points, dstBox) {
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function () {
  function Shape() {var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    this.style = style;

    // assign unique id
    this.id = nextShapeId++;

    this.bbox = new THREE.Box2();
    this.bboxDirty = true;

    // Should be set by creator by something more descriptive.
    this.name = this.id.toString();
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.
  }, { key: "move", value: function move()
    /*dx, dy*/{return this;}

    // Apply a transform to each point. (assuming z=0)
    // @param {Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    }

    // Return bbox while making sure that it's up-to-date.
  }, { key: "getBBox", value: function getBBox() {
      this.updateBBox();
      return this.bbox;
    }

    // @param {string}  svg - e.g. '<path d="M 13,4 L 14,4"/>'
    // @param {Object}  [options]
    // @param {boolean} [options.forcePaths] - By default, paths without arcs are interpreted as Polygon resp. Polyline.
    //                                         This option ensures that the result is always a Path. This is important
    //                                         if you want to allow converting it into a path later.
  }, { key: "toSVG",



    // Convert to SVG style string, e.g., '<path d="M 13,4 L 14,4"/>'
    // See Svg.toSvg() comment for options.
    //
    // Note: The digits param is deprecated and only exists for legacy reasons. 
    //       Set digits via options.digits instead.
    value: function toSVG(options, digits) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvg(this, options, digits);
    }

    // Converts shape into a DOM element (usually a <path>).
    //  @param {Object} 
    //  @param {bool}   [options.exportStyle=true]
  }, { key: "createSvgShape", value: function createSvgShape(options) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvgElement(this, options);
    } }], [{ key: "fromSVG", value: function fromSVG(svg, options) {return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].fromSvg(svg, options);} }]);return Shape;}();


av.GlobalManagerMixin.call(Shape.prototype);

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);

  function PolyBase() {var _this;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolyBase).call(this, style));

    // Array of Array of points, each represented as an object {x, y}
    // By default, we start with a single loop/chain
    _this.loops = points ? [points] : [];

    // Set by derived classes
    _this.isClosed = undefined;return _this;
  }

  // For backward compatibility
  _createClass(PolyBase, [{ key: "getLoopCount", value: function getLoopCount()




    {
      return this.loops.length;
    } }, { key: "loopCount", value: function loopCount()

    {
      return this.loops.length;
    } }, { key: "isPolygon", value: function isPolygon()

    {return this.isClosed;} }, { key: "isPolyline", value: function isPolyline()
    {return !this.isClosed;} }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // get or create loop
      var loop = this.loops[loopIndex] || (this.loops[loopIndex] = []);

      // add point to loop
      var point = { x: x, y: y };
      loop.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      target = target || new THREE.Vector2();
      return target.copy(this.loops[loopIndex][index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.loops[loopIndex].splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var p = this.loops[loopIndex][index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.loops[loopIndex].splice(index, 0, p);
    } }, { key: "getVertexCount",











    // Returns 0 if a loop is empty or does not exist.
    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // Array may not exist yet if no vertices were added to the loop yet.
      var loop = this.loops[loopIndex];
      return loop ? loop.length : 0;
    }

    // Reset back to a single empty loop
  }, { key: "clear", value: function clear() {
      this.loops = [];
      this.modified();
    }

    // Enumerate all edges (a,b).
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {

      // get edge count
      var edgeCount = this.getEdgeCount();

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = this.nextIndex(i);

        // get points
        var a = this.getPoint(ai);
        var b = this.getPoint(bi);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb);
      return edgeIndex;
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];
        for (var i = 0; i < points.length; i++) {
          points[i].x += dx;
          points[i].y += dy;
        }
      }
      this.modified();
      return this;
    }

    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)
    // @param {THREE.Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          // set target to (x,y) * matrix
          var transformPoint = function transformPoint(x, y, target) {
            // convert to vec3, transform, and write back to target
            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);
            target.x = vec3.x;
            target.y = vec3.y;
            return target;
          };

          transformPoint(p.x, p.y, p);

          // transform Bezier control points
          if (this.isBezierArc(i, l)) {
            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);
            p.cp1x = cp.x;
            p.cp1y = cp.y;

            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);
            p.cp2x = cp.x;
            p.cp2y = cp.y;
          }

          // Transform ellipse arcs
          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)
          if (this.isEllipseArc(i, l)) {
            p.ellipseArcParams.applyMatrix4(matrix);
          }
        }
      }
      this.modified();
      return this;
    }

    // Copy a single loop from src poly and adds it to this one
    //  @param {PolyBase} srcPoly
    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src
  }, { key: "addLoop", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // copy loop points
      var srcLoop = srcPoly.loops[srcLoopIndex];
      var newLoop = cloneVectorArray(srcLoop);

      // get free loop index to store the new one
      var dstLoopIndex = this.nextFreeLoop();
      this.loops[dstLoopIndex] = newLoop;
      this.modified();

      return dstLoopIndex;
    } }, { key: "copy", value: function copy(

    srcPoly) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, srcPoly);

      this.isClosed = srcPoly.isClosed;

      // copy loops
      this.loops = [];
      for (var i = 0; i < srcPoly.getLoopCount(); i++) {
        this.addLoop(srcPoly, i);
      }
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.makeEmpty();
      for (var i = 0; i < this.loops.length; i++) {
        var loop = this.loops[i];
        if (loop) {
          addPointsToBBox(loop, this.bbox);
        }
      }
      return this.bbox;
    } }, { key: "indexValid", value: function indexValid(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return index >= 0 && index < this.getVertexCount(loopIndex);
    }

    // Returns -1 if there is no next Index    
  }, { key: "nextIndex", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle last vertex
      var isLast = index === this.getVertexCount(loopIndex) - 1;
      if (isLast) {
        // If closed, restart. Otherwise, there is no next index.
        return this.isClosed ? 0 : -1;
      }

      return index + 1;
    }

    // Returns -1 if there is no previous vertex index
  }, { key: "prevIndex", value: function prevIndex(index) {
      // Return -1 for invalid input
      if (!this.indexValid(index)) {
        return -1;
      }

      // Handle first vertex
      if (index === 0) {
        // if closed, continue at end. Otherwise, there is no previous index.
        return this.isClosed ? this.vertexCount - 1 : -1;
      }

      return index - 1;
    }

    // Returns index of the edge ending at the given vertex or -1 if it does not exist.
  }, { key: "edgeBeforeVertex", value: function edgeBeforeVertex(index) {
      return this.prevIndex(index);
    }

    // Returns index of the edge starting at the given vertex.
    // Returns -1 if index is the end vertex of a polyline.
  }, { key: "edgeAfterVertex", value: function edgeAfterVertex(index) {
      return this.edgeIndexValid(index) ? index : -1;
    }

    // Returns -1 if there is no previous edge.
  }, { key: "nextEdgeIndex", value: function nextEdgeIndex(edgeIndex) {
      // Check edgeIndex validity
      if (!this.edgeIndexValid(edgeIndex)) {
        return -1;
      }

      // Return -1 for last polyline edge
      if (!this.isClosed && edgeIndex === this.getEdgeCount() - 1) {
        return -1;
      }

      return this.nextIndex(edgeIndex);
    } }, { key: "prevEdgeIndex", value: function prevEdgeIndex(

    edgeIndex) {
      // Check edgeindex validity
      if (!this.edgeIndexValid(edgeIndex)) {
        return -1;
      }

      // Return -1 for first polyline edge
      if (!this.isClosed && edgeIndex === 0) {
        return -1;
      }

      return this.prevIndex(edgeIndex);
    } }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var edgeCount = this.getEdgeCount(loopIndex);
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    } }, { key: "prevEdgeExists", value: function prevEdgeExists(

    edgeIndex) {
      return this.edgeIndexValid(edgeIndex) && this.vertexCount > 2 && (edgeIndex > 0 || this.isClosed);
    } }, { key: "nextEdgeExists", value: function nextEdgeExists(

    index) {
      var isLastEdge = edgeIndex === this.vertexCount - 2;
      return this.edgeIndexValid(edgeIndex) && this.vertexCount > 2 && (!isLastEdge || this.isClosed);
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      this.getPoint(ia, outA);
      this.getPoint(ib, outB);
    } }, { key: "getEdgeDirection", value: function getEdgeDirection(

    edgeIndex, target) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      target = target || new THREE.Vector2();
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(this.points[ia], this.points[ib], target);
    } }, { key: "getEdgeLength", value: function getEdgeLength(

    edgeIndex) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      var a = this.points[ia];
      var b = this.points[ib];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.isClosed ? vertexCount : vertexCount - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    //
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(); i++) {
        this.getEdge(i, a, b);

        // apply optional measure transform
        if (measureTransform) {
          measureTransform.apply(a);
          measureTransform.apply(b);
        }

        sum += a.distanceTo(b);
      }
      return sum;
    }

    // Set vertices from THREE.Box2
  }, { key: "fromBox2", value: function fromBox2(box) {
      this.addPoint(box.min.x, box.min.y);
      this.addPoint(box.max.x, box.min.y);
      this.addPoint(box.max.x, box.max.y);
      this.addPoint(box.min.x, box.max.y);
      return this;
    }

    // Returns a point along an edge. Note that the edge may be an arc for Paths.
    //  @param {number} edgeIndex - A valid edgeIndex
    //  @param {number} t         - in [0,1]. t=0: startPoint, t=1: endPoint
    //  @param {Vector2} optionalTarget
  }, { key: "getPointOnEdge", value: function getPointOnEdge(edgeIndex, t, optionalTarget) {
      var target = optionalTarget || new THREE.Vector2();
      var p0 = this.points[edgeIndex];
      var p1 = this.points[this.nextIndex(edgeIndex)];
      return target.lerpVectors(p0, p1, t);
    }

    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, 
    // we assume an additional edge from end to start.
    // @returns {bool}
  }, { key: "isCCW", value: function isCCW() {
      return Autodesk.Extensions.CompGeom.polygonArea(this.points) > 0;
    }

    // Return 2D edge normal
  }, { key: "getLeftEdgeNormal", value: function getLeftEdgeNormal(edgeIndex, target) {
      target = target || new THREE.Vector2();

      // get start/end point of the edge
      var vi1 = edgeIndex;
      var vi2 = (edgeIndex + 1) % this.vertexCount;
      var v1 = this.points[vi1];
      var v2 = this.points[vi2];

      // get edge direction
      target.subVectors(v2, v1).normalize();

      // rotate by 90 degrees
      var tmp = target.x;
      target.x = -target.y;
      target.y = tmp;

      return target;
    }

    // Get edge normal facing outside wrt. to the outer loop. If the contour is not closed, we
    // assume an additional connection between endpoint and startpoint to defined "outside".
  }, { key: "getOuterNormal", value: function getOuterNormal(edgeIndex, target) {
      var normal = this.getLeftEdgeNormal(edgeIndex, target);
      return this.isCCW() ? normal.multiplyScalar(-1) : normal;
    }

    // Returns the first loopIndex >=0 that doesn't contain any points yet.
    //  @param {number}
  }, { key: "nextFreeLoop", value: function nextFreeLoop() {
      var isFree = function isFree(l) {return !l || !l.length;};
      var index = this.loops.findIndex(isFree);
      return index >= 0 ? index : this.loops.length;
    } }, { key: "points", get: function get() {// Create empty loop 0 if needed
      return this.loops[0] || (this.loops[0] = []);} }, { key: "length", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility
  }, { key: "vertexCount", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);
var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);

  function Polygon() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, points, style));
    _this2.isClosed = true;return _this2;
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it
    // is enclosed by an odd number of loops.
  }, { key: "hitTest", value: function hitTest(x, y) {
      if (!this.vertexCount) {
        return false;
      }

      // Compute number of loops that enclose (x,y)
      var rank = 0;
      for (var l = 0; l < this.loops.length; l++) {
        var loop = this.loops[l];
        if (!loop) {
          continue;
        }

        // set current loop as points
        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);

        // create dummy contour
        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
        var contour = [];
        for (var i = 0; i < loop.length; i++) {
          contour.push(i);
        }

        if (cp.pointInContour(x, y, contour)) {
          rank++;
        }
      }

      // Apply even-odd-rule
      return Boolean(rank & 1);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (this.points.length < 3) {
        return 0.0;
      }

      var area = 0.0;
      this.enumEdges(function (a, b) {
        // apply optional transform
        measureTransform && measureTransform.apply(a);
        measureTransform && measureTransform.apply(b);

        // sum up signed areas
        area += a.x * b.y - b.x * a.y;
      });

      return Math.abs(0.5 * area);
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);

  function Polyline() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, points, style));
    _this3.isClosed = false;return _this3;
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.vertexCount !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var EdgeType = {
  Line: 0, // Simple line segment
  Bezier: 1, // Cubic Bezier Arc
  Ellipse: 2 // Ellipse Arc
};


// Tmp objct for Ellipse Arcs. We need delayed initialization, 
// because Autodesk.Extensions.CompGeom might not be available yet at compile time.
var _tmpArc = null;
var getTmpArc = function getTmpArc() {
  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();
  return _tmpArc;
};

var tmpVec = new THREE.Vector2();

// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
//  @param {number}                         loopIndex - must be a valid loop index in path
var runLoop = function runLoop(ctx, path, loopIndex) {

  var points = path.loops[loopIndex];
  if (!points || !points.length) {
    return;
  }

  ctx.moveTo(points[0].x, points[0].y);

  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {
    switch (pStart.arcType) {
      case EdgeType.Line:break;

      case EdgeType.Bezier:{
          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);
          return;
        }

      case EdgeType.Ellipse:{
          var params = pStart.ellipseArcParams;
          var arc = path.exportEllipseArc(edgeIndex, getTmpArc(), loopIndex);

          // ignore arcs with NaN values
          if (!arc.isValid()) {
            break;
          }

          if (ctx.ellipseArcTo) {
            // Support SolidDef Path2D
            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);
          } else {
            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.
            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);
          }

          return;
        }}

    ctx.lineTo(pEnd.x, pEnd.y);
  };

  for (var i = 1; i < points.length; i += 1) {
    // The segment start point defines the type (line or arc)
    var prev = points[i - 1];
    var p = points[i];

    processSegment(prev, p, i - 1);
  }

  if (path.isClosed) {
    // add closing segment
    var pLast = points[points.length - 1];
    var pFirst = points[0];
    processSegment(pLast, pFirst, points.length - 1);

    ctx.closePath();
  }
};

// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
var runPath = function runPath(ctx, path) {
  for (var i = 0; i < path.loopCount(); i++) {
    runLoop(ctx, path, i);
  }
};

// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon
//  @param {LmvCanvasContext}      ctx
//  @param {Polyline|Polygon|Path} path
//  @param {Style}                 [overrideStyle]
var drawPath = function drawPath(ctx, path, overrideStyle) {

  if (!path.vertexCount) {
    return;
  }

  var style = overrideStyle || path.style;

  ctx.dbId = path.id;
  ctx.lineStyle = style.lineStyle;
  ctx.isScreenSpace = style.isScreenSpace;

  ctx.beginPath();

  // Run moveTo/lineTo/... commands on context
  runPath(ctx, path);

  var c = ctx.canvasContext;

  // Draw fill for closed paths
  if (path.isClosed) {

    c.fillStyle = style.fillColor;
    c.globalAlpha = style.fillAlpha;

    ctx.fill();
  }

  // draw lines
  c.strokeStyle = style.lineColor;
  c.globalAlpha = style.lineAlpha;
  c.lineWidth = style.lineWidth;

  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
  // For human eyes the line width is then the same width.
  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

  ctx.stroke();

  // restore default values
  ctx.dbId = -1;
  ctx.lineStyle = 0;
  ctx.isScreenSpace = false;
};

// SVG compatible ellipse arc params
// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
var EllipseArcParams = /*#__PURE__*/function () {

  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);
    // {number} Radius along x-axis
    this.rx = 0;

    // {number} Radius along y-axis
    this.ry = 0;

    // {number} ccw rotation of x/y-axes in degrees
    this.rotation = 0;

    // {bool} whether to use shorter or longer path around ellipse.
    this.largeArcFlag = false;

    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.
    this.sweepFlag = false;
  }_createClass(EllipseArcParams, [{ key: "copy", value: function copy(

    src) {
      this.rx = src.rx;
      this.ry = src.ry;
      this.rotation = src.rotation;
      this.largeArcFlag = src.largeArcFlag;
      this.sweepFlag = src.sweepFlag;
      return this;
    } }, { key: "clone", value: function clone()
    {
      return new EllipseArcParams().copy(this);
    }

    // @param {number} angle - counterclockwise in degrees
  }, { key: "rotate", value: function rotate(angle) {

      this.rotation += angle;

      // Normalize angle to keep within [0,360]
      this.rotation -= Math.trunc(this.rotation / 360) * 360;
    } }, { key: "scale", value: function scale(

    factor) {
      this.rx *= factor;
      this.ry *= factor;
    }

    // updates arc params according to a given transform.
    // Note: Transforming ellipse arcs is currently only supported for 
    //       simple transforms like translation, rotation, and uniform scaling.
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      // apply transform to x-axis direction
      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);
      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);
      var axis = tmpVec3.sub(tmpVec3_2);

      // obtain rotation angle and scale (assuming uniform scaling)
      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));
      var scale = axis.length();

      // update ellipse params
      this.rotate(rotAngle);
      this.scale(scale);

      // If a transform changes the orientation, we have to invert sweepFlag and rotation param
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].changesOrientation(matrix)) {
        this.sweepFlag = !this.sweepFlag;
        this.rotation = 360.0 - this.rotation;
      }
    } }]);return EllipseArcParams;}();


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);

  function Path(points) {var _this4;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, points, style));

    // If true, the path is automatically closed and can be filled.
    _this4.isClosed = isClosed;return _this4;
  }

  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   
  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.
  // @param {Vector2} newA, newB - edge vertices after modification
  _createClass(Path, [{ key: "_updateEllipseArcParams", value: function _updateEllipseArcParams(edgeIndex, newA, newB) {

      var params = this.points[edgeIndex].ellipseArcParams;

      // compute angle by which the edge was rotated
      var oldDir = this.getEdgeDirection(edgeIndex);
      var newDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(newA, newB);
      var dAngle = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].angleBetweenDirections(newDir, oldDir);

      params.rotate(THREE.Math.radToDeg(dAngle));

      // get scale factor applied to the edge
      var oldLength = this.getEdgeLength(edgeIndex);
      var newLength = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].distance2D(newA, newB); // also works for simple {x,y} pairs
      var scale = newLength / oldLength;

      // scale ellipse radii (if scaling is valid)
      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work
      if (scaleValid) {
        params.scale(scale);
      }
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {

      var p = this.points[index];

      var pNew = tmpVec.set(x, y);

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Update ellipse arc starting at p
      if (this.isEllipseArc(index)) {
        // next point must exist if index is a valid ellipse-arc edge.
        var pNext = this.points[this.nextIndex(index)];
        this._updateEllipseArcParams(index, pNew, pNext);
      }

      // Update arc params of segment ending at p
      // Note: For polylines, this edge does not exist for index==0
      var prevEdge = this.edgeBeforeVertex(index);
      if (this.edgeIndexValid(prevEdge)) {

        // get previous vertex
        var pPrev = this.points[prevEdge];

        // Update bezier control point
        if (this.isBezierArc(prevEdge)) {
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }

        // Update ellipse arc
        if (this.isEllipseArc(prevEdge)) {
          this._updateEllipseArcParams(prevEdge, pPrev, pNew);
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "getEdgeType", value: function getEdgeType(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = this.loops[loopIndex][segmentIndex].arcType;
      return type ? type : EdgeType.Line;
    }

    // Change segment into a cubic Bezier arc.
    // First and last control point are already given by the vertex positions.
    //
    //  @param {number} segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {number} cp1x, cp1y - Control point for start tangent
    //  @param {number} cp2x, cp2y - Control point for end tangent
    //  @param 
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y) {var loopIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      var p = this.loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Bezier;
      p.cp1x = cp1x;
      p.cp1y = cp1y;
      p.cp2x = cp2x;
      p.cp2y = cp2y;

      this.modified();
    }

    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.
    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
    //
    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {EllipseArcParams} arcParams 
  }, { key: "setEllipseArc", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var p = this.loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Ellipse;
      p.ellipseArcParams = arcParams.clone();

      this.modified();
    }

    // @param {number}           segmentIndex - must be a valid ellipse-arc edge
    // @param {EllipseArcParams} target
    // @returns {EllipseArcParams}
  }, { key: "getEllipseArcParams", value: function getEllipseArcParams(segmentIndex, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      // Find params
      var p = this.loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;

      // Return a copy if found, otherwise undefined.
      return srcParams && (target || new EllipseArcParams()).copy(srcParams);
    }

    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.
    //  @param {number}     edgeIndex     - must be an ellipse arc
    //  @param {EllipseArc} [target]      - optional
    //  @param {number}     [loopIndex=0] - loopIndex
    //  @returns {EllipseArc}
  }, { key: "exportEllipseArc", value: function exportEllipseArc(edgeIndex, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var points = this.loops[loopIndex];

      // get start/end points
      var nextIndex = this.nextIndex(edgeIndex, loopIndex);
      var pStart = points[edgeIndex];
      var pEnd = points[nextIndex];
      var params = pStart.ellipseArcParams;

      var arc = target || new EllipseArc();
      arc.setFromSvgArc(
      params.rx,
      params.ry,
      params.rotation,
      params.largeArcFlag,
      params.sweepFlag,
      pStart,
      pEnd);

      return arc;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this.loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;
    } }, { key: "isEllipseArc", value: function isEllipseArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this.loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;
    } }, { key: "isArc", value: function isArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);
    }

    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.
    // Only allowed for Bezier arcs. Result is not normalized.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getStartTangent", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var target = outTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];
      target.x = p.cp1x - p.x;
      target.y = p.cp1y - p.y;
      return target;
    }

    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getEndTangent", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var target = outTarget || new THREE.Vector2();
      var endVertex = this.nextIndex(segmentIndex);

      // get start/end point of the segment
      var pStart = this.points[segmentIndex];
      var pEnd = this.points[endVertex];
      target.x = pStart.cp2x - pEnd.x;
      target.y = pStart.cp2y - pEnd.y;
      return target;
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setStartTangent", value: function setStartTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      p.cp1x = p.x + tangent.x;
      p.cp1y = p.y + tangent.y;
      this.modified();
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setEndTangent", value: function setEndTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      var pEnd = this.points[this.nextIndex(segmentIndex)];
      p.cp2x = pEnd.x + tangent.x;
      p.cp2y = pEnd.y + tangent.y;
      this.modified();
    }

    // Change Bezier or Ellipse arc back to simple line segment
  }, { key: "removeArc", value: function removeArc(segmentIndex) {
      var p = this.points[segmentIndex];

      if (p.arcType === EdgeType.Bezier) {
        p.cp1x = undefined;
        p.cp1y = undefined;
        p.cp2x = undefined;
        p.cp2y = undefined;
      }

      if (p.ellipseArcParams) p.ellipseArcParams = undefined;

      // reset type
      p.arcType = EdgeType.Line;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
    // @param {Vector2} [target]
    // @param {number}  [loopIndex]
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex, optionalTarget) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var result = optionalTarget || new THREE.Vector2();
      var p = this.loops[loopIndex][segmentIndex];

      if (ctrlPointIndex === 1) {
        result.x = p.cp1x;
        result.y = p.cp1y;
      } else {
        result.x = p.cp2x;
        result.y = p.cp2y;
      }
      return result;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {
      var p = this.points[segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // Sample path into a Polygon or Polyline.
    //  @returns {Polygon|Polyline}
  }, { key: "toPoly", value: function toPoly() {var _this5 = this;

      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(
      l) {

        // Extents of the full path. Used to determine sample density: 
        // Finer sampling for arcs that are large wrt. to the full path.
        _this5.updateBBox();
        var sz = _this5.bbox.size().length();

        // Build up a polygon from path commands
        var ctx = {
          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},
          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},
          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {

            // get last added point
            var last = poly.points[poly.vertexCount - 1];

            // sample arc into lineTo() segments
            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz);
          },
          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {

            // determine tesselation params
            var tessParams = this.tessParams || Autodesk.Extensions.CompGeom.DefaultTessParams;
            var maxSegments = tessParams.numIterations;
            var minSegmentLength = tessParams.minSegLenFraction * sz;

            // tesselate arc
            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);
            arc.tesselate(ctx, maxSegments, minSegmentLength);
          },
          closePath: function closePath() {} // Polygon is closed anyway.
        };
        runLoop(ctx, _this5, l);};for (var l = 0; l < this.loops.length; l++) {_loop(l);
      }
      return poly;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      // Compute bbox of all vertices
      _get(_getPrototypeOf(Path.prototype), "computeBBox", this).call(this);

      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control
      // points. Therefore, we can simply add the control points to the bbox.
      //
      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.
      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.
      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
      var cp = new THREE.Vector2();
      for (var l = 0; l < this.getLoopCount(); l++) {
        for (var i = 0; i < this.getVertexCount(l); i++) {

          if (this.isBezierArc(i, l)) {
            // add control point 1
            this.getControlPoint(i, 1, cp, l);
            this.bbox.expandByPoint(cp);

            // add control point 2
            this.getControlPoint(i, 2, cp, l);
            this.bbox.expandByPoint(cp);
          } else
          if (this.isEllipseArc(i)) {
            var arc = this.exportEllipseArc(i, getTmpArc(), l);
            this.bbox.union(arc.computeBBox(tmpBox2));
          }
        }
      }
    } }, { key: "hitTest", value: function hitTest(

    x, y, hitRadius) {
      var poly = this.toPoly();
      return poly.hitTest(x, y, hitRadius);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    }

    // @param {Path} srcPath
  }, { key: "addLoop", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var dstLoopIndex = _get(_getPrototypeOf(Path.prototype), "addLoop", this).call(this, srcPath, srcLoopIndex);

      var srcPoints = srcPath.loops[srcLoopIndex];
      var dstPoints = this.loops[dstLoopIndex];

      // Copy extra information for arcs
      for (var i = 0; i < srcPoints.length; i++) {
        var type = srcPath.getEdgeType(i, srcLoopIndex);

        // Line segments are fully handled by the base class already
        if (type === EdgeType.Line) {
          continue;
        }

        var src = srcPoints[i];
        var dst = dstPoints[i];

        dst.arcType = src.arcType;

        switch (type) {
          case EdgeType.Bezier:{
              // copy control points
              dst.cp1x = src.cp1x;
              dst.cp1y = src.cp1y;
              dst.cp2x = src.cp2x;
              dst.cp2y = src.cp2y;
              break;
            }
          case EdgeType.Ellipse:{
              // copy arc params
              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();
              break;
            }}

      }
      return this;
    } }, { key: "move", value: function move(

    dx, dy) {
      _get(_getPrototypeOf(Path.prototype), "move", this).call(this, dx, dy);

      // Move affected control points as well
      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];
        for (var i = 0; i < points.length; i++) {

          if (!this.isBezierArc(i, l)) {
            continue;
          }

          var p = points[i];
          p.cp1x += dx;
          p.cp1y += dy;
          p.cp2x += dx;
          p.cp2y += dy;
        }
      }
      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.

      this.modified();
      return this;
    } }, { key: "getArea", value: function getArea(

    measureTransform) {
      if (!this.isClosed) {
        return undefined;
      }

      var poly = this.toPoly();
      return poly.getArea(measureTransform);
    } }, { key: "getLength", value: function getLength(

    measureTransform) {
      var poly = this.toPoly();
      return poly.getLength(measureTransform);
    }

    // Get point on segment. This refines the implementation 
    // of PolyBase by supporting arc segments.
  }, { key: "getPointOnEdge", value: function getPointOnEdge(segmentIndex, t, optionalTarget) {

      var type = this.getEdgeType(segmentIndex);
      switch (type) {
        case EdgeType.Line:break;
        case EdgeType.Bezier:{
            // get segment start/end
            var a = this.points[segmentIndex];
            var b = this.points[this.nextIndex(segmentIndex)];

            var result = optionalTarget || new THREE.Vector2();
            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, result);
          }
        case EdgeType.Ellipse:{
            var arc = this.exportEllipseArc(segmentIndex, getTmpArc());

            // ignore arcs with NaN values
            if (!arc.isValid()) {
              break;
            }
            return arc.getPoint(t, optionalTarget);
          }
        default:avp.logger.error('unexpected edge type');}


      return _get(_getPrototypeOf(Path.prototype), "getPointOnEdge", this).call(this, segmentIndex, t, optionalTarget);
    }

    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    
    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
  }, { key: "runPathCommands", value: function runPathCommands(ctx) {
      runPath(ctx, this);
    } }]);return Path;}(PolyBase);


// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.
var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);
  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _possibleConstructorReturn(this, _getPrototypeOf(PolygonPath).call(this,
    points, true, style));
  }return PolygonPath;}(Path);
;

var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);
  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _possibleConstructorReturn(this, _getPrototypeOf(PolylinePath).call(this,
    points, false, style));
  }return PolylinePath;}(Path);
;

var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this6;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, style));

    _this6.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this6.polygon.id = _this6.id;

    _this6.centerX = centerX;
    _this6.centerY = centerY;
    _this6.radius = radius;
    _this6.tessSegments = tessSegments;

    _this6.needsUpdate = true;return _this6;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this7;_classCallCheck(this, ShapeWrapper);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeWrapper).call(this));
    _this7.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this7), 'bbox', {
      get: function get() {return _this7.shape.bbox;},
      set: function set(bbox) {_this7.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'id', {
      get: function get() {return _this7.shape.id;},
      set: function set(id) {_this7.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'bboxDirty', {
      get: function get() {return _this7.shape.bboxDirty;},
      set: function set(dirty) {_this7.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'name', {
      get: function get() {return _this7.shape.name;},
      set: function set(name) {_this7.shape.name = name;} });return _this7;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/EllipseArcGizmo.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/EllipseArcGizmo.js ***!
  \**********************************************/
/*! exports provided: getEllipseArcEdgeParams, EllipseArcGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEllipseArcEdgeParams", function() { return getEllipseArcEdgeParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcGizmo", function() { return EllipseArcGizmo; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var tmpVec2 = new THREE.Vector2();

// Get ellipse arc params in a way that the edge is bended inside or outside wrt.
// to the outer loop.
//
// @param {Path}   path - not changed   
// @param {number} edgeIndex
// @param {number} bendRadius: Signed distance between line-segment center and arc center. 
//                             Positive values for outside, negative for inside.   
// @param {EllipseArcParams} [target]
// @returns {EllipseArcParams}
var getEllipseArcEdgeParams = function getEllipseArcEdgeParams(path, edgeIndex, bendRadius, target) {

  var params = target || new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

  // compute ellipse rotation, so that ellipse x-axis is parallel to the edge
  var dir = path.getEdgeDirection(edgeIndex, tmpVec2);
  var angle = Math.atan2(dir.y, dir.x);
  params.rotation = THREE.Math.radToDeg(angle);

  // Compute radius in a way that ellipse center matches with line-segment center
  params.rx = 0.5 * path.getEdgeLength(edgeIndex);

  // Apply bending by varying y-radius
  params.ry = Math.abs(bendRadius);

  // Always use shortest connection
  params.largeArcFlag = false;

  // Make sure that positive bendRadius bends outside, negative inside
  params.sweepFlag = Boolean(path.isCCW() ^ bendRadius < 0);

  return params;
};

// Gizmo class to pull ellipse arc centers. The gizmo implements the full interaction, but
// the owner controls when startDrag(), moveDrag(), and endDrag() are called.
var EllipseArcGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EllipseArcGizmo, _EdgeGizmo);

  function EllipseArcGizmo(layer, gizmoManager, undoStack, visible) {var _this;_classCallCheck(this, EllipseArcGizmo);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(EllipseArcGizmo).call(this, layer, visible));

    _this.container.classList.add('ellipse-arc-gizmo');

    _this.dragging = false;

    // arc params when drag had started
    _this.dragStartParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    // delta between exact dragStart position and gizmo-center at dragStart
    _this.dragOffset = new THREE.Vector2();

    // tmp values
    _this.tmpVec = new THREE.Vector2();
    _this.tmpVec2 = new THREE.Vector2();
    _this.tmpVec3 = new THREE.Vector2();
    _this.tmpParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    _this.gizmoManager = gizmoManager;
    _this.undoStack = undoStack;return _this;
  }_createClass(EllipseArcGizmo, [{ key: "isUnderMouse", value: function isUnderMouse()

    {
      return this.visible && this.edgeValid() && this.gizmoManager.isUnderMouse(this);
    } }, { key: "startDrag", value: function startDrag(

    canvasX, canvasY) {

      // Stop here if there is nothing to drag
      if (!this.edgeValid() || !this.isUnderMouse()) {
        return false;
      }

      // Usually, dragging will be false here unless in weird focus-change scenarios
      if (this.dragging) {
        return true;
      }

      this.dragging = true;

      // Highlight in green while dragging
      this.setSelected(true);

      // Store offset between exact mouse pos and the vertex we are dragging
      var pos = this.layerPos;
      var posScreen = this.layer.layerToCanvas(pos.x, pos.y);
      this.dragOffset.set(posScreen.x - canvasX, posScreen.y - canvasY);

      // Backup initial arc params
      this.poly.getEllipseArcParams(this.edgeIndex, this.dragStartParams);

      return true;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      if (!this.dragging) {
        return false;
      }

      // Compute layer position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Compute vector (a => p), where a is the edge start
      var a = this.poly.getPoint(this.edgeIndex, this.tmpVec);
      var diff = this.tmpVec2.copy(p).sub(a); // vector from edge start towards new gizmo position

      // Compute distance of the new gizmo position from edge spanned by line segment (a,b)
      var normal = this.poly.getOuterNormal(this.edgeIndex, this.tmpVec3);
      var signedDistance = diff.dot(normal);

      // Configure ellipse arc, so that the distance of the arc midpoint is the same
      var params = getEllipseArcEdgeParams(this.poly, this.edgeIndex, signedDistance, this.tmpParams);

      // Update polygon
      this.poly.setEllipseArc(this.edgeIndex, params);
      this.update();
      this.layer.update();

      return true;
    } }, { key: "endDrag", value: function endDrag(

    canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);
      this.dragging = false;

      var newParams = this.poly.getEllipseArcParams(this.edgeIndex, this.tmpParams);

      this.restoreArc();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].ChangeEdgeType(this.layer, this.poly, this.edgeIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, newParams));

      // stop highlighting
      this.setSelected(false);
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      this.restoreArc();
      this.dragging = false;
      this.layer.update();
    }

    // Restore state of the arc before dragging it
  }, { key: "restoreArc", value: function restoreArc() {
      this.poly.setEllipseArc(this.edgeIndex, this.dragStartParams);
    } }]);return EllipseArcGizmo;}(_CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeGizmo"]);

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });
var tmpVec2d = new THREE.Vector2();
var tmpVec2d2 = new THREE.Vector2();

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

//  @param {Vector2} dir1, dir2           - No normalization required.
//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// see isPointOnEdge
var isPointOnLine = function isPointOnLine(p, a, b, precision) {
  return isPointOnEdge(p, a, b, precision, false);
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

// same as p1.distanceTo(p2), but working for any {x,y} object.
var distance2D = function distance2D(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Checks if a matrix changes the orientation.
//  @param {Matrix4} matrix
var changesOrientation = function changesOrientation(matrix) {
  return matrix.determinant() < 0;
};

// Compute a matrix that transforms fromBox into toBox.
//
//  @param {Box2}    fromBox
//  @param {Box2}    toBox
//  @param {Object}  [options]
//  @param {bool}    [options.flipY]           - include y-axis flip
//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)
//  @param {Matrix4} [target]
var getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();
  var fromSize = fromBox.size(tmpVec2d);
  var toSize = toBox.size(tmpVec2d2);

  // compute scale   
  var sx = toSize.x / fromSize.x;
  var sy = toSize.y / fromSize.y;

  // preserveAspect
  if (options.preserveAspect) {
    sx = Math.min(sx, sy);
    sy = sx;
  }

  // anchor is the point of fromBox that will be mapped to toBox.min
  var anchorX = fromBox.min.x;
  var anchorY = fromBox.min.y;

  // apply optional y-flip
  if (options.flipY) {
    sy *= -1;
    anchorY = fromBox.max.y;
  }

  // compute translation: after scaling, anchor should move to toBox.min
  var tx = -sx * anchorX + toBox.min.x;
  var ty = -sy * anchorY + toBox.min.y;

  // Create (scale + translate)-matrix.
  var matrix = target.makeScale(sx, sy, 1.0);
  matrix.elements[12] = tx;
  matrix.elements[13] = ty;

  return matrix;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  isPointOnLine: isPointOnLine,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear,
  distance2D: distance2D,
  changesOrientation: changesOrientation,
  getFitToBoxTransform: getFitToBoxTransform };

/***/ }),

/***/ "./extensions/Edit2D/MeasureTransform.js":
/*!***********************************************!*\
  !*** ./extensions/Edit2D/MeasureTransform.js ***!
  \***********************************************/
/*! exports provided: MeasureTransform, DefaultMeasureTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeasureTransform", function() { return MeasureTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMeasureTransform", function() { return DefaultMeasureTransform; });
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// Workaround to choose a viewport for a given 2d sheet.
// 
// Actually, we should choose it based on 2d-position. But, F2D doesn't give us proper data to 
// do this. Also, even with proper viewport outlines, it wouldn't always unique as viewports may overlap.
// Therefore, we have to use a workaround here to make it use for simple single-viewport sheets at least.
//
// @returns {number|-1} Either -1 or a valid viewportId.
var chooseViewportId = function chooseViewportId(model) {

  var data = model.getData();
  var viewports = data.viewports;
  if (!viewports) {
    return -1;
  }

  // find viewport with maximum number of dbIds    
  var vpIndex = -1;
  var maxDbIds = -1;
  for (var i = 0; i < viewports.length; i++) {

    // Skip viewports without transform
    var vp = viewports[i];
    if (!vp.transform) {
      continue;
    }

    // Use current vp if it has most dbIds
    var numDbIds = vp.geom_metrics.db_ids;
    if (numDbIds > maxDbIds) {
      vpIndex = i;
      maxDbIds = numDbIds;
    }
  }

  return vpIndex;
};

// A MeasureTransform allows for doing length/area measurements in another coordinate system than the actual shape geometry.
// The transform is applied to all points before doing calculations.
var MeasureTransform = /*#__PURE__*/function () {function MeasureTransform() {_classCallCheck(this, MeasureTransform);}_createClass(MeasureTransform, [{ key: "apply",

    // @param {Vector2} p - Point to be transformed in-place.
    value: function apply(p) {} }]);return MeasureTransform;}();
;


// Sets the pageToModel transform in LMV as MeasureTransform to make measurements consistent with Measure extension.
var DefaultMeasureTransform = /*#__PURE__*/function (_MeasureTransform) {_inherits(DefaultMeasureTransform, _MeasureTransform);

  function DefaultMeasureTransform(viewer) {var _this;_classCallCheck(this, DefaultMeasureTransform);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultMeasureTransform).call(this));
    _this.viewer = viewer;return _this;
  }

  // Transform geometry point to the coordinate system in which measurements should be computed and displayed.
  //
  // @param {vector2} p
  //
  // Note: Currently, we do some simplifying assumptions here that may need additional
  //       work to support scenarios with multiple viewports or multiple 2d models.
  _createClass(DefaultMeasureTransform, [{ key: "apply", value: function apply(p) {
      // Get viewportId
      var model = this.viewer.model;
      if (!model) {
        return;
      }

      var vpId = chooseViewportId(model);

      // In case there are no viewports, there still might be a pageToModelTransform,
      // which we need to take into account. This is the case for raster PDF.
      model.pageToModel(p, null, vpId);
    } }]);return DefaultMeasureTransform;}(MeasureTransform);

/***/ }),

/***/ "./extensions/Edit2D/ModifierMask.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/ModifierMask.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModifierMask; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper to check whether certain modifiers are currently hold or not.
// See https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/getModifierState for list of supported keys.
// E.g.:
//  "Control", "Shift", "Alt", ..
var ModifierMask = /*#__PURE__*/function () {

  function ModifierMask() {_classCallCheck(this, ModifierMask);
    // By default, don't check any modifers.
    this.checkedModifiers = {};
  }

  // Add a modifier to be checked. E.g. addCondition("Control", true).
  _createClass(ModifierMask, [{ key: "addCondition", value: function addCondition(modifierName, expectedState) {
      this.checkedModifiers[modifierName] = expectedState;
    }

    // Remove condition - accept any state of this modifier
  }, { key: "removeCondition", value: function removeCondition(modifierName) {
      delete this.checkedModifiers[modifierName];
    }

    // Check if current event meets all modifier conditions
  }, { key: "accepts", value: function accepts(event) {
      for (var key in this.checkedModifiers) {
        var state = event.getModifierState(key);
        var expected = this.checkedModifiers[key];
        if (state !== expected) {
          return false;
        }
      }
      return true;
    } }]);return ModifierMask;}();
;

/***/ }),

/***/ "./extensions/Edit2D/SegmentTree.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/SegmentTree.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SegmentTree; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // 
// SegmentTree is a spatial datastructure that helps to quickly find all segments (lines, arcs) within a given 2d bbox.
//

var SegmentType = {
  Line: 1,
  CircularArc: 2,
  EllipticalArc: 3 };


// A segment is an object that describes a single line or arc segment.
// Properties depend on segment type (see functions below)
var createLineSegment = function createLineSegment(x1, y1, x2, y2, vpId) {return { type: SegmentType.Line, x1: x1, y1: y1, x2: x2, y2: y2, vpId: vpId };};
var createCircularArcSegment = function createCircularArcSegment(cx, cy, start, end, radius, vpId) {return { type: SegmentType.CirularArc, cx: cx, cy: cy, start: start, end: end, radius: radius, vpId: vpId };};
var createEllipticalArcSegment = function createEllipticalArcSegment(cx, cy, start, end, major, minor, tilt, vpId) {return { type: SegmentType.EllipticalArc, cx: cx, cy: cy, start: start, end: end, major: major, minor: minor, tilt: tilt, vpId: vpId };};

// Triggers the corresponding callbacks (onLineSegment, onCircularArc...) from a given segment object.
//  @param {Object} s             - Segment object whose data are sent to geomCb
//  @param {Object} geomCallbacks - Provides handlers for different segments. Same as used by VertexBufferReader.
var processSegment = function processSegment(s, geomCallbacks) {
  switch (s.type) {
    case SegmentType.Line:geomCallbacks.onLineSegment(s.x1, s.y1, s.x2, s.y2, s.vpId);break;
    case SegmentType.CirularArc:geomCallbacks.onCircularArc(s.cx, s.cy, s.start, s.end, s.radius, s.vpId);break;
    case SegmentType.EllipticalArc:geomCallbacks.onEllipticalArc(s.cx, s.cy, s.tart, s.end, s.major, s.minor, s.tilt, s.vpId);break;}

};

// Implements required functions to allow organizing segments in a quadtree
var SegmentHandler = /*#__PURE__*/function () {

  function SegmentHandler() {_classCallCheck(this, SegmentHandler);

    // Used BoundsCallback to get segment bboxes
    this.boundsCb = new Autodesk.Viewing.Private.BoundsCallback(new THREE.Box2());

    // Reused tmp values
    this.queryBox = new THREE.Box2();
    this.tmpPoint = new THREE.Vector2();
  }_createClass(SegmentHandler, [{ key: "getSegmentBox", value: function getSegmentBox(

    segment) {
      this.boundsCb.bounds.makeEmpty();
      processSegment(segment, this.boundsCb);
      return this.boundsCb.bounds;
    } }, { key: "getQueryBox", value: function getQueryBox(

    minx, miny, maxx, maxy) {
      // get query box
      this.queryBox.min.set(minx, miny);
      this.queryBox.max.set(maxx, maxy);
      return this.queryBox;
    } }, { key: "intersectsBox", value: function intersectsBox(

    segment, minx, miny, maxx, maxy) {
      var queryBox = this.getQueryBox(minx, miny, maxx, maxy);
      var segmentBox = this.getSegmentBox(segment);
      return queryBox.isIntersectionBox(segmentBox);
    }

    // Note that outPoint is just an {x,y} pair, not a Vector2
  }, { key: "getPoint", value: function getPoint(segment, outPoint) {
      // Just use bbox center for all segment types
      var center = this.getSegmentBox(segment).center(this.tmpPoint);
      outPoint.x = center.x;
      outPoint.y = center.y;
    } }]);return SegmentHandler;}();var


SegmentTree = /*#__PURE__*/function () {function SegmentTree() {_classCallCheck(this, SegmentTree);}_createClass(SegmentTree, [{ key: "buildFromModel",

    // Build SegmentTree from 2D vector-data model (PDF or F2D).
    // Note: Make sure that the model is fully loaded - otherwise, the tree will be incomplete.
    value: function buildFromModel(model) {

      // The quadtree must know the extents in advance.
      var box = model.getBoundingBox();

      // Init quadtree that manages segments
      this.tree = new Autodesk.Extensions.CompGeom.QuadTree(box.min.x, box.min.y, box.max.x, box.max.y, 0.0, new SegmentHandler());

      // Add geomtry for all fragments
      var frags = model.getFragmentList();
      var count = frags.getCount();
      for (var i = 0; i < count; i++) {
        var geom = frags.getGeometry(i);
        this.addGeometry(geom);
      }
    }

    // Adds all segments from a given 2D LineShader geometry.
    //  @param {BufferGeometry} geom
    //
    // Precondition: Can only be called if tree has been initialized and geom is within the bbox used to initialize the tree
  }, { key: "addGeometry", value: function addGeometry(geom) {var _this = this;

      // GeometryCallback that just collects all segments as objects and adds them to the tree
      var collectSegment = {
        onLineSegment: function onLineSegment() {return _this.tree.addItem(createLineSegment.apply(void 0, arguments));},
        onCircularArc: function onCircularArc() {return _this.tree.addItem(createCircularArcSegment.apply(void 0, arguments));},
        onEllipticalArc: function onEllipticalArc() {return _this.tree.addItem(createEllipticalArcSegment.apply(void 0, arguments));} };


      var vbr = new Autodesk.Viewing.Private.VertexBufferReader(geom);
      vbr.enumGeoms(null, collectSegment);
    }

    //  @param {Object} geomCallbacks - Visitor that provides callbacks to handle different segments. Same as used by VertexBufferReader.
  }, { key: "enumSegments", value: function enumSegments(minx, miny, maxx, maxy, geomCallbacks) {

      // Find all segments in the tree and invoke corresponding call on GeometryCallback
      this.tree.enumInBox(minx, miny, maxx, maxy, function (s) {return processSegment(s, geomCallbacks);});
    } }]);return SegmentTree;}();

/***/ }),

/***/ "./extensions/Edit2D/Selection.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Selection.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var av = Autodesk.Viewing;var

Selection = /*#__PURE__*/function () {

  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);

    av.EventDispatcher.prototype.apply(this);

    // Keys: shapeIds, Values: shapes
    this.isSelected = {};

    // For mouse-over highlighting. 0 = nothing highlighted (ShapeIds start at 1)
    this.hoveredId = 0;

    // Reused as temporary override style for shapes
    this.tmpStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();

    // Callback function that controls how to modify the style on selected shapes
    this.modifier = function (shape, style) {

      // only modify style for selected or hovered shapes
      var isSelected = _this.isSelected[shape.id];
      var isHovered = shape.id === _this.hoveredId;
      if (!isSelected && !isHovered) {
        return undefined;
      }

      // Create a tmp copy of the initial shape style that is modified to indicate highlighting.
      // Note that we can reuse tmpStyle for multiple shapes, because style modifiers are applied right before drawing.
      _this.tmpStyle.copy(style);

      if (isSelected) {
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      } else {
        // hovered
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.2, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      }

      return _this.tmpStyle;
    };

    this.layer = layer;
    this.onShapeRemoved = this.onShapeRemoved.bind(this);
    this.onLayerCleared = this.onLayerCleared.bind(this);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);

    this.layer.addStyleModifier(this.modifier);

    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone
    // or a RemoveShape action happened.
    this.undoStack = undoStack;
    this.onActionCb = function (a) {return _this.onAction(a);};
    this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
  }_createClass(Selection, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeStyleModifier(this.modifier);
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);
    }

    // @param {Shape[]) shapes
  }, { key: "setSelection", value: function setSelection(shapes) {

      // This works for null as well (unlike ES6 default params)
      shapes = shapes || [];

      var selected = this.getSelectedShapes();

      // Check if the set of ids changed
      var changed = false;
      if (selected.length != shapes.length) {
        changed = true;
      } else {
        // Check if any new shape was not selected before
        for (var i = 0; i < shapes.length; i++) {
          var shape = shapes[i];
          if (!this.isSelected[shape.id]) {
            changed = true;
          }
        }
      }

      if (!changed) {
        return;
      }

      // Add all shapes to this.isSelected
      this.isSelected = {};
      for (var _i = 0; _i < shapes.length; _i++) {
        var _shape = shapes[_i];
        this.isSelected[_shape.id] = _shape;
      }
      this.modified();
    } }, { key: "empty", value: function empty()

    {
      return !Object.keys(this.isSelected).length;
    }

    // Set selection to a single shape. Calling with null clears the selection.
  }, { key: "selectOnly", value: function selectOnly(shape) {
      this.setSelection(shape && [shape]);
    } }, { key: "clear", value: function clear()

    {
      this.setSelection([]);
    }

    // Passes all selected shapes to the callback
  }, { key: "getSelectedShapes", value: function getSelectedShapes() {
      return Object.values(this.isSelected);
    } }, { key: "getSelectedIds", value: function getSelectedIds()

    {
      return Object.keys(this.isSelected);
    } }, { key: "modified", value: function modified()

    {
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });
    } }, { key: "onAction", value: function onAction()

    {

      if (this.empty()) {
        return;
      }

      // Single-selection: Clear selection if selected shape has gone
      var selected = this.getSelectedShapes();
      if (selected.length == 1) {
        var exists = this.layer.findShapeById(selected[0].id);
        if (!exists) {
          this.clear();
        }
        return;
      }

      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections

      // Create dictionary of all shapes in the layer
      var shapeIdExists = {};
      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});

      // Clear all shapes from selection that don't exist anymore
      selected = selected.filter(function (s) {return shapeIdExists[s.id];});
      this.setSelection(selected);
    } }, { key: "onShapeRemoved", value: function onShapeRemoved(_ref)

    {var shape = _ref.shape;
      if (this.empty()) {
        return;
      }

      // Remove the shape from the selection if found.
      if (this.isSelected[shape.id]) {
        delete this.isSelected[shape.id];
        this.modified();
      }
    } }, { key: "onLayerCleared", value: function onLayerCleared()

    {
      if (this.empty()) {
        return;
      }

      this.clear();
    } }, { key: "setHoveredId", value: function setHoveredId(

    id) {

      if (id === this.hoveredId) {
        return;
      }

      this.hoveredId = id;
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_HOVER_CHANGED });
    }

    // Result may be null if selection is empty
    // @returns {Shape|null}
  }, { key: "getFirstSelected", value: function getFirstSelected() {
      var selected = this.getSelectedShapes();
      return selected.length ? selected[0] : null;
    } }]);return Selection;}();


Selection.Events = {
  SELECTION_CHANGED: 'selectionChanged',
  SELECTION_HOVER_CHANGED: 'selectionHoverChanged' };

/***/ }),

/***/ "./extensions/Edit2D/SolidDefConvert.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/SolidDefConvert.js ***!
  \**********************************************/
/*! exports provided: SolidDefConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidDefConvert", function() { return SolidDefConvert; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");




// TODO: SolidDefinition library is required before we can use this functionality
//window.SolidDef = require("@adsk/solid-definition");

var tmpVec1 = new THREE.Vector3();
var tmpVec2 = new THREE.Vector3();

// Convert SolidDef float-array to THREE-Vector3
var toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();
  return target.set(ar[0], ar[1], ar[2]);
};

// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is
// assumed that it already ends at the start point of the new edge
//  @param {Path}                     path         - Edit2D path
//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef 
//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to
//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.
//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.
var addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var vertexCount = path.getVertexCount(loopIndex);

  // Add start vertex on first call
  if (vertexCount == 0) {
    var pStart = ce.getStartVertex().getPosition();
    path.addPoint(pStart[0], pStart[1], loopIndex);
  }

  // Add end point - unless this is the last edge of a loop.
  if (!lastLoopEdge) {
    var pEnd = ce.getEndVertex().getPosition();
    path.addPoint(pEnd[0], pEnd[1], loopIndex);
  }

  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.
  var isCoedge = ce instanceof SolidDef.Coedge;
  var e = isCoedge ? ce.getEdge() : ce;

  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because
  // cedge as well as edge have their own isReversed flag.
  var ceReversed = isCoedge ? ce.isReversed() : false;
  var edgeReversed = e.isReversed();
  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)

  var type = e.getCurveType();

  // For line segments, we are done
  if (type === SolidDef.GEOMETRY_TYPES.LINE) {
    return;
  }

  // convert curve parameters for new edge
  var edgeIndex = Math.max(vertexCount - 1, 0);
  var curve = e.getCurve();

  // Bezier case
  if (type === SolidDef.GEOMETRY_TYPES.BCURVE) {

    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:
    //  1. Coedge or edge may be reversed (which may invert the order of the control points)
    //  2. The edge may not cover the whole curve, but only a part of it.
    //
    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.

    // get params at edge start/end
    var t0 = ce.t0();
    var t1 = ce.t1();

    // get start/end point
    var _pStart = ce.evaluatePosition(t0);
    var _pEnd = ce.evaluatePosition(t1);

    // get start/end tangent
    var tStart = ce.evaluateDt(t0);
    var tEnd = ce.evaluateDt(t1);

    // We are searching for a cubic Bezier B with the following properties:
    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex
    //  - Tangents at start/end positions are the same as for the given edge.

    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.
    var rangeScale = Math.abs(t1 - t0);
    tStart[0] *= rangeScale;
    tStart[1] *= rangeScale;
    tEnd[0] *= rangeScale;
    tEnd[1] *= rangeScale;

    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.
    // Same principle applies to cp2.
    var cp1x = _pStart[0] + tStart[0] / 3;
    var cp1y = _pStart[1] + tStart[1] / 3;
    var cp2x = _pEnd[0] - tEnd[0] / 3;
    var cp2y = _pEnd[1] - tEnd[1] / 3;

    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
    return;
  }

  // Ellipse arcs
  if (type === SolidDef.GEOMETRY_TYPES.ELLIPSE) {

    var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
    params.rx = curve.getMajorRadius();
    params.ry = curve.getMinorRadius();

    // compute axis rotation
    var xAxis = curve.getMajorAxis();
    var angle = Math.atan2(xAxis[1], xAxis[0]);
    params.rotation = THREE.Math.radToDeg(angle);

    // determine largeArc flag
    var range = curve.getRange();
    var startAngle = range[0];
    var endAngle = range[1];
    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle

    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).
    // But it may be inverted if the edge direction is flipped.
    params.sweepFlag = !isReversed;

    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).
    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse
    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.
    //       If this happens, we have to invert the ellipse orientation.
    var yAxis = curve.getMinorAxis();
    var xDir = toVec3(xAxis, tmpVec1);
    var yDir = toVec3(yAxis, tmpVec2);
    var needsExtraFlip = xDir.cross(yDir).z < 0;
    if (needsExtraFlip) {
      params.sweepFlag = !params.sweepFlag;
    }

    path.setEllipseArc(edgeIndex, params, loopIndex);
    return;
  }

  console.error("Unexpected curve type");
};

// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.
//  @param {SolidDef.Loop} loop
//  @param {Path}          [target]
//  @returns {Path}
var loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // start new loop in target path
  var loopIndex = target.nextFreeLoop();

  // traverse coedges of the loop
  var coedges = loop.getCoedges();
  for (var i = 0; i < coedges.length; i++) {
    var ce = coedges[i];

    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex
    var lastLoopEdge = i == coedges.length - 1;

    // add next edge to target
    addCoedge(target, ce, loopIndex, lastLoopEdge);
  }

  return target;
};

// Convert SolidDef face into one or more Edit2D Paths.
// Todo: If we support multiple loops per Path, result will be a single Path
//  @param {SolidDef.Face} face
//  @param {Path}          [target]
//  @returns {Path}
var faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // convert loops and collect them into target path
  face.getLoops().forEach(function (l) {
    target = loopToShape(l, target);
  });
  return target;
};

// Convert array of faces to array of shapes
var facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  faces.forEach(function (f) {
    target = faceToShape(f, target);
  });
  return target;
};

// Convert SolidDef wire to an Edit2D Path.
//
// Note: This function only works for wires that don't branch and have already ordered edges.
//       This is true for wires that we get from SolidDef.Path.
//  @param {SolidDef.Wire} wire
var wireToShape = function wireToShape(wire) {

  // create empty path
  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  path.isClosed = wire.isClosed();

  // add edges    
  var edges = wire.getOrderedEdges().edges;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;
    addCoedge(path, edge, 0, lastLoopEdge);
  }
  return path;
};

// Convert SolidDef path to an array of shapes
var pathToShape = function pathToShape(path) {
  var body = path.getWireBody();
  var wires = body.getWires();

  if (wires.length == 0) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  }

  var result = wireToShape(wires[0]);

  // convert additional loops (if any)
  for (var i = 1; i < wires.length; i++) {
    var wire = wires[i];
    var tmp = wireToShape(wire);
    result.addLoop(tmp, 0);
  }

  return result;
};

// Convert Edit2D Path to SolidDef Path2D
var toSolidDefPath = function toSolidDefPath(path) {
  var path2D = new SolidDef.Path2D();
  path.runPathCommands(path2D);
  return path2D;
};

var SolidDefConvert = {
  addCoedge: addCoedge,
  loopToShape: loopToShape,
  faceToShape: faceToShape,
  facesToShape: facesToShape,
  wireToShape: wireToShape,
  pathToShape: pathToShape,
  toSolidDefPath: toSolidDefPath };

/***/ }),

/***/ "./extensions/Edit2D/Svg.js":
/*!**********************************!*\
  !*** ./extensions/Edit2D/Svg.js ***!
  \**********************************/
/*! exports provided: Svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}


var domParser = null;

// SVG (de)serialization for EditShapes

// Url of XML-Namespace for SVG
var SvgNs = "http://www.w3.org/2000/svg";

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var domToCircle = function domToCircle(circleNode) {

  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {
    throw 'No attributes available on the <circle/> node';
  }
  var circle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]();
  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {
    var attr = circleNode.attributes[i];
    switch (attr.name) {
      case 'cx':
        circle.centerX = parseFloat(attr.value);
        break;
      case 'cy':
        circle.centerY = parseFloat(attr.value);
        break;
      case 'r':
        circle.radius = parseFloat(attr.value);
        break;}

  }
  return circle;
};

var circleToSvg = function circleToSvg(circle) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;var stylePostFix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  return "<circle cx=\"".concat(limitDigits(circle.centerX, digits), "\" cy=\"").concat(limitDigits(circle.centerY, digits), "\" r=\"").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, "\"/>");
};

var domToPath = function domToPath(pathNode, forcePaths) {

  var d = pathNode.getAttribute('d');
  if (!d) {
    return;
  }var _parsePath =

  parsePath(d),points = _parsePath.points,isPolygon = _parsePath.isPolygon;

  if (forcePaths || points.find(function (p) {return p.arcType !== undefined;})) {
    var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"](points, isPolygon);
    return path;
  } else
  if (isPolygon) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"](points);
  }
  return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"](points);
};

var parsePath = function parsePath(svgPath) {
  // split at all chars but keep the char using positive look ahead
  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
  // results into list with glyph with position array:
  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);
  var validChars = "MLHVCZA";

  var previousPoint = { x: 0, y: 0 };
  var newPoint;
  var points = [];
  var isPolygon = false;

  for (var i = 0; i < pointStrings.length; i++) {

    var pointString = pointStrings[i];
    if (validChars.indexOf(pointString[0]) === -1) {
      throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);
    }
    var value = pointString.substring(1);
    switch (pointString[0]) {
      case 'M':
      case 'L':
        var coords = value.split(',');
        newPoint = { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };
        if (pointString[0] === 'M') {
          // remove the initial 0,0 point
          points.shift();
        }
        break;
      case 'H':
        newPoint = { x: parseFloat(value), y: previousPoint.y };
        break;
      case 'V':
        newPoint = { x: previousPoint.x, y: parseFloat(value) };
        break;
      case 'C':
        var bezierCoords = value.split(',');
        newPoint = { x: parseFloat(bezierCoords[4]), y: parseFloat(bezierCoords[5]) };
        previousPoint.arcType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier;
        previousPoint.cp1x = parseFloat(bezierCoords[0]);
        previousPoint.cp1y = parseFloat(bezierCoords[1]);
        previousPoint.cp2x = parseFloat(bezierCoords[2]);
        previousPoint.cp2y = parseFloat(bezierCoords[3]);
        break;
      case 'A':
        var src = value.split(',');
        newPoint = { x: parseFloat(src[5]), y: parseFloat(src[6]) };
        previousPoint.arcType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse;

        // read ellipse params.
        var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
        params.rx = parseFloat(src[0]);
        params.ry = parseFloat(src[1]);
        params.rotation = parseFloat(src[2]);
        params.largeArcFlag = Boolean(parseFloat(src[3]));
        params.sweepFlag = Boolean(parseFloat(src[4]));

        previousPoint.ellipseArcParams = params;
        break;
      case 'Z':
        // we are done
        isPolygon = true;
        continue;}

    previousPoint = newPoint;
    points.push(newPoint);
  }

  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
  var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(points[0], points[points.length - 1], 0);
  if (!delta) {
    points.pop(); // remove the duplicate last point which the same as the first point.
  }

  return { points: points, isPolygon: isPolygon };
};

var pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!path.vertexCount) {
    return [];
  }

  var svgPath = [];
  svgPath.push("M ".concat(limitDigits(path.points[0].x, digits), ",").concat(limitDigits(path.points[0].y, digits)));
  for (var i = 1; i < path.points.length; i += 1) {

    // The segment start point defines the type (line or arc)
    var prev = path.points[i - 1];
    var p = path.points[i];
    var value = void 0;

    switch (prev.arcType) {

      case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:
        var par = prev.ellipseArcParams;
        var largeArc = par.largeArcFlag ? 1 : 0;
        var sweep = par.sweepFlag ? 1 : 0;

        value = "A ".concat(par.rx, ",").concat(par.ry, ",").concat(par.rotation, ",").concat(largeArc, ",").concat(sweep, ",").concat(p.x, ",").concat(p.y);
        break;

      case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:
        value = "C ".concat(limitDigits(prev.cp1x, digits), ",").concat(limitDigits(prev.cp1y, digits), ",").concat(limitDigits(prev.cp2x, digits), ",").concat(limitDigits(prev.cp2y, digits), ",").concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
        break;

      default:
        {
          // skip empty/duplicate points
          var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(prev, p, digits);
          if (!delta) {
            continue;
          }

          if (Math.abs(delta.x) <= precision) {
            value = "V ".concat(limitDigits(p.y, digits));
          } else if (Math.abs(delta.y) <= precision) {
            value = "H ".concat(limitDigits(p.x, digits));
          } else {
            value = "L ".concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
          }
        }}

    svgPath.push(value);
  }

  if (path.isClosed) {
    // close path
    var pLast = path.points[path.points.length - 1];
    if (pLast.arcType === _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier) {
      var pFirst = path.points[0];
      var _value = "C ".concat(limitDigits(pLast.cp1x, digits), ",").concat(limitDigits(pLast.cp1y, digits), ",").concat(limitDigits(pLast.cp2x, digits), ",").concat(limitDigits(pLast.cp2y, digits), ",").concat(limitDigits(pFirst.x, digits), ",").concat(limitDigits(pFirst.y, digits));
      svgPath.push(_value);
    }
    svgPath.push('Z');
  }

  return svgPath;
};

var polyToSvgPath = function polyToSvgPath(poly) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!poly.vertexCount) {
    return;
  }

  var previousIndex = 0;
  var reduceToPath = function reduceToPath(result, current, index, list) {
    if (!index) {
      result.push("M ".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits)));
      return result;
    }

    var prefix, value;
    var previous = list[previousIndex];
    var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(previous, current, digits);
    // skip empty/duplicate points
    if (!delta) {
      return result;
    }
    if (Math.abs(delta.x) <= precision) {
      prefix = 'V';
      value = limitDigits(current.y, digits);
    } else if (Math.abs(delta.y) <= precision) {
      prefix = 'H';
      value = limitDigits(current.x, digits);
    } else {
      prefix = 'L';
      value = "".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits));
    }
    result.push("".concat(prefix, " ").concat(value));
    previousIndex = index;
    return result;
  };

  var path = poly.points.reduce(reduceToPath, []);
  if (poly.isPolygon()) {
    path.push('Z');
  }
  return path;
};

// Extract dictionary of SVG style attributes from Edit2D style
//  @param {Style} style
//  @returns {Object}
var getSvgStyleAttributes = function getSvgStyleAttributes(style) {

  var target = {};
  target["stroke"] = style.lineColor;
  target["fill"] = style.fillColor;
  target["stroke-width"] = style.lineWidth;

  // omit opacities if they are 1 (default)
  if (style.lineAlpha != 1) target["stroke-opacity"] = style.lineAlpha;
  if (style.fillAlpha != 1) target["fill-opacity"] = style.fillAlpha;

  return target;
};

// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it
// to other attributes, it contains a preceding space. 
// Example: ' stroke="rgb(0,0,0)" fill="rgb(0,0,255)" ... '
var getAttributePostFix = function getAttributePostFix(attribs) {
  var str = '';
  for (var key in attribs) {
    str += " ".concat(key, "=\"").concat(attribs[key], "\"");
  }
  return str;
};

// Apply all given attributes to a Dom Element
var applyAttributes = function applyAttributes(domElement, attribs) {
  for (var key in attribs) {
    domElement.setAttribute(key, attribs[key]);
  }
};

// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),
// style attributes are only exported if specified in options.
//
// @param {Shape} shape
// @param {Object} [options]
// @param {number} [options.precision=0]       - accuracy for unifying duplicate points 
// @param {number} [options.digis=0]           - number of digits for number strings 
// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes
//
// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.
var toSvg = function toSvg(shape, options) {

  var precision = options && options.precision || 0;
  var digits = options && options.digits || null; // means no limitation of digits
  var exportStyle = options && options.exportStyle || false;

  // add style params if wanted
  var stylePostfix = '';
  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    stylePostfix = getAttributePostFix(attribs);
  }

  // Legacy: Keep old code using that still passes precision/digits separately
  // Todo: Remove this when checked with clients.
  if (_typeof(options) !== 'object') {
    if (typeof arguments[1] == 'number') precision = arguments[1];
    if (typeof arguments[2] == 'number') digits = arguments[2];
  }

  if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]) {
    return circleToSvg(shape, precision, digits, stylePostfix);
  }

  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  // PolyBase and Path are translated to SVG Path
  var path = pathToSvgPath(shape, precision, digits);

  return "<path d=\"".concat(path.join(' '), "\"").concat(stylePostfix, "/>");
};

// see toSvg for options.
var createSvgShape = function createSvgShape(shape, options) {
  var precision = options && options.precision || 0;
  var digits = options && options.digits || 0;
  var exportStyle = options && options.exportStyle || true;

  // Todo: support circles and other shapes if anyone needs it.
  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  var path = document.createElementNS(SvgNs, 'path');
  path.setAttribute('d', pathToSvgPath(shape, precision, digits));

  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    applyAttributes(path, attribs);
  }

  return path;
};

// @param {string}  svg - e.g. '<path d="M 13.882,4.8592 L 14.6757,4.738"/>'
// @param {Object}  [options]
// @param {boolean} [options.forcePaths] - By default, paths without arcs are interpreted as Polygon resp. Polyline.
//                                         This option ensures that the result is always a Path. This is important
//                                         if you want to allow converting it into a path later.
var fromSvg = function fromSvg(svg, options) {
  if (!svg) {
    return;
  }

  // init on first use
  domParser = domParser || new DOMParser();

  var dom = domParser.parseFromString(svg, 'application/xml');

  var forcePaths = options && options.forcePaths;

  if (dom.childNodes.length !== 1) {
    throw 'Function does only support svg with a single element: path, circle';
  }
  var node = dom.firstChild;
  if (node.nodeName === 'circle') {
    return domToCircle(node);
  } else
  if (node.nodeName === 'path') {
    return domToPath(node, forcePaths);
  }

  throw "Unsupported svg node type: ".concat(node.nodeName);
};

// Converts several shapes to an SVG element.
//  @param {Object} [options]
//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.
//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.
// see toSvg() for other options
var createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // get summed box of all shapes
  var sumBox = new THREE.Box2();
  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});

  var srcBox = options.srcBox || sumBox;
  var dstBox = options.dstBox || sumBox;

  // Note that we always have to swap y-axis, because the y-axis direction is flipped when 
  // converting 2D world coords in LMV to SVG.
  var scaleOptions = {
    preserveAspect: true,
    flipY: true };

  var tf = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getFitToBoxTransform(srcBox, dstBox, scaleOptions);

  // get required size of svg
  var width = dstBox.max.x - dstBox.min.x;
  var height = dstBox.max.y - dstBox.min.y;

  // create svg root element      
  var svg = document.createElementNS(SvgNs, 'svg');
  svg.setAttribute('height', width);
  svg.setAttribute('width', height);

  // rescale & convert each shape
  shapes.forEach(function (shape) {
    var scaledShape = shape.clone().applyMatrix4(tf);
    var path = createSvgShape(scaledShape, options);
    svg.appendChild(path);
  });

  return svg;
};

var Svg = {
  toSvg: toSvg,
  fromSvg: fromSvg,
  createSvgShape: createSvgShape,
  createSvgElement: createSvgElement };

/***/ }),

/***/ "./extensions/Edit2D/TangentGizmo.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/TangentGizmo.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TangentGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // A tangent gizmo is a dashed line with two vertex gizmos at the end.
// It is used to control tangents for Bezier arcs.





var tangentGizmoName = function tangentGizmoName(vertexIndex, sideIndex) {
  return "TangentGizmo-$vertexIndex-$sideIndex";
};

// Indicates which endpoint of the tangent is being dragged
var DragIndex = {
  None: -1, // Nothing dragged
  Start: 0, // Dragging start point
  End: 1 // Dragging end point
};var

TangentGizmo = /*#__PURE__*/function () {

  function TangentGizmo(path, index, layer, gizmoLayer, gizmoManager) {_classCallCheck(this, TangentGizmo);

    this.path = path;
    this.gizmoLayer = gizmoLayer;
    this.layer = layer;
    this.gizmoManager = gizmoManager; // Used to track which gizmo is under mouse

    // index of the vertex whose tangent we control
    this.index = index;

    // dashed tangent line
    this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]();
    this.lineVisible = false;

    // configure style of dashed line
    this.line.style.isScreenSpace = true;
    this.line.style.lineColor = 'rgb(255, 0, 255)',
    this.line.style.lineWidth = 1.0,
    this.line.style.lineStyle = 10;
    this.line.style.lineAlpha = 1.0;

    // VertexGizmos at both ends of the tangent line
    this.vertexGizmo1 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, 1));
    this.vertexGizmo2 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, 2));

    // Hide vertex gizmos until we have proper positions
    this.vertexGizmo1.setVisible(false);
    this.vertexGizmo2.setVisible(false);

    // Start/end vertex of tangent Gizmo
    this.pStart = new THREE.Vector2();
    this.pEnd = new THREE.Vector2();

    // Add this to main layer. This triggers this.update() on layer updates to respond to
    // vertex position changes.
    this.layer.addCanvasGizmo(this);

    // 0: dragging startPoint, 1: dragging endPoint, 2: nothing dragged
    this.dragIndex = DragIndex.None;

    // Last tracked dragging position for currently dragged vertex
    this.lastDragPos = new THREE.Vector2(); // in layer coords

    // When dragging vertices, we store the offset (in layer-coords) between 
    // the accurate click position and the center of the clicked vertex gizmo
    this.dragOffset = new THREE.Vector2(0, 0); // in pixels

    this.update();
  }_createClass(TangentGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
      this.layer.removeCanvasGizmo(this);
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      this.vertexGizmo1.setVisible(visible);
      this.vertexGizmo2.setVisible(visible);

      // Show/Hide tangent line gizmo
      if (visible !== this.lineVisible) {
        if (visible) {
          this.gizmoLayer.addShape(this.line);
        } else {
          this.gizmoLayer.removeShape(this.line);
        }
      }
      this.lineVisible = visible;
    } }, { key: "update", value: function update()

    {

      // get index of previous edge (ending at the vertex)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index);
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index);

      // prev/next edge may not exist in case of polyline paths
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Check which of the adjacent edges are arcs
      var prevIsArc = prevEdgeExists && this.path.isBezierArc(prevEdgeIndex);
      var nextIsArc = nextEdgeExists && this.path.isBezierArc(nextEdgeIndex);

      // If none of the edges is an Arc, just hide all gizmos
      if (!prevIsArc && !nextIsArc) {
        this.setVisible(false);
        return;
      }

      // Compute both endpoints of tangent gizmo
      var p = this.path.points[this.index];
      if (nextIsArc) {

        // End point is first control point of the arc starting at p
        this.pEnd.set(p.cp1x, p.cp1y);

        // In general, the start point would be cp2 of the previous arc. 
        // But, we enforce tangents to be identical for previous edge and next edge.
        // Therefore, we obtain the other endpoint by mirroring the tangent of the leaving edge
        // on point p
        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pEnd, p, this.pStart);
      } else {
        // Only previous edge is an arc: We have to obtain the tangent from
        // control point 2 of the previous edge.
        var pPrev = this.path.points[prevEdgeIndex];
        this.pStart.set(pPrev.cp2x, pPrev.cp2y);

        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pStart, p, this.pEnd);
      }

      // update vertex gizmos
      this.vertexGizmo1.setPosition(this.pStart.x, this.pStart.y);
      this.vertexGizmo2.setPosition(this.pEnd.x, this.pEnd.y);

      // update line gizmo
      this.line.makeLine(this.pStart.x, this.pStart.y, this.pEnd.x, this.pEnd.y);
      this.gizmoLayer.update();

      this.setVisible(true);
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "setTangentEndPoints", value: function setTangentEndPoints(pStart, pEnd) {

      // Set start point: This is cp2 of previous arc segment (if any)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index);
      var prevExists = prevEdgeIndex !== -1;
      if (prevExists && this.path.isBezierArc(prevEdgeIndex)) {
        this.path.updateControlPoint(prevEdgeIndex, 2, pStart.x, pStart.y);
      }

      // Set end point: This is cp1 of current segment
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index);
      var nextExists = nextEdgeIndex !== -1;
      if (nextExists && this.path.isBezierArc(nextEdgeIndex)) {
        this.path.updateControlPoint(this.index, 1, pEnd.x, pEnd.y);
      }

      // update gizmos
      this.update();
    }

    // @param {Vector2} newPos - new position in layer coords
  }, { key: "onStartVertexMoved", value: function onStartVertexMoved(startPos) {
      // get new tangent end point by mirroring on vertex position
      var center = this.path.getPoint(this.index);
      var endPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(startPos, center);

      this.setTangentEndPoints(startPos, endPos);
    }

    // @param {Vector2} startPos - new position in layer coords
  }, { key: "onEndVertexMoved", value: function onEndVertexMoved(endPos) {
      // get new tangent start point by mirroring on vertex position
      var center = this.path.getPoint(this.index);
      var startPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(endPos, center);

      this.setTangentEndPoints(startPos, endPos);
    }

    // @param {DragIndex} dragIndex
  }, { key: "startDrag", value: function startDrag(canvasX, canvasY, dragIndex) {

      this.dragIndex = dragIndex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = dragIndex === DragIndex.Start ? this.pStart : this.pEnd;
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - canvasX, vposScreen.y - canvasY);

      this.lastDragPos.copy(vpos);
    }

    // process last position and finish dragging
  }, { key: "endDrag", value: function endDrag(canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);
      this.dragIndex = DragIndex.None;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      // Compute canvas position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Move tangent vertex by dx/dy
      if (this.dragIndex === DragIndex.Start) {
        this.onStartVertexMoved(p);
      } else if (this.dragIndex === DragIndex.End) {
        this.onEndVertexMoved(p);
      }

      this.layer.update();
    }

    // @returns {bool} true if dragging started
  }, { key: "onButtonDown", value: function onButtonDown(canvasX, canvasY) {

      var startDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo1);
      var endDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo2);

      if (!startDragged && !endDragged) {
        return false;
      }

      var dragIndex = startDragged ? DragIndex.Start : DragIndex.End;
      this.startDrag(canvasX, canvasY, dragIndex);

      return true;
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.dragIndex !== DragIndex.None;
    } }]);return TangentGizmo;}();
;

/***/ }),

/***/ "./extensions/Edit2D/UndoStack.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/UndoStack.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoStack; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;var

UndoStack = /*#__PURE__*/function () {

  function UndoStack() {_classCallCheck(this, UndoStack);

    av.EventDispatcher.prototype.apply(this);

    // Array of action objects
    this.stack = [];

    // By default, this simply points to the end of this.stack. Only if undo has been called, 
    // it points to the next operation to be run on a redo() call
    this.current = 0;
  }

  // Executes an action and pushes it to the undo stack
  _createClass(UndoStack, [{ key: "run", value: function run(action) {
      // If we did a couple of undos before, a new operation will clear all redo steps
      this.stack.length = this.current;

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });

      this.stack.push(action);
      this.current = this.stack.length;
    } }, { key: "undo", value: function undo()

    {
      if (!this.current) {
        // We reached the beginning of the stack
        return false;
      }
      this.current--;

      var action = this.stack[this.current];

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });

      action.undo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });

      action.layer.update();

      return true;
    } }, { key: "redo", value: function redo()

    {
      var action = this.stack[this.current];
      if (!action) {
        // Nothing to redo
        return false;
      }

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });

      this.current++;

      action.layer.update();

      return true;
    } }, { key: "clear", value: function clear()

    {
      this.stack.length = 0;
      this.current = 0;
    } }]);return UndoStack;}();


// Events sent before/after any action is executed by UndoStack
UndoStack.BEFORE_ACTION = 'beforeAction';
UndoStack.AFTER_ACTION = 'afterAction';

/***/ }),

/***/ "./extensions/Edit2D/UnitHandler.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/UnitHandler.js ***!
  \******************************************/
/*! exports provided: UnitHandler, SimpleUnitHandler, DefaultUnitHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitHandler", function() { return UnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleUnitHandler", function() { return SimpleUnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUnitHandler", function() { return DefaultUnitHandler; });
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var avp = Autodesk.Viewing.Private;

// Interface to control display of length/area units.
var UnitHandler = /*#__PURE__*/function () {

  function UnitHandler() {_classCallCheck(this, UnitHandler);
    // Optional: Returns a transform that is applied to all points for length/area calculations.
    //  @returns {MeasureTransform}
    this.measureTransform = null;
  }

  // @param   {number} val - length in layer coords
  // @returns {string} String to display, including units.
  _createClass(UnitHandler, [{ key: "lengthToString", value: function lengthToString(val) {
      console.error('Not implemented');
    }

    // @param   {number} val - area in layer coords
    // @returns {string} String to display - including units.
  }, { key: "areaToString", value: function areaToString(val) {
      console.error('Not implemented');
    } }]);return UnitHandler;}();
;

// If nothing is specified, we display with 2 digits and assume all unit in inches.
var DefaultPrecision = 2;
var DefaultUnits = "inch";

// Format length / area strings based on:
//  - layerUnits:  We assume the layer to be specified in these units.
//  - displayUnit: Values are converted from layerUnits to displayUnits for display
//  - precision:   Number of digits shown
//  - scaleFactor: Optional scale factor applied to all values
var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);

  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleUnitHandler).call(this));

    _this.viewer = viewer;

    _this.config = {
      // {string} We assume layers to be in these units (in GNU units format)
      layerUnits: DefaultUnits,

      // {string} Units in which we display lengths/areas (in GNU units format)
      displayUnits: DefaultUnits,

      // {number} Number of digits that we display
      precision: DefaultPrecision,

      // {number} Optional scale factor applied to all values
      scaleFactor: 1.0 };return _this;

  }_createClass(SimpleUnitHandler, [{ key: "lengthToString", value: function lengthToString(

    val) {
      var cfg = this.config;

      // Convert length units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);

      // Format length value with unit string
      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      var cfg = this.config;

      // Convert area units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');

      // Format length value with unit string
      var units = cfg.displayUnits ? "".concat(cfg.displayUnits, "^2") : null;
      return avp.formatValueWithUnits(val, units, 3, cfg.precision);
    } }]);return SimpleUnitHandler;}(UnitHandler);


// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model 
// and current settings from MeasureToolExtension:
//  - If MeasureExtension is loaded, it displays in the same way as Measure tools
//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.
//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)
var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);

  function DefaultUnitHandler(viewer) {var _this2;_classCallCheck(this, DefaultUnitHandler);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DefaultUnitHandler).call(this, viewer));

    _this2.measureTransform = new _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__["DefaultMeasureTransform"](viewer);return _this2;
  }_createClass(DefaultUnitHandler, [{ key: "updateConfig", value: function updateConfig()

    {
      var cfg = this.config;

      // Assume values to be in model units or default units
      var model = this.viewer.model;
      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;

      // Set other configuration values
      var ext = this.viewer.getExtension('Autodesk.Measure');
      var msrCfg = ext && ext.sharedMeasureConfig;
      if (msrCfg) {
        // get from measure extension
        cfg.displayUnits = msrCfg.units;
        cfg.precision = msrCfg.precision;
        cfg.scaleFactor = msrCfg.calibrationFactor;
      } else {
        // No Measure extension available => use defaults
        cfg.displayUnits = this.config.layerUnits;
        cfg.precision = DefaultPrecision;
        cfg.scaleFactor = 1.0;
      }
    } }, { key: "lengthToString", value: function lengthToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "areaToString", this).call(this, val);
    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);

/***/ }),

/***/ "./extensions/Edit2D/tools/CopyTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/CopyTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var CopyToolName = 'Edit2_CopyTool';

var av = Autodesk.Viewing;

// Apply constant offset in x/y for each paste step, so that shape copies are not exactly on top of the src shapes.
var PasteOffset = 30;var

CopyTool = /*#__PURE__*/function () {

  function CopyTool(ctx) {_classCallCheck(this, CopyTool);

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // {Shape[]}
    this.clipBoard = [];

    // After copying some shapes, this counts the number of times that we paste those.
    this.pasteCounter = 0;
  }_createClass(CopyTool, [{ key: "copy", value: function copy()

    {
      this.clipBoard.length = 0;

      var shapes = this.selection.getSelectedShapes();

      // Store the original shapes that get copied for event handlers
      this.originalShapes = shapes;

      // Remember selected shapes
      this.clipBoard = shapes.slice();

      // Reset paste counter
      this.pasteCounter = 0;
    } }, { key: "paste", value: function paste()

    {

      // Track how often we pasted the same clipboard content
      this.pasteCounter++;

      // Compute how far we want to shift the copy that we create.
      // On first paste, we shift by 30pixels, then by 60 etc.
      var offset = this.pasteCounter * PasteOffset * this.layer.getUnitsPerPixel();

      // Insert copies of shapes in the clipboard (+ add offset per paste steps)
      var shapes = [];

      var eventArgs = { type: CopyTool.BEFORE_PASTE, originalShapes: this.originalShapes, veto: false };
      this.dispatchEvent(eventArgs);
      if (eventArgs.veto) {
        return;
      }

      for (var i = 0; i < this.clipBoard.length; i++) {
        var newShape = this.clipBoard[i].clone();

        // Apply offset before cloning, so that another paste will add another offset
        newShape.move(offset, offset);

        // Insert copy
        shapes.push(newShape);
      }

      // Change selection to new shapes
      this.selection.setSelection(shapes);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].AddShapes(this.layer, shapes));

      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, originalShapes: this.originalShapes, shapes: shapes });
    }

    // delete all selected shapes
  }, { key: "delete", value: function _delete() {
      var shapes = this.selection.getSelectedShapes();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
      this.selection.clear();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (!this.selection.empty()) {
        if (keyCode === av.KeyCode.DELETE) {
          this.delete();
          return true;
        }

        if (event.ctrlKey && keyCode === av.KeyCode.c) {
          this.copy();
          return true;
        }
      }

      if (this.clipBoard.length !== 0) {
        if (event.ctrlKey && keyCode === av.KeyCode.v) {
          this.paste();
          return true;
        }
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return CopyToolName + this.nameSuffix;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return CopyTool;}();
;

CopyTool.BEFORE_PASTE = "BEFORE_PASTE";
CopyTool.AFTER_PASTE = "AFTER_PASTE";

/***/ }),

/***/ "./extensions/Edit2D/tools/EditToolBase.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EditToolBase.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditToolBase; });
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var av = Autodesk.Viewing;


// Utility class shared by Edit2D tools to facilitate snapping
var EditToolBase = /*#__PURE__*/function () {

  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);

    this.viewer = ctx.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.snapper = ctx.snapper;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.unitHandler = ctx.unitHandler;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.
    this.ignoreDragging = false;

    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.
    this.ignoreActions = false;

    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.
    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.
    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. 
    this.onActionCb = function (a) {
      if (!_this.ignoreActions) {
        _this.handleExternalAction(a);
      }
    };

    // indicates if snapping is currently suppressed by hold modifier key
    this.suppressSnapping = false;

    this.keyMap = {
      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping
      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in
    };

    // When using selection, register a handler to notify about selection changed
    if (this.selection) {
      this.selectionCb = function () {

        // Only respond if tool is activated
        if (!_this.active) {
          return;
        }

        // Call handler if derived class defines one
        _this.onSelectionChanged && _this.onSelectionChanged();
      };

      this.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
    }

    this.active = false;

    // Track last mouse position in canvas coords. Note that derived classes must call
    // the base class mouse handlers to keep this value valid.
    this.canvasPos = new THREE.Vector2();

    // Tracks which gizmo is under mouse
    this.gizmoManager = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["GizmoManager"]();

    // Track which keys are currently hold down
    this.keyState = {
      ctrl: false,
      shift: false,
      alt: false };

  }_createClass(EditToolBase, [{ key: "getSnapPosition", value: function getSnapPosition(

    canvasX, canvasY) {var _this2 = this;
      var useSnapper = this.snapper && !this.suppressSnapping;
      if (useSnapper) {
        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});
      } else {
        // Make sure that we don't keep outdated snapping gizmos
        this.snapper.clearSnappingGizmos();

        // Just convert canvas pos to layer pos
        return this.layer.canvasToLayer(canvasX, canvasY);
      }
    } }, { key: "dtor", value: function dtor()

    {
      if (this.selectionCb) {
        this.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
      }
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      this.keyState[keyCode] = true;

      // Hold key to suppress snapping
      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {
        this.suppressSnapping = true;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise
      // the customer might lose his drawings when he's in an editing session, does a invalid selection and
      // hits backspace.
      if (keyCode === av.KeyCode.BACKSPACE) {
        return true;
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = true;
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {

      this.keyState[keyCode] = false;

      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {
        this.suppressSnapping = false;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = false;
      }
    }

    // Invoked whenever another tool triggered 
  }, { key: "handleExternalAction", value: function handleExternalAction(action) {}

    // Run an action without triggering handleExternalAction
  }, { key: "runAction", value: function runAction(action) {
      this.ignoreActions = true;
      this.undoStack.run(action);
      this.ignoreActions = false;
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

      // Make sure we don't keep outdated snapping indicators
      this.snapper && this.snapper.clearSnappingGizmos();
    } }, { key: "register", value: function register()

    {}

    // Maps a key event to a function key in the key-map.
  }, { key: "mapKey", value: function mapKey(event, keyMap) {

      for (var key in keyMap) {
        var assigned = keyMap[key];

        // Skip disabled key commands
        if (assigned === null) {
          continue;
        }

        // If a single key is assigned to this function and it matches, return the function key
        if (event.keyCode == assigned) {
          return key;
        }

        // If multiple keys are assigned, check if one matches.
        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {
          return key;
        }

        // If it is an object, it may define modifiers and a custom filter
        if (_typeof(assigned) === 'object') {
          var ctrl = assigned.ctrlKey === undefined ? true : assigned.ctrlKey === event.ctrlKey;
          var shift = assigned.shiftKey === undefined ? true : assigned.shiftKey === event.shiftKey;
          var alt = assigned.altKey === undefined ? true : assigned.altKey === event.altKey;
          var meta = assigned.meta === undefined ? true : assigned.metaKey === event.metaKey;

          // return true if code and all (assigned) modifiers match
          var match = assigned.keyCode === event.keyCode && ctrl && shift && alt && meta;
          if (match) {
            return key;
          }
        }

        // Allow generic key-handler function
        if (typeof assigned === 'function' && assigned(event)) {
          return key;
        }
      }
      // event does not match any assigned keyCode
      return null;
    } }, { key: "snappingFilter",

    // By default, we consider all EditShapes for snapping
    value: function snappingFilter() {
      return true;
    }

    // Remember last mouse position
  }, { key: "trackMousePos", value: function trackMousePos(e) {
      this.canvasPos.set(e.canvasX, e.canvasY);
      this.gizmoManager.update(e);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    e) {this.trackMousePos(e);} }, { key: "handleSingleClick", value: function handleSingleClick(
    e) {this.trackMousePos(e);} }, { key: "handleDoubleClick", value: function handleDoubleClick(
    e) {this.trackMousePos(e);} }, { key: "handleButtonUp", value: function handleButtonUp(
    e) {this.trackMousePos(e);} }, { key: "handleButtonDown", value: function handleButtonDown(
    e) {this.trackMousePos(e);} }]);return EditToolBase;}();
;

av.GlobalManagerMixin.call(EditToolBase.prototype);

/***/ }),

/***/ "./extensions/Edit2D/tools/InsertSymbolTool.js":
/*!*****************************************************!*\
  !*** ./extensions/Edit2D/tools/InsertSymbolTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InsertSymbolTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}



var InsertSymbolToolName = "Edit2_InsertSymbolTool";var

InsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);

  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(InsertSymbolTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.symbol = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"](0, 0,
    0.2,
    new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      fillAlpha: 1.0,
      lineWidth: 0.01,
      fillColor: 'rgb(255, 255, 0)' }));return _this;

  }_createClass(InsertSymbolTool, [{ key: "getName", value: function getName()

    {
      return InsertSymbolToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "setSymbol", value: function setSymbol(

    symbol) {
      this.symbol = symbol;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event) {

      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var symbol = this.symbol.clone();
      symbol.move(res.x, res.y);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, symbol));

      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });

      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      return true;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return InsertSymbolTool;}(_EditToolBase__WEBPACK_IMPORTED_MODULE_2__["default"]);


InsertSymbolTool.SYMBOL_INSERTED = "symbolInserted";

/***/ }),

/***/ "./extensions/Edit2D/tools/LineTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/LineTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CanvasGizmo */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var LineToolName = "Edit2_LineTool";

var av = Autodesk.Viewing;

// Draws lines with single drag
var LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);

  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, LineTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineTool).call(this, ctx));

    _this.style = style;

    // New polyline created by dragging
    _this.line = null;

    // Start/Endpoint of the line being dragged
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the length labels (public API)
  _createClass(LineTool, [{ key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return LineToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Make sure that we consider latest end-coords
      this.handleMouseMove(event);

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.line) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      var points = [startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.line = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolylinePath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"](points, style);
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.line);
    } }, { key: "updateLine", value: function updateLine()

    {

      if (!this.isDragging()) {
        return;
      }

      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);
      this.gizmoLayer.update();

      this.lengthLabel.setShape(this.line);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateLine();
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.line) {
        return false;
      }

      // Remove temporary gizmo shape
      this.gizmoLayer.removeShape(this.line);

      // Add line shape if valid
      var lineValid = !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].edgeIsDegenerated(this.startPoint, this.endPoint);
      if (lineValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.line));
      }

      this.line = null;

      this.lengthLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.line) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.line);
        this.line = null;

        this.dragCanceled = true;

        this.lengthLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.line);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(false);
      }
    } }]);return LineTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/MoveTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/MoveTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var MoveToolName = "Edit2_MoveTool";

var av = Autodesk.Viewing;var

MoveTool = /*#__PURE__*/function () {

  function MoveTool(ctx) {_classCallCheck(this, MoveTool);

    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // Only set during dragging
    this.shape = null;

    // drag-start position in layer coords
    this.dragStartPoint = new THREE.Vector2();

    // backup original shape on drag-start as long as we are modifying it on-hover
    this.backupShape = null;

    this.keyMap = {
      CancelEdit: av.KeyCode.ESCAPE };


    // Remember last mouse-pos on mouse-move events
    this.lastMousePos = new THREE.Vector2(); // in layer coords
  }_createClass(MoveTool, [{ key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return MoveToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var hitShape = this.layer.hitTest(p.x, p.y);

      if (hitShape) {
        this.startDrag(hitShape, p);
      }

      // Set selection to the shape that we picked
      if (this.shape) {
        this.selection.selectOnly(this.shape);
      } else {
        this.selection.clear();
      }

      return Boolean(this.shape);
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(shape, startPos) {
      this.shape = shape;
      this.dragStartPoint.copy(startPos);
      this.backupShape = shape.clone();
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p) {
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      // Apply this offset to shape. We always start with the original shape as a reference 
      // to avoid accumulating delta inaccuracies.
      this.shape.copy(this.backupShape);
      this.shape.move(dx, dy);
      this.layer.update();
    }

    // Clean up data hold during a drag interaction
  }, { key: "resetDragging", value: function resetDragging() {
      this.shape = null;
      this.backupShape = null;
    } }, { key: "endDrag", value: function endDrag(

    p) {
      // No drag active
      if (!this.shape) {
        return;
      }

      // Revert any temporary modifications done during mouse move
      this.shape.copy(this.backupShape);

      // Apply move operation
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveShape(this.layer, this.shape, dx, dy));

      if (this.shape) {
        this.shape = null;
        return true;
      }
      return false;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.isDragging()) {

        // Revert shape o state when dragging was started
        this.shape.copy(this.backupShape);
        this.layer.update();

        this.resetDragging();
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.shape);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get and store latest mouse position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.lastMousePos.copy(p);

      if (!this.shape) {
        return false;
      }

      // get delta between last and current position        
      this.moveDrag(p);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.endDrag(p);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
      }
    }

    // Display move cursor if a shape is under mouse or if we are dragging
  }, { key: "getCursor", value: function getCursor() {
      if (this.shape) {
        return 'move';
      }

      // Show move cursor if a shape is under mouse
      var shapeAtMouse = this.layer.hitTest(this.lastMousePos.x, this.lastMousePos.y);
      return shapeAtMouse ? 'move' : undefined;
    } }]);return MoveTool;}();

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonEditTool.js":
/*!****************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonEditTool.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonEditTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../EllipseArcGizmo.js */ "./extensions/Edit2D/EllipseArcGizmo.js");
/* harmony import */ var _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}










var PolygonEditToolName = 'Edit2_PolygonEditTool';

var av = Autodesk.Viewing;

// Allow to pick an edge within 
var EdgeSelectTolerance = 17;

var vertexGizmoName = function vertexGizmoName(index) {
  return 'PolygonEditTool_vertexGizmo_' + index.toString();
};

var edgeGizmoName = function edgeGizmoName(index) {
  return 'PolygonEditTool_edgeGizmo_' + index.toString();
};

var updateVertexGizmoNames = function updateVertexGizmoNames(vertexGizmos) {
  for (var i = 0; i < vertexGizmos.length; i++) {
    var gizmo = vertexGizmos[i];
    gizmo.setName(vertexGizmoName(i));
    gizmo.update(false); // Make sure that the shapes get the name immediately - we don't need a layer update for this.
  }
};

// Given a Polyline/Polygon and a vertex index, check if the two edges next to 'vertex' are collinear.
// Returns false if vertex does not have 2 different neighbor edges.
var edgesCollinear = function edgesCollinear(poly, vertex) {

  // If polygon/polyline just contains 0 or 1 edges, just return false.
  if (poly.vertexCount < 3) {
    return false;
  }

  // check if neighbor edges exist
  var isLine = poly.isPolyline();
  var prevExists = !(isLine && vertex === 0);
  var nextExists = !(isLine && vertex === poly.vertexCount - 1);

  // If poly has only 1 edge or 'vertex' is an end vertex of a polyline, stop here.
  if (!prevExists || !nextExists) {
    return false;
  }

  // get points before and after vertex
  var prevIndex = poly.prevIndex(vertex);
  var nextIndex = poly.nextIndex(vertex);

  var precision = 1.e-5;

  var a = poly.getPoint(prevIndex);
  var b = poly.getPoint(vertex);
  var c = poly.getPoint(nextIndex);
  return _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].isPointOnLine(b, a, c, precision);
};var

PolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);

  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonEditTool).call(this, ctx));

    _this.moveTool = new _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);

    // Only set during dragging
    _this.poly = null;

    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();

    // Circles around each vertex
    _this.vertexGizmos = [];

    // Index of the vertex currently being dragged (or -1 if no dragging is active)
    _this.draggedVertex = -1;

    // When dragging a vertex, this stores a copy of its original position
    _this.dragVertexStartPos = new THREE.Vector2();

    // When dragging an edge, this stores a copy of its original position
    _this.dragEdgeStartPos = {
      a: new THREE.Vector2(),
      b: new THREE.Vector2() };


    // Index of the edge being dragged or -1
    _this.draggedEdge = -1;

    // When dragging an edge, selectedEdge is the same as draggedEdge. After the interaction, draggedEdge is reset to -1, but
    // the edge keeps selected until clicking somewhere else.
    _this.selectedEdge = -1;

    // In some cases, we duplicate start/end vertex when beginning to drag an edge. This may shift this.draggedEdge by 1 or 2.
    // draggedEdgeBefore stores the original edgeIndex before duplicating vertices.
    _this.draggedEdgeBefore = -1;

    // Reused to store edge normal of dragged edge
    _this.draggedEdgeNormal = new THREE.Vector2();

    // Used when dragging an edge: Indicates whether we had to duplicate 
    // start/end vertex of the edge in order to move it.
    _this.duplicateStartVertex = false;
    _this.duplicateEndVertex = false;

    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex, 
    // but (unlike draggedVertex) keeps the same after dragEnd.
    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.
    _this.selectedVertex = -1;

    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.
    _this.edgeGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]();
    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer

    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;
    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;
    _this.keyMap.ChangeToArc = av.KeyCode.a; // Change selected edge to arc
    _this.keyMap.ChangeToLine = av.KeyCode.l; // Change selected edge to line

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // {EdgeGizmo[]} Array of Gizmos used for moving edges. 
    _this.edgeGizmos = [];

    // Displays dashed lines that connect start/end vertex of arc segments
    _this.arcEdgeGizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["ArcEdgeGizmo"](ctx.layer, ctx.gizmoLayer);

    // {TangentGizmo[]} Array of TangentGizmos for BezierArcs
    _this.tangentGizmos = [];

    // If true, we apply hover-highlight on shape under mouse.
    _this.hoverEnabled = true;

    // If true, we allow changing edge type to ellipse arcs.
    _this.enableEllipseArcs = false;

    // Ellipse-arc gizmo. Only shown if an ellipse-edge is selected
    _this.ellipseArcGizmo = new _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["EllipseArcGizmo"](ctx.layer, _this.gizmoManager, ctx.undoStack, false);return _this;
  }_createClass(PolygonEditTool, [{ key: "setHoverEnabled", value: function setHoverEnabled(

    enabled) {

      // On disable, make sure that we don't leave any highlight behind
      if (this.hoverEnabled && !enabled) {
        this.selection.setHovered(null);
      }

      this.hoverEnabled = enabled;
    }

    // Enable the area labels (public API)
  }, { key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return PolygonEditToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "deactivate", this).call(this);
      this.reset();
    } }, { key: "createVertexGizmos", value: function createVertexGizmos()

    {
      for (var i = 0; i < this.poly.points.length; i++) {
        // create new vertex gizmo
        var p = this.poly.points[i];
        var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, vertexGizmoName(i), this.poly.style);
        this.vertexGizmos.push(vertex);

        // We implement drag-behavior, so we want hover-highlight
        vertex.setHoverEnabled(true);
      }
    }

    // Make sure that VertexGizmos reflect latest state of the shape
  }, { key: "updateVertexGizmos", value: function updateVertexGizmos() {
      var vertexCount = this.poly ? this.poly.vertexCount : 0;

      // If just the positions changed (e.g. while moving the shape), we just update the positions.
      var p = new THREE.Vector2();
      if (vertexCount == this.vertexGizmos.length) {
        for (var i = 0; i < vertexCount; i++) {
          this.poly.getPoint(i, p);
          this.vertexGizmos[i].setPosition(p.x, p.y);
        }
      } else {
        // just re-create all VertexGizmos
        this.clearVertexGizmos();
        this.createVertexGizmos();
      }
    } }, { key: "clearVertexGizmos", value: function clearVertexGizmos()

    {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    } }, { key: "clearEdgeGizmos", value: function clearEdgeGizmos()

    {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        this.edgeGizmos[i].dtor();
      }
      this.edgeGizmos.length = 0;

      // Clear dashed lines between start/endPoint of arcs.
      this.arcEdgeGizmo.setPoly(null);
    }

    // Update selection highlighting for edge gizmos
  }, { key: "updateEdgeGizmoHighlighting", value: function updateEdgeGizmoHighlighting() {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        var gizmo = this.edgeGizmos[i];
        gizmo.setSelected(i == this.selectedEdge);
      }
    }

    // Update edgeGizmos to this.poly or hide all if poly is null
  }, { key: "createEdgeGizmos", value: function createEdgeGizmos() {
      // Make sure that we don't leak outdated ones
      this.clearEdgeGizmos();

      // Create gizmo per edge
      var edgeCount = this.poly ? this.poly.getEdgeCount() : 0;

      // For simple lines, we don't show the edge-move gizmo: It does not make sense to
      // move an edge, because you can simply move the whole shape instead.
      var needEdgeMoveGizmos = edgeCount >= 2;

      if (needEdgeMoveGizmos) {
        for (var i = 0; i < edgeCount; i++) {
          var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["EdgeMoveGizmo"](this.layer, edgeGizmoName(i));
          gizmo.attachToEdge(this.poly, i);
          this.edgeGizmos.push(gizmo);
        }
      }

      // attach arcEdgeGizmo to current shape, so that dashed lines are displayed for its arc segments
      this.arcEdgeGizmo.setPoly(this.poly);

      this.updateEdgeGizmoHighlighting();

      // Shift label a bit up to avoid it from occluding the move-edge gizmo
      var yOffset = needEdgeMoveGizmos ? 20 : 0;
      this.lengthLabel.pixelOffset.set(0, yOffset);
    }

    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)
  }, { key: "updateVertexHighlighting", value: function updateVertexHighlighting() {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].setSelected(i === this.selectedVertex);
      }
    }

    // Update vertex-gizmos, edge gizmos (for edge highlighting), and tangent gizmos.
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateVertexGizmos();
      this.updateEdgeGizmo();
      this.createEdgeGizmos();
      this.updateTangentGizmos();
      this.updateEllipseArcGizmo();
    } }, { key: "setSelectedVertex", value: function setSelectedVertex(

    index) {

      // Selecting a vertex resets edge selection and vice versa
      if (index !== -1) {
        this.setSelectedEdge(-1);
      }

      this.selectedVertex = this.poly ? index : -1;
      this.updateVertexHighlighting();
      this.updateTangentGizmos();
      this.updateEllipseArcGizmo();
    }

    // Returns the index of the vertex gizmo at the given position (or -1 if no vertexGizmo is hit)
  }, { key: "getVertexIndex", value: function getVertexIndex() {
      return this.gizmoManager.getGizmoIndex(this.vertexGizmos);
    }

    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)
    // (x,y) are in layer-coords
  }, { key: "getEdgeIndex", value: function getEdgeIndex() {
      return this.gizmoManager.getGizmoIndex(this.edgeGizmos);
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      // Clear any gizmos from previous polygon
      this.clearVertexGizmos();
      this.clearEdgeGizmos();
      this.clearTangentGizmos();

      // Cleanup area and length labels
      this.areaLabel.setShape(null);
      this.lengthLabel.setShape(null);

      this.poly = null;
      this.draggedVertex = -1;
      this.draggedEdge = -1;
      this.selectedVertex = -1;
      this.selectedEdge = -1;

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }

      // Sync label with polygon or polyline. If this.poly is null, it will be hidden
      var polygon = poly && poly.isPolygon() ? poly : null;
      this.areaLabel.setShape(polygon);
      var polyline = poly && poly.isPolyline() ? poly : null;
      this.lengthLabel.setShape(polyline);
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddVertex(this.layer, this.poly, index, p));

      // insert new VertexGizmo
      var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, undefined, this.poly.style);
      gizmo.setHoverEnabled(true);

      // update vertex gizmos
      this.vertexGizmos.splice(index, 0, gizmo);
      updateVertexGizmoNames(this.vertexGizmos);

      // removeupdate edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Display polygon change and new gizmo
      this.layer.update();
    } }, { key: "removePoint", value: function removePoint(

    index) {

      // If removing a vertex would make the shape degenerate, remove it completely
      var minVerts = this.poly.isPolygon() ? 3 : 2;
      if (this.poly.vertexCount <= minVerts) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShape(this.layer, this.poly));
        this.reset();
        return;
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveVertex(this.layer, this.poly, index));

      // update vertex gizmos
      var gizmo = this.vertexGizmos.splice(index, 1)[0];
      updateVertexGizmoNames(this.vertexGizmos);

      // update edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Display changed polygon and removed vertex gizmo
      gizmo.dtor();

      // Make sure that this vertex is not selected anymore
      if (this.selectedVertex === index) {
        this.setSelectedVertex(-1);
      }

      // Unselect edge if edgeIndex got invalid
      if (!this.poly.edgeIndexValid(this.selectedEdge)) {
        this.setSelectedEdge(-1);
      }

      this.layer.update();
    } }, { key: "startDragVertex", value: function startDragVertex(

    event, draggedVertex) {

      // Configure angle snapping to consider latest state of the polygon
      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex);

      this.draggedVertex = draggedVertex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = this.poly.points[this.draggedVertex];
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);

      // highlight the vertex we clicked on
      this.setSelectedVertex(this.draggedVertex);

      this.lastDragPoint.copy(vpos);
      this.dragVertexStartPos.copy(vpos);
    } }, { key: "moveDragVertex", value: function moveDragVertex(

    canvasX, canvasY) {
      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;

      // get delta between last and current position
      var p = this.getSnapPosition(x, y);
      var dx = p.x - this.lastDragPoint.x;
      var dy = p.y - this.lastDragPoint.y;

      // apply this offset to polygon point
      var point = this.poly.points[this.draggedVertex];
      this.poly.updatePoint(this.draggedVertex, point.x + dx, point.y + dy);

      // re-center gizmo at new point position
      var vertexGizmo = this.vertexGizmos[this.draggedVertex];
      vertexGizmo.setPosition(point.x, point.y);

      this.gizmoLayer.update(); // we moved the vertex gizmo
      this.layer.update(); // we changed the main polygon

      this.lastDragPoint.copy(p);
    } }, { key: "restoreDragVertex", value: function restoreDragVertex()

    {
      this.poly.updatePoint(this.draggedVertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y);
    } }, { key: "endDragVertex", value: function endDragVertex()

    {

      // First, restore "before move" position of the vertex
      this.restoreDragVertex();

      var pBefore = this.dragVertexStartPos;
      var pAfter = this.lastDragPoint;

      // don't add extra undo-operation if the vertex was hardly moved at all
      var minDist = this.layer.getUnitsPerPixel() * 0.5;
      var moved = pBefore.distanceTo(pAfter) > minDist;

      if (moved) {
        // Finalize vertex-move
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));
      }

      this.draggedVertex = -1;
      this.snapper.clearSnappingGizmos();
    } }, { key: "startDragEdge", value: function startDragEdge(

    event, draggedEdge) {

      // store edge normal for the edge being dragged
      this.draggedEdgeNormal = this.poly.getLeftEdgeNormal(draggedEdge, this.draggedEdgeNormal);
      this.lastDragPoint.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));

      // store original position of the two edge vertices
      var ia = draggedEdge;
      var ib = (draggedEdge + 1) % this.poly.vertexCount;
      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia));
      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib));

      // Check if we need to duplicate start and/or end vertex of the edge.
      // This happens when the neighbor edges are collinear with the ones being moved.
      this.duplicateStartVertex = edgesCollinear(this.poly, ia);
      this.duplicateEndVertex = edgesCollinear(this.poly, ib);

      // Duplicate start/end vertices if necessary
      _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge.duplicateVertices(this.poly, draggedEdge, this.duplicateStartVertex, this.duplicateEndVertex);

      // Store initial edge index (not considering any duplicated vertices)
      this.draggedEdgeBefore = draggedEdge;

      // Select the edge - using its index after duplicating vertices
      var newEdgeIndex = _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge.getNewEdgeIndex(this.poly, draggedEdge, this.duplicateStartVertex, this.duplicateEndVertex);
      this.setSelectedEdge(newEdgeIndex);

      // Set the edge being dragged
      this.draggedEdge = newEdgeIndex;

      // Make sure that all gizmos are updated if we duplicated vertices
      if (this.duplicateStartVertex || this.duplicateEndVertex) {
        this.updateAllGizmos();
      }
    } }, { key: "moveDragEdge", value: function moveDragEdge(

    event) {

      // get delta between last and current position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var delta = p.clone().sub(this.lastDragPoint);

      // get indices of prev and next edge
      var prevEdgeIndex = this.poly.prevEdgeIndex(this.draggedEdge);
      var nextEdgeIndex = this.poly.nextEdgeIndex(this.draggedEdge);

      // prev/next edge may not exist if we are at the end of a polyline
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Will contain the new edge endpoints
      var newEdgeA = new THREE.Vector2();
      var newEdgeB = new THREE.Vector2();

      // get edge vertices
      var curEdgeA = new THREE.Vector2();
      var curEdgeB = new THREE.Vector2();
      this.poly.getEdge(this.draggedEdge, curEdgeA, curEdgeB);

      if (!prevEdgeExists && !nextEdgeExists) {
        // If prev/next are both missing, we are moving an isoldated line segment around.
        // In this case, we can just allow unconstrained moving and are done here.
        newEdgeA.copy(curEdgeA).add(delta);
        newEdgeB.copy(curEdgeB).add(delta);
      } else {

        // get next/previous edge (if existing)
        var prevEdgeA = new THREE.Vector2();
        var prevEdgeB = new THREE.Vector2();
        var nextEdgeA = new THREE.Vector2();
        var nextEdgeB = new THREE.Vector2();
        prevEdgeExists && this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB);
        nextEdgeExists && this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB);

        // Handle start edges of polylines: Choose some "assumed" previous edge if there is none. 
        if (!prevEdgeExists) {

          prevEdgeB.copy(curEdgeA);

          if (!this.duplicateEndVertex) {
            // Assume previous edge to be parallel to the next one. In this
            // way, we constrain the movement only along one direction.
            prevEdgeA.copy(nextEdgeB).sub(curEdgeB).add(curEdgeA);
          } else {
            // The second edge was collinear with the first, so we had to add an extra vertex at dragStart.
            // Therefore, nextEdge is degenerated and we cannot use it.
            // For this case, we just assume prevEdge to be perpendicular to the current edge.
            prevEdgeA.copy(curEdgeA).add(this.draggedEdgeNormal);
          }
        }

        // Handle end edges of polylines: Choose some "assumed" next edge if there is none
        if (!nextEdgeExists) {

          nextEdgeA.copy(curEdgeB);

          if (!this.duplicateStartVertex) {
            // Assume next edge to be parallel to the previous one. In this
            // way, we constrain the movement only along one direction.
            nextEdgeB.copy(prevEdgeA).sub(curEdgeA).add(curEdgeB);
          } else {
            // The previous edge was collinear with the current one, so we had to add an extra vertex at dragStart.
            // Therefore, prevEdge is degenerated and we cannot use it.
            // For this case, we just assume nextEdge to be perpendicular to the current edge.
            nextEdgeB.copy(curEdgeB).add(this.draggedEdgeNormal);
          }
        }

        // Compute directions for each edge to intersect
        var prevEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(prevEdgeA, prevEdgeB);
        var curEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(curEdgeA, curEdgeB);
        var nextEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(nextEdgeA, nextEdgeB);

        // Apply move offset
        curEdgeA.add(delta);
        curEdgeB.add(delta);

        // If we added extra vertices, the (newly inserted) neighbor edges will be degenerated
        // and the edge directions will be invalid. In this case, we choose the edge direction
        // perpendicular to the edge that we are dragging.
        if (this.duplicateStartVertex) prevEdgeDir.copy(this.draggedEdgeNormal);
        if (this.duplicateEndVertex) nextEdgeDir.copy(this.draggedEdgeNormal);

        // Compute new edge endpoints as intersection of prev/next edge with the moved line
        if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||
        !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {
          // If we don't find an intersection, reject this edge move attempt, because
          // it's not possible to move the edge in this way by enlarging the neighbor edges.
          return;
        }
      }

      // get indices of the points to modify
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      // The intersections gives us the new position for the edge vertices
      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y);
      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y);

      // update affected vertex gizmos
      this.vertexGizmos[ia].setPosition(newEdgeA.x, newEdgeA.y);
      this.vertexGizmos[ib].setPosition(newEdgeB.x, newEdgeB.y);

      this.gizmoLayer.update();
      this.layer.update();

      this.lastDragPoint.copy(p);

      // We moved the edge => Keep gizmo in-sync
      this.updateEdgeGizmo();
    }

    // While dragging an edge, this function restores the original position at drag start
  }, { key: "restoreDragEdge", value: function restoreDragEdge() {
      var a = this.dragEdgeStartPos.a;
      var b = this.dragEdgeStartPos.b;

      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      this.poly.updatePoint(ia, a.x, a.y);
      this.poly.updatePoint(ib, b.x, b.y);

      // Revert insertion of extra vertices
      _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge.revertDuplicateVertices(this.poly, this.draggedEdgeBefore, this.duplicateStartVertex, this.duplicateEndVertex);

      // If we duplicated vertices at dragStart and reverted it now, 
      // the index of the selected edge may have shifted. So, we must change it to the old one to keep to (visually) keep the same 
      // edge selected as before.
      this.selectedEdge = this.draggedEdgeBefore;
    } }, { key: "endDragEdge", value: function endDragEdge()

    {

      // get final position of the edge vertices
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      var newPos1 = this.poly.getPoint(ia);
      var newPos2 = this.poly.getPoint(ib);

      this.restoreDragEdge();

      // If the edge was hardly moved at all, we drop the operation. Otherwise, the only effect would be to add invisible
      // vertex duplicates.
      var delta = this.dragEdgeStartPos.a.distanceTo(newPos1) * this.layer.getPixelsPerUnit();
      if (delta >= 3) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge(this.layer, this.poly, this.draggedEdgeBefore, newPos1, newPos2, this.duplicateStartVertex, this.duplicateEndVertex));

        // If the action duplicated vertices, make sure that the selected edge is updated to
        // the index that the selected edge has after the action.
        this.selectedEdge = this.draggedEdge;
      }

      // Reset draggedEdge, but the edge keeps selected (we don't reset this.selectedEdge)
      this.draggedEdge = -1;

      // update all gizmos
      this.updateAllGizmos();
    } }, { key: "edgeMovePossible", value: function edgeMovePossible()

    {
      return this.poly && this.poly.vertexCount > 2;
    } }, { key: "isSingleLine", value: function isSingleLine()

    {
      return this.poly && this.poly.vertexCount === 2;
    }

    // If the given mousePos (in layerCoords) is located close to an edge (not edge gizmo), 
    // the edge index is returned, otherwise -1.
  }, { key: "findEdgeUnderMouse", value: function findEdgeUnderMouse(pos) {
      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
      return this.poly ? this.poly.findEdgeIndex(pos, precision) : -1;
    }

    // Checks if a point p can be inserted to split the given edge. If so, it returns the projected
    // position that is located exactly on edge to be split.
    //
    //  @param {Vector2} p         - pos in layer coords - usually close to given edge.
    //  @param {number}  edgeIndex - index of the edge to be split by this vertex
    //  @returns {Vector2|null} Adjusted position where the new point will be added.
  }, { key: "getNewVertexPosition", value: function getNewVertexPosition(p, edgeIndex) {

      if (!this.poly || !this.poly.edgeIndexValid(edgeIndex)) {
        return null;
      }

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, a, b);

      // get edge direction
      var edgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(a, b);

      // compute projection of p to the line spanned by the edge
      var newPos = p.clone();
      _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].projectToLine(newPos, a, edgeDir);

      // Reject position if the projection is outside the segment
      if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].isPointOnEdge(newPos, a, b, 0.0001)) {
        return null;
      }

      // Return position where to insert the new vertex
      return newPos;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      // If we hit an existing vertex, start dragging it
      var draggedVertex = this.getVertexIndex();
      if (draggedVertex != -1) {
        this.startDragVertex(event, draggedVertex);
        return true;
      }

      // Handle Vertex-Add: Check if we hold ctrl and hit an edge
      var newVertex = -1;
      if (event.ctrlKey) {
        // Is mouse close to an edge and can be projected onto that edge?
        var edgeIndex = this.findEdgeUnderMouse(this.mousePos);
        var newVertexPos = this.getNewVertexPosition(this.mousePos, edgeIndex);
        if (newVertexPos) {
          // We don't insert exactly at the mouse position. Instead, new vertices
          // are always located exactly on the edge being split. Therefore, newVertexPos is
          // usually slightly different from mousePos.

          // insert new vertex after edge starting point
          newVertex = edgeIndex + 1;
          this.insertPoint(newVertex, newVertexPos);

          // Allow to drag the new vertex immediately
          this.startDragVertex(event, newVertex);

          return true;
        }
      }

      // Handle dragging of TangentGizmo control points for Bezier arcs.
      for (var i = 0; i < this.tangentGizmos.length; i++) {
        var gizmo = this.tangentGizmos[i];
        if (gizmo.onButtonDown(event.canvasX, event.canvasY)) {
          // We started dragging of a Bezier control point
          return true;
        }
      }

      // Handle dragging of EllipseArc gizmo
      if (this.ellipseArcGizmo.startDrag(event.canvasX, event.canvasY)) {
        // We started dragging an ellipse arc
        return true;
      }

      // Reset selection highlighting of vertices and edges.
      this.setSelectedVertex(-1);
      this.setSelectedEdge(-1);

      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it
      var selectedEdgeGizmo = this.getEdgeIndex();
      if (this.edgeMovePossible() && selectedEdgeGizmo !== -1) {
        this.startDragEdge(event, selectedEdgeGizmo);
        return true;
      }

      // If we just clicked inside the already active polygon, delegate to MoveTool
      if (this.poly) {
        // Note: this.poly may be a Polyline. To allow moving it, it's essential to use a hitRadius for picking.
        var hitRadius = this.layer.getLineHitRadius(this.poly);
        if (this.poly.hitTest(p.x, p.y, hitRadius)) {
          this.moveTool.startDrag(this.poly, p);
          return true;
        }
      }

      // Check if we selected a new polygon
      var newPolygon = this.layer.hitTest(p.x, p.y);

      // If the clicked object is neither polygon nor polyline, ignore it.
      var isPolygon = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
      var isPolyline = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"];
      var isPath = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];
      if (!isPolygon && !isPolyline && !isPath) {
        newPolygon = null;
      }

      // Set selection to current polygon. This will also trigger setEditPoly() 
      // via selectionChanged event.
      this.selection.selectOnly(newPolygon);

      return Boolean(this.poly);
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    e) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleSingleClick", this).call(this, e);

      return Boolean(this.poly);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));
      this.updateMouseOverHighlights();

      if (!this.poly) {
        return false;
      }

      if (this.draggedVertex != -1) {
        this.moveDragVertex(event.canvasX, event.canvasY);
        return true;
      }

      if (this.draggedEdge != -1) {
        this.moveDragEdge(event);
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.moveDrag(this.mousePos);

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the ellipseArc gizmo
      if (this.ellipseArcGizmo.dragging) {
        return this.ellipseArcGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonUp", this).call(this, event, button);

      if (this.draggedVertex !== -1) {
        this.endDragVertex();
        return true;
      }

      if (this.draggedEdge !== -1) {
        this.endDragEdge();
        return true;
      }

      if (this.moveTool.isDragging()) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);

        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves
        this.ignoreActions = true;
        this.moveTool.endDrag(p);
        this.ignoreActions = false;

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.endDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the center of an ellipse arc
      if (this.ellipseArcGizmo.dragging) {
        this.ellipseArcGizmo.endDrag(event.canvasX, event.canvasY);
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && this.poly && button == 0;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();
      var shape = selected[0];
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.DeleteSelectedVertex) {
        if (this.poly && this.selectedVertex !== -1) {
          this.removePoint(this.selectedVertex);
          handled = true;
        }
      }

      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
        return true;
      }

      // Check if we have an edge to work on
      var targetEdge = this.isSingleLine() ? 0 : this.selectedEdge; // If we have just a single segment, we don't need edge selection.
      var targetEdgeValid = this.poly && this.poly.edgeIndexValid(targetEdge);

      if (keyCode === this.keyMap.ChangeToArc) {

        // If a line segment is selected, convert it to an arc
        var lineSegmentSelected = targetEdgeValid && !this.poly.isBezierArc(targetEdge);
        if (lineSegmentSelected) {
          this.changeEdgeToBezier(targetEdge);
        }
        return true;
      }

      if (keyCode === this.keyMap.ChangeToLine) {
        // If an arc segment is selected, convert it to a line
        var arcSegmentSelected = targetEdgeValid && this.poly.isBezierArc(targetEdge);
        if (arcSegmentSelected) {
          this.changeEdgeToLine(targetEdge);
        }
      }

      return handled;
    } }, { key: "onSnappingToggled",

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
    value: function onSnappingToggled(canvasX, canvasY) {

      // If we are dragging a vertex, toggling snapping will affect the result and 
      // we should update line gizmos and snapping lines.
      if (this.draggedVertex !== -1) {
        this.moveDragVertex(canvasX, canvasY);
      }
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedVertex !== -1) {
        this.restoreDragVertex();
        this.draggedVertex = -1;
        needsUpdate = true;
      }

      if (this.draggedEdge !== -1) {
        this.restoreDragEdge();
        this.draggedEdge = -1;
        needsUpdate = true;
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.cancelDrag();
        this.updateVertexGizmos();
      }

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      if (this.ellipseArcGizmo.dragging) {
        this.ellipseArcGizmo.cancelDrag();
        this.updateAllGizmos();
      }

      this.snapper.clearSnappingGizmos();
    } }, { key: "handleExternalAction", value: function handleExternalAction()

    {
      // If nothing is active, we don't need to care
      if (!this.poly) {
        return;
      }

      // If shape was removed, reset state
      var shapeFound = Boolean(this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // If poly was modified from outside, we can't know if the selected vertex or edge
      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.
      this.setSelectedEdge(-1);
      this.setSelectedVertex(-1);

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      this.snapper.clearSnappingGizmos();
    }

    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.
  }, { key: "updateEdgeGizmo", value: function updateEdgeGizmo() {

      // Check if mouse is on an edge gizmo
      var edgeUnderMouse = this.getEdgeIndex();

      // Check if a vertex gizmo is under mouse or being dragged. If so, it has precedence, so that we don't highlight the edge anymore
      var vertexUnderMouse = this.getVertexIndex();
      var vertexHighlighted = vertexUnderMouse != -1 || this.draggedVertex != -1;
      var edgeMovePossible = this.edgeMovePossible();

      // Check if we need any highlight
      var edgeSelected = this.poly && this.selectedEdge != -1;
      var edgeHovered = edgeMovePossible && edgeUnderMouse != -1 && !vertexHighlighted;

      // If edge is an arc and hovered, we just colorize the arcEdgeGizmo and don't need the extra edge-highlight gizmo
      var arcEdgeHovered = edgeHovered && this.poly.isPath() && this.poly.isArc(edgeUnderMouse);

      // We show the gizmo if an edge is selected or a line-segment is hovered.
      var gizmoNeeded = edgeSelected || edgeHovered && !arcEdgeHovered;

      // Make sure that edge gizmo is shown if needed
      if (gizmoNeeded && !this.edgeGizmoShown) {
        this.gizmoLayer.addShape(this.edgeGizmo);
        this.edgeGizmoShown = true;
      } else
      if (!gizmoNeeded && this.edgeGizmoShown) {
        this.gizmoLayer.removeShape(this.edgeGizmo);
        this.edgeGizmoShown = false;
      }

      // get index of the edge to be highlighted
      var edgeToHighlight = edgeSelected ? this.selectedEdge : edgeUnderMouse;

      // Constant color for highlighted edges
      var EdgeHighlightColor = 'rgb(0, 255, 0)';

      // Only for arcs: Colorize ArcEdgeGizmo if needed. For hover, this replaces the highlight gizmo. For select, we just set it to the same color to avoid color conflicts.
      var colorizeArcEdge = this.edgeGizmoShown || arcEdgeHovered;
      colorizeArcEdge ? this.arcEdgeGizmo.setEdgeHighlighted(edgeToHighlight, EdgeHighlightColor) : this.arcEdgeGizmo.clearEdgeHighlighting();

      // If we just had to hide it, we are done here
      if (!gizmoNeeded) {
        return;
      }

      // Update edge gizmo position...

      // get the two vertex positions of the edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeToHighlight, a, b);

      // copy values to edge gizmo
      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);

      // Adopt lineWidth from selected polygon
      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;
      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;

      if (edgeSelected) {
        // Override color by green
        this.edgeGizmo.style.lineColor = EdgeHighlightColor;
        this.edgeGizmo.style.lineAlpha = 1.0;
      } else {
        // Just make it a bit brighter using a semitransparent white overlay
        this.edgeGizmo.style.lineColor = EdgeHighlightColor;
        this.edgeGizmo.style.lineAlpha = 0.5;
      }

      this.gizmoLayer.update();
    } }, { key: "setSelectedEdge", value: function setSelectedEdge(

    edgeIndex) {

      // Selecting an edge resets vertex selection and vice versa.
      if (edgeIndex !== -1) {
        this.setSelectedVertex(-1);
      }

      this.selectedEdge = edgeIndex;
      this.updateEdgeGizmo();
      this.updateEdgeGizmoHighlighting();
      this.updateTangentGizmos();
      this.updateEllipseArcGizmo();
    } }, { key: "updateMouseOverHighlights", value: function updateMouseOverHighlights()

    {
      this.updateEdgeGizmo();

      // Handle mouse-over highlighting for shapes
      if (this.hoverEnabled) {
        var shape = this.layer.hitTest(this.mousePos.x, this.mousePos.y);
        this.selection.setHoveredId(shape ? shape.id : 0);
      }
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.

      var p = this.mousePos;

      // Indicate: "Moving whole shape"
      // While dragging, keep the move-cursor, even if the mouse is temporarily leaving polygon and gizmos
      if (this.moveTool.isDragging()) {
        return 'move';
      }

      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedVertex != -1 || this.draggedEdge != -1) {
        return 'move';
      }

      // Indicate: "Moving a ellipse-arc gizmo" to modify radius of an ellipse arc.
      if (this.ellipseArcGizmo.dragging) {
        return 'move';
      }

      // Indicate: "Click to insert new vertex"
      //
      // If we are holding down Ctrl and hover over an edge, clicking would insert a vertex.
      var ctrlHold = this.keyState[av.KeyCode.CONTROL];
      if (ctrlHold) {
        var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
        var edgeIndex = this.poly ? this.poly.findEdgeIndex(this.mousePos, precision) : -1;
        if (edgeIndex !== -1) {
          return 'copy';
        }
      }

      // Are we about to move a shape?
      var hitRadius = this.layer.getLineHitRadius(this.poly);
      var moveShape = this.poly.hitTest(p.x, p.y, hitRadius);
      if (moveShape) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }, { key: "clearTangentGizmos", value: function clearTangentGizmos()

    {
      this.tangentGizmos.forEach(function (g) {return g.dtor();});
      this.tangentGizmos.length = 0;
    } }, { key: "updateTangentGizmos", value: function updateTangentGizmos()

    {

      // Clear any previous gizmos (if any)
      this.clearTangentGizmos();

      if (!this.poly || !this.poly.isPath()) {
        return;
      }

      // We only show a tangent gizmo if it has relevance for the selected vertex or edge:
      // For a vertex v with neighbor edges prevEdge und nextEdge, we show a tangent gizmo if...
      //  - v, prevEdge, or nextEdge is selected
      //  - If an edge is selected, the selected edge is an arc
      //  - If v is selected, prevEdge or nextEdge is an arc
      for (var i = 0; i < this.poly.points.length; i++) {

        var vertexSelected = this.selectedVertex === i;

        // get prev/next edge. 
        var prevEdge = this.poly.edgeBeforeVertex(i);
        var nextEdge = this.poly.edgeAfterVertex(i);

        // edges may not exist at polyline ends
        var prevExists = prevEdge !== -1;
        var nextExists = nextEdge !== -1;

        // check if any neighbor edge is selected
        var prevSelected = prevExists && this.selectedEdge === prevEdge;
        var nextSelected = nextExists && this.selectedEdge === nextEdge;

        // check if any neighbor edge is an arc
        var prevIsArc = prevExists && this.poly.isBezierArc(prevEdge);
        var nextIsArc = nextExists && this.poly.isBezierArc(nextEdge);

        // If we just have a single line segment, always show the tangent gizmos
        var isSingleLine = this.isSingleLine();

        // Check if we selected an arc edge or a vertex of one
        var arcVertexSelected = vertexSelected && (prevIsArc || nextIsArc);
        var arcEdgeSelected = prevSelected && prevIsArc || nextSelected && nextIsArc;

        // show the gizmo if anything is selected and one of the edges is an arc
        var showTangents = isSingleLine || arcVertexSelected || arcEdgeSelected;
        if (showTangents) {
          this.tangentGizmos.push(new _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.poly, i, this.layer, this.gizmoLayer, this.gizmoManager));
        }
      }
    } }, { key: "updateEllipseArcGizmo", value: function updateEllipseArcGizmo()

    {
      var edgeSelected = this.selectedEdge !== -1;
      var showGizmo = edgeSelected && this.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"] && this.poly.isEllipseArc(this.selectedEdge);
      this.ellipseArcGizmo.setVisible(showGizmo);

      if (!showGizmo) {
        // Make sure that ellipseArcGizmo doesn't keep bound to an edge. Oterhwise, it may
        // cause an error later if that edge is removed.
        this.ellipseArcGizmo.detachFromEdge();
        return;
      }

      this.ellipseArcGizmo.attachToEdge(this.poly, this.selectedEdge);
    }

    // If any tangent gizmo is being dragged, it is returned.
    // Result is null if nothing is dragged.
  }, { key: "findDraggedTangentGizmo", value: function findDraggedTangentGizmo() {
      return this.tangentGizmos.find(function (gizmo) {return gizmo.isDragging();});
    }

    // Heuristic for choosing the tangent length when turning a line segment into an arc.
    // The basic idea here is
    //  - When turning all 4 lines of a square into arcs, we should get something that approximates a circle.
    //  - When generalizing that to more fancy cases, it should at least behave consistent and sort-of reasonable (e.g. always keep within a reasonable ratio to segment lengths)
    //
    // Note: It's probably cleaner to always approximate some sort of elliptical arcs for the general case. But that will make things a lot harder (and possibly slower).
    //       So let's get away with the linear-scale cheating for now.
  }, { key: "getVertexTangentLength", value: function getVertexTangentLength(prevLength, nextLength) {

      // Given a square of edge length sqrt(2), the circle passing through all 4 vertices can be
      // approximated by 4 cubic bezier arc segments. The tangents for these bezier arcs all have this length:
      // (See here: http://spencermortensen.com/articles/bezier-circle/)
      var c = 0.551915024494;

      // Scaling down the quad/beziers to a unit quad, we obtain the corresponding tangent lengths for a unit quad as:
      var unitQuadTangentLength = c / Math.SQRT2;

      // For a square of length l, the tangent length scales up accordingly.
      // For different segment lengths, we simply use the average of both lengths.
      var l = 0.5 * (prevLength + nextLength);

      return l * unitQuadTangentLength;
    }

    // Given a corner vertex p and its previous and next neighbor, this function computes an averaged tangent
    // vector that we use if (prev, p) and (p, next) are replaced by Bezier arcs.
  }, { key: "getVertexTangent", value: function getVertexTangent(prev, p, next) {

      // get tangent direction by averaging the edge directions.
      var tangent = new THREE.Vector2().copy(next).sub(prev).normalize();

      // Scale tangent direction
      var prevLength = p.distanceTo(prev);
      var nextLength = p.distanceTo(next);
      var tangentLength = this.getVertexTangentLength(prevLength, nextLength);

      return tangent.multiplyScalar(tangentLength);
    } }, { key: "changeEdgeToEllipse", value: function changeEdgeToEllipse(

    edgeIndex) {

      // By default, bend outsidde by half of the edge length. In this way, we get a circle centered
      // at the line-segment midpoint.
      var bendRadius = 0.5 * this.poly.getEdgeLength(edgeIndex);
      var arcParams = Object(_EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["getEllipseArcEdgeParams"])(this.poly, edgeIndex, bendRadius);
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, edgeIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, arcParams));

      this.layer.update();
      this.setSelectedEdge(edgeIndex);
    } }, { key: "changeEdgeToBezier", value: function changeEdgeToBezier(

    edgeIndex) {

      var path = this.poly;

      // get neighbor edges
      var prevEdgeIndex = path.prevEdgeIndex(edgeIndex);
      var nextEdgeIndex = path.nextEdgeIndex(edgeIndex);

      // check if neighbor edge exist (usually true unless at the end of a polyline)
      var prevExists = prevEdgeIndex !== -1;
      var nextExists = nextEdgeIndex !== -1;

      // get start/end position of the segment
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      path.getEdge(edgeIndex, a, b);

      // If previous/next edge exist, get their start/endVertex as well
      var prevEdgeA = prevExists && path.getPoint(prevEdgeIndex);
      var nextEdgeB = nextExists && path.getPoint(path.nextIndex(nextEdgeIndex));

      // If prev/nextEdge do not exist, we simply assume length and angle of the missing edge to be the same as the current edge.
      if (!prevExists) prevEdgeA = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(b, a);
      if (!nextExists) nextEdgeB = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(a, b);

      // Control points 0 and 3 are already given by edge a and b
      // Below, we have to determine cp1, cp2 to define the tangents
      var cp1 = null;
      var cp2 = null;

      // Check if previous and next edges are arcs as well
      var prevIsArc = prevExists && path.isBezierArc(prevEdgeIndex);
      var nextIsArc = nextExists && path.isBezierArc(nextEdgeIndex);

      // Determine control point for start tangent cp1
      if (prevIsArc) {
        // Previous edge is an arc: Get start tangent by mirroring the end tangent of that arc.
        var prevCp2 = path.getControlPoint(prevEdgeIndex, 2);
        cp1 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(prevCp2, a);
      } else {
        // Previous edge is a line: Use average direction of both segments to choose the new tangent
        cp1 = this.getVertexTangent(prevEdgeA, a, b).add(a);
      }

      // Analog for end tangent cp2
      if (nextIsArc) {
        // Next edge is an arc: Get end tangent by mirroring the start tangent of that arc.
        var nextCp1 = path.getControlPoint(nextEdgeIndex, 1);
        cp2 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(nextCp1, b);
      } else {
        // Next edge is a line: Use average direction of both segments to choose the new tangent
        // Note that we must pass the points in backward order for the end tangent.
        cp2 = this.getVertexTangent(nextEdgeB, b, a).add(b);
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, edgeIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier, cp1, cp2));

      this.layer.update();

      // select the edge so that you can edit its tangents
      this.setSelectedEdge(edgeIndex);
    } }, { key: "changeEdgeToLine", value: function changeEdgeToLine(

    edgeIndex) {
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, edgeIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line));
      this.layer.update();

      this.setSelectedEdge(edgeIndex);
    } }]);return PolygonEditTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonTool.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonTool.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _LineTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var Mode = {
  Polyline: 1,
  Polygon: 2 };


var PolygonToolName = "Edit2_PolygonTool";
var PolylineToolName = "Edit2_PolylineTool";

var av = Autodesk.Viewing;
var DefaultStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();var

PolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);

  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, PolygonTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonTool).call(this, ctx));

    // Delegate single-drag interactions: 
    _this.lineRectTool = mode === Mode.Polygon ?
    new _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx, style) : // PolygonMode: Draw rect/quad on drag
    new _LineTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx, style) // PolylineMode: Draw simple line on drag
    ;

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    // Circle shapes per vertex
    _this.vertexGizmos = [];

    // The polygon/polyline we are currently creating (if tool is active)
    _this.poly = undefined;

    // Style used for polygon creation
    _this.style = style;

    // Style used to display the thin line to connect last added vertex with current mouse position.        
    _this.edgePreviewStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineWidth: 2,
      isScreenSpace: true,
      lineStyle: 11 // dashed line
    });

    // whether editing Polylines or Polygons
    _this.mode = mode;

    // last canvas position where we added a vertex
    _this.lastClickX = undefined;
    _this.lastClickY = undefined;

    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;
    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;
    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];

    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos
    _this.fillGizmo = null;

    // OutlineGizmo: Polyline that connects all added vertices
    _this.outlineGizmo = null;

    // Line to connect last added vertex with mouse position
    _this.edgePreviewGizmo = null;

    // Last tracked mouse-pos in layer-coords (after considering snapping)
    _this.mousePos = new THREE.Vector2();

    // Label to display polygon area - hidden by default
    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["AreaLabel"](null, _this.gizmoLayer, _this.unitHandler, false);

    // Label to display polyline length
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeLabel"](_this.gizmoLayer, false);

    // If true, we always create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(PolygonTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(

    visible) {
      this.lengthLabel.setVisible(visible);
    }

    // If true, all new shapes are Paths instead of Polygons/Polylines.
  }, { key: "setArcsEnabled", value: function setArcsEnabled(enable) {
      this.enableArcs = enable;
      this.lineRectTool.enableArcs = enable;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonTool.prototype), "deactivate", this).call(this);
      this.cancelEdit();
    }

    // Returns true when editing a Polygon, false when editing a Polyline or nothing.
  }, { key: "isPolygon", value: function isPolygon() {
      return this.poly && this.poly.isPolygon();
    }

    /**
       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines
       * that appear during drawing. Style.isScreenSpace won't be considered.
       * @param {Style} style         - a Style instance
       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style
       */ }, { key: "setStyles", value: function setStyles(
    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {
        this.style.lineColor = style.lineColor;
      }
      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {
        this.style.lineAlpha = style.lineAlpha;
      }
      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {
        this.style.lineWidth = style.lineWidth;
        this.lineRectTool.style.lineWidth = style.lineWidth;
        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;
      }
      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {
        this.style.lineStyle = style.lineStyle;
        this.lineRectTool.style.lineStyle = style.lineStyle;
        // skip this.edgePreviewStyle.lineStyle
      }

      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {
        this.style.fillColor = style.fillColor;
      }
      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {
        this.style.fillAlpha = style.fillAlpha;
      }

      // skip isScreenSpace
    }

    // Initialize all gizmos when starting to edit a Polygon/Polyline
  }, { key: "initGizmos", value: function initGizmos() {

      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos
      if (this.isPolygon()) {
        this.fillGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        this.fillGizmo.style.lineAlpha = 0;
        this.gizmoLayer.addShape(this.fillGizmo);
      }

      // OutlineGizmo: Connect added vertices
      this.outlineGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      this.gizmoLayer.addShape(this.outlineGizmo);

      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.
      this.edgePreviewGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.edgePreviewStyle);
      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;
      this.gizmoLayer.addShape(this.edgePreviewGizmo);

      this.areaLabel.setShape(this.fillGizmo);

      // For Polylines, attach label to preview edge that displays the summed length
      if (this.poly && this.poly.isPolyline()) {
        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);
      }
    } }, { key: "clearGizmos", value: function clearGizmos()

    {
      if (this.fillGizmo) {
        this.gizmoLayer.removeShape(this.fillGizmo);
        this.fillGizmo = null;
      }

      this.areaLabel.setShape(null);
      this.lengthLabel.detachFromEdge();

      if (this.outlineGizmo) {
        this.gizmoLayer.removeShape(this.outlineGizmo);
        this.outlineGizmo = null;
      }

      if (this.edgePreviewGizmo) {
        this.gizmoLayer.removeShape(this.edgePreviewGizmo);
        this.edgePreviewGizmo = null;
      }

      // clear vertex gizmos
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    }

    // Update gizmos and snapping if polygon was modified
  }, { key: "polyModified", value: function polyModified() {
      this.updateGizmos();

      // Configure angle snapping to consider latest state of the polygon
      // Note that angleSnapper requires the shape including "vertex under mouse", while
      // this.poly only contains the already added/clicked vertices.
      // Note that we cannot use fillGizmo here, because it does not exist for polylines.
      var snapGeom = this.poly.clone();
      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);
      this.snapper.startAngleSnapping(snapGeom, this.poly.vertexCount);
    }

    // Update gizmos if vertices of current polygon/polyline have changed
  }, { key: "updateGizmos", value: function updateGizmos() {

      // FillGizmo: Show fill without outline for the polygon formed by all added
      // vertices + current mousePos
      if (this.fillGizmo) {
        // copy vertices of main polygon (not geom, not style)
        this.fillGizmo.clear();
        for (var i = 0; i < this.poly.vertexCount; i++) {
          var p = this.poly.getPoint(i);
          this.fillGizmo.addPoint(p.x, p.y);
        }
        // add additional point that traces mouse-pos
        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);
      }

      // OutlineGizmo: Solid polyline that connects all added vertices
      this.outlineGizmo.clear();
      if (this.poly.vertexCount >= 2) {
        for (var _i = 0; _i < this.poly.vertexCount; _i++) {
          var _p = this.poly.getPoint(_i);
          this.outlineGizmo.addPoint(_p.x, _p.y);
        }
      }

      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position
      this.edgePreviewGizmo.clear();
      if (this.poly.vertexCount >= 1) {
        var pLast = this.poly.getPoint(this.poly.vertexCount - 1);
        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);
        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);

        this.updateLengthLabel();
      }

      this.gizmoLayer.update();
    } }, { key: "updateLengthLabel", value: function updateLengthLabel()

    {
      // Compute resulting length of polyline including previewEdge
      if (this.poly && this.poly.isPolyline()) {
        // get transform from geometry coords to measure coordinate system
        var transform = this.unitHandler.measureTransform;

        var length = this.poly.getLength(transform) + this.edgePreviewGizmo.getLength(transform);
        var lengthStr = this.unitHandler.lengthToString(length);
        this.lengthLabel.setText(lengthStr);
      }
    } }, { key: "getName", value: function getName()

    {
      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleMouseMove", this).call(this, event);

      if (!event.buttons) {
        // When not dragging, we always return false here. Otherwise, the event will not propagated
        // to navigation tools, so that the zoom focus is not updated properly.
        this.onHover(event.canvasX, event.canvasY);
        return false;
      }
      return this.lineRectTool.handleMouseMove(event);
    } }, { key: "onHover", value: function onHover(

    canvasX, canvasY) {
      // Check if shape editing is already in progress
      if (!this.poly) {

        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.
        this.getSnapPosition(canvasX, canvasY);
        return;
      }

      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);

      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators
      var closingAllowed = this.poly.vertexCount >= 3;
      var startVertexHit = closingAllowed && this.gizmoManager.isUnderMouse(this.vertexGizmos[0]);
      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex
      if (startVertexHit) {
        // Remove snapping indicators
        this.snapper.clearSnappingGizmos();

        // snap position to vertex center
        pLayer.copy(this.vertexGizmos[0].layerPos);
      } else {
        // Standard case: If mouse is not on start vertex, allow standard snapping
        pLayer = this.getSnapPosition(canvasX, canvasY);
      }

      // track last mouse pos
      this.mousePos.copy(pLayer);

      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo
      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);
      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.vertexCount - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline
      this.gizmoLayer.update();
      this.updateLengthLabel();
    }

    // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.
  }, { key: "handleStartVertexClicked", value: function handleStartVertexClicked(event) {

      if (!this.poly && this.poly.vertexCount < 3) {
        return;
      }

      // For polylines, we have to repeat the first vertex to close it
      if (this.poly.isPolyline()) {
        var pStart = this.poly.getPoint(0);
        this.addVertex(pStart.x, pStart.y);
      }

      // Finish editing
      this.finishPolygon();

      // Make sure that the event is not passed on to ToolManager. Otherwise,
      // we would evaluate it a second time in handleSingleClick()
      event.stopPropagation();
    }

    // Add vertex on single-click
  }, { key: "handleSingleClick", value: function handleSingleClick(event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleSingleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      // Avoid duplicate vertices on double-clicks
      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {
        return true;
      }

      this.lastClickX = event.canvasX;
      this.lastClickY = event.canvasY;

      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));

      // Init polygon on first click
      if (!this.poly) {
        this.startPoly(this.mousePos.x, this.mousePos.y);
      }

      this.addVertex(this.mousePos.x, this.mousePos.y);
      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.
      if (this.ignoreDragging) {
        return false;
      }

      // If no clicks have been made so far, allow to drag line/rectangle.
      if (!this.poly) {
        // Clear the selection, this will make sure all other gizmos get removed
        this.selection.clear();

        return this.lineRectTool.handleButtonDown(event, button);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return this.lineRectTool.handleButtonUp(event, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleDoubleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      this.finishPolygon();
      return true;
    }

    // Start new polyline or polygon
  }, { key: "startPoly", value: function startPoly(x, y) {

      if (this.enableArcs) {
        // Arcs enabled: Always create Paths
        var isClosed = this.mode === Mode.Polygon;
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]([], isClosed, this.style.clone());
      } else {
        // No arcs enabled: Create Polygons or Polylines
        if (this.mode === Mode.Polygon) {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        } else {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
        }
      }

      this.initGizmos();
    } }, { key: "addVertex", value: function addVertex(

    x, y) {var _this2 = this;

      // add "next" point - which will follow the mouse motion 
      // until next click
      this.poly.addPoint(x, y);

      // add vertex-gizmo
      var name = 'PolygonTool_vertexGizmo_' + this.vertexGizmos.length;
      var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["VertexGizmo"](this.gizmoLayer, x, y, name);
      this.vertexGizmos.push(vertex);

      // For the start vertex-gizmo, we register a handler to finish the polygon when clicking it again
      var isStartVertex = this.vertexGizmos.length === 1;
      if (isStartVertex) {
        vertex.container.addEventListener('click', function (e) {return _this2.handleStartVertexClicked(e);});
      }

      this.polyModified();
    } }, { key: "removeLastVertex", value: function removeLastVertex()

    {
      if (!this.poly || !this.poly.vertexCount) {
        return;
      }

      // Cancel edit if there was only the starting point.
      if (this.poly.vertexCount <= 1) {
        this.cancelEdit();
        return;
      }

      this.poly.removePoint(this.poly.vertexCount - 1);

      // remove last added vertex gizmo
      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];
      lastGizmo.dtor();
      this.vertexGizmos.pop();

      this.polyModified();
    } }, { key: "finishPolygon", value: function finishPolygon()

    {

      // remove all vertex gizmos
      this.clearGizmos();

      // Stop snapping to edges of this polygon
      this.snapper.stopAngleSnapping();

      // move polygon to main layer
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].AddShape(this.layer, this.poly));

      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });

      // Start another polygon on next click
      this.poly = null;
    } }, { key: "cancelEdit", value: function cancelEdit()

    {

      if (this.lineRectTool.isDragging()) {
        this.lineRectTool.cancelDrag();
      }

      if (this.poly) {
        this.gizmoLayer.removeShape(this.poly);
        this.poly = null;
      }

      this.clearGizmos();
      this.snapper.stopAngleSnapping();
    } }, { key: "handleFinishKey", value: function handleFinishKey(

    event) {
      if (!this.poly) {
        return false;
      }

      // Avoid closing if it would result in a polygon that is degenerated to a line.
      if (this.isPolygon() && this.poly.vertexCount < 3) {
        return false;
      }

      this.finishPolygon();
      return true;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // delegate to rectTool
      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;

      // Map event to any known key in this.keyMap
      var funcKey = this.mapKey(event, this.keyMap);
      switch (funcKey) {
        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;
        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;
        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyUp", this).call(this, event, keyCode);
      this.lineRectTool.handleKeyUp(event, keyCode);
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.onHover(canvasX, canvasY);
    } }, { key: "mouseOnStartVertex", value: function mouseOnStartVertex()

    {
      if (!this.vertexGizmos[0]) {
        return false;
      }

      // Check if start vertex was clicked
      return this.gizmoManager(this.this.vertexGizmos[0]);
    } }, { key: "setStartVertexHighlighted", value: function setStartVertexHighlighted(

    enable) {
      if (this.vertexGizmos[0]) {
        this.vertexGizmos[0].setSelected(enable);
      }
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return PolygonTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


PolygonTool.POLYGON_ADDED = "polygonAdded";
PolygonTool.Mode = Mode;

/***/ }),

/***/ "./extensions/Edit2D/tools/RectangleTool.js":
/*!**************************************************!*\
  !*** ./extensions/Edit2D/tools/RectangleTool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ModifierMask.js */ "./extensions/Edit2D/ModifierMask.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}








var RectangleToolName = "Edit2_RectangleTool";

var av = Autodesk.Viewing;

// Creates rectangles by dragging
var RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);

  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, RectangleTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RectangleTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.style = style;

    // New polygon created by dragging
    _this.rect = null;

    // First corner of the new rectangle
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // Allow to enable/disable tool based on modifiers
    _this.modifiers = new _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(RectangleTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return RectangleToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Check if modifers allow starting an interaction
      if (!this.modifiers.accepts(event)) {
        return false;
      }

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return false;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      // Make sure that we consider latest mouse position
      this.handleMouseMove(event);

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.rect) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      var points = [startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.rect = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"](points, style);

      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.rect);
    } }, { key: "updateRect", value: function updateRect(

    forceQuad) {

      if (!this.isDragging()) {
        return;
      }

      var p0 = this.startPoint;
      var p1 = this.endPoint;

      if (forceQuad) {

        // Use maximum of dx/dy as edge length
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));

        // Consider drag direction to span quad right/left resp. up/down
        var sx = Math.sign(dx);
        var sy = Math.sign(dy);

        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);
        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);
        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);

      } else {
        this.rect.updatePoint(1, p1.x, p0.y);
        this.rect.updatePoint(2, p1.x, p1.y);
        this.rect.updatePoint(3, p0.x, p1.y);
      }

      this.gizmoLayer.update();

      this.areaLabel.setShape(this.rect);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateRect(forceQuad);
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.rect) {
        return false;
      }

      // Check if rect is valid
      var dx = this.endPoint.x - this.startPoint.x;
      var dy = this.endPoint.y - this.startPoint.y;
      var Eps = 1.e-10;
      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;

      // Move shape to main layer (or just remove if invalid)
      this.gizmoLayer.removeShape(this.rect);
      if (rectValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.rect));
      }

      this.rect = null;

      this.areaLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.rect) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.rect);
        this.rect = null;

        this.dragCanceled = true;

        this.areaLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.rect);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(false);
      }
    } }]);return RectangleTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/UndoTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/UndoTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolname = 'Edit2_UndoTool';

var av = Autodesk.Viewing;

// Simple tool that triggers undo/redo on ctrl-z/ctrl-shift-z
var UndoTool = /*#__PURE__*/function () {

  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);
    this.undoStack = undoStack;
  }_createClass(UndoTool, [{ key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      if (keyCode !== av.KeyCode.z || !event.ctrlKey) {
        return false;
      }

      if (event.shiftKey) {
        this.undoStack.redo();
      } else {
        this.undoStack.undo();
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return UndoToolname;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return UndoTool;}();
;

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".adsk-viewing-viewer .edge-gizmo:hover {\n  background-color: lime; }\n\n.adsk-viewing-viewer .edge-gizmo {\n  position: absolute;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  cursor: move;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edge-gizmo.selected {\n  background-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover {\n  border-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 7px;\n  height: 7px;\n  left: -2px;\n  top: -2px;\n  background-color: #009bff;\n  border-style: solid;\n  border-width: 2px;\n  border-color: #FFFFFF;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  cursor: move; }\n\n.adsk-viewing-viewer .ellipse-arc-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 5px;\n  height: 5px;\n  left: -1px;\n  top: -1px;\n  background-color: #ff00ff;\n  border-style: solid;\n  border-width: 1px;\n  border-color: #000000;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 2;\n  /* Must always be in front of the EdgeMove gizmo. Otherwise it would become unreachable on low radii.*/\n  cursor: move; }\n\n.adsk-viewing-viewer .vertex-gizmo.selected {\n  border-color: lime; }\n\n.adsk-viewing-viewer .edge-move-gizmo {\n  width: 20px;\n  /* width along the edge */\n  height: 6px;\n  /* height vertical to the edge */ }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Edit2D.js.map