/*!
 * LMV v7.17.1
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.MaterialConverterPrism=function(e){var n={};function o(a){if(n[a])return n[a].exports;var t=n[a]={i:a,l:!1,exports:{}};return e[a].call(t.exports,t,t.exports,o),t.l=!0,t.exports}return o.m=e,o.c=n,o.d=function(e,n,a){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:a})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(o.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var t in e)o.d(a,t,function(n){return e[n]}.bind(null,t));return a},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s=583)}({0:function(e,n){e.exports=THREE},11:function(e,n,o){"use strict";o.d(n,"a",(function(){return Me}));var a=o(0),t=o(17),r=o.n(t),i=o(18),l=o.n(i),s=o(19),f=o.n(s),d=o(20),c=o.n(d),u=o(21),_=o.n(u),p=o(22),m=o.n(p),v=o(23),g=o.n(v),h=o(24),y=o.n(h),w=o(25),x=o.n(w),T=o(26),R=o.n(T),E=o(27),M=o.n(E),b=o(28),A=o.n(b),S=o(29),N=o.n(S),I=o(30),P=o.n(I),D=o(31),V=o.n(D),L=o(32),H=o.n(L),C=o(33),O=o.n(C),z=o(34),U=o.n(z),F=o(35),G=o.n(F),W=o(36),B=o.n(W),q=o(37),k=o.n(q),j=o(38),X=o.n(j),Y=o(39),Z=o.n(Y),Q=o(40),K=o.n(Q),J=o(41),$=o.n(J),ee=o(42),ne=o.n(ee),oe=o(43),ae=o.n(oe),te=o(44),re=o.n(te),ie=o(45),le=o.n(ie),se=o(46),fe=o.n(se),de=o(47),ce=o.n(de),ue={cutplanes:{type:"v4v",value:[]},hatchParams:{type:"v2",value:new a.Vector2(1,10)},hatchTintColor:{type:"c",value:new a.Color(16777215)},hatchTintIntensity:{type:"f",value:1}},_e={dbId:{type:"v3",value:new a.Vector3(0,0,0)},modelId:{type:"v3",value:new a.Vector3(0,0,0)}},pe={themingColor:{type:"v4",value:new a.Vector4(0,0,0,0)}},me={shadowESMConstant:{type:"f",value:0}},ve=a.UniformsUtils.merge([{shadowMap:{type:"t",value:null},shadowMapSize:{type:"v2",value:new a.Vector2(0,0)},shadowBias:{type:"f",value:0},shadowDarkness:{type:"f",value:0},shadowMatrix:{type:"m4",value:new a.Matrix4},shadowLightDir:{type:"v3",value:new a.Vector3}},me]),ge={view_size:{type:"v2",value:new a.Vector2(640,480)}},he={tDepth:{type:"t",value:null},projInfo:{type:"v4",value:new a.Vector4},isOrtho:{type:"f",value:0},worldMatrix_mainPass:{type:"m4",value:new a.Matrix4}},ye={};for(var we in a.ShaderChunk)ye[we]=a.ShaderChunk[we];ye.pack_depth=r.a,ye.depth_texture=l.a,ye.tonemap=f.a,ye.ordered_dither=c.a,ye.cutplanes=_.a,ye.pack_normals=m.a,ye.hatch_pattern=g.a,ye.env_sample=y.a,ye.id_decl_vert=x.a,ye.id_vert=R.a,ye.id_decl_frag=M.a,ye.id_frag=A.a,ye.final_frag=N.a,ye.theming_decl_frag=P.a,ye.theming_frag=V.a,ye.instancing_decl_vert=H.a,ye.shadowmap_decl_common=O.a,ye.shadowmap_decl_vert=U.a,ye.shadowmap_vert=G.a,ye.shadowmap_decl_frag=B.a,ye.float3_average=k.a,ye.line_decl_common=X.a,ye.prism_wood=Z.a,ye.prism_glazing=K.a,ye.prism_transparency=$.a,ye.normal_map=ne.a,ye.decl_point_size=ae.a,ye.point_size=re.a,ye.wide_lines_decl=le.a,ye.wide_lines_vert=fe.a,ye.hsv=ce.a;var xe={};function Te(e,n,o,a){var t=o?"_v3":"",r=o?"vec3 ":"",i=o?n+" = average("+n+t+");":"",l=a?n+t+" = SRGBToLinear("+n+t+");":"";return["#if defined( USE_"+e.toUpperCase()+"_MAP )","vec2 uv_"+e+"_map = ("+e+"_map_texMatrix * vec3(uv, 1.0)).xy;",e.toUpperCase()+"_CLAMP_TEST;",r+n+t+" = texture2D("+e+"_map, uv_"+e+"_map).xyz;",l,"if("+e+"_map_invert) "+n+t+" = vec3(1.0) - "+n+t+";",i,"#else",n+" = "+e+";","#endif"].join("\n")}function Re(e){var n=e+"_texMatrix",o=e+"_invert";return["#if defined( "+("USE_"+e).toUpperCase()+" )","uniform sampler2D "+e+";","uniform mat3 "+n+";","uniform bool "+o+";","#endif"].join("\n")}xe.prism_check=function(e){return["#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )","#define "+e,"#endif"].join("\n")},xe.prism_sample_texture=function(e,n,o,a){return Te(e,n,"true"===o,"true"===a)},xe.prism_uniforms=Re,xe.prism_bump_uniforms=function(e){var n=e+"_texMatrix",o=e+"_bumpScale",a=e+"_bumpmapType";return["#if defined( "+("USE_"+e).toUpperCase()+" )","uniform sampler2D "+e+";","uniform mat3 "+n+";","uniform vec2 "+o+";","uniform int "+a+";","#endif"].join("\n")};var Ee={};for(we in xe)Ee[we]=new RegExp("#"+we+" *<([\\w\\d., ]*)>","g");var Me={IdUniforms:_e,ThemingUniform:pe,CutPlanesUniforms:ue,ShadowMapCommonUniforms:me,ShadowMapUniforms:ve,PointSizeUniforms:{point_size:{type:"f",value:1}},WideLinesUniforms:ge,DepthTextureUniforms:he,PackDepthShaderChunk:ye.pack_depth,TonemapShaderChunk:ye.tonemap,OrderedDitheringShaderChunk:ye.ordered_dither,CutPlanesShaderChunk:ye.cutplanes,PackNormalsShaderChunk:ye.pack_normals,HatchPatternShaderChunk:ye.hatch_pattern,EnvSamplingShaderChunk:ye.env_sample,IdVertexDeclaration:ye.id_decl_vert,IdVertexShaderChunk:ye.id_vert,IdFragmentDeclaration:ye.id_decl_frag,IdOutputShaderChunk:ye.id_frag,FinalOutputShaderChunk:ye.final_frag,ThemingFragmentDeclaration:ye.theming_decl_frag,ThemingFragmentShaderChunk:ye.theming_frag,InstancingVertexDeclaration:ye.instancing_decl_vert,ShadowMapDeclareCommonUniforms:ye.shadowmap_decl_common,ShadowMapVertexDeclaration:ye.shadowmap_decl_vert,ShadowMapVertexShaderChunk:ye.shadowmap_vert,ShadowMapFragmentDeclaration:ye.shadowmap_decl_frag,PointSizeDeclaration:ye.decl_point_size,PointSizeShaderChunk:ye.point_size,GetPrismMapSampleChunk:Te,GetPrismMapUniformChunk:Re,resolve:function e(n){for(var o in xe){var a=Ee[o];n=n.replace(a,(function(e,n){var a=n.split(",").map((function(e){return e.trim()}));return xe[o].apply(null,a)}))}return n.replace(/#include *<([\w\d.]+)>/g,(function(n,o){if(!ye[o])throw new Error("Cannot resolve #include<"+o+">");return e(ye[o])}))}}},16:function(e,n,o){"use strict";o.d(n,"a",(function(){return t}));var a=o(0),t=function(e){var n={vertexShader:e.vertexShader,fragmentShader:e.fragmentShader};return e.uniforms&&(n.uniforms=a.UniformsUtils.clone(e.uniforms)),e.defines&&(n.defines=Object.assign({},e.defines)),e.extensions&&(n.extensions=Object.assign({},e.extensions)),e.attributes&&(n.attributes=e.attributes),new a.ShaderMaterial(n)}},17:function(e,n){e.exports="\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n"},18:function(e,n){e.exports="\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n"},19:function(e,n){e.exports="\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n"},20:function(e,n){e.exports="vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n"},21:function(e,n){e.exports="#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n"},22:function(e,n){e.exports="\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n"},23:function(e,n){e.exports="#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n"},24:function(e,n){e.exports="\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n"},25:function(e,n){e.exports="#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n"},26:function(e,n){e.exports="\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n"},27:function(e,n){e.exports="#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\n    varying highp float depth;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n    #ifdef USE_VERTEX_ID\n        varying vec3 vId;\n    #elif defined(LINE_2D_SHADER)\n        varying vec4 dbId;\n    #else\n        uniform vec3 dbId;\n    #endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\n    uniform vec3 modelId;\n#endif\n#ifdef _LMVWEBGL2_\n    #if defined(MRT_NORMALS)\n        layout(location = 1) out vec4 outNormal;\n        #if defined(MRT_ID_BUFFER)\n            layout(location = 2) out vec4 outId;\n            #if defined(MODEL_COLOR)\n                layout(location = 3) out vec4 outModelId;\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        layout(location = 1) out vec4 outId;\n        #if defined(MODEL_COLOR)\n            layout(location = 2) out vec4 outModelId;\n        #endif\n    #endif\n#else\n    #define gl_FragColor gl_FragData[0]\n    #if defined(MRT_NORMALS)\n        #define outNormal gl_FragData[1]\n        #if defined(MRT_ID_BUFFER)\n            #define outId gl_FragData[2]\n            #if defined(MODEL_COLOR)\n                #define outModelId gl_FragData[3]\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        #define outId gl_FragData[1]\n        #if defined(MODEL_COLOR)\n            #define outModelId gl_FragData[2]\n        #endif\n    #endif\n#endif"},28:function(e,n){e.exports="\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\n    vec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n    #ifndef ENABLE_ID_DISCARD\n        const float writeId = 1.0;\n    #endif\n    outId = vec4(dbId.rgb, writeId);\n    #ifdef MODEL_COLOR\n        outModelId = vec4(modelId.rgb, writeId);\n    #endif\n#elif defined(ID_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n"},29:function(e,n){e.exports="#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#ifdef MRT_NORMALS\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n"},30:function(e,n){e.exports="uniform vec4 themingColor;\n"},307:function(e,n){e.exports="varying vec3 vViewPosition;\nvarying vec3 vNormal;\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#if defined(PRISMWOODBUMP)\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#prism_check<USE_MAP>\n#if defined(USE_MAP) || defined(USE_TILING)\nvarying vec2 vUv;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif\n#include<pack_normals>\n#include<instancing_decl_vert>\n#include<id_decl_vert>\n#include<shadowmap_decl_vert>\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\n#endif\nvoid main() {\n#if defined(USE_MAP) || defined(USE_TILING)\n    vUv = uv;\n#endif\n#ifdef UNPACK_NORMALS\n    vec3 objectNormal = decodeNormal(normal);\n#else\n    vec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n    objectNormal = getInstanceNormal(objectNormal);\n    vec3 instPos = getInstancePos(position);\n#if defined(PRISMWOOD) && !defined(NO_UVW)\n#if defined(PRISMWOODBUMP)\n    vUvw = instPos;\n    vtNormal = normalize(objectNormal);\n    mNormalMatrix = normalMatrix;\n#else\n    vUvw = uvw;\n#endif\n#endif\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    vNormal = normalize( transformedNormal );\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\n    vec3 Tu, Tv;\n#if defined(PRISMWOODBUMP)\n    ComputeTangents(vtNormal, Tu, Tv);\n#else\n    ComputeTangents(vNormal, Tu, Tv);\n#endif\n    vTangent = Tu;\n    vBitangent = Tv;\n#endif\n#ifdef MRT_NORMALS\n    depth = mvPosition.z;\n#endif\n#include<id_vert>\n#include<shadowmap_vert>\n}\n"},308:function(e,n){e.exports="\n#include<common>\n#define RECIPROCAL_PI 0.318309886\n#define ONE 0.00390625\nuniform float opacity;\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform sampler2D importantSamplingRandomMap;\nuniform sampler2D importantSamplingSolidAngleMap;\n#if defined( PRISMOPAQUE )\nuniform vec3 opaque_albedo;\nuniform float opaque_f0;\nuniform vec3 opaque_luminance_modifier;\nuniform float opaque_luminance;\n#elif defined( PRISMMETAL )\nuniform vec3 metal_f0;\n#elif defined( PRISMLAYERED )\nuniform float layered_f0;\nuniform vec3 layered_diffuse;\nuniform float layered_fraction;\nuniform vec3 layered_bottom_f0;\nuniform float layered_roughness;\nuniform float layered_anisotropy;\nuniform float layered_rotation;\n#elif defined( PRISMTRANSPARENT )\nuniform float transparent_ior;\nuniform vec3 transparent_color;\nuniform float transparent_distance;\n#elif defined( PRISMGLAZING )\nuniform vec3 glazing_f0;\nuniform vec3 glazing_transmission_color;\nuniform float glazing_transmission_roughness;\n#elif defined( PRISMWOOD )\nuniform bool wood_fiber_cosine_enable;\nuniform int wood_fiber_cosine_bands;\nuniform vec4 wood_fiber_cosine_weights;\nuniform vec4 wood_fiber_cosine_frequencies;\nuniform bool wood_fiber_perlin_enable;\nuniform int wood_fiber_perlin_bands;\nuniform vec4 wood_fiber_perlin_weights;\nuniform vec4 wood_fiber_perlin_frequencies;\nuniform float wood_fiber_perlin_scale_z;\nuniform bool wood_growth_perlin_enable;\nuniform int wood_growth_perlin_bands;\nuniform vec4 wood_growth_perlin_weights;\nuniform vec4 wood_growth_perlin_frequencies;\nuniform float wood_latewood_ratio;\nuniform float wood_earlywood_sharpness;\nuniform float wood_latewood_sharpness;\nuniform float wood_ring_thickness;\nuniform bool wood_earlycolor_perlin_enable;\nuniform int wood_earlycolor_perlin_bands;\nuniform vec4 wood_earlycolor_perlin_weights;\nuniform vec4 wood_earlycolor_perlin_frequencies;\nuniform vec3 wood_early_color;\nuniform bool wood_use_manual_late_color;\nuniform vec3 wood_manual_late_color;\nuniform bool wood_latecolor_perlin_enable;\nuniform int wood_latecolor_perlin_bands;\nuniform vec4 wood_latecolor_perlin_weights;\nuniform vec4 wood_latecolor_perlin_frequencies;\nuniform float wood_late_color_power;\nuniform bool wood_diffuse_perlin_enable;\nuniform int wood_diffuse_perlin_bands;\nuniform vec4 wood_diffuse_perlin_weights;\nuniform vec4 wood_diffuse_perlin_frequencies;\nuniform float wood_diffuse_perlin_scale_z;\nuniform bool wood_use_pores;\nuniform int wood_pore_type;\nuniform float wood_pore_radius;\nuniform float wood_pore_cell_dim;\nuniform float wood_pore_color_power;\nuniform float wood_pore_depth;\nuniform bool wood_use_rays;\nuniform float wood_ray_color_power;\nuniform float wood_ray_seg_length_z;\nuniform float wood_ray_num_slices;\nuniform float wood_ray_ellipse_z2x;\nuniform float wood_ray_ellipse_radius_x;\nuniform bool wood_use_latewood_bump;\nuniform float wood_latewood_bump_depth;\nuniform bool wood_use_groove_roughness;\nuniform float wood_groove_roughness;\nuniform float wood_diffuse_lobe_weight;\nuniform sampler2D permutationMap;\nuniform sampler2D gradientMap;\nuniform sampler2D perm2DMap;\nuniform sampler2D permGradMap;\nuniform vec4 wood_ring_fraction;\nuniform vec2 wood_fall_rise;\n#endif\n#ifdef USE_TILING\nuniform mat4 tilingOverallTransform;\nuniform sampler2D TilingMap;\nuniform mat3 TilingMap_texMatrix;\nuniform vec4 uv2tile;\nuniform vec4 tile2uv;\nuniform vec2 tileAlignOffset;\nuniform mat4 tilingUVTransform;\n#ifdef USE_TILING_NORMAL\nuniform sampler2D TilingNormalMap;\nuniform mat3 TilingNormalMap_texMatrix;\n#endif\n#ifdef USE_TILING_RANDOM\nuniform sampler2D TilingRandomMap;\nuniform mat3 TilingRandomMap_texMatrix;\nuniform vec2 tilingRandomAxisS;\nuniform vec2 tilingRandomAxisT;\nuniform vec2 tilingRandomAlignmentOffset;\n#endif\n#endif\nuniform float envExponentMin;\nuniform float envExponentMax;\nuniform float envExponentCount;\n#include<env_sample>\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include<tonemap>\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<id_decl_frag>\n#include<theming_decl_frag>\n#include<shadowmap_decl_frag>\n#ifdef USE_FOG\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#prism_check<USE_MAP>\n#if defined(USE_MAP) || defined(USE_TILING)\nvarying vec2 vUv;\n#endif\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#endif\n#prism_uniforms<surface_albedo_map>\n#prism_uniforms<surface_roughness_map>\n#prism_uniforms<surface_cutout_map>\n#prism_uniforms<surface_anisotropy_map>\n#prism_uniforms<surface_rotation_map>\n#prism_uniforms<opaque_albedo_map>\n#prism_uniforms<opaque_f0_map>\n#prism_uniforms<opaque_luminance_modifier_map>\n#prism_uniforms<layered_bottom_f0_map>\n#prism_uniforms<layered_f0_map>\n#prism_uniforms<layered_diffuse_map>\n#prism_uniforms<layered_fraction_map>\n#prism_uniforms<layered_roughness_map>\n#prism_uniforms<layered_anisotropy_map>\n#prism_uniforms<layered_rotation_map>\n#prism_uniforms<metal_f0_map>\n#prism_uniforms<glazing_f0_map>\n#prism_uniforms<glazing_transmission_roughness_map>\n#prism_uniforms<glazing_transmission_color_map>\n#prism_uniforms<wood_curly_distortion_map>\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nuniform bool wood_curly_distortion_enable;\nuniform float wood_curly_distortion_scale;\n#endif\n#prism_bump_uniforms<surface_normal_map>\n#prism_bump_uniforms<layered_normal_map>\nfloat SRGBToLinearComponent(float color) {\n    float result = color;\n    if (result<=0.04045)\n        result *= 0.07739938;\n    else\n        result = pow(abs((result+0.055)*0.947867298), 2.4);\n    return result;\n}\nvec3 SRGBToLinear(vec3 color) {\n    vec3 result = color;\n    result.x = SRGBToLinearComponent(result.x);\n    result.y = SRGBToLinearComponent(result.y);\n    result.z = SRGBToLinearComponent(result.z);\n    return result;\n}\n#if defined( USE_ENVMAP )\nuniform float envMapExposure;\nuniform samplerCube envMap;\n#endif\n#include<normal_map>\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#if defined( PRISMWOODBUMP )\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if defined( USE_ENVMAP )\nvec3 sampleReflection(vec3 N, vec3 V, float mipIndex) {\n    vec3 dir = (2.0 * dot(V, N)) * N - V;\n    dir = adjustLookupVector(mat3(viewMatrixInverse) * dir);\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return RGBMDecode(envTexColor, envMapExposure);\n#else\n    vec4 envTexColor = textureCube( envMap, dir );\n    vec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\n    cubeColor *= cubeColor;\n#endif\n    return cubeColor;\n#endif\n}\n#endif\n#include<hatch_pattern>\n#if defined( USE_ENVMAP ) && defined( USE_IRRADIANCEMAP )\nuniform samplerCube irradianceMap;\nvec3 sampleNormal(vec3 normal) {\n    vec3 worldNormal = mat3(viewMatrixInverse) * normal;\n    vec3 irradiance = sampleIrradianceMap(worldNormal, irradianceMap, envMapExposure);\n    irradiance = applyEnvShadow(irradiance, worldNormal);\n    return irradiance;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\nfloat sqr(float x) {return x*x;}\nfloat aSqrd(float maxAlphaSqr, float cosTheta)\n{\n    if (abs(cosTheta) < 1e-10)\n    {\n        return 1e10;\n    }\n    float tan2 = 1.0/sqr(cosTheta) - 1.0;\n    return maxAlphaSqr * tan2;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 Fresnel_Rough(vec3 f0, float cosAngle, float alpha)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\nfloat IORToReflectance(float ior)\n{\n    return sqr((1.0 - ior)/(1.0 + ior));\n}\nvec2 RoughnessToAlpha(float roughness, float anisotropy)\n{\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nfloat AlphaToPhong(float alpha)\n{\n    return max(0.0, 2.56/alpha - 7.0);\n}\nfloat ExponentToReflMipIndex(float exponent)\n{\n    float targetLog = log2(exponent);\n    float minLog = log2(envExponentMin);\n    float maxLog = log2(envExponentMax);\n    float deltaLog = clamp(targetLog - minLog, 0.0, maxLog - minLog);\n    float level = clamp((1.0-(deltaLog + 0.5) / envExponentCount), 0.0, 1.0) * 6.0;\n    return level;\n}\n#include<prism_wood>\n#if defined( ENABLEIMPORTANTSAMPLING ) && (defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ))\n#define IMPORTANTSAMPLING\n#endif\n#if defined( IMPORTANTSAMPLING )\n#define SAMPLECOUNT 32\nvec2 Hammersley(int index)\n{\n    float u = (float(index) + 0.5) / 32.0;\n    float v = 0.5;\n    float noise = texture2D(importantSamplingRandomMap, vec2(u, v), 0.0).r;\n   return vec2(2.0 * PI * float(index/SAMPLECOUNT), noise);\n}\nvec3 ImportanceSampleAnisotropicGGX(int index, vec2 alpha, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec2 uniformSample2D = Hammersley(index);\n    float coef = sqrt(uniformSample2D.y / (1.0 - uniformSample2D.y));\n    float sinSigma, cosSigma;\n    sinSigma = sin(uniformSample2D.x);\n    cosSigma = cos(uniformSample2D.x);\n    vec3 H = coef * ((alpha.x * cosSigma) * Tu + (alpha.y * sinSigma) * Tv) + N;\n    H = normalize(H);\n    return H;\n}\nfloat ComputePDF(vec2 alpha, float NdotH, float HdotTu, float HdotTv, float VdotH)\n{\n    float factor1 = HdotTu / alpha.x;\n    float factor2 = HdotTv / alpha.y;\n    float factor3 = factor1 * factor1 + factor2 * factor2 + NdotH * NdotH;\n    float factor = factor3 * factor3 * alpha.x * alpha.y * VdotH * 4.0 * PI;\n    if (factor > 0.0)\n    {\n        return (NdotH / factor);\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n#define INVFACESIZE 0.0078125\nfloat DirectionToSolidAngle(vec3 dir)\n{\n    dir = abs(dir);\n    float first = min(dir.x, dir.y);\n    float temp = max(dir.x, dir.y);\n    float second = min(temp, dir.z);\n    float third = max(temp, dir.z);\n    first /= third;\n    second /= third;\n    float u = (first+1.0)/2.0;\n    float v = (second + 1.0) / 2.0;\n    float solidAngle = texture2D(importantSamplingSolidAngleMap, vec2(u, v), 0.0).r * 0.000255;\n    return solidAngle;\n}\nfloat Smith_GGX(float value)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + value));\n}\nvec2 RoughnessAnisotropyToAlpha(float roughness, float anisotropy)\n{\n    float aspect = sqrt(1.0 - 0.9 * anisotropy);\n    vec2 alpha = vec2(roughness * roughness / aspect, roughness * roughness * aspect);\n    return alpha;\n}\nvec3 ImportanceSamplingSpecular(float angle, vec3 reflectance, float roughness, float anisotropy, vec3 V, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec3 specular = vec3(0.0);\n    float radAngle;\n    if (anisotropy < 1e-10)\n    {\n        radAngle = 0.0;\n    }\n    else\n    {\n        radAngle = -PI * angle;\n    }\n    vec2 alpha = RoughnessAnisotropyToAlpha(roughness, anisotropy);\n    float alpha2 = max(alpha.x * alpha.x, alpha.y * alpha.y);\n    float NdotV = dot(N, V);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    vec2 sincosTheta;\n    sincosTheta.x = sin(radAngle);\n    sincosTheta.y = cos(radAngle);\n    vec3 Tu1, Tv1;\n    Tu1 = sincosTheta.y * Tu - sincosTheta.x * Tv;\n    Tv1 = sincosTheta.x * Tu + sincosTheta.y * Tv;\n    vec3 H;\n    vec3 sampleLightIntensity;\n    vec3 L;\n    float effectiveSample = 0.0;\n    for (int i = 0; i < SAMPLECOUNT; i++)\n    {\n        H = ImportanceSampleAnisotropicGGX(i, alpha, N, Tu1, Tv1);\n        float VdotH = dot(V, H);\n        L = 2.0 * VdotH * H - V;\n        float NdotH = dot(N, H);\n        float NdotL = dot(N, L);\n        if (NdotL >= 0.0 && NdotV > 0.0 && NdotH > 0.0)\n        {\n            float alpha2NL = aSqrd(alpha2, NdotL);\n            float HdotTu = dot(H, Tu1);\n            float HdotTv = dot(H, Tv1);\n            float pdf = ComputePDF(alpha, NdotH, HdotTu, HdotTv, VdotH);\n            float mipmapLevel = 0.0;\n            if (pdf > 0.0)\n            {\n                mipmapLevel = 0.3 * log2(1.0 / (float(SAMPLECOUNT) * pdf * DirectionToSolidAngle(L)));\n            }\n            mipmapLevel = clamp(mipmapLevel, 0.0, 4.0);\n            L = normalize(L);\n            sampleLightIntensity = sampleReflection(L, L, mipmapLevel).rgb;\n            float G = Smith_GGX(alpha2NL) * Smith_GGX(alpha2NV);\n            vec3 F = Fresnel_Schlick(reflectance, VdotH);\n            float factor = G * VdotH / (NdotH * NdotV);\n            if (factor >= 0.0)\n            {\n                specular += abs(sampleLightIntensity * F * factor);\n                effectiveSample += 1.0;\n            }\n        }\n    }\n    if (effectiveSample > 0.0)\n    {\n        specular /= effectiveSample;\n    }\n    return specular;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 DiffuseLobe(vec3 diffuseColor)\n{\n    return diffuseColor * RECIPROCAL_PI;\n}\nvec3 Rotate(vec3 vec, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal)\n{\n    float nx2 = sqr(normal.x);\n    float ny2 = sqr(normal.y);\n    float nz2 = sqr(normal.z);\n    float scale = 1.0/(alphaU * alphaV * PI);\n    return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\n        vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        float roughness, float anisotropy, float rotation, vec3 reflectance)\n{\n    vec2 alpha = RoughnessToAlpha(roughness, anisotropy);\n    Hlocal = Rotate(Hlocal, rotation);\n    vec3 F = Fresnel_Schlick(reflectance, VdotH);\n    float D = NDF_GGX(alpha.x, alpha.y, Hlocal);\n    float alpha2 = max(sqr(alpha.x), sqr(alpha.y));\n    float alpha2NL = aSqrd(alpha2, NdotL);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\n    return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\n#if defined( PRISMOPAQUE )\nvec3 BRDF_Opaque(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        float opaqueF0, vec3 opaqueAlbedo)\n{\n    vec3 diffuse = DiffuseLobe(opaqueAlbedo);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, vec3(opaqueF0));\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMMETAL )\nvec3 BRDF_Metal(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        vec3 metalF0)\n{\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0);\n    return specular*NdotL;\n}\n#elif defined( PRISMLAYERED )\nvec3 BRDF_Layered(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 Hlocal2, float N2dotL, float N2dotH, float N2dotV,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,\n        float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 Fl = Fresnel_Schlick(vec3(layeredF0), NdotL);\n    vec3 Fv = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    vec3 amount = (1.0 - Fl) * (1.0 - Fv);\n    vec3 topSpecular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n            vec3(layeredF0));\n    vec3 topDiffuse = DiffuseLobe(layeredDiffuse);\n    vec3 botSpecular = MicrofacetLobe(\n            Hlocal2, N2dotL, N2dotH, N2dotV, VdotH,\n            layeredRoughness, layeredAnisotropy, layeredRotation,\n            bottom_f0);\n    return topSpecular*NdotL + amount * mix(topDiffuse*NdotL, botSpecular*N2dotL, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 BRDF_Transparent(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, reflectance);\n    return specular*NdotL;\n}\n#elif defined( PRISMGLAZING )\nvec3 BRDF_Glazing(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        vec3 glazingF0, vec3 glazingTransmissionColor, float glazingIlluminance)\n{\n    vec3 diffuse = DiffuseLobe(glazingTransmissionColor - vec3(glazingIlluminance, glazingIlluminance, glazingIlluminance));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, glazingF0);\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMWOOD )\nvec3 BRDF_Wood(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse)\n{\n    vec3 diffuse = DiffuseLobe(woodDiffuse);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, 0.0, 0.0, vec3(0.04));\n    return (specular+diffuse)*NdotL;\n}\n#endif\n#endif\n#if defined( USE_ENVMAP )\n#if defined( PRISMOPAQUE )\nvec3 Environment_Opaque(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float opaqueF0, vec3 opaqueAlbedo, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 T)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(opaqueF0), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(opaqueF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F* surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;\n    return diffuse + specular;\n}\n#elif defined( PRISMMETAL )\nvec3 Environment_Metal(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 metalF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, metalF0, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 F = Fresnel_Rough(metalF0, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n    return specular;\n}\n#elif defined( PRISMLAYERED )\nvec3 Environment_Layered(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float layeredF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv, vec3 layeredDiffuse, float layeredRoughness,\n        float layeredAnisotropy, float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 F = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n#if defined( IMPORTANTSAMPLING )\n    vec3 topSpecular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(layeredF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 topSpecular = F * surfaceAlbedo * envSpecular;\n#endif\n    vec3 amount = (1.0 - F);\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 topDiffuse = layeredDiffuse * envIrradiance;\n#if defined( IMPORTANTSAMPLING )\n    vec3 botSpecular = ImportanceSamplingSpecular(layeredRotation, bottom_f0, layeredRoughness, layeredAnisotropy, V, N2, Tu, Tv);\n#else\n    alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;\n    exponent = AlphaToPhong(alpha);\n    reflMipIndex = ExponentToReflMipIndex(exponent);\n    envSpecular = sampleReflection(N2, V, reflMipIndex);\n    F = Fresnel_Rough(bottom_f0, N2dotV, alpha);\n    vec3 botSpecular = F * envSpecular;\n#endif\n    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 Environment_Transparent(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(reflectance, NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, reflectance, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = F * surfaceRoughness * transparent_color * envIrradiance;\n    return specular + color;\n}\n#elif defined( PRISMGLAZING )\nvec3 Environment_Glazing(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv,\n                         vec3 glazing_f0, vec3 transmissionF, float transmissionAlpha, vec3 glazingAdjustedColor, float glazingIlluminace)\n{\n    float surfaceAlpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 surfaceF = Fresnel_Rough(glazing_f0, NdotV, surfaceAlpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, glazing_f0, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(surfaceAlpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = surfaceF * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = 0.5 * (1.0 - transmissionF) * (glazingAdjustedColor - vec3(glazingIlluminace, glazingIlluminace, glazingIlluminace)) * envIrradiance; \n    return specular + color;\n}\n#elif defined( PRISMWOOD )\nvec3 Environment_Wood(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(0.04), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(0.04), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * woodDiffuse * envIrradiance;\n    return diffuse + specular;\n}\n#endif\n#endif\n#if defined( PRISMTRANSPARENT )\n#include <prism_transparency>\n#elif defined( PRISMGLAZING )\n#include <prism_glazing>\n#endif\n#ifdef USE_TILING\nvec3 tilingTransform(vec2 uv, mat4 transform)\n{\n\treturn (transform * vec4(uv, 0.0, 1.0)).xyz;\n}\nvec4 tilingMapTest(sampler2D tilingSampler, mat3 transf, vec3 uv, vec4 uv2tile, vec4 tile2uv)\n{\n\tvec2 tileCoord = vec2(dot(uv2tile.xz, uv.xy), dot(uv2tile.yw, uv.xy));\n\tvec2 ijBase = floor(tileCoord);\n    vec2 fracC = fract(tileCoord);\n\tvec2 st = vec2(dot(tile2uv.xz, fracC), dot(tile2uv.yw, fracC));\n\tvec4 tileInfo = vec4(0.0, 0.0, 2.0, 2.0);\n\tvec2 iOffset = float(TILE_RANGE_X_MIN) * tile2uv.xy;\n\tvec2 jBaseOffset = float(TILE_RANGE_Y_MIN) * tile2uv.zw;\n\tfor( int i = TILE_RANGE_X_MIN; i <= TILE_RANGE_X_MAX; i++)\n\t{\n\t\tvec2 jOffset = jBaseOffset;\n\t\tfor( int j = TILE_RANGE_Y_MIN; j <= TILE_RANGE_Y_MAX; j++)\n\t\t{\n\t\t\tvec2 sampleUV = st + iOffset + jOffset;\n\t\t\tjOffset += tile2uv.zw;\n\t\t\tsampleUV = (transf * vec3(sampleUV, 1.0)).xy;\n\t\t\tvec4 tex = texture2D(tilingSampler, sampleUV);\n\t\t\tfloat d = max( min(tex.r, tex.g), min( max(tex.r, tex.g), tex.b));\n            if (d < tileInfo.z) {\n\t\t\t\ttileInfo.xy = vec2(float(i),float(j));\n\t\t\t\ttileInfo.w = tileInfo.z;\n\t\t\t\ttileInfo.z = d;\n\t\t\t} else {\n\t\t\t\ttileInfo.w = min(tileInfo.w, d);\n\t\t\t}\n\t\t}\n\t\tiOffset += tile2uv.xy;\n\t}\n\ttileInfo.zw = tileInfo.zw - 0.5;\n\tfloat w = clamp(tileInfo.z/max(fwidth(tileInfo.z), 0.000001) + 0.5, 0.0, 1.0);\n\tif ( w == 1.0 )\n\t\tdiscard;\n \tif (abs(tileInfo.w)<=abs(tileInfo.z))\n\t\tw = 0.0;\n\ttileInfo.w = 1.0 - w;\n\ttileInfo.xy -= ijBase;\n\treturn tileInfo;\n}\nvec2 tilingSubMaterialRelocate(vec3 uv, vec4 tileInfo, vec4 tile2uv)\n{\n\tvec2 offset = vec2(dot(tile2uv.xz, tileInfo.xy), dot(tile2uv.yw, tileInfo.xy));\n\treturn (uv.xy + offset);\n}\n#ifdef USE_TILING_RANDOM\nvec2 tilingRandom(vec2 uv, vec4 tileInfo, sampler2D randomSampler, mat3 transf, vec2 tileTextureAxisS, vec2 tileTextureAxisT, vec2 tile2TextureOffset)\n{\n    vec2 xti = (vec3(tileInfo.xy, 1.0) * transf).xy;\n    vec4 random = texture2D(randomSampler, xti);\n    vec2 randomOffset = vec2(tileTextureAxisS.x*random.z + tileTextureAxisT.x*random.w,\n        tileTextureAxisS.y*random.z + tileTextureAxisT.y*random.w) + tile2TextureOffset;\n    return uv + randomOffset;\n}\n#endif\nvoid tilingNormalOffset(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (vec3(uv, 1.0) * transform).xy;\n    vec3 distort =  (2.0 * texture2D(bumpTexture, st).xyz - 1.0) - vec3(0.0,0.0,1.0);\n    mat3 mat = mat3(\n        T.x, B.x, N.x,\n        T.y, B.y, N.y,\n        T.z, B.z, N.z\n    );\n    N = normalize(N + (mat*distort));\n}\n#endif\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec3 N = normalize(vNormal);\n    vec3 Tu = vec3(0.0);\n    vec3 Tv = vec3(0.0);\n#if defined(USE_MAP) || defined(USE_TILING)\n    vec2 uv = vUv;\n#endif\n#ifdef USE_TILING\n    vec3 v_tilingOverallTransf = tilingTransform( vUv, tilingOverallTransform );\n    vec4 v_TilingMap = tilingMapTest( TilingMap, TilingMap_texMatrix, v_tilingOverallTransf, uv2tile, tile2uv );\n    uv = tilingSubMaterialRelocate( v_tilingOverallTransf, v_TilingMap, tile2uv ) + tileAlignOffset;\n#ifdef USE_TILING_NORMAL\n    vec2 uvNorm = uv;\n#endif\n#ifdef USE_TILING_RANDOM\n    uv = tilingRandom( uv, v_TilingMap, TilingRandomMap, TilingRandomMap_texMatrix, tilingRandomAxisS, tilingRandomAxisT, tilingRandomAlignmentOffset );\n#endif\n    uv = tilingTransform( uv, tilingUVTransform ).xy;\n#endif\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0 || defined( PRISMWOODBUMP ) || defined( IMPORTANTSAMPLING )\n#if !defined(USE_MAP) || defined( PRISMWOODBUMP )\n    Tu = normalize(vTangent);\n    Tv = normalize(vBitangent);\n#else\n    vec3 q0 = dFdx( -vViewPosition );\n    vec3 q1 = dFdy( -vViewPosition );\n    vec2 st0 = dFdx( uv );\n    vec2 st1 = dFdy( uv );\n    Tu = normalize(  q0 * st1.t - q1 * st0.t );\n    Tv = normalize( -q0 * st1.s + q1 * st0.s );\n#endif\n#endif\n    vec3 V;\n    if (projectionMatrix[3][3] == 0.0) {\n        V = normalize( vViewPosition );\n    } else {\n        V = vec3(0.0, 0.0, 1.0);\n    }\n    N = faceforward(N, -V, N);\n#if defined(PRISMLAYERED)\n    vec3 N2 = N;\n#endif\n#ifndef FLAT_SHADED\n    vec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\n    normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n#endif\n    vec3 geomNormal = normal;\n#if defined( USE_SURFACE_NORMAL_MAP )\n    if (surface_normal_map_bumpmapType == 0)\n        heightMapTransform(surface_normal_map, uv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    else\n        normalMapTransform(surface_normal_map, uv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n#endif\n#if defined( USE_LAYERED_NORMAL_MAP )\n    if (layered_normal_map_bumpmapType == 0)\n        heightMapTransform(layered_normal_map, uv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n    else\n        normalMapTransform(layered_normal_map, uv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n#endif\n#ifdef USE_TILING_NORMAL\n    tilingNormalOffset(TilingNormalMap, uvNorm, TilingNormalMap_texMatrix, Tu, Tv, N);\n#endif\n#if defined( PRISMWOOD )\n#ifdef NO_UVW\n    vec3 p = vec3(0.0);\n#elif defined( USE_WOOD_CURLY_DISTORTION_MAP )\n    vec3 p = DistortCurly(vUvw);\n#else\n    vec3 p = vUvw;\n#endif\n#if !defined( NO_UVW ) && defined( PRISMWOODBUMP )\n    getFinalWoodContext(\n        N, V, Tu, Tv, p,\n        normal, vtNormal, vNormalMatrix\n    );\n#endif\n#endif\n    float NdotV = clamp(dot(N, V), EPSILON, 1.0);\n#if defined(PRISMLAYERED)\n    float N2dotV = clamp(dot(N2, V), EPSILON, 1.0);\n#endif\n    vec3 surfaceAlbedo;\n#prism_sample_texture<surface_albedo, surfaceAlbedo, false, true>\n    float surfaceRoughness;\n#prism_sample_texture<surface_roughness, surfaceRoughness, true, false>\n    float surfaceAnisotropy;\n#prism_sample_texture<surface_anisotropy, surfaceAnisotropy, true, false>\n    float surfaceRotation;\n#prism_sample_texture<surface_rotation, surfaceRotation, true, false>\n#if defined(PRISMOPAQUE)\n    float opaqueF0;\n#prism_sample_texture<opaque_f0, opaqueF0, true, false>\n    vec3 opaqueAlbedo;\n#prism_sample_texture<opaque_albedo, opaqueAlbedo, false, true>\n#elif defined(PRISMMETAL)\n    vec3 metalF0;\n#prism_sample_texture<metal_f0, metalF0, false, true>\n#elif defined(PRISMLAYERED)\n    float layeredF0;\n#prism_sample_texture<layered_f0, layeredF0, true, false>\n    vec3 layeredDiffuse;\n#prism_sample_texture<layered_diffuse, layeredDiffuse, false, true>\n    float layeredRoughness;\n#prism_sample_texture<layered_roughness, layeredRoughness, true, false>\n    float layeredAnisotropy;\n#prism_sample_texture<layered_anisotropy, layeredAnisotropy, true, false>\n    float layeredRotation;\n#prism_sample_texture<layered_rotation, layeredRotation, true, false>\n    vec3 bottom_f0;\n#prism_sample_texture<layered_bottom_f0, bottom_f0, false, true>\n    float layeredFraction;\n#prism_sample_texture<layered_fraction, layeredFraction, true, false>\n#elif defined( PRISMGLAZING )\n    vec3 glazingTransmissionColor;\n#prism_sample_texture<glazing_transmission_color, glazingTransmissionColor, false, true>\n    vec3 glazingF0;\n#prism_sample_texture<glazing_f0, glazingF0, false, true>\n    float glazingTransmissionRoughness;\n#prism_sample_texture<glazing_transmission_roughness, glazingTransmissionRoughness, true, false>\n    vec3 glazingAdjustedColor = TransmitAdjust(glazingTransmissionColor, glazingF0);\n    float glazingIlluminace = ColorToIlluminance(glazingAdjustedColor);\n    float transmissionAlpha = RoughnessToAlpha(glazingTransmissionRoughness, 0.0).x;\n    vec3 transmissionF = Fresnel_Rough(glazingF0, NdotV, transmissionAlpha);\n#elif defined(PRISMWOOD)\n    vec3 woodDiffuse = NoiseWood(p, surfaceRoughness);\n#endif\n    vec3 outRadianceLight = vec3(0.0);\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\n    vec3 lightDirection[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n    vec3 lightColor[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n#if MAX_DIR_LIGHTS > 0\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n        lightDirection[i] = normalize( lDirection.xyz );\n        lightColor[i] = SRGBToLinear(directionalLightColor[ i ]);\n    }\n#endif\n#if MAX_POINT_LIGHTS > 0\n    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( pointLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n        lightColor[MAX_DIR_LIGHTS + i] = SRGBToLinear(pointLightColor[ i ]) * lDistance;\n    }\n#endif\n#if MAX_SPOT_LIGHTS > 0\n    for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( spotLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n        if ( spotEffect > spotLightAngleCos[ i ] )\n            spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n        lightColor[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = SRGBToLinear(spotLightColor[ i ]) * lDistance * spotEffect;\n    }\n#endif\n    for( int i = 0; i < MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS; i ++ ) {\n        vec3 L = lightDirection[i];\n        float NdotL = max(EPSILON, dot(N, L));\n        vec3 H = normalize(L + V);\n        float NdotH = dot(N, H);\n        float VdotH = dot(V, H);\n        float Hu = dot(H, Tu);\n        float Hv = dot(H, Tv);\n        vec3 Hlocal = vec3(Hu, Hv, NdotH);\n#if defined(PRISMLAYERED)\n        float N2dotL = dot(N2, L);\n        float N2dotH = dot(N2, H);\n        vec3 Hlocal2 = vec3(Hu, Hv, N2dotH);\n#endif\n        vec3 brdf = lightColor[i] *\n#if defined(PRISMOPAQUE)\n            BRDF_Opaque(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                    surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                    opaqueF0, opaqueAlbedo);\n#elif defined(PRISMMETAL)\n            BRDF_Metal(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                metalF0);\n#elif defined(PRISMLAYERED)\n            BRDF_Layered(Hlocal, NdotL, NdotH, NdotV, VdotH, Hlocal2, N2dotL, N2dotH, N2dotV,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n                layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n            BRDF_Transparent(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation);\n#elif defined(PRISMGLAZING)\n            BRDF_Glazing(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                         glazingF0, glazingTransmissionColor, glazingIlluminace);\n#elif defined(PRISMWOOD)\n            BRDF_Wood(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, woodDiffuse);\n#endif\n        outRadianceLight += max(vec3(0.0), brdf);\n    }\n#endif\n    vec3 outRadianceEnv = vec3(0.0);\n#if defined( USE_ENVMAP )\n    outRadianceEnv =\n#if defined(PRISMOPAQUE)\n        Environment_Opaque(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n                opaqueF0, opaqueAlbedo, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMMETAL)\n        Environment_Metal(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, metalF0, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMLAYERED)\n        Environment_Layered(N, V, clamp(NdotV, 0.0, 1.0), N2, clamp(N2dotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n            layeredF0, surfaceAnisotropy, surfaceRotation, Tu, Tv, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n            layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n        Environment_Transparent(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMGLAZING)\n        Environment_Glazing(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, Tu, Tv,\n            glazingF0, transmissionF, transmissionAlpha, glazingAdjustedColor, glazingIlluminace);\n#elif defined(PRISMWOOD)\n        Environment_Wood(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, woodDiffuse, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#endif\n#endif\n#if defined(PRISMOPAQUE)\n    vec3 luminanceModifier;\n#prism_sample_texture<opaque_luminance_modifier, luminanceModifier, false, true>\n    outRadianceEnv += luminanceModifier * opaque_luminance;\n#endif\n    float surface_cutout = 1.0;\n#prism_sample_texture<surface_cutout, surface_cutout, true, false>\n#if defined( USE_SURFACE_CUTOUT_MAP )\n    if(surface_cutout < 0.01) discard;\n#endif\n    gl_FragColor = vec4( outRadianceLight + outRadianceEnv, opacity*surface_cutout );\n#if TONEMAP_OUTPUT == 1\n    gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);\n#elif TONEMAP_OUTPUT == 2\n    gl_FragColor.xyz = toneMapCanonFilmic_WithGamma(exposureBias * gl_FragColor.xyz);\n#endif\n#ifdef USE_FOG\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif\n#if defined(PRISMTRANSPARENT)\n    applyPrismTransparency(gl_FragColor, transparent_color, transparent_ior);\n    gl_FragColor.a *= surface_cutout;\n#ifdef USE_TILING\n    gl_FragColor.a *= v_TilingMap.a;\n#endif\n#elif defined( PRISMGLAZING )\n    applyPrismGlazingOpacity(gl_FragColor, transmissionF, transmissionAlpha, NdotV, glazingIlluminace);\n#ifdef USE_TILING\n    gl_FragColor.a *= v_TilingMap.a;\n#endif\n#endif\n#include<theming_frag>\n#include<final_frag>\n}\n"},31:function(e,n){e.exports="gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n"},32:function(e,n){e.exports="\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n"},33:function(e,n){e.exports="\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n"},34:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n"},35:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n"},36:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n"},37:function(e,n){e.exports="float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n"},38:function(e,n){e.exports="\n#define LINE_2D_SHADER 1\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\n#define LTSCALE 0.25\nvarying vec4 fsColor;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n#ifdef LOADING_ANIMATION\nvarying float loadingProgress;\n#endif\n"},39:function(e,n){e.exports="#if defined( PRISMWOOD )\n#define ONE 0.00390625\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    return clamp(transPixels * 0.5, 0.0, 1.0);\n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\n                              float depthVar)\n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\n    return clamp(porePixels, 0.0, 1.0);\n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\n                          float depthVar)\n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{\n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#if defined(PRISMWOODBUMP)\nvoid getFinalWoodContext(\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\n) {\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n}\n#endif\n#endif\n"},40:function(e,n){e.exports="\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \n{ \n   vec3 limit = max(1.0 - f0, 0.00001); \n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \n} \nfloat ColorToIlluminance(in vec3 color) \n{ \n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \n   float illuminance = dot(rgb2grey, color); \n   return illuminance; \n} \nvoid applyPrismGlazingOpacity(\n    inout vec4 color,\n    vec3 transmissionF,\n    float transmissionAlpha,\n    float NdotV,\n    float glazingIlluminace) \n{\n    const float third = 1.0/3.0; \n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \n    opacity = clamp(opacity, 0.01, 0.99);\n    color.a *= opacity;\n} \n"},41:function(e,n){e.exports="void applyPrismTransparency(\n    inout vec4 color,\n    vec3 transparentColor,\n    float transparentIor\n) {\n    float fsLevel = max(max(color.r, color.g), color.b);\n    color = vec4(color.rgb/fsLevel, fsLevel);\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\n    transLevel = min( (1.0 - surface_roughness), transLevel );\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\n    vec3 tr_g_color = sqrt(transparentColor);\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\n    color = mix(transColor, color, strength);\n    color.a = max(color.a, 0.05);\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\n        color.a = 0.0;\n    }\n}"},42:function(e,n){e.exports="#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\nvoid heightMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    N = normalize(\n        N + (\n            diff.x * T * bumpScale.x +\n            diff.y * B * bumpScale.y\n        )\n    );\n}\nvoid normalMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\n    mapN.xy *= bumpScale.x;\n    mapN.z *= bumpScale.y;\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n    float c = -mapN.z;\n    mat3 skewV = mat3(\n        0.0, v.z, -v.y,\n        -v.z, 0.0, v.x,\n        v.y, -v.x, 0.0\n    );\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\n    N *= rot;\n    T *= rot;\n    B *= rot;\n}\n#endif\n"},43:function(e,n){e.exports="uniform float point_size;"},44:function(e,n){e.exports="gl_PointSize = point_size;"},45:function(e,n){e.exports="\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n"},46:function(e,n){e.exports="\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n"},47:function(e,n){e.exports="vec3 rgb2hsv(vec3 color)\n{\n    float delta;\n    float colorMax, colorMin;\n    float h,s,v;\n    vec3 hsv;\n    colorMax = max(color.r,color.g);\n    colorMax = max(colorMax,color.b);\n    colorMin = min(color.r,color.g);\n    colorMin = min(colorMin,color.b);\n    v = colorMax;\n    if(colorMax != 0.0)\n    {\n        s = (colorMax - colorMin)/colorMax;\n    }\n    else\n    {\n        s = 0.0;\n    }\n    if(s != 0.0)\n    {\n        delta = colorMax-colorMin;\n        if (color.r == colorMax)\n        {\n            h = (color.g-color.b)/delta;\n        }\n        else if (color.g == colorMax)\n        {\n            h = 2.0 + (color.b-color.r) / delta;\n        }\n        else\n        {\n            h = 4.0 + (color.r-color.g)/delta;\n        }\n        h /= 6.0;\n        if( h < 0.0)\n        {\n            h +=1.0;\n        }\n    }\n    else\n    {\n        h = 0.0;\n    }\n    hsv = vec3(h,s,v);\n    return hsv;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 color;\n    float f,p,q,t;\n    float h,s,v;\n    float i,hi;\n    {\n        h = hsv.x*6.0;\n        s = hsv.y;\n        v = hsv.z;\n        i = floor(h);\n        f = h-i;\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n        float r,g,b;\n        if (i == 0.0)\n        {\n            r = v;\n            g = t;\n            b = p;\n        }\n        else if (i == 1.0)\n        {\n            r = q;\n            g = v;\n            b = p;\n        }\n        else if (i == 2.0)\n        {\n            r = p;\n            g = v;\n            b = t;\n        }\n        else if (i == 3.0)\n        {\n            r = p;\n            g = q;\n            b = v;\n        }\n        else if (i == 4.0)\n        {\n            r = t;\n            g = p;\n            b = v;\n        }\n        else\n        {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r,g,b);\n    }\n    return color;\n}"},583:function(e,n,o){"use strict";o.r(n);var a={};o.r(a),o.d(a,"PrismShader",(function(){return _})),o.d(a,"createPrismMaterial",(function(){return p})),o.d(a,"clonePrismMaterial",(function(){return m}));var t={};o.r(t),o.d(t,"materialTilingPattern",(function(){return k})),o.d(t,"swapPrismWoodTextures",(function(){return F})),o.d(t,"disposePrismWoodTextures",(function(){return G})),o.d(t,"convertPrismTexture",(function(){return ae})),o.d(t,"convertPrismMaterial",(function(){return B}));var r=o(0),i=o(11),l=o(16),s=o(8),f=o(307),d=o.n(f),c=o(308),u=o.n(c),_={uniforms:r.UniformsUtils.merge([r.UniformsLib.common,r.UniformsLib.lights,r.UniformsLib.fog,i.a.CutPlanesUniforms,i.a.IdUniforms,i.a.ThemingUniform,i.a.ShadowMapUniforms,Object(s.b)("surface_albedo_map"),Object(s.b)("surface_roughness_map"),Object(s.b)("surface_cutout_map"),Object(s.b)("surface_anisotropy_map"),Object(s.b)("surface_rotation_map"),Object(s.b)("opaque_albedo_map"),Object(s.b)("opaque_f0_map"),Object(s.b)("opaque_luminance_modifier_map"),Object(s.b)("layered_bottom_f0_map"),Object(s.b)("layered_f0_map"),Object(s.b)("layered_diffuse_map"),Object(s.b)("layered_fraction_map"),Object(s.b)("layered_roughness_map"),Object(s.b)("layered_anisotropy_map"),Object(s.b)("layered_rotation_map"),Object(s.b)("metal_f0_map"),Object(s.b)("wood_curly_distortion_map"),Object(s.b)("glazing_f0_map"),Object(s.b)("glazing_transmission_color_map"),Object(s.b)("glazing_transmission_roughness_map"),Object(s.a)("surface_normal_map"),Object(s.a)("layered_normal_map"),Object(s.b)("TilingMap"),Object(s.b)("TilingNormalMap"),Object(s.b)("TilingRandomMap"),{surface_albedo:{type:"c",value:new r.Color(1118481)},surface_roughness:{type:"f",value:1},surface_anisotropy:{type:"f",value:1},surface_rotation:{type:"f",value:1},opaque_albedo:{type:"c",value:new r.Color(1118481)},opaque_f0:{type:"f",value:1},opaque_luminance_modifier:{type:"c",value:new r.Color(1118481)},opaque_luminance:{type:"f",value:1},metal_f0:{type:"c",value:new r.Color(1118481)},layered_f0:{type:"f",value:1},layered_diffuse:{type:"c",value:new r.Color(0)},layered_fraction:{type:"f",value:1},layered_bottom_f0:{type:"c",value:new r.Color(1118481)},layered_roughness:{type:"f",value:1},layered_anisotropy:{type:"f",value:1},layered_rotation:{type:"f",value:1},transparent_ior:{type:"f",value:2},transparent_color:{type:"c",value:new r.Color(1118481)},transparent_distance:{type:"f",value:1},glazing_f0:{type:"c",value:new r.Color(16777215)},glazing_transmission_roughness:{type:"f",value:0},glazing_transmission_color:{type:"c",value:new r.Color(16777215)},wood_fiber_cosine_enable:{type:"i",value:1},wood_fiber_cosine_bands:{type:"i",value:2},wood_fiber_cosine_weights:{type:"v4",value:new r.Vector4(2.5,.5,1,1)},wood_fiber_cosine_frequencies:{type:"v4",value:new r.Vector4(15,4,1,1)},wood_fiber_perlin_enable:{type:"i",value:1},wood_fiber_perlin_bands:{type:"i",value:3},wood_fiber_perlin_weights:{type:"v4",value:new r.Vector4(3,1,.2,1)},wood_fiber_perlin_frequencies:{type:"v4",value:new r.Vector4(40,20,3.5,1)},wood_fiber_perlin_scale_z:{type:"f",value:.3},wood_growth_perlin_enable:{type:"i",value:1},wood_growth_perlin_bands:{type:"i",value:3},wood_growth_perlin_weights:{type:"v4",value:new r.Vector4(1,2,1,1)},wood_growth_perlin_frequencies:{type:"v4",value:new r.Vector4(1,5,13,1)},wood_latewood_ratio:{type:"f",value:.238},wood_earlywood_sharpness:{type:"f",value:.395},wood_latewood_sharpness:{type:"f",value:.109},wood_ring_thickness:{type:"f",value:.75},wood_earlycolor_perlin_enable:{type:"i",value:1},wood_earlycolor_perlin_bands:{type:"i",value:2},wood_earlycolor_perlin_weights:{type:"v4",value:new r.Vector4(.3,.5,.15,1)},wood_earlycolor_perlin_frequencies:{type:"v4",value:new r.Vector4(8,3,.35,1)},wood_early_color:{type:"c",value:new r.Color(.286,.157,.076)},wood_use_manual_late_color:{type:"i",value:0},wood_manual_late_color:{type:"c",value:new r.Color(.62,.35,.127)},wood_latecolor_perlin_enable:{type:"i",value:1},wood_latecolor_perlin_bands:{type:"i",value:1},wood_latecolor_perlin_weights:{type:"v4",value:new r.Vector4(.75,.55,1,1)},wood_latecolor_perlin_frequencies:{type:"v4",value:new r.Vector4(4.5,.05,1,1)},wood_late_color_power:{type:"f",value:1.25},wood_diffuse_perlin_enable:{type:"i",value:1},wood_diffuse_perlin_bands:{type:"i",value:3},wood_diffuse_perlin_weights:{type:"v4",value:new r.Vector4(.15,.2,.05,1)},wood_diffuse_perlin_frequencies:{type:"v4",value:new r.Vector4(.05,.1,3,1)},wood_diffuse_perlin_scale_z:{type:"f",value:.2},wood_use_pores:{type:"i",value:1},wood_pore_type:{type:"i",value:0},wood_pore_radius:{type:"f",value:.04},wood_pore_cell_dim:{type:"f",value:.15},wood_pore_color_power:{type:"f",value:1.45},wood_pore_depth:{type:"f",value:.02},wood_use_rays:{type:"i",value:1},wood_ray_color_power:{type:"f",value:1.1},wood_ray_seg_length_z:{type:"f",value:5},wood_ray_num_slices:{type:"f",value:160},wood_ray_ellipse_z2x:{type:"f",value:10},wood_ray_ellipse_radius_x:{type:"f",value:.2},wood_use_latewood_bump:{type:"i",value:1},wood_latewood_bump_depth:{type:"f",value:.01},wood_use_groove_roughness:{type:"i",value:1},wood_groove_roughness:{type:"f",value:.85},wood_diffuse_lobe_weight:{type:"f",value:.9},wood_curly_distortion_enable:{type:"i",value:0},wood_curly_distortion_scale:{type:"f",value:.25},wood_ring_fraction:{type:"v4",value:new r.Vector4(0,0,0,0)},wood_fall_rise:{type:"v2",value:new r.Vector2(0,0)},permutationMap:{type:"t",value:null},gradientMap:{type:"t",value:null},perm2DMap:{type:"t",value:null},permGradMap:{type:"t",value:null},importantSamplingRandomMap:{type:"t",value:null},importantSamplingSolidAngleMap:{type:"t",value:null},irradianceMap:{type:"t",value:null},envMap:{type:"t",value:null},exposureBias:{type:"f",value:1},envMapExposure:{type:"f",value:1},envRotationSin:{type:"f",value:0},envRotationCos:{type:"f",value:1},envExponentMin:{type:"f",value:1},envExponentMax:{type:"f",value:512},envExponentCount:{type:"f",value:10},tilingOverallTransform:{type:"m4",value:new r.Matrix4},uv2tile:{type:"v4",value:new r.Vector4(1,0,0,1)},tile2uv:{type:"v4",value:new r.Vector4(1,0,0,1)},tileAlignOffset:{type:"v2",value:new r.Vector2(0,0)},tilingUVTransform:{type:"m4",value:new r.Matrix4},tilingRandomAxisS:{type:"v2",value:new r.Vector2(0,0)},tilingRandomAxisT:{type:"v2",value:new r.Vector2(0,0)},tilingRandomAlignmentOffset:{type:"v2",value:new r.Vector2(0,0)}}]),vertexShader:d.a,fragmentShader:u.a};r.ShaderLib.prism=_;var p=function(){var e=Object(l.a)(_);return e.defaultAttributeValues.uvw=[0,0,0],e.enable3DWoodBump=!1,e.enableImportantSampling=!1,e.mapList={},e.isPrismMaterial=!0,e},m=function(e){var n=p();switch(n.name=e.name,n.side=e.side,n.opacity=e.opacity,n.transparent=e.transparent,n.blending=e.blending,n.blendSrc=e.blendSrc,n.blendDst=e.blendDst,n.blendEquation=e.blendEquation,n.blendSrcAlpha=e.blendSrcAlpha,n.blendDstAlpha=e.blendDstAlpha,n.blendEquationAlpha=e.blendEquationAlpha,n.depthTest=e.depthTest,n.depthWrite=e.depthWrite,n.polygonOffset=e.polygonOffset,n.polygonOffsetFactor=e.polygonOffsetFactor,n.polygonOffsetUnits=e.polygonOffsetUnits,n.alphaTest=e.alphaTest,n.overdraw=e.overdraw,n.visible=e.visible,n.mapList=e.mapList,n.prismType=e.prismType,n.surface_albedo=e.surface_albedo,void 0!==e.surface_albedo_map&&(n.surface_albedo_map=e.surface_albedo_map),n.surface_roughness=e.surface_roughness,void 0!==e.surface_roughness_map&&(n.surface_roughness_map=e.surface_roughness_map),n.surface_anisotropy=e.surface_anisotropy,void 0!==e.surface_anisotropy_map&&(n.surface_anisotropy_map=e.surface_anisotropy_map),n.surface_rotation=e.surface_rotation,void 0!==e.surface_rotation_map&&(n.surface_rotation_map=e.surface_rotation_map),void 0!==e.surface_cutout_map&&(n.surface_cutout_map=e.surface_cutout_map),void 0!==e.surface_normal_map&&(n.surface_normal_map=e.surface_normal_map),n.uniforms.importantSamplingRandomMap.value=e.uniforms.importantSamplingRandomMap.value,n.uniforms.importantSamplingSolidAngleMap.value=e.uniforms.importantSamplingSolidAngleMap.value,n.prismType){case"PrismOpaque":n.opaque_albedo=(new r.Color).copy(e.opaque_albedo),n.opaque_luminance_modifier=(new r.Color).copy(e.opaque_luminance_modifier),n.opaque_f0=e.opaque_f0,n.opaque_luminance=e.opaque_luminance,void 0!==e.opaque_albedo_map&&(n.opaque_albedo_map=e.opaque_albedo_map),void 0!==e.opaque_luminance_modifier_map&&(n.opaque_luminance_modifier_map=e.opaque_luminance_modifier_map),void 0!==e.opaque_f0_map&&(n.opaque_f0_map=e.opaque_f0_map);break;case"PrismMetal":n.metal_f0=(new r.Color).copy(e.metal_f0),void 0!==e.metal_f0_map&&(n.metal_f0_map=e.metal_f0_map);break;case"PrismLayered":n.layered_f0=e.layered_f0,n.layered_diffuse=(new r.Color).copy(e.layered_diffuse),n.layered_fraction=e.layered_fraction,n.layered_bottom_f0=(new r.Color).copy(e.layered_bottom_f0),n.layered_roughness=e.layered_roughness,n.layered_anisotropy=e.layered_anisotropy,n.layered_rotation=e.layered_rotation,void 0!==e.layered_bottom_f0_map&&(n.layered_bottom_f0_map=e.layered_bottom_f0_map),void 0!==e.layered_f0_map&&(n.layered_f0_map=e.layered_f0_map),void 0!==e.layered_diffuse_map&&(n.layered_diffuse_map=e.layered_diffuse_map),void 0!==e.layered_fraction_map&&(n.layered_fraction_map=e.layered_fraction_map),void 0!==e.layered_rotationlayered_roughness_map&&(n.layered_rotationlayered_roughness_map=e.layered_rotationlayered_roughness_map),void 0!==e.layered_anisotropy_map&&(n.layered_anisotropy_map=e.layered_anisotropy_map),void 0!==e.layered_rotation_map&&(n.layered_rotation_map=e.layered_rotation_map),void 0!==e.layered_normal_map&&(n.layered_normal_map=e.layered_normal_map);break;case"PrismTransparent":n.transparent_color=(new r.Color).copy(e.transparent_color),n.transparent_distance=e.transparent_distance,n.transparent_ior=e.transparent_ior,n.transparent=e.transparent,n.twoPassTransparency=e.twoPassTransparency;break;case"PrismGlazing":n.glazing_f0=(new r.Color).copy(e.glazing_f0),n.glazing_transmission_color=(new r.Color).copy(e.glazing_transmission_color),n.glazing_transmission_roughness=e.glazing_transmission_roughness,void 0!==e.glazing_f0_map&&(n.glazing_f0_map=e.glazing_f0_map),void 0!==e.glazing_transmission_color_map&&(n.glazing_transmission_color_map=e.glazing_transmission_color_map),void 0!==e.glazing_transmission_roughness_map&&(n.glazing_transmission_roughness_map=e.glazing_transmission_roughness_map);break;case"PrismWood":n.wood_fiber_cosine_enable=e.wood_fiber_cosine_enable,n.wood_fiber_cosine_bands=e.wood_fiber_cosine_bands,n.wood_fiber_cosine_weights=(new r.Vector4).copy(e.wood_fiber_cosine_weights),n.wood_fiber_cosine_frequencies=(new r.Vector4).copy(e.wood_fiber_cosine_frequencies),n.wood_fiber_perlin_enable=e.wood_fiber_perlin_enable,n.wood_fiber_perlin_bands=e.wood_fiber_perlin_bands,n.wood_fiber_perlin_weights=(new r.Vector4).copy(e.wood_fiber_perlin_weights),n.wood_fiber_perlin_frequencies=(new r.Vector4).copy(e.wood_fiber_perlin_frequencies),n.wood_fiber_perlin_scale_z=e.wood_fiber_perlin_scale_z,n.wood_growth_perlin_enable=e.wood_growth_perlin_enable,n.wood_growth_perlin_bands=e.wood_growth_perlin_bands,n.wood_growth_perlin_weights=(new r.Vector4).copy(e.wood_growth_perlin_weights),n.wood_growth_perlin_frequencies=(new r.Vector4).copy(e.wood_growth_perlin_frequencies),n.wood_latewood_ratio=e.wood_latewood_ratio,n.wood_earlywood_sharpness=e.wood_earlywood_sharpness,n.wood_latewood_sharpness=e.wood_latewood_sharpness,n.wood_ring_thickness=e.wood_ring_thickness,n.wood_earlycolor_perlin_enable=e.wood_earlycolor_perlin_enable,n.wood_earlycolor_perlin_bands=e.wood_earlycolor_perlin_bands,n.wood_earlycolor_perlin_weights=(new r.Vector4).copy(e.wood_earlycolor_perlin_weights),n.wood_earlycolor_perlin_frequencies=(new r.Vector4).copy(e.wood_earlycolor_perlin_frequencies),n.wood_early_color=(new r.Color).copy(e.wood_early_color),n.wood_use_manual_late_color=e.wood_use_manual_late_color,n.wood_manual_late_color=(new r.Color).copy(e.wood_manual_late_color),n.wood_latecolor_perlin_enable=e.wood_latecolor_perlin_enable,n.wood_latecolor_perlin_bands=e.wood_latecolor_perlin_bands,n.wood_latecolor_perlin_weights=(new r.Vector4).copy(e.wood_latecolor_perlin_weights),n.wood_latecolor_perlin_frequencies=(new r.Vector4).copy(e.wood_latecolor_perlin_frequencies),n.wood_late_color_power=e.wood_late_color_power,n.wood_diffuse_perlin_enable=e.wood_diffuse_perlin_enable,n.wood_diffuse_perlin_bands=e.wood_diffuse_perlin_bands,n.wood_diffuse_perlin_weights=(new r.Vector4).copy(e.wood_diffuse_perlin_weights),n.wood_diffuse_perlin_frequencies=(new r.Vector4).copy(e.wood_diffuse_perlin_frequencies),n.wood_diffuse_perlin_scale_z=e.wood_diffuse_perlin_scale_z,n.wood_use_pores=e.wood_use_pores,n.wood_pore_type=e.wood_pore_type,n.wood_pore_radius=e.wood_pore_radius,n.wood_pore_cell_dim=e.wood_pore_cell_dim,n.wood_pore_color_power=e.wood_pore_color_power,n.wood_pore_depth=e.wood_pore_depth,n.wood_use_rays=e.wood_use_rays,n.wood_ray_color_power=e.wood_ray_color_power,n.wood_ray_seg_length_z=e.wood_ray_seg_length_z,n.wood_ray_num_slices=e.wood_ray_num_slices,n.wood_ray_ellipse_z2x=e.wood_ray_ellipse_z2x,n.wood_ray_ellipse_radius_x=e.wood_ray_ellipse_radius_x,n.wood_use_latewood_bump=e.wood_use_latewood_bump,n.wood_latewood_bump_depth=e.wood_latewood_bump_depth,n.wood_use_groove_roughness=e.wood_use_groove_roughness,n.wood_groove_roughness=e.wood_groove_roughness,n.wood_diffuse_lobe_weight=e.wood_diffuse_lobe_weight,n.uniforms.permutationMap.value=e.uniforms.permutationMap.value,n.uniforms.gradientMap.value=e.uniforms.gradientMap.value,n.uniforms.perm2DMap.value=e.uniforms.perm2DMap.value,n.uniforms.permGradMap.value=e.uniforms.permGradMap.value,void 0!==e.wood_curly_distortion_map&&(n.wood_curly_distortion_map=e.wood_curly_distortion_map,n.wood_curly_distortion_enable=e.wood_curly_distortion_enable,n.wood_curly_distortion_scale=e.wood_curly_distortion_scale),n.wood_ring_fraction=e.wood_ring_fraction,n.wood_fall_rise=e.wood_fall_rise;break;default:r.warn("Unknown prism type: "+e.prismType)}return n.envExponentMin=e.envExponentMin,n.envExponentMax=e.envExponentMax,n.envExponentCount=e.envExponentCount,n.envMap=e.envMap,e.useTiling&&(n.useTiling=e.useTiling,n.tilingOverallTransform=(new r.Matrix4).copy(e.tilingOverallTransform),n.TilingMap=e.TilingMap,n.TilingMap_texMatrix=(new r.Matrix3).copy(e.TilingMap_texMatrix),n.hasRoundCorner=e.hasRoundCorner,n.hasRoundCorner&&(n.TilingNormalMap=e.TilingNormalMap,n.TilingNormalMap_texMatrix=(new r.Matrix3).copy(e.TilingNormalMap_texMatrix)),n.useRandomOffset=e.useRandomOffset,n.useRandomOffset&&(n.TilingRandomMap=e.TilingRandomMap,n.TilingRandomMap_texMatrix=(new r.Matrix3).copy(e.TilingRandomMap_texMatrix),n.tilingRandomAxisS=(new r.Vector2).copy(e.tilingRandomAxisS),n.tilingRandomAxisT=(new r.Vector2).copy(e.tilingRandomAxisT),n.tilingRandomAlignmentOffset=(new r.Vector2).copy(e.tilingRandomAlignmentOffset)),n.uv2tile=e.uv2tile,n.tile2uv=e.tile2uv,n.tilingRepeatRange=[e.tilingRepeatRange[0],e.tilingRepeatRange[1],e.tilingRepeatRange[2],e.tilingRepeatRange[3]],n.tileAlignOffset=(new r.Vector2).copy(e.tileAlignOffset),n.tilingUVTransform=(new r.Matrix4).copy(e.tilingUVTransform)),n.defines=e.defines,n};function v(){this.distance=-1e240,this.dot=1}function g(e,n){return e.x*n.y-e.y*n.x}function h(e,n,o){n=n,o=o;var a=e.length();return 0===a?n?new THREE.Vector2(0,o?0:1):new THREE.Vector2(0,-(o?0:1)):n?new THREE.Vector2(-e.y/a,e.x/a):new THREE.Vector2(e.y/a,-e.x/a)}v.prototype={constructor:v,set:function(e,n){return this.distance=e,this.dot=n,this},copy:function(e){this.distance=e.distance,this.dot=e.dot},lessThan:function(e){return Math.abs(this.distance)<Math.abs(e.distance)||Math.abs(this.distance)===Math.abs(e.distance)&&this.dot<e.dot},greaterThan:function(e){return Math.abs(this.distance)>Math.abs(e.distance)||Math.abs(this.distance)===Math.abs(e.distance)&&this.dot>e.dot},lessThanOrEquals:function(e){return Math.abs(this.distance)<Math.abs(e.distance)||Math.abs(this.distance)==Math.abs(e.distance)&&this.dot<=e.dot},greaterThanOrEquals:function(e){return Math.abs(this.distance)>Math.abs(e.distance)||Math.abs(this.distance)==Math.abs(e.distance)&&this.dot>=e.dot}};function y(e,n,o){this.p=[],this.p[0]=e.clone(),this.p[1]=n.clone(),this.color=o}function w(e,n){return(n.x-e.x)*(e.y+n.y)}function x(){this.edges=[]}function T(e,n,o){return e.dot(n)<=0||Math.abs(g(e,n))>o}function R(e,n){return E(e,n,0)}function E(e,n,o){var a=e&o;if(1==a||2==a||4==a)return[e=7^a,n];if(0==e||7==e)return[e=[6,5,3][n%3],n=Math.floor(n/3)];var t=e<<1+(1&n);return[e=7&(t|t>>3),n>>=1]}function M(){this.minDistance=new v,this.nearEdge=null,this.nearParam=0}function b(e,n,o){return Math.max(Math.min(e,n),Math.min(Math.max(e,n),o))}function A(e,n){var o=n.point(0),a=n.point(1),t=e,r=e.clone().sub(o),i=a.clone().sub(o),l=r.dot(i)/i.dot(i);return l<0?r.length():l>1?t.clone().sub(a).length():Math.abs(h(i,!1,!1).dot(r))}function S(){this.contours=[],this.windings=[],this.inverseYAxis=!1}function N(e,n,o){if(!e||!e.colors)return new r.Color(1,0,0);var a=e.colors[n];if(!a)return new r.Color(0,0,0);var t=a.values;if(!t||!t.length)return new r.Color(1,0,0);var i=t[0];return new r.Color(i.r,i.g,i.b)}function I(e,n,o){if(!e||!e.scalars)return o;var a=e.scalars[n];return a?a.values[0]:o}function P(e,n,o,a){if(!e||!e[n])return a;var t=e[n][o];return t?t.values[0]:a}function D(e){var n=e;return n<=.04045?n/=12.92:n=Math.pow((n+.055)/1.055,2.4),n}function V(e){var n,o,a;return n=D(e.r),o=D(e.g),a=D(e.b),new r.Color(n,o,a)}y.prototype={constructor:y,set:function(e){return this.color=e,this},clone:function(){return new this.constructor(this.p[0],this.p[1],this.color)},point:function(e){return this.p[0].clone().lerp(this.p[1],e)},direction:function(){return this.p[1].clone().sub(this.p[0])},signedDistance:function(e){var n=e.clone().sub(this.p[0]),o=this.direction(),a=n.dot(o)/o.dot(o),t=this.p[a>.5?1:0].clone().sub(e),r=t.length();if(a>0&&a<1){var i=h(o,!1,!1).dot(n);if(Math.abs(i)<r){var l=new v;return l.set(i,0),[l,a]}}var s=2*(g(n,o)>0?1:0)-1,f=new v;return f.set(s*r,Math.abs(o.normalize().dot(t.normalize(t)))),[f,a]},distanceToPseudoDistance:function(e,n,o){var a,t;if(o<0){t=this.direction().normalize();var r=n.clone().sub(this.p[0]);r.dot(t)<0&&(a=g(r,t),Math.abs(a)<=Math.abs(e.distance)&&(e.distance=a,e.dot=0))}else if(o>1){t=this.direction().normalize();var i=n.clone().sub(this.p[1]);i.dot(t)>0&&(a=g(i,t),Math.abs(a)<=Math.abs(e.distance)&&(e.distance=a,e.dot=0))}},moveStartPoint:function(e){this.p[0].copy(e)},moveEndPoint:function(e){this.p[1].copy(e)},splitInThirds:function(e,n,o){var a=this.point(1/3),t=this.point(2/3);new y(this.p[0],a,this.color),new y(a,t,this.color),new y(t,this.p[1],this.color)}},x.prototype={constructor:x,addEdge:function(e){this.edges.push(e)},winding:function(){if(0===this.edges.length)return 0;var e,n,o,a,t,r=0;if(1==this.edges.length)e=new THREE.Vector2,n=new THREE.Vector2,o=new THREE.Vector2,e.copy(this.edges[0].point(0)),n.copy(this.edges[0].point(1/3)),o.copy(this.edges[0].point(2/3)),r+=w(e,n),r+=w(n,o),r+=w(o,e);else if(2==this.edges.length)e=new THREE.Vector2,n=new THREE.Vector2,o=new THREE.Vector2,a=new THREE.Vector2,e.copy(this.edges[0].point(0)),n.copy(this.edges[0].point(.5)),o.copy(this.edges[1].point(0)),a.copy(this.edges[1].point(.5)),r+=w(e,n),r+=w(n,o),r+=w(o,a),r+=w(a,e);else{var i=new THREE.Vector2,l=new THREE.Vector2;i=this.edges[this.edges.length-1].point(0);for(var s=0;s<this.edges.length;s++)r+=w(i,l=this.edges[s].point(0)),i=l}return(t=r)>0?1:t<0?-1:0}},M.prototype={constructor:M,clear:function(){this.nearEdge=null,this.nearParam=0},copy:function(e){this.minDistance.copy(e.minDistance),this.nearEdge=e.nearEdge,this.nearParam=e.nearParam}},S.prototype={constructor:S,addContour:function(e){this.contours.push(e)},addBlankContour:function(){var e=new x;return this.contours.push(e),e},initialize:function(){this.contours.length;for(var e=0;e<this.contours.length;++e){var n=this.contours[e];this.windings.push(n.winding())}},edgeColoringSimple:function(e,n){for(var o=Math.sin(e),a=0;a<this.contours.length;++a){var t=this.contours[a],r=[];if(t.edges.length>0)for(var i=t.edges[t.edges.length-1].direction(1),l=0;l<t.edges.length;++l){var s=t.edges[l];T(i.normalize(),s.direction(0).normalize(),o)&&r.push(l),i=s.direction(1)}if(0===r.length)for(var f=0;f<t.edges.length;++f)t.edges[f].color=7;else if(1==r.length){var d=[7,7],c=R(d[0],n);d[0]=c[0],n=c[1],d[2]=d[0],c=R(d[0],n),d[0]=c[0],n=c[1];var u=r[0];if(t.edges.length>=3)for(var _=t.edges.length,p=0;p<_;++p)t.edges[(u+p)%_].color=d[Math.floor(2.875*p/(_-1)+.0625)];else if(t.edges.length>=1){var m=[];t.edges[0].splitInThirds(m[0+3*u],m[1+3*u],m[2+3*u]),t.edges.length>=2?(t.edges[1].splitInThirds(m[3-3*u],m[4-3*u],m[5-3*u]),m[0].color=m[1].color=d[0],m[2].color=m[3].color=d[1],m[4].color=m[5].color=d[2]):(m[0].color=d[0],m[1].color=d[1],m[2].color=d[2]),t.edges.clear();for(var v=0;v<m.length;++v)t.edges.push(m[v])}}else{var g=r.length,h=0,y=r[0],w=t.edges.length,x=7,M=R(x,n);x=M[0],n=M[1];for(var b=x,A=0;A<w;++A){var S=(y+A)%w;h+1<g&&r[h+1]==S&&(x=(M=E(x,n,(++h===g-1?1:0)*b))[0],n=M[1]),t.edges[S].color=x}}}},calculateMSDFValue:function(e){for(var n=this.contours.length,o=[],a=new M,t=new M,r=new M,i=Math.abs(-1e240),l=1e240,s=-1e240,f=0,d=new M,c=new M,u=new M,_=0;_<this.contours.length;++_){o[_]={r:-1e240,g:-1e240,b:-1e240,med:-1e240};var p=this.contours[_];d.clear(),c.clear(),u.clear();for(var m=0;m<p.edges.length;++m){var v=p.edges[m],g=v.signedDistance(e),h=g[0],y=g[1];(1&v.color)>0&&h.lessThan(d.minDistance)&&(d.minDistance.copy(h),d.nearEdge=v,d.nearParam=y),(2&v.color)>0&&h.lessThan(c.minDistance)&&(c.minDistance.copy(h),c.nearEdge=v,c.nearParam=y),(4&v.color)>0&&h.lessThan(u.minDistance)&&(u.minDistance.copy(h),u.nearEdge=v,u.nearParam=y)}d.minDistance.lessThan(a.minDistance)&&a.copy(d),c.minDistance.lessThan(t.minDistance)&&t.copy(c),u.minDistance.lessThan(r.minDistance)&&r.copy(u);var w=Math.abs(b(d.minDistance.distance,c.minDistance.distance,u.minDistance.distance));w<i&&(i=w,f=-this.windings[_]),d.nearEdge&&d.nearEdge.distanceToPseudoDistance(d.minDistance,e,d.nearParam),c.nearEdge&&c.nearEdge.distanceToPseudoDistance(c.minDistance,e,c.nearParam),u.nearEdge&&u.nearEdge.distanceToPseudoDistance(u.minDistance,e,u.nearParam),w=b(d.minDistance.distance,c.minDistance.distance,u.minDistance.distance),o[_].r=d.minDistance.distance,o[_].g=c.minDistance.distance,o[_].b=u.minDistance.distance,o[_].med=w,this.windings[_]>0&&w>=0&&Math.abs(w)<Math.abs(s)&&(s=w),this.windings[_]<0&&w<=0&&Math.abs(w)<Math.abs(l)&&(l=w)}a.nearEdge&&a.nearEdge.distanceToPseudoDistance(a.minDistance,e,a.nearParam),t.nearEdge&&t.nearEdge.distanceToPseudoDistance(t.minDistance,e,t.nearParam),r.nearEdge&&r.nearEdge.distanceToPseudoDistance(r.minDistance,e,r.nearParam);var x={r:-1e240,g:-1e240,b:-1e240,med:-1e240};if(s>=0&&Math.abs(s)<=Math.abs(l)){x.med=-1e240,f=1;for(var T=0;T<n;++T)this.windings[T]>0&&o[T].med>x.med&&Math.abs(o[T].med)<Math.abs(l)&&(x=o[T])}else if(l<=0&&Math.abs(l)<=Math.abs(s)){x.med=1e240,f=-1;for(var R=0;R<n;++R)this.windings[R]<0&&o[R].med<x.med&&Math.abs(o[R].med)<Math.abs(s)&&(x=o[R])}for(var E=0;E<n;++E)this.windings[E]!=f&&Math.abs(o[E].med)<Math.abs(x.med)&&(x=o[E]);return b(a.minDistance.distance,t.minDistance.distance,r.minDistance.distance)==x.med&&(x.r=a.minDistance.distance,x.g=t.minDistance.distance,x.b=r.minDistance.distance),new THREE.Vector3(x.r,x.g,x.b)},minSameColoredEdgeDistance:function(){for(var e=[1e10,1e10,1e10],n=0;n<this.contours.length;++n)for(var o=this.contours[n],a=0;a<o.edges.length;++a)for(var t=o.edges[a],r=0;r+1<a;++r){var i=o.edges[r];if(t.color==i.color){var l=Math.min(Math.min(A(t.point(0),i),A(t.point(1),i)),Math.min(A(i.point(0),t),A(i.point(1),t))),s=t.color-5;e[s]=Math.min(e[s],l)}}return Math.min(Math.min(e[0],e[1]),e[2])}};var L,H,C={MilliMeter:1e3,mm:1e3,8206:1e3,DeciMeter:10,dm:10,8204:10,CentiMeter:100,cm:100,8205:100,Meter:1,m:1,8193:1,KiloMeter:.001,km:.001,8201:.001,Inch:39.37008,in:39.37008,8214:39.37008,Foot:3.28084,ft:3.28084,8215:3.28084,Mile:62137e-8,mi:62137e-8,8225:62137e-8,Yard:1.09361,yard:1.09361,8221:1.09361};function O(e,n,o,a){if(!e||!e.scalars)return a;var t=e.scalars[n];return t?function(e,n,o){var a=C[o];a||(a=1,THREE.warn("Unsupported unit: "+o));var t=C[n];return t||(t=1,THREE.warn("Unsupported unit: "+n)),e*a/t}(t.values[0],t.units,o):a}function z(e,n,o,a){if(!e||!e[n])return a;var t=e[n][o];return t&&t.connections?t.connections[0]:a}function U(e,n){var o=O(e,"texture_RealWorldOffsetX",n,0),a=O(e,"texture_RealWorldOffsetY",n,0),t=P(e,"scalars","texture_UOffset",0),r=P(e,"scalars","texture_VOffset",0),i=1,l=1;null!=P(e,"scalars","texture_RealWorldScale")?i=l=O(e,"texture_RealWorldScale",n,1):(i=O(e,"texture_RealWorldScaleX",n,1),l=O(e,"texture_RealWorldScaleY",n,1)),i=0===i?1:i,l=0===l?1:l;var s=P(e,"scalars","texture_UScale",1),f=P(e,"scalars","texture_VScale",1),d=P(e,"scalars","texture_WAngle",0);d*=Math.PI/180;var c=Math.cos(d),u=Math.sin(d),_=s/i,p=f/l;return{elements:[c*_,u*_,0,-u*p,c*p,0,-c*_*o+u*p*a+t,-u*_*o-c*p*a+r,1]}}function F(e){var n=H;return H=e,n}function G(e){e&&(e.permutation.dispose(),e.gradient.dispose(),e.perm2D.dispose(),e.permGrad.dispose())}function W(e,n,o){e[o+"_enable"]=P(n,"booleans",o+"_enable",0);var a=function(e,n,o){var a={bands:0,weights:new THREE.Vector4(1,1,1,1),frequencies:new THREE.Vector4(1,1,1,1)};if(!e||!e[n])return a;var t=e[n][o];if(!(t&&t.values&&t.values instanceof Array))return a;var r=t.values;a.bands=r.length/2;for(var i=0;i<a.bands;++i)a.frequencies.setComponent(i,1/r[2*i]),a.weights.setComponent(i,r[2*i+1]);return a}(n,"scalars",o+"_prof");e[o+"_bands"]=a.bands,e[o+"_weights"]=a.weights,e[o+"_frequencies"]=a.frequencies}function B(e,n,o,a){a=a||e.userassets;var t=e.materials,r=t[a];r&&("TilingPattern"===r.definition&&(r=t[r.properties.references.grout_material.connections[0]]));var i,l,s=r.properties;if(o){if(!o.isPrismMaterial)return null;o.needsUpdate=!0}else o=p();o.proteinMat=e,o.proteinCategories=r.categories,o.packedNormals=!0,o.tag=r.tag,o.prismType=r.definition,void 0===o.prismType&&(o.prismType=""),void 0!==e.IsSingleSided&&!1===e.IsSingleSided&&(o.side=THREE.DoubleSide);var f=o.mapList;switch(o.transparent=!1,o.envExponentMin=1,o.envExponentMax=512,o.envExponentCount=10,o.surface_albedo=V(N(s,"surface_albedo",new THREE.Color(1,0,0))),f.surface_albedo_map=z(s,"colors","surface_albedo",null),o.surface_anisotropy=P(s,"scalars","surface_anisotropy",0),f.surface_anisotropy_map=z(s,"scalars","surface_anisotropy",null),o.surface_rotation=P(s,"scalars","surface_rotation",0),f.surface_rotation_map=z(s,"scalars","surface_rotation",null),o.surface_roughness=P(s,"scalars","surface_roughness",0),f.surface_roughness_map=z(s,"scalars","surface_roughness",null),f.surface_cutout_map=z(s,"textures","surface_cutout",null),f.surface_normal_map=z(s,"textures","surface_normal",null),null!=f.surface_cutout_map&&(o.side=THREE.DoubleSide,o.transparent=!0),o.prismType){case"PrismOpaque":o.opaque_albedo=V(N(s,"opaque_albedo",new THREE.Color(1,0,0))),f.opaque_albedo_map=z(s,"colors","opaque_albedo",null),o.opaque_luminance_modifier=V(N(s,"opaque_luminance_modifier",new THREE.Color(0,0,0))),f.opaque_luminance_modifier_map=z(s,"colors","opaque_luminance_modifier",null),o.opaque_f0=P(s,"scalars","opaque_f0",0),f.opaque_f0_map=z(s,"scalars","opaque_f0",null),o.opaque_luminance=P(s,"scalars","opaque_luminance",0);break;case"PrismMetal":o.metal_f0=V(N(s,"metal_f0",new THREE.Color(1,0,0))),f.metal_f0_map=z(s,"colors","metal_f0",null);break;case"PrismLayered":o.layered_bottom_f0=V(N(s,"layered_bottom_f0",new THREE.Color(1,1,1))),f.layered_bottom_f0_map=z(s,"colors","layered_bottom_f0",null),o.layered_diffuse=V(N(s,"layered_diffuse",new THREE.Color(1,0,0))),f.layered_diffuse_map=z(s,"colors","layered_diffuse",null),o.layered_anisotropy=P(s,"scalars","layered_anisotropy",0),f.layered_anisotropy_map=z(s,"scalars","layered_anisotropy",null),o.layered_f0=P(s,"scalars","layered_f0",0),f.layered_f0_map=z(s,"scalars","layered_f0",null),o.layered_fraction=P(s,"scalars","layered_fraction",0),f.layered_fraction_map=z(s,"scalars","layered_fraction",null),o.layered_rotation=P(s,"scalars","layered_rotation",0),f.layered_rotation_map=z(s,"scalars","layered_rotation",null),o.layered_roughness=P(s,"scalars","layered_roughness",0),f.layered_roughness_map=z(s,"scalars","layered_roughness",null),f.layered_normal_map=z(s,"textures","layered_normal",null);break;case"PrismTransparent":o.transparent_color=V(N(s,"transparent_color",new THREE.Color(1,0,0))),o.transparent_distance=P(s,"scalars","transparent_distance",0),o.transparent_ior=P(s,"scalars","transparent_ior",0),o.transparent=!0;break;case"PrismGlazing":o.glazing_f0=V(N(s,"glazing_f0",new THREE.Color(1,1,1))),f.glazing_f0_map=z(s,"colors","glazing_f0",null),o.glazing_transmission_color=V(N(s,"glazing_transmission_color",new THREE.Color(1,1,1))),f.glazing_transmission_color_map=z(s,"colors","glazing_transmission_color",null),o.glazing_transmission_roughness=I(s,"glazing_transmission_roughness",0),f.glazing_transmission_roughness_map=z(s,"scalars","glazing_transmission_roughness",null),o.side=P(s,"booleans","glazing_backface_culling",!1)?THREE.FrontSide:THREE.DoubleSide,o.transparent=!0;break;case"PrismWood":W(o,s,"wood_fiber_cosine"),W(o,s,"wood_fiber_perlin"),o.wood_fiber_perlin_scale_z=P(s,"scalars","wood_fiber_perlin_scale_z",0),W(o,s,"wood_growth_perlin"),o.wood_latewood_ratio=P(s,"scalars","wood_latewood_ratio",0),o.wood_earlywood_sharpness=P(s,"scalars","wood_earlywood_sharpness",0),o.wood_latewood_sharpness=P(s,"scalars","wood_latewood_sharpness",0),o.wood_ring_thickness=P(s,"scalars","wood_ring_thickness",0),W(o,s,"wood_earlycolor_perlin"),o.wood_early_color=V(N(s,"wood_early_color",new THREE.Color(1,0,0))),o.wood_use_manual_late_color=P(s,"booleans","wood_use_manual_late_color",0),o.wood_manual_late_color=V(N(s,"wood_manual_late_color",new THREE.Color(1,0,0))),W(o,s,"wood_latecolor_perlin"),o.wood_late_color_power=P(s,"scalars","wood_late_color_power",0),W(o,s,"wood_diffuse_perlin"),o.wood_diffuse_perlin_scale_z=P(s,"scalars","wood_diffuse_perlin_scale_z",0),o.wood_use_pores=P(s,"booleans","wood_use_pores",0),o.wood_pore_type=P(s,"choicelists","wood_pore_type",0),o.wood_pore_radius=P(s,"scalars","wood_pore_radius",0),o.wood_pore_cell_dim=P(s,"scalars","wood_pore_cell_dim",0),o.wood_pore_color_power=P(s,"scalars","wood_pore_color_power",0),o.wood_pore_depth=P(s,"scalars","wood_pore_depth",0),o.wood_use_rays=P(s,"booleans","wood_use_rays",0),o.wood_ray_color_power=P(s,"scalars","wood_ray_color_power",0),o.wood_ray_seg_length_z=P(s,"scalars","wood_ray_seg_length_z",0),o.wood_ray_num_slices=P(s,"integers","wood_ray_num_slices",0),o.wood_ray_ellipse_z2x=P(s,"scalars","wood_ray_ellipse_z2x",0),o.wood_ray_ellipse_radius_x=P(s,"scalars","wood_ray_ellipse_radius_x",0),o.wood_use_latewood_bump=P(s,"booleans","wood_use_latewood_bump",0),o.wood_latewood_bump_depth=P(s,"scalars","wood_latewood_bump_depth",0),o.wood_use_groove_roughness=P(s,"booleans","wood_use_groove_roughness",0),o.wood_groove_roughness=P(s,"scalars","wood_groove_roughness",0),o.wood_diffuse_lobe_weight=P(s,"scalars","wood_diffuse_lobe_weight",0),o.wood_curly_distortion_enable=P(s,"booleans","wood_curly_distortion_enable",0),o.wood_curly_distortion_scale=P(s,"scalars","wood_curly_distortion_scale",0),f.wood_curly_distortion_map=z(s,"scalars","wood_curly_distortion_map",null),H||function(){var e=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],n=new Uint8Array(e),o=new THREE.DataTexture(n,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);o.generateMipmaps=!1,o.flipY=!1,o.needsUpdate=!0;var a=new Uint8Array([225,39,122,231,29,173,15,159,75,88,233,19,179,79,72,94,54,73,151,161,171,113,221,144,127,83,168,19,88,122,62,225,109,128,246,247,172,101,61,139,211,168,64,210,224,82,87,97,119,250,201,44,242,239,154,99,126,13,44,70,246,170,100,52,135,28,187,22,207,119,199,1,235,187,55,131,190,124,222,249,236,53,225,231,71,30,173,185,153,47,79,133,225,10,140,62,17,99,100,29,137,95,142,244,76,5,83,124,38,216,253,195,44,210,148,185,188,39,78,195,132,30,60,73,92,223,133,80,230,56,118,207,79,15,251,211,111,21,79,23,240,146,150,207,3,61,103,27,148,6,31,127,235,58,173,244,116,81,34,120,192,213,188,226,97,23,16,161,106,80,242,148,35,37,91,117,51,216,97,193,126,222,39,38,133,217,215,23,237,57,205,42,222,165,126,133,33,8,227,154,27,18,56,11,192,120,80,92,236,38,210,207,128,31,135,39,123,5,49,127,107,200,34,14,153,239,134,19,248,162,58,201,159,198,243,158,72,5,138,184,222,200,34,141,233,40,195,238,191,122,171,32,66,254,229,197]),t=new THREE.DataTexture(a,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);t.generateMipmaps=!1,t.flipY=!1,t.needsUpdate=!0;for(var r,i,l,s,f,d,c,u,_=function(n){return e[n%256]},p=new Array(262144),m=0;m<256;++m)for(u=0;u<256;++u)r=_(u)+m,i=_(r),l=_(r+1),s=_(u+1)+m,f=_(s),d=_(s+1),p[c=4*(256*m+u)]=i,p[c+1]=l,p[c+2]=f,p[c+3]=d;var v=new Uint8Array(p),g=new THREE.DataTexture(v,256,256,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);g.generateMipmaps=!1,g.flipY=!1,g.needsUpdate=!0;var h=[1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1,1,1,0,0,-1,1,-1,1,0,0,-1,-1],y=new Array(1024);for(u=0;u<256;++u){var w=e[u]%16;y[4*u]=127*h[3*w]+128,y[4*u+1]=127*h[3*w+1]+128,y[4*u+2]=127*h[3*w+2]+128,y[4*u+3]=0}var x=new Uint8Array(y),T=new THREE.DataTexture(x,256,1,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);T.generateMipmaps=!1,T.flipY=!1,T.needsUpdate=!0,H={permutation:o,gradient:t,perm2D:g,permGrad:T}}(),o.uniforms.permutationMap.value=H.permutation,o.uniforms.gradientMap.value=H.gradient,o.uniforms.perm2DMap.value=H.perm2D,o.uniforms.permGradMap.value=H.permGrad;break;default:THREE.warn("Unknown prism type: "+o.prismType)}for(var d in o.enableImportantSampling&&(o.surface_anisotropy||o.surface_rotation||o.layered_anisotropy||o.layered_rotation)&&(L||function(){var e=new Uint8Array([0,128,64,191,32,160,96,223,16,143,80,207,48,175,112,239,8,135,72,199,40,167,103,231,25,151,88,215,56,183,120,250]),n=new THREE.DataTexture(e,32,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);n.generateMipmaps=!1,n.flipY=!1,n.needsUpdate=!0;for(var o,a,t=function(e,n){return Math.atan2(e*n,Math.sqrt(e*e+n*n+1))},r=new Uint8Array(16384),i=0;i<128;++i)for(var l=0;l<128;++l){o=i/128*2-1,a=l/128*2-1;var s=(o=Math.min(Math.max(1/128-1,o),1-1/128))-1/128,f=o+1/128,d=(a=Math.min(Math.max(1/128-1,a),1-1/128))-1/128,c=a+1/128,u=t(f,c)-t(s,c)-t(f,d)+t(s,d);r[128*i+l]=1e6*u}var _=new THREE.DataTexture(r,128,128,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);_.generateMipmaps=!1,_.flipY=!1,_.needsUpdate=!0,L={randomNum:n,solidAngle:_}}(),o.uniforms.importantSamplingRandomMap.value=L.randomNum,o.uniforms.importantSamplingSolidAngleMap.value=L.solidAngle),o.defines={},o.textureMaps={},f)if(f[d]){var c=t[f[d]];l=c.properties,c.matrix=te(c,!0,n);var u="BumpMap"==c.definition?"bumpmap_Bitmap":"unifiedbitmap_Bitmap",_=l.uris[u].values,m=_[0];m&&(i={mapName:d,uri:m,uriPointer:_,textureObj:c,isPrism:!0},o.textureMaps[i.mapName]=i,o.defines["USE_"+d.toUpperCase()]="")}return o.defines[o.prismType.toUpperCase()]="","PrismWood"==o.prismType&&o.enable3DWoodBump&&(o.defines.PRISMWOODBUMP=""),o.enableImportantSampling&&(o.defines.ENABLEIMPORTANTSAMPLING=""),o}function q(e,n){if(0!==n.randomOffsetMode){e.tilingRandomAxisS=new THREE.Vector2,e.tilingRandomAxisT=new THREE.Vector2,e.tilingRandomAlignmentOffset=new THREE.Vector2;var o=e.tilingRandomAxisS;o.set(1,0);var a=e.tilingRandomAxisT;a.set(0,1);var t=e.tilingRandomAlignmentOffset;t.set(0,0);var r=new THREE.Matrix4,i=new THREE.Matrix4,l=function(e){var n=["opaque_albedo_map","opaque_f0_map","layered_diffuse_map","layered_bottom_f0_map","surface_roughness_map","surface_normal_map","surface_albedo_map","surface_anisotropy_map","surface_cutout_map"];if(void 0!==e.textureMaps)for(var o=0;o<n.length;++o)if(void 0!==e.textureMaps[n[o]]&&void 0!==e.textureMaps[n[o]].textureObj&&void 0!==e.textureMaps[n[o]].textureObj.matrix){var a=e.textureMaps[n[o]].textureObj.matrix.elements,t=new THREE.Matrix4;return t.set(a[0],a[1],0,a[2],a[3],a[4],0,a[5],0,0,1,0,a[6],a[7],0,a[8]),t}return new THREE.Matrix4}(e),s=function(e,n){var o=new THREE.Matrix4;o.makeScale(n.x,n.y,1);var a=new THREE.Matrix4;return a.makeTranslation(-e.x,-e.y,0),o.multiply(a),o}(new THREE.Vector2(0,1),new THREE.Vector2(1,-1));s.multiply(l),l.copy(s),r.multiplyMatrices(l,e.tilingUVTransform),i.getInverse(r);var f=new THREE.Vector4(1,0,0,0).applyMatrix4(i);o.set(f.x,f.y),f=new THREE.Vector4(0,1,0,0).applyMatrix4(i),a.set(f.x,f.y);for(var d=new THREE.Vector2,c=new THREE.Box2,u=n.alignedVertices,_=0;_<u.length;_++)f.set(u[_].x,u[_].y,0,1),f.applyMatrix4(r),d.set(f.x,f.y),c.expandByPoint(d);f.set(-c.min.x,-c.min.y,0,0),f.applyMatrix4(i),t.set(f.x,f.y);var p=c.size(),m=1===n.randomOffsetMode?new THREE.Vector2(p.x,p.y):new THREE.Vector2(0,0);o.multiplyScalar(1-m.x),a.multiplyScalar(1-m.y)}}function k(e,n,o,a,t){var r,i,l=n.properties,s={overallTransform:new THREE.Matrix4,insetSize:0,hasRoundCorner:!1,cornerRoundingAngle:0,cornerRoundingSize:0,offsetVectorA:new THREE.Vector2,offsetVectorB:new THREE.Vector2},f=new THREE.Vector2(O(l,"scale_factor_x",t,1),O(l,"scale_factor_y",t,1)),d=O(l,"overall_offset_vector_x",t,1),c=O(l,"overall_offset_vector_y",t,1),u=I(l,"overall_rotation_angle",0)*Math.PI/180;!function(e,n,o,a){e.scale(a);var t=new THREE.Vector3(Math.sin(o.x),Math.sin(o.y),Math.sin(o.z)),r=new THREE.Vector3(Math.cos(o.x),Math.cos(o.y),Math.cos(o.z)),i=t.y*t.x,l=t.y*r.x,s=new THREE.Matrix4;s.set(r.z*r.y,t.z*r.y,-t.y,0,r.z*i-t.z*r.x,t.z*i+r.z*r.x,r.y*t.x,0,r.z*l+t.z*t.x,t.z*l-r.z*t.x,r.y*r.x,0,0,0,0,1),s.multiply(e),e.makeTranslation(n.x,n.y,n.z),e.multiply(s)}(s.overallTransform,new THREE.Vector3(-d,-c,0),new THREE.Vector3(0,0,-u),new THREE.Vector3(1,1,1)),s.insetSize=O(l,"inset_size",t,1),s.cornerRoundingAngle=I(l,"overall_corner_rounding_angle",0)*Math.PI/180,s.cornerRoundingSize=O(l,"overall_corner_rounding_size",t,1),s.offsetVectorA.x=I(l,"offset_vector_a_x",0)*f.x,s.offsetVectorA.y=I(l,"offset_vector_a_y",0)*f.y,s.offsetVectorB.x=I(l,"offset_vector_b_x",0)*f.x,s.offsetVectorB.y=I(l,"offset_vector_b_y",0)*f.y,s.hasRoundCorner=s.cornerRoundingAngle>0&&s.cornerRoundingSize>0;var _=[];for(r=0,i=o.length;r<i;r++){var p=o[r].properties,m={material:a[r].material,randomOffsetMode:0,rotation:0,vertices:[]};_[r]=m,m.randomOffsetMode=P(p,"choicelists","random_offset_mode",0),m.rotation=I(p,"rotation_angle",0)*Math.PI/180;for(var v=p.scalars.vertices.values,g=0;g<v.length;g+=2)m.vertices[g/2]=new THREE.Vector2(v[g],v[g+1]);for(var h=0;h<m.vertices.length;h++)m.vertices[h].multiply(f);m.material.useRandomOffset=0!=m.randomOffsetMode}!function(e,n){var o=new THREE.Box2;o.expandByPoint(new THREE.Vector2(0,0)),o.expandByPoint(e.offsetVectorA),o.expandByPoint(e.offsetVectorB);var a,t,r=new THREE.Vector2(e.offsetVectorA.x,e.offsetVectorA.y);for(r.add(e.offsetVectorB),o.expandByPoint(r),a=0,t=n.length;a<t;a++){var i=n[a];i.material.tilingRepeatRange=[],$(e,i,i.material.tilingRepeatRange),i.bbox=new THREE.Box2;for(var l=0;l<i.vertices.length;++l)i.bbox.expandByPoint(i.vertices[l]);oe(e,i),e.hasRoundCorner&&Z(e,i),i.material.useRandomOffset&&J(i,a),i.alignedVertices=[];for(var s=0;s<i.vertices.length;++s){var f=new THREE.Vector2(i.vertices[s].x,i.vertices[s].y);f.sub(i.bbox.min),i.alignedVertices.push(f)}i.material.tileAlignOffset=new THREE.Vector2(-i.bbox.min.x,-i.bbox.min.y)}}(s,_);var y,w,x,T,R=ee([s.offsetVectorA.clone(),s.offsetVectorB.clone()]);for(r=0,i=_.length;r<i;r++){var E=_[r],M=E.material;M.tilingOverallTransform=s.overallTransform,M.hasRoundCorner=s.hasRoundCorner,M.tilingUVTransform=(y=E.rotation,w=void 0,x=void 0,T=void 0,w=Math.sin(y),x=Math.cos(y),(T=new THREE.Matrix4).set(x,-w,0,0,w,x,0,0,0,0,1,0,0,0,0,1),T),M.useRandomOffset&&q(M,E),M.tile2uv=new THREE.Vector4(s.offsetVectorA.x,s.offsetVectorA.y,s.offsetVectorB.x,s.offsetVectorB.y),M.uv2tile=new THREE.Vector4(R[0].x,R[0].y,R[1].x,R[1].y)}}function j(e,n,o){var a=new THREE.Vector2(o.x,o.y).sub(n),t=new THREE.Vector2(e.x,e.y).sub(n),r=a.dot(t);if(r<=0)return t.length();var i=a.dot(a);return r>=i?new THREE.Vector2(e).sub(o).length():Math.sqrt(Math.max(t.dot(t)-r*r/i,0))}function X(e,n){for(var o=1e11,a=o,t=-1,r=0;r<e.vertices.length;r++){var i=r==e.vertices.length-1?0:r+1;(a=j(n,e.vertices[r],e.vertices[i]))<o&&(o=a,t=r)}return[o,t]}function Y(e,n,o){for(var a=e.length,t=a-1,r=!1,i=0;i<a;++i)(e[i].y<o&&e[t].y>=o||e[t].y<o&&e[i].y>=o)&&e[i].x+(o-e[i].y)/(e[t].y-e[i].y)*(e[t].x-e[i].x)<n&&(r=!r),t=i;return r}function Z(e,n){var o=n.bbox.size(),a=2*e.cornerRoundingSize*.7071/3,t=ne(Math.ceil(o.x/a)+2,128,1024),r=ne(Math.ceil(o.y/a)+2,128,1024);t-=2,r-=2,o.x<o.y?r=Math.floor(t*o.y/o.x):t=Math.floor(r*o.x/o.y),t+=2,r+=2,function(e,n){e.normalToEdges=[];for(var o=e.vertices.length,a=Math.cos(n),t=Math.sin(n),r=0;r<o;++r){var i=r,l=r==o-1?0:r+1,s=new THREE.Vector2(e.vertices[l].x,e.vertices[l].y);s.sub(e.vertices[i]),s.normalize();var f=new THREE.Vector3(s.y*t,-s.x*t,a);e.normalToEdges.push(f)}e.cornerRoundingAngle=n}(n,e.cornerRoundingAngle);for(var i=new Uint8Array(t*r*4),l=new THREE.Vector2(o.x/(t-2),o.y/(r-2)),s=new THREE.Vector2,f=new THREE.Vector3,d=new THREE.Vector3(0,0,1),c=0,u=0;u<r;u++){s.y=(r-u-1.5)*l.y+n.bbox.min.y;for(var _=0;_<t;_++){s.x=(_-.5)*l.x+n.bbox.min.x;var p=X(n,s),m=p[0],v=p[1];m<e.cornerRoundingSize+e.insetSize?(Y(n.vertices,s.x,s.y)||(m=-m),f.copy(n.normalToEdges[v]),f.lerp(d,(m-e.insetSize)/e.cornerRoundingSize),f.normalize(),i[c++]=255*ne(.5*(f.x+1),0,1),i[c++]=255*ne(.5*(f.y+1),0,1),i[c++]=255*ne(.5*(f.z+1),0,1),i[c++]=255):(i[c++]=127,i[c++]=127,i[c++]=255,i[c++]=255)}}n.material.TilingNormalMap=new THREE.DataTexture(i,t,r,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.LinearFilter,THREE.LinearFilter),n.material.TilingNormalMap.needsUpdate=!0;var g=new THREE.Vector2(-n.bbox.min.x,-n.bbox.min.y);n.material.TilingNormalMap_texMatrix=new THREE.Matrix3,n.material.TilingNormalMap_texMatrix.set(1/o.x*(t-2)/t,0,0,0,1/o.y*(r-2)/r,0,g.x/o.x*(t-2)/t+1/t,g.y/o.y*(r-2)/r+1/r,1),n.material.TilingNormalMap_texMatrix.transpose()}function Q(e,n){return e<<n|e>>>32-n}function K(e,n){var o,a,t;return o=a=t=3735928567+n,a+=e.y,function(e,n,o){var a=4294967296;return o=((o^=n)-Q(n,14)+a)%a,o=((o^=n=((n^=e=((e^=o)-Q(o,11)+a)%a)-Q(e,25)+a)%a)-Q(n,16)+a)%a,o=((o^=n=((n^=e=((e^=o)-Q(o,4)+a)%a)-Q(e,14)+a)%a)-Q(n,24)+a)%a}(o+=e.x,a,t)}function J(e,n){for(var o,a,t=new Uint8Array(1048576),r=new THREE.Vector2,i=new THREE.Vector2(107021*n,n),l=new THREE.Vector2,s=new THREE.Vector2,f=0,d=0;d<512;d++){r.y=Math.floor(-(d+1-256));for(var c=0;c<512;c++)r.x=Math.floor(c-256),l.copy(r),l.add(i),o=s,a=void 0,a=K(l,33),o.x=(65535&a)>>>8,o.y=a>>>16>>>8,t[f++]=0,t[f++]=0,t[f++]=s.x,t[f++]=s.y}e.material.TilingRandomMap=new THREE.DataTexture(t,512,512,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter),e.material.TilingRandomMap.needsUpdate=!0;new THREE.Vector2(-e.bbox.min.x,-e.bbox.min.y);e.material.TilingRandomMap_texMatrix=new THREE.Matrix3,e.material.TilingRandomMap_texMatrix.set(1/512,0,0,0,1/512,0,.5,.5,1),e.material.TilingRandomMap_texMatrix.transpose()}function $(e,n,o){var a=[];a[0]=new THREE.Vector2(e.offsetVectorA.x,e.offsetVectorB.x),a[1]=new THREE.Vector2(e.offsetVectorA.y,e.offsetVectorB.y);for(var t=ee(a),r=new THREE.Box2,i=new THREE.Vector2,l=0;l<n.vertices.length;++l)i.x=n.vertices[l].dot(t[0]),i.y=n.vertices[l].dot(t[1]),r.expandByPoint(i);o[0]=Math.floor(r.min.x-1),o[2]=Math.ceil(r.max.x),o[1]=Math.floor(r.min.y-1),o[3]=Math.ceil(r.max.y)}function ee(e){var n=e[0].x*e[1].y-e[0].y*e[1].x,o=[];return o[0]=new THREE.Vector2(e[1].y/n,-e[0].y/n),o[1]=new THREE.Vector2(-e[1].x/n,e[0].x/n),o}function ne(e,n,o){return e>o?o:e<n?n:e}function oe(e,n){var o=new S;!function(e,n){for(var o=e.addBlankContour(),a=new THREE.Vector2,t=new THREE.Vector2,r=0;r<n.vertices.length;++r){var i=r,l=(r+1)%n.vertices.length;a=n.vertices[i],t=n.vertices[l],o.addEdge(new y(a,t,7))}e.initialize(),e.edgeColoringSimple(3,0)}(o,n);for(var a=n.bbox.size(),t=.7071*o.minSameColoredEdgeDistance()*.5,r=ne(Math.ceil(a.x/t)+2,16,512),i=ne(Math.ceil(a.y/t)+2,16,512),l=new Uint8Array(r*i*4),s=new THREE.Vector2(a.x/(r-2),a.y/(i-2)),f=(new THREE.Vector2(s.x*r,s.y*i),.5/(s.x+s.y)),d=new THREE.Vector2,c=new THREE.Vector3,u=0,_=0;_<i;_++){d.y=(i-_-1.5)*s.y+n.bbox.min.y;for(var p=0;p<r;p++)d.x=(p-.5)*s.x+n.bbox.min.x,c=(c=o.calculateMSDFValue(d)).add(new THREE.Vector3(e.insetSize,e.insetSize,e.insetSize)),l[u++]=255*ne(c.x*f+.5,0,1),l[u++]=255*ne(c.y*f+.5,0,1),l[u++]=255*ne(c.z*f+.5,0,1),l[u++]=0}n.material.TilingMap=new THREE.DataTexture(l,r,i,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.LinearFilter,THREE.LinearFilter),n.material.TilingMap.needsUpdate=!0;var m=new THREE.Vector2(-n.bbox.min.x,-n.bbox.min.y);n.material.TilingMap_texMatrix=new THREE.Matrix3,n.material.TilingMap_texMatrix.set(1/a.x*(r-2)/r,0,0,0,1/a.y*(i-2)/i,0,m.x/a.x*(r-2)/r+1/r,m.y/a.y*(i-2)/i+1/i,1),n.material.TilingMap_texMatrix.transpose()}function ae(e,n,o){var a=e.properties;n.clampS=!P(a,"booleans","texture_URepeat",!1),n.clampT=!P(a,"booleans","texture_VRepeat",!1),n.wrapS=n.clampS?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,n.wrapT=n.clampT?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,n.matrix=e.matrix||(e.matrix=U(a,o)),"UnifiedBitmap"==e.definition&&(n.invert=P(a,"booleans","unifiedbitmap_Invert",!1)),"BumpMap"==e.definition&&(n.bumpmapType=P(a,"choicelists","bumpmap_Type",0),n.bumpScale=function(e,n,o){if(0===n){var a=O(e,"bumpmap_Depth",o,0),t=1,r=1;return null!=P(e,"scalars","texture_RealWorldScale")?t=r=O(e,"texture_RealWorldScale",o,1):(t=O(e,"texture_RealWorldScaleX",o,1),r=O(e,"texture_RealWorldScaleY",o,1)),t=0===t?1:1/t,r=0===r?1:1/r,new THREE.Vector2(t*a,r*a)}var i=P(e,"scalars","bumpmap_NormalScale",1);return new THREE.Vector2(i,i)}(a,n.bumpmapType,o))}function te(e,n,o){return e.matrix||(e.matrix=U(e.properties,o)),e.matrix}function re(e){return(re="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ie(e,n){for(var o=0;o<n.length;o++){var a=n[o];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function le(e,n){return!n||"object"!==re(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function se(e){return(se=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function fe(e,n){return(fe=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function de(e,n){for(var o in e)n[o]=e[o]}var ce=Autodesk.Viewing;de(t,AutodeskNamespace("Autodesk.Viewing.MaterialConverterPrism")),de(a,ce.Private);var ue=function(e){function n(e,o){return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),le(this,se(n).call(this,e,o))}var o,a,t;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&fe(e,n)}(n,e),o=n,(a=[{key:"load",value:function(){return!0}},{key:"unload",value:function(){return!0}},{key:"activate",value:function(){return!0}},{key:"deactivate",value:function(){return!1}}])&&ie(o.prototype,a),t&&ie(o,t),n}(ce.Extension);ce.theExtensionManager.registerExtension("Autodesk.Viewing.MaterialConverterPrism",ue)},8:function(e,n,o){"use strict";o.d(n,"b",(function(){return t})),o.d(n,"a",(function(){return r}));var a=o(0);function t(e){var n=e+"_texMatrix",o=e+"_invert",t={};return t[e]={type:"t",value:null},t[n]={type:"m3",value:new a.Matrix3},t[o]={type:"i",value:0},t}function r(e){var n=e+"_texMatrix",o=e+"_bumpScale",t=e+"_bumpmapType",r={};return r[e]={type:"t",value:null},r[n]={type:"m3",value:new a.Matrix3},r[o]={type:"v2",value:new a.Vector2(1,1)},r[t]={type:"i",value:0},r}}});
//# sourceMappingURL=MaterialConverterPrism.min.js.map