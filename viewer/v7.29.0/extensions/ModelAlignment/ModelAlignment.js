/*!
 * LMV v7.29.0
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelAlignment =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelAlignment/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/ModelAlignment/AngleToAngle.js":
/*!***************************************************!*\
  !*** ./extensions/ModelAlignment/AngleToAngle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleToAngle; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
// Controls the user interaction workflow for rotating a model by selecting center point and two directions.

var Events = {
  CENTER_SELECTED: 'centerSelected',
  CENTER_HOVERED: 'centerHovered',

  // from/to angle: event.angle contains the angle in degrees.
  FROM_ANGLE_SELECTED: 'startAngleSelected',
  FROM_ANGLE_HOVERED: 'startAngleHovered',
  TO_ANGLE_SELECTED: 'endAngleSelected',
  TO_ANGLE_HOVERED: 'endAngleHovered' };


var Modes = {
  NotSelecting: 0,
  SelectingCenter: 1,
  SelectingStartAngle: 2,
  SelectingEndAngle: 3,
  SelectingStartAngleEdge: 4,
  SelectingEndAngleEdge: 5 };


var PickingModes = {
  SinglePoint: 0,
  Edge: 1 };


var tmpMatrix1 = new THREE.Matrix4();
var tmpMatrix2 = new THREE.Matrix4();
var tmpMatrix3 = new THREE.Matrix4();
var tmpQuat = new THREE.Quaternion();
var tmpVec = new THREE.Vector3();var

AngleToAngle = /*#__PURE__*/function () {

  function AngleToAngle(viewer, coordPicker, screenOverlay) {var _this = this;_classCallCheck(this, AngleToAngle);

    var CoordPicker = Autodesk.Edit3D.CoordPicker;
    var PointMarker = Autodesk.Edit3D.PointMarker;
    var TwoPointPicker = Autodesk.Edit3D.TwoPointPicker;

    this.viewer = viewer;
    this.coordPicker = coordPicker;

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.mode = Modes.NotSelecting;
    this.defaultPickingMode = PickingModes.Edge;

    // Points that define the rotation. Note that these points are optional, because the rotation may also be defined 
    // just by fromAngle and toAngle or just by offset alone.
    this.center = new THREE.Vector3(); // rotation center
    this.fromPoint = new THREE.Vector3(); // point that determined fromDirection
    this.toPoint = new THREE.Vector3(); // point that determined toDirection

    this.centerValid = false;
    this.fromValid = false;
    this.toValid = false;

    // Projections of fromPoint/toPoint on the selectionPlane. Used for gizmo placement
    this.fromPointOnPlane = new THREE.Vector3();
    this.toPointOnPlane = new THREE.Vector3();

    // One marker per point
    this.centerMarker = new PointMarker(this.viewer, undefined, 'Pivot', PointMarker.Icons.Cross);
    this.fromMarker = new PointMarker(this.viewer, undefined, 'From', PointMarker.Icons.Empty);
    this.toMarker = new PointMarker(this.viewer, undefined, 'To', PointMarker.Icons.Empty);

    this.centerMarker.addEventListener(PointMarker.Events.DRAG_START, function () {_this.startSelectCenter(true);});
    this.centerMarker.addEventListener(PointMarker.Events.DRAG_END, function (event) {return _this.onDragCenterEnd(event);});

    this.centerMarker.setColor('rgb(0, 0, 0)');

    this.angleGizmo = new Autodesk.Edit2D.AngleGizmo3d(this.viewer, {
      startColor: Autodesk.Edit3D.NPointPicker.Colors.Blue,
      endColor: Autodesk.Edit3D.NPointPicker.Colors.Red });


    // AngleGizmo is always visible, because it hides itself anyway if the required points are not specified yet.
    this.angleGizmo.setVisible(true);

    // Rotation axis
    this.axis = new THREE.Vector3(0, 0, 1);

    // The plane in which we have to choose points to specify startAngle and endAngle. 
    this.selectionPlane = new THREE.Plane();

    // {Autodesk.Edit2D.ScreenOverlay}
    this.screenOverlay = screenOverlay;

    // Lines to connect selected from/to points with their projections to the selection plane
    this.fromConnector = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();
    this.toConnector = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();

    // Configure line style for connectors
    var style = this.fromConnector.line2D.style;
    style.lineStyle = 10; // dashed line (see LineStyleDef.js)
    style.lineWidth = 1.5;
    style.lineColor = 'rgb(255, 0, 0)';
    style.lineOpacity = 0.7;

    // Apply same style to toConnector
    this.toConnector.line2D.style.copy(style);

    // Duration of the rotation animation in seconds
    this.animTime = 1.5;

    // Determines when (within the rotation animation) we start to fade-out the angle gizmo
    // Value is in [0,1], where 0="at anim start", 1="at anim end". 
    this.fadeOutAngleGizmoAfter = 0.7;

    // If false, we hide all gizmos
    this.visible = true;

    this.onDragEdgeEnd = this.onDragEdgeEnd.bind(this);

    var edgePickerOptions = {
      draggable: true,
      icons: [Autodesk.Edit3D.PointMarker.Icons.Cross, Autodesk.Edit3D.PointMarker.Icons.Empty],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Blue],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Arrow,
        color: Autodesk.Edit3D.NPointPicker.Colors.Blue,
        getEdgeLabelText: function getEdgeLabelText() {
          if (!_this.fromValid) {
            return '';
          }

          var angle = _this.pointToAngle(_this.fromPoint, true);
          var text = angle.toFixed(1) + "°";

          return text;
        } }] };




    this.fromEdgePicker = new TwoPointPicker(viewer, coordPicker, screenOverlay, edgePickerOptions);

    this.fromEdgePicker.addEventListener(TwoPointPicker.Events.TO_POINT_SELECTED, function () {return _this.onEdgeSelected(_this.fromEdgePicker);});
    this.fromEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingStartAngleEdge;});
    this.fromEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingStartAngleEdge;});
    this.fromEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);
    this.fromEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);
    this.fromEdgePicker.getEdgeLabelText = function () {
      if (!_this.fromValid) {
        return '';
      }

      var angle = _this.pointToAngle(_this.fromPoint, true);
      var text = angle.toFixed(1) + "°";

      return text;
    };

    edgePickerOptions = {
      draggable: true,
      icons: [Autodesk.Edit3D.PointMarker.Icons.Cross, Autodesk.Edit3D.PointMarker.Icons.Empty],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Red, Autodesk.Edit3D.NPointPicker.Colors.Red],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Arrow,
        color: Autodesk.Edit3D.NPointPicker.Colors.Red,
        getEdgeLabelText: function getEdgeLabelText() {
          if (!_this.toValid) {
            return '';
          }

          var angle = _this.pointToAngle(_this.toPoint, true);
          var text = angle.toFixed(1) + "°";

          return text;
        } }] };




    this.toEdgePicker = new TwoPointPicker(viewer, coordPicker, screenOverlay, edgePickerOptions);
    this.toEdgePicker.addEventListener(TwoPointPicker.Events.TO_POINT_SELECTED, function () {return _this.onEdgeSelected(_this.toEdgePicker);});
    this.toEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingEndAngleEdge;});
    this.toEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_START, function () {_this.mode = Modes.SelectingEndAngleEdge;});
    this.toEdgePicker.markers[0].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);
    this.toEdgePicker.markers[1].addEventListener(PointMarker.Events.DRAG_END, this.onDragEdgeEnd);

    // bind CoordPicker listeners
    this.onPointClicked = this.onPointClicked.bind(this);
    this.onPointHovered = this.onPointHovered.bind(this);
    this.coordPicker.addEventListener(CoordPicker.Events.POINT_CLICKED, this.onPointClicked);
    this.coordPicker.addEventListener(CoordPicker.Events.POINT_HOVERED, this.onPointHovered);
    this.coordPicker.addEventListener(CoordPicker.Events.ESCAPE, function () {return _this.cancelPointSelection();});

    // Initially, all markers are hidden
    this.updateGizmos();
  }_createClass(AngleToAngle, [{ key: "dtor", value: function dtor()

    {
      this.coordPicker.removeEventListener(Autodesk.Edit3D.CoordPicker.Events.POINT_CLICKED, this.onPointClicked);
      this.coordPicker.removeEventListener(Autodesk.Edit3D.CoordPicker.Events.POINT_HOVERED, this.onPointHovered);
    } }, { key: "startSelectCenter", value: function startSelectCenter(

    enableDrag) {

      // When selecting a new center, we clear from/to points. Otherwise it looks confusing if they keep connected during dragging.
      this.clear();
      this.isActive = true;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.centerValid ? this.center.clone() : null;

      this.viewer.toolController.activateTool(this.coordPicker.getName());
      this.mode = Modes.SelectingCenter;

      if (enableDrag) {
        this.coordPicker.setDragging(true);
      }

      this.centerMarker.setDraggable(enableDrag);
    } }, { key: "startCoordPicker", value: function startCoordPicker(

    selectOnPlane) {

      // If wanted, restrict selection to the selectionPlane and disable snapping.
      // TODO: Find a way how to still support reasonable snapping for this case.
      //this.coordPicker.setSelectionPlane(selectOnPlane && this.selectionPlane);
      //this.coordPicker.setSnapperEnabled(!selectOnPlane);

      this.viewer.toolController.activateTool(this.coordPicker.getName());
    } }, { key: "endCoordPicker", value: function endCoordPicker()

    {
      // Clear selection plane (if any)
      //this.coordPicker.setSelectionPlane(null);

      // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and
      //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.
      this.viewer.toolController.setIsLocked(false);
      this.viewer.toolController.deactivateTool(this.coordPicker.getName());
    } }, { key: "onDragCenterEnd", value: function onDragCenterEnd(_ref)

    {var event = _ref.event;
      if (!this.coordPicker.getDragging()) {
        return;
      }

      this.coordPicker.handleSingleClick(event, 0);
      this.coordPicker.setDragging(false);
    } }, { key: "onDragEdgeEnd", value: function onDragEdgeEnd()

    {
      this.mode = Modes.NotSelecting;
      this.continuePointSelectionIfNeeded();
    } }, { key: "startSelectFromAngle", value: function startSelectFromAngle(

    enableDrag) {
      this.startCoordPicker(true);
      this.mode = Modes.SelectingStartAngle;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.fromValid ? this.fromPoint.clone() : null;
    } }, { key: "startSelectToAngle", value: function startSelectToAngle(

    enableDrag) {
      this.startCoordPicker(true);
      this.mode = Modes.SelectingEndAngle;

      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.
      this.pointBackup = this.toValid ? this.toPoint.clone() : null;
    } }, { key: "setCenter", value: function setCenter(

    center) {
      if (center) {
        this.center.copy(center);
        this.centerValid = true;

        // Adjust plane to be contain the center.
        this.selectionPlane.setFromNormalAndCoplanarPoint(this.axis, this.center);

      } else {
        this.centerValid = false;
      }
      this.updateGizmos();
    }

    // Set fromPoint that defines the start direction.
  }, { key: "setFromPoint", value: function setFromPoint(from) {

      this.fromValid = !!from;

      if (this.fromValid) {
        this.fromPoint.copy(from);
      }

      this.updateGizmos();
    } }, { key: "setToPoint", value: function setToPoint(

    to) {
      this.toValid = !!to;

      if (this.toValid) {
        this.toPoint.copy(to);
      }

      this.updateGizmos();
    }

    // Derive angle from center and selected to-Point
    //  @param {Vector3} p
    //  @param {bool}    convertToDegrees - Used for UI events
    //  @returns angle in radians (or optionally in degrees)
    //
    // Todo: This needs to be generalized when we support different rotation axes.
  }, { key: "pointToAngle", value: function pointToAngle(p, convertToDegrees) {
      var dx = p.x - this.center.x;
      var dy = p.y - this.center.y;
      var angle = Math.atan2(dy, dx);
      return convertToDegrees ? THREE.Math.radToDeg(angle) : angle;
    } }, { key: "onPointHovered", value: function onPointHovered(

    event) {

      if (this.mode === Modes.NotSelecting || !event.point) {
        return;
      }

      var angleInDegrees = this.pointToAngle(event.point, true);

      switch (this.mode) {
        case Modes.SelectingCenter:{
            this.setCenter(event.point);
            this.fireEvent({ type: Events.CENTER_HOVERED, point: event.point });

            if (this.fromValid) {
              this.fireEvent({ type: Events.FROM_ANGLE_HOVERED, angle: this.pointToAngle(this.fromPoint, true) });
            }

            if (this.toValid) {
              this.fireEvent({ type: Events.TO_ANGLE_HOVERED, angle: this.pointToAngle(this.toPoint, true) });
            }
            break;
          }
        case Modes.SelectingStartAngle:{
            this.setFromPoint(event.point);
            this.fireEvent({ type: Events.FROM_ANGLE_HOVERED, angle: angleInDegrees });
            break;
          }
        case Modes.SelectingEndAngle:{
            this.setToPoint(event.point);
            this.fireEvent({ type: Events.TO_ANGLE_HOVERED, angle: angleInDegrees });
          }
        case Modes.SelectingStartAngleEdge:{
            // If we are selecting the second point of a direction edge, reflect the edge direction immediately
            if (this.fromEdgePicker.selectingIndex === 1 || this.fromValid) {
              if (!this.fromValid) {
                this.setFromPoint(this.fromEdgePicker.points[1]);
              }
              this.setPointFromEdge(this.fromPoint, this.fromEdgePicker.points[0], this.fromEdgePicker.points[1]);
              this.updateGizmos();
              this.fireEvent({ type: Events.FROM_ANGLE_HOVERED, angle: this.pointToAngle(this.fromPoint) });
            }
            break;
          }
        case Modes.SelectingEndAngleEdge:{
            // Same if are selecting an edge for the to direction
            if (this.toEdgePicker.selectingIndex === 1 || this.toValid) {
              if (!this.toValid) {
                this.setToPoint(this.toEdgePicker.points[1]);
              }
              this.setPointFromEdge(this.toPoint, this.toEdgePicker.points[0], this.toEdgePicker.points[1]);
              this.updateGizmos();
              this.fireEvent({ type: Events.TO_ANGLE_HOVERED, angle: this.pointToAngle(this.toPoint) });
            }
            break;
          }}

    } }, { key: "updateGizmos", value: function updateGizmos()

    {

      // Compute projections of fromPoint/toPoint on selection plane
      this.fromPointOnPlane = this.selectionPlane.projectPoint(this.fromPoint, this.fromPointOnPlane);
      this.toPointOnPlane = this.selectionPlane.projectPoint(this.toPoint, this.toPointOnPlane);

      // PointMarker center
      this.centerMarker.setPosition(this.center);
      this.centerMarker.setVisible(this.visible && this.centerValid);

      // PointMarker start
      if (this.fromValid) this.fromMarker.setPosition(this.fromPointOnPlane);
      this.fromMarker.setVisible(this.visible && this.fromValid);

      // PointMarker end
      if (this.toValid) this.toMarker.setPosition(this.toPointOnPlane);
      this.toMarker.setVisible(this.visible && this.toValid);

      this.fromEdgePicker.setVisible(this.visible && this.fromValid);
      this.toEdgePicker.setVisible(this.visible && this.toValid);

      var showAngleGizmo = this.visible && (this.fromValid || this.toValid);

      if (!showAngleGizmo) {
        // Fade-out gizmo if not needed
        this.angleGizmo.fadeTo(0.0);
        this.angleGizmo.setLabelEnabled(false);
        this.angleGizmo.update();
      } else {
        this.angleGizmo.fadeTo(1.0);
        this.angleGizmo.setLabelEnabled(true);

        // If we start selecting a from/toPoint, show the gizmo immediately.
        // For this case, the fading looks rather confusing than helpful.
        if (this.mode !== Modes.NotSelecting) {
          this.angleGizmo.skipFade();
        }

        // Set angleGizmo points - or set them to undefined if invalid
        this.angleGizmo.setCenter3d(this.centerValid && this.center);
        this.angleGizmo.setStart3d(this.fromValid && this.fromPoint);
        this.angleGizmo.setEnd3d(this.toValid && this.toPoint);

        this.angleGizmo.update();
      }

      // Update connector gizmos
      this.fromConnector.setLine(this.fromPoint, this.fromPointOnPlane);
      this.toConnector.setLine(this.toPoint, this.toPointOnPlane);

      // Update connector gizmo visibility
      this.screenOverlay.setGizmoVisible(this.fromConnector, this.visible && this.mode === Modes.SelectingStartAngle);
      this.screenOverlay.setGizmoVisible(this.toConnector, this.visible && this.mode === Modes.SelectingEndAngle);

      this.screenOverlay.update();
    } }, { key: "onPointClicked", value: function onPointClicked(_ref2)

    {var point = _ref2.point;var pickAnother = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.mode === Modes.NotSelecting) {
        return;
      }

      // These modes are handled separately in the onEdgeSelected() event handler 
      if (this.mode === Modes.SelectingStartAngleEdge || this.mode == Modes.SelectingEndAngleEdge) {
        return;
      }

      // In case not point was selected, try restoring point backup.
      point = point || this.pointBackup;

      // Clear point backup
      this.pointBackup = null;

      // remember mode before we reset it
      var mode = this.mode;

      // Finish interaction
      this.mode = Modes.NotSelecting;

      this.endCoordPicker();

      if (point) {
        // Set pivot to selected point, so that we can orbit around it
        this.viewer.impl.camera.pivot.copy(point);
        this.viewer.impl.camera.dirty = true;
      }

      var angleInDegrees = point ? this.pointToAngle(point, true) : null;

      // Fire events at the very end, so that AngleToAngle is in final state when the events are evaluated.
      switch (mode) {
        case Modes.SelectingCenter:
          this.setCenter(point);
          this.centerMarker.setDraggable(!!point);
          this.fireEvent({ type: Events.CENTER_SELECTED, point: point });
          break;
        case Modes.SelectingStartAngle:
          this.setFromPoint(point);
          this.fireEvent({ type: Events.FROM_ANGLE_SELECTED, angle: angleInDegrees });
          break;
        case Modes.SelectingEndAngle:
          this.setToPoint(point);
          this.fireEvent({ type: Events.TO_ANGLE_SELECTED, angle: angleInDegrees });
          break;
        case Modes.SelectingStartAngleEdge:
        case Modes.SelectingEndAngleEdge:
          break; // this case is handled in onEdgeSelected 
        default:console.error('Unexpeced mode');}


      if (pickAnother) {
        this.continuePointSelectionIfNeeded();
      }
    } }, { key: "cancelPointSelection", value: function cancelPointSelection()

    {
      // Call onPointClicked twice in case we are in the middle of edge selection.
      this.onPointClicked({}, false);
      this.fromEdgePicker.cancelPointSelection();
      this.toEdgePicker.cancelPointSelection();
    } }, { key: "startSelect", value: function startSelect()

    {
      this.isActive = true;
      this.continuePointSelectionIfNeeded();
    } }, { key: "continuePointSelectionIfNeeded", value: function continuePointSelectionIfNeeded()

    {var _this2 = this;
      if (!this.isPickerActive()) {
        return;
      }

      // Make sure the tool is visible.
      this.setVisible(true);

      // For simplicity, wait for the next frame before continue picking another point.
      // This is needed so the click event won't populate from the first pick to the second pick immediately after it starts.
      setTimeout(function () {
        if (!_this2.centerValid) {
          _this2.startSelectCenter();
        } else if (!_this2.fromValid) {
          if (_this2.defaultPickingMode === PickingModes.Edge) {
            _this2.startSelectFromAngleEdge();
          } else if (_this2.defaultPickingMode === PickingModes.SinglePoint) {
            _this2.startSelectFromAngle();
          }
        } else if (!_this2.toValid) {
          if (_this2.defaultPickingMode === PickingModes.Edge) {
            _this2.startSelectToAngleEdge();
          } else if (_this2.defaultPickingMode === PickingModes.SinglePoint) {
            _this2.startSelectToAngle();
          }
        }
      }, 1);
    } }, { key: "getOffsetAngle", value: function getOffsetAngle()

    {

      // If all points are specified, compute offset from from/to directions
      var fromToValid = this.fromValid && this.toValid;
      if (fromToValid) {

        var fromAngle = this.pointToAngle(this.fromPoint);
        var toAngle = this.pointToAngle(this.toPoint);
        return toAngle - fromAngle;
      }

      // Alternatvely, the offset angle can be specified numerically.
      return this.offset;
    }

    // Setup rotation matrix to rotate around this.axis centered at this.center.
    //  @param {number}  angle  - in radians
    //  @param {Vector3} center
  }, { key: "createRotation", value: function createRotation(angle, target, center) {
      var centerToOrigin = tmpMatrix1.makeTranslation(-center.x, -center.y, -center.z);
      var originToCenter = tmpMatrix2.makeTranslation(center.x, center.y, center.z);

      var quat = tmpQuat.setFromAxisAngle(this.axis, angle);
      var rot = tmpMatrix3.makeRotationFromQuaternion(quat);

      return target.copy(originToCenter).multiply(rot).multiply(centerToOrigin);
    } }, { key: "clear", value: function clear()

    {
      this.fromValid = false;
      this.toValid = false;
      this.centerValid = false;
      this.fromEdgePicker.clear();
      this.toEdgePicker.clear();
      this.isActive = false;

      this.updateGizmos();
    }

    // Rotates the given model, so that "from" angle is rotated to "to" angle
  }, { key: "apply", value: function apply(model) {var _this3 = this;

      // If possible, use fromPoint/toPoint. In this case, we also show the PointMarkers.
      // Otherwise, we only use the model of an offset value is specified directly.
      var offsetAngle = this.getOffsetAngle();

      // Backup model matrix in "before" state.
      var modelMatrix = model.getPlacementTransform();
      var startMatrix = modelMatrix.clone();

      // Reused during animation
      var matrix = new Autodesk.Viewing.Private.LmvMatrix4(true);

      // used to animate from-arrow
      var fromPoint = new THREE.Vector3();

      // Note: this.center is in viewer coords, i.e. with subtracted globalOffset.
      // If we modify the placementMatrix, we must use the center in world-coords, i.e. without subtracted globalOffset
      var globalOffset = model.getGlobalOffset();
      var centerWorld = globalOffset ? this.center.clone().add(globalOffset) : this.center;

      // blend between start/end position
      var onTimer = function onTimer(unitTime) {

        var t = THREE.Math.smootherstep(unitTime, 0.0, 1.0);

        // interpolate angle
        var angle = t * offsetAngle;

        // create rotation matrix
        matrix = _this3.createRotation(angle, matrix, _this3.center);

        // let 'from' arrow follow the animation
        _this3.angleGizmo.setStart3d(fromPoint.copy(_this3.fromPointOnPlane).applyMatrix4(matrix));
        _this3.angleGizmo.update();

        // fade-out angle gizmo shortly before end of the animation
        if (unitTime > _this3.fadeOutAngleGizmoAfter) {
          _this3.angleGizmo.fadeTo(0.0);
        }

        // Note: this.center is in viewer coords, i.e. with subtracted globalOffset.
        // If we modify the placementMatrix, we must use the center in world-coords, i.e. without subtracted globalOffset
        matrix = _this3.createRotation(angle, matrix, centerWorld).multiply(startMatrix);

        // apply this rotation to the model placement
        _this3.viewer.impl.setPlacementTransform(model, matrix);
      };

      // Fade-out marker labels immediately, because it looks weird if they overlap.
      this.fromMarker.setVisible(false);
      this.toMarker.setVisible(false);

      this.centerMarker.setDraggable(false);
      this.fromMarker.setDraggable(false);
      this.toMarker.setDraggable(false);
      this.fromEdgePicker.markers[0].setDraggable(false);
      this.fromEdgePicker.markers[1].setDraggable(false);
      this.toEdgePicker.markers[0].setDraggable(false);
      this.toEdgePicker.markers[1].setDraggable(false);

      // Fade-out label
      this.angleGizmo.setLabelEnabled(false);

      var onEnd = function onEnd(t) {
        _this3.clear();
        _this3.anim = null;
      };
      this.anim = Autodesk.Viewing.Private.fadeValue(0, 1, this.animTime, onTimer, onEnd);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible !== this.visible) {
        this.visible = visible;
        this.updateGizmos();
      }
    }

    // Helper function to update a given point (from/to) based on current center and an angle value indicating the direction
    // NOTE: This function needs to be generalized if we support other rotation axes than Z.
    //
    //  @param {Vector3} target
    //  @param {number}  angle    - target direction angle in radians. 0 = positive x-axis.
    //  @param {number}  distance - distance from center
  }, { key: "setPointFromAngle", value: function setPointFromAngle(target, angle, distance) {
      target.set(1, 0, 0);
      Autodesk.Edit2D.Math2D.rotateAround(target, angle);
      target.multiplyScalar(distance).add(this.center);
    }

    // Update fromPoint to another direction. It requires that a previous fromPoint was already set to define the length.
    //  @param {number|undefined} ccw angle in radians. 0 corresponds to positive x-axis.
  }, { key: "changeFromAngle", value: function changeFromAngle(angle) {

      if (!this.fromValid) {
        return;
      }

      if (angle !== undefined) {
        // Recompute toPoint based on angle and prior length
        var dist = this.fromPointOnPlane.distanceTo(this.center);
        this.setPointFromAngle(this.fromPoint, angle, dist);
      } else {
        // Setting an undefined angle just invalidates the fromPoint
        this.fromValid = false;
      }

      this.updateGizmos();
    }

    // Update toPoint to another direction. It requires that a previous toPoint was already set to define the length.
    //  @param {number|undefined} ccw angle in radians. 0 corresponds to positive x-axis.
  }, { key: "changeToAngle", value: function changeToAngle(angle) {

      if (!this.toValid) {
        return;
      }

      if (angle !== undefined) {
        // Recompute toPoint based on angle and prior length
        var dist = this.toPointOnPlane.distanceTo(this.center);
        this.setPointFromAngle(this.toPoint, angle, dist);
      } else {
        // Setting an undefined angle just invalidates the toPoint
        this.toValid = false;
      }

      this.updateGizmos();
    }

    // Update offset according to a specific angle (Used when typing an offset in the panel)
    // Enables to set all of the points according to a single angle.
  }, { key: "changeOffset", value: function changeOffset(angle) {
      if (!this.centerValid) {
        return;
      }

      // If we are in the middle of point selection, cancel it until the operation is finished.
      this.cancelPointSelection();

      // If From point is not set, set it as zero.
      if (!this.fromValid) {
        this.startSelectFromAngle();
        this.fromValid = true;
        this.changeFromAngle(0);
        this.onPointClicked({ point: this.fromPoint });
      }

      // If To point is not set, set it as From point + given angle.
      if (!this.toValid) {
        this.startSelectToAngle();
        this.toValid = true;
        this.changeToAngle(this.pointToAngle(this.fromPoint) + angle);
        this.onPointClicked({ point: this.toPoint });
      }

      this.continuePointSelectionIfNeeded();
    }

    // Start selecting an edge whose direction we use for aligning fromAngle.
  }, { key: "startSelectFromAngleEdge", value: function startSelectFromAngleEdge() {
      this.mode = Modes.SelectingStartAngleEdge;
      this.fromEdgePicker.startSelect();
    }

    // Start selecting an edge whose direction we use for aligning toAngle
  }, { key: "startSelectToAngleEdge", value: function startSelectToAngleEdge() {
      this.mode = Modes.SelectingEndAngleEdge;
      this.toEdgePicker.startSelect();
    }

    // Helper function to update a given point (from/to)
    // in a way that the vector (center->to) is the projection
    // of (a->b) to the selection plane.
  }, { key: "setPointFromEdge", value: function setPointFromEdge(target, a, b) {

      // Do nothing if (a,b) are nearly the same. Otherwise, we don't get any direction information and instead
      // would just set target to the same position as center. 
      if (a.distanceTo(b) < 1.e-5) {
        return;
      }

      // We are only interested in the edge direction, not its length. So we preserve the original one
      var length = target.distanceTo(this.center);

      target.copy(b).sub(a) // vector (a->b)
      .normalize().multiplyScalar(length) // ...rescaled to length
      .add(this.center);
      this.selectionPlane.projectPoint(target, tmpVec);
    } }, { key: "onEdgeSelected", value: function onEdgeSelected(

    edgePicker) {
      var selectingFrom = this.mode === Modes.SelectingStartAngleEdge;
      var selectingTo = this.mode === Modes.SelectingEndAngleEdge;
      if (!selectingFrom && !selectingTo) {
        return;
      }

      var a = edgePicker.points[0];
      var b = edgePicker.points[1];

      if (selectingFrom) {
        this.setPointFromEdge(this.fromPoint, a, b);
      } else {
        this.setPointFromEdge(this.toPoint, a, b);
      }

      // Finish interaction and remove gizmos from edgePicker
      this.mode = Modes.NotSelecting;

      this.updateGizmos();

      // Fire event to signal that angle has changed
      if (selectingFrom) {
        var angle = this.pointToAngle(this.fromPoint, true);
        this.fireEvent({ type: Events.FROM_ANGLE_SELECTED, angle: angle });
        this.continuePointSelectionIfNeeded();
      } else {
        var _angle = this.pointToAngle(this.toPoint, true);
        this.fireEvent({ type: Events.TO_ANGLE_SELECTED, angle: _angle });
        this.continuePointSelectionIfNeeded();
      }
    } }, { key: "isPickerActive", value: function isPickerActive()

    {
      return this.isActive;
    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {
      this.anim && this.anim.skip();
    } }]);return AngleToAngle;}();


AngleToAngle.Events = Events;
AngleToAngle.Modes = Modes;
AngleToAngle.PickingModes = PickingModes;

/***/ }),

/***/ "./extensions/ModelAlignment/FourPointsAlignment.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignment/FourPointsAlignment.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FourPointsAlignment; });
/* harmony import */ var _TransformCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransformCommon */ "./extensions/ModelAlignment/TransformCommon.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var Events = {
  SOURCE_POINT_SELECTION_STARTED: 'sourcePointSelectionStarted',
  DEST_POINT_SELECTION_STARTED: 'destPointSelectionStarted' };


var firstFromIndex = 0;
var secondFromIndex = 1;
var firstToIndex = 2;
var secondToIndex = 3;

// Pick two points on the source model, and two point on the target model, and align accordingly.
var FourPointsAlignment = /*#__PURE__*/function (_Autodesk$Edit3D$NPoi) {_inherits(FourPointsAlignment, _Autodesk$Edit3D$NPoi);var _super = _createSuper(FourPointsAlignment);

  function FourPointsAlignment(viewer, coordPicker, screenOverlay) {var _this;_classCallCheck(this, FourPointsAlignment);
    var options = {
      draggable: true,
      colors: [
      Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Blue,
      Autodesk.Edit3D.NPointPicker.Colors.Red, Autodesk.Edit3D.NPointPicker.Colors.Red],

      connections: [
      {
        fromIndex: 0,
        toIndex: 2,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Black },

      {
        fromIndex: 1,
        toIndex: 3,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Black }] };




    _this = _super.call(this, viewer, coordPicker, screenOverlay, 4, options);

    _this.tmpVec = new THREE.Vector3();

    _this.addEventListener(Autodesk.Edit3D.NPointPicker.Events.POINT_SELECTION_STARTED, function (_ref) {var index = _ref.index;
      if (index === firstFromIndex && !_this.pointValid[firstFromIndex]) {
        _this.fireEvent({ type: Events.SOURCE_POINT_SELECTION_STARTED });
      } else if (index === firstToIndex && !_this.pointValid[firstToIndex]) {
        _this.fireEvent({ type: Events.DEST_POINT_SELECTION_STARTED });
      }
    });return _this;
  }_createClass(FourPointsAlignment, [{ key: "apply", value: function apply(

    model) {var _this2 = this;
      var originalMatrix = model.getPlacementTransform().clone();
      var s0 = this.points[0].clone();
      var s1 = this.points[1].clone();
      var t0 = this.points[2].clone();
      var t1 = this.points[3].clone();

      this.anim = Object(_TransformCommon__WEBPACK_IMPORTED_MODULE_0__["animateEdgeToEdge"])(s0, s1, t0, t1,
      {
        onChange: function onChange(matrix) {
          // Transform source marker points
          _this2.setPoint(0, _this2.tmpVec.copy(s0).applyMatrix4(matrix));
          _this2.setPoint(1, _this2.tmpVec.copy(s1).applyMatrix4(matrix));

          // Transform model
          _this2.viewer.impl.setPlacementTransform(model, matrix.multiply(originalMatrix));
        },
        onEnd: function onEnd() {
          _this2.clear();
          _this2.anim = null;
        } });


    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {var _this$anim;
      (_this$anim = this.anim) === null || _this$anim === void 0 ? void 0 : _this$anim.skip();
    } }, { key: "isSelectingSourcePointsDone", value: function isSelectingSourcePointsDone()

    {
      // Verify that the first or second points are not being dragged now.
      if (this.selectingIndex === firstFromIndex || this.selectingIndex === secondFromIndex) {
        return false;
      }

      return this.pointValid[firstFromIndex] && this.pointValid[secondFromIndex];
    } }]);return FourPointsAlignment;}(Autodesk.Edit3D.NPointPicker);


FourPointsAlignment.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignment.js":
/*!*****************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignment.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentExtension; });
/* harmony import */ var _ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignmentBase.js */ "./extensions/ModelAlignment/ModelAlignmentBase.js");
/* harmony import */ var _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ModelAlignmentPanel.js */ "./extensions/ModelAlignment/ModelAlignmentPanel.js");
/* harmony import */ var _PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PointToPoint.js */ "./extensions/ModelAlignment/PointToPoint.js");
/* harmony import */ var _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AngleToAngle.js */ "./extensions/ModelAlignment/AngleToAngle.js");
/* harmony import */ var _ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ModelSelector.js */ "./extensions/ModelAlignment/ModelSelector.js");
/* harmony import */ var _ModelAlignmentLocales__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ModelAlignmentLocales */ "./extensions/ModelAlignment/ModelAlignmentLocales.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);} /** 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * ModelAlignment extension provides tools to edit/fix spatially alignment of multiple models in an aggregated view.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @example
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *   viewer.loadExtension('Autodesk.ModelAlignment')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @memberof Autodesk.Viewing.Extensions
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @alias Autodesk.Viewing.Extensions.ModelAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */








var extensionName = "Autodesk.ModelAlignment";
var av = Autodesk.Viewing;

var namespace = AutodeskNamespace("Autodesk.ModelAlignment");

// set color for all dbIds that are associated with shapes. Note that some dbIds may appear more
// than once, but this is not a problem here.
var setModelThemingColor = function setModelThemingColor(model, color) {
  // Note: Calling setThemingColor with the rootId and recursive=true would mostly work as well, but
  //       would fail if the instance tree is not loaded yet.
  if (model.isLeaflet()) {
    model.setThemingColor(null, color); // dbId is irrelevant for leaflet. The whole model is colored.
    return;
  }

  var dbIds = model.myData.fragments.fragId2dbId;
  for (var i = 0; i < dbIds.length; i++) {
    var dbId = dbIds[i];
    if (Array.isArray(dbId)) {// Can be an array for 2D
      for (var j = 0; j < dbId.length; j++) {
        model.setThemingColor(dbId[j], color);
      }
    } else {
      model.setThemingColor(dbId, color);
    }
  }
};

// Degrees to radians with support for undefined angles
var toRadians = function toRadians(angle) {
  return angle !== undefined ? THREE.Math.degToRad(angle) : undefined;
};var


ModelAlignmentExtension = /*#__PURE__*/function (_ModelAlignmentBase) {_inherits(ModelAlignmentExtension, _ModelAlignmentBase);var _super = _createSuper(ModelAlignmentExtension);

  // @param {Object} [options]
  // @param {function()} onSaveButton - Triggered if "Save" button is pressed.
  function ModelAlignmentExtension(viewer, options) {var _this;_classCallCheck(this, ModelAlignmentExtension);
    _this = _super.call(this, viewer, options);

    _this.name = extensionName;

    // bind some handlers
    _this.onPlacementChanged = _this.onPlacementChanged.bind(_assertThisInitialized(_this));
    _this.onSaveButton = _this.onSaveButton.bind(_assertThisInitialized(_this));return _this;
  }_createClass(ModelAlignmentExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extendLocalization(_ModelAlignmentLocales__WEBPACK_IMPORTED_MODULE_5__["locales"]);_context.next = 3;return _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "load", this).call(this);case 3:



                this.panel = new _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.viewer, 'ModelAlignmentPanel', 'Model Alignment');

                // This ensures that the Panel keeps visible within the viewer canvas on resize.
                this.viewer.addPanel && this.viewer.addPanel(this.panel);

                // Make sure that panel always displays the correct matrix
                this.viewer.addEventListener(av.MODEL_PLACEMENT_CHANGED_EVENT, this.onPlacementChanged);

                // bind it so that we can use it for event listeners
                this.onModelPanelSelect = this.onModelPanelSelect.bind(this);
                this.onTabChanged = this.onTabChanged.bind(this);
                this.pointToPoint = new _PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.viewer, this.coordPicker, this.screenOverlay);
                this.angleToAngle = new _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.viewer, this.coordPicker, this.screenOverlay);

                this.modelSelector = new _ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.viewer);
                this.viewer.toolController.registerTool(this.modelSelector);

                // Synchronize with ModelsPanel (if any).
                this.connectModelsPanel();

                this.connectPointToPoint();
                this.connectAngleToAngle();
                this.connectModelSelector();
                this.connectModelMoveTool();

                // Connect user-defined behavior for save-button
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.SAVE_BUTTON_PRESSED, this.onSaveButton);

                // Mark model as modified if transform was modified in the panel
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.MODEL_TRANSFORM_EDITED, function () {return _this2.modified();});

                // Make sure that we only show the gizmos of the tool for the current tab
                this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TAB_CHANGED, this.onTabChanged);

                // Color applied to selected models in selection mode
                this.selectionColor = new THREE.Vector4(1, 1, 0, 0.25);case 21:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "unload", this).call(this);

      // Remove Panel from GuiViewer if we added it on load.
      this.viewer.removePanel && this.viewer.removePanel(this.panel);

      this.panel.uninitialize();
      this.panel = null;

      this.viewer.removeEventListener(av.PLACEMENT_TRANSFORM_CHANGED_EVENT, this.onPlacementChanged);

      // Stop watching extension loads
      if (this.onExtensionLoaded) {
        this.viewer.removeEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, this.onExtensionLoaded);
      }

      if (this.pointToPoint) {
        this.pointToPoint.dtor();
        this.pointToPoint = null;
      }

      if (this.angleToAngle) {
        this.angleToAngle = null;
      }

      this.disconnectModelsPanel();
    } }, { key: "onTabChanged", value: function onTabChanged()

    {
      var selectedTabId = this.panel.selectedTabId;

      var modelTransformToolName = this.modelTransformTool.getName();
      // Transform
      if (selectedTabId === _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].TabIds.Transform && this.model) {
        if (!this.viewer.toolController.isToolActivated(modelTransformToolName)) {
          this.viewer.toolController.activateTool(modelTransformToolName);
        }
      } else {
        this.viewer.toolController.deactivateTool(modelTransformToolName);
      }

      // PointToPoint
      if (selectedTabId === _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].TabIds.PointToPoint) {
        this.pointToPoint.startSelect();
      } else {
        this.pointToPoint.cancelPointSelection();
        this.pointToPoint.setVisible(false);
      }

      // AngleToAngle
      if (selectedTabId === _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].TabIds.AngleToAngle) {
        this.angleToAngle.startSelect();
      } else {
        this.angleToAngle.cancelPointSelection();
        this.angleToAngle.setVisible(false);
      }
    } }, { key: "connectModelsPanel", value: function connectModelsPanel()

    {var _this3 = this;
      var ext = this.viewer.getExtension('Autodesk.ModelsPanel');

      // If not loaded, try again if ModelsPanel is loaded later
      if (!ext) {
        this.onExtensionLoaded = function (event) {return event.extensionId === 'Autodesk.ModelsPanel' && _this3.connectModelsPanel();};
        this.viewer.addEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, this.onExtensionLoaded);
        return;
      }

      this.modelsPanel = ext.panel;
      this.modelsPanel.addEventListener(Autodesk.Viewing.UI.ListPanelEvents.ITEM_SELECT, this.onModelPanelSelect);
      this.modelsPanel.setModelSelectionModeEnabled(true);
    } }, { key: "disconnectModelsPanel", value: function disconnectModelsPanel()

    {
      if (this.modelsPanel) {
        this.modelsPanel.removeEventListener(
        Autodesk.Viewing.UI.ListPanelEvents.ITEM_SELECT,
        this.onModelPanelSelect);


        // Todo: This assumes exclusive control on the ModelsPanel selection behavior.
        this.modelsPanel.setModelSelectionModeEnabled(false);
      }
    }

    // If a model is selected in ModelsPanel, synchronize transform panel and models tool
  }, { key: "onModelPanelSelect", value: function onModelPanelSelect(event) {
      this.setModel(event.item.model);
    }

    // Connects PointToPoint workflow with Alignment panel
  }, { key: "connectPointToPoint", value: function connectPointToPoint() {var _this4 = this;

      // Update from/to point indicators when they are changed in the panel
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_POINT_CHANGED, function (event) {return _this4.pointToPoint.setFrom(event.fromPoint);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_POINT_CHANGED, function (event) {return _this4.pointToPoint.setTo(event.toPoint);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.OFFSET_CHANGED, function (event) {return _this4.pointToPoint.setOffset(event.offset);});

      // Trigger tool to select from/to-point when pressing the corresponding button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_POINT_BUTTON_PRESSED, function () {return _this4.pointToPoint.startSelectFrom();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_POINT_BUTTON_PRESSED, function () {return _this4.pointToPoint.startSelectTo();});

      // connect apply button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.APPLY_PTP_PRESSED, function () {
        _this4.pointToPoint.apply(_this4.panel.model);
        _this4.modified();
      });

      // connect fitToView button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FIT_TO_VIEW_BUTTON_PRESSED, function () {
        _this4.pointToPoint.fitModelToView(_this4.panel.model);
        _this4.modified();
      });

      // After picking a from/to point, fill in the values to the panel
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.FROM_POINT_SELECTED, function (event) {return _this4.panel.onFromSelected(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.FROM_POINT_HOVERED, function (event) {return _this4.panel.onFromHovered(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.TO_POINT_HOVERED, function (event) {return _this4.panel.onToHovered(event.point);});
      this.pointToPoint.addEventListener(_PointToPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.TO_POINT_SELECTED, function (event) {return _this4.panel.onToSelected(event.point);});
    }

    // Connects AngleToAngle workflow with Alignment panel
  }, { key: "connectAngleToAngle", value: function connectAngleToAngle() {var _this5 = this;

      // synchronize model selection
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.MODEL_SELECTED, function () {return _this5.setModel(_this5.panel.model);});

      // Update from/to point indicators when they are changed in the panel
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.CENTER_CHANGED, function (event) {return _this5.angleToAngle.setCenter(event.center);});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_ANGLE_CHANGED, function (event) {return _this5.angleToAngle.changeFromAngle(toRadians(event.angle));});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_ANGLE_CHANGED, function (event) {return _this5.angleToAngle.changeToAngle(toRadians(event.angle));});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.OFFSET_ANGLE_CHANGED, function (event) {return _this5.angleToAngle.changeOffset(toRadians(event.angle));});

      // Trigger tool to select center/fromAngle/toAngle when pressing the corresponding button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.CENTER_BUTTON_PRESSED, function () {return _this5.angleToAngle.startSelectCenter();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_ANGLE_BUTTON_PRESSED, function () {return _this5.angleToAngle.startSelectFromAngle();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_ANGLE_BUTTON_PRESSED, function () {return _this5.angleToAngle.startSelectToAngle();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.FROM_EDGE_BUTTON_PRESSED, function () {return _this5.angleToAngle.startSelectFromAngleEdge();});
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.TO_EDGE_BUTTON_PRESSED, function () {return _this5.angleToAngle.startSelectToAngleEdge();});

      // connect apply button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.APPLY_ATA_PRESSED, function () {
        _this5.angleToAngle.apply(_this5.panel.model);
        _this5.modified();
      });

      // After picking a from/to point, fill in the values to the panel
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.CENTER_HOVERED, function (event) {return _this5.panel.onCenterHovered(event.point);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.CENTER_SELECTED, function (event) {return _this5.panel.onCenterSelected(event.point);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.FROM_ANGLE_HOVERED, function (event) {return _this5.panel.onFromAngleHovered(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.FROM_ANGLE_SELECTED, function (event) {return _this5.panel.onFromAngleSelected(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.TO_ANGLE_HOVERED, function (event) {return _this5.panel.onToAngleHovered(event.angle);});
      this.angleToAngle.addEventListener(_AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"].Events.TO_ANGLE_SELECTED, function (event) {return _this5.panel.onToAngleSelected(event.angle);});
    } }, { key: "connectModelMoveTool", value: function connectModelMoveTool()

    {var _this6 = this;
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.EDIT_POSITION_PRESSED, function () {return _this6.viewer.toolController.activateTool(_this6.modelTransformTool.getName());});
    }

    // Connect modelSelectorTool with UI
  }, { key: "connectModelSelector", value: function connectModelSelector() {var _this7 = this;
      // Trigger Model-select when pressing the button
      this.panel.addEventListener(_ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"].Events.SELECT_MODEL_PRESSED, function (event) {
        if (!_this7.viewer.toolController.isToolActivated(_this7.modelSelector.getName())) {
          _this7.viewer.toolController.activateTool(_this7.modelSelector.getName());
        }
      });

      // After selecting a model, apply it to panel and placement tool
      this.modelSelector.addEventListener(_ModelSelector_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.MODEL_SELECTED, function (event) {
        // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and
        //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.
        _this7.viewer.toolController.setIsLocked(false);
        _this7.viewer.toolController.deactivateTool(_this7.modelSelector.getName()); // model-select finished

        _this7.setModel(event.model);
      });
    }

    // set model to be aligned next
  }, { key: "setModel", value: function setModel(model) {
      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "setModel", this).call(this, model);

      this.panel.setModel(model);
      this.updateColorTheming();
      this.onTabChanged();
    }


    // Mark selected model by color theming
  }, { key: "updateColorTheming", value: function updateColorTheming() {

      // We may have multiple views of the same model file. Since alignment can only be saved per model file,
      // placement is synced for all views of the same model. Therefore, we highlight all views of the selected urn.
      var selectedUrn = this.model && this.model.myData.urn;
      var isSelected = function isSelected(model) {return selectedUrn && model.myData.urn === selectedUrn;};

      // Make sure no other theming is leaked.
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        var model = models[i];

        // Color theming is not supported for leaflets
        if (model.isLeaflet()) {
          continue;
        }

        if (isSelected(model)) {
          // colorize selected model
          setModelThemingColor(model, this.selectionColor);
        } else {
          this.viewer.clearThemingColors(model);
        }
      }

      this.viewer.impl.invalidate(true);
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      // Make sure that any in-progress animation is skipped before we start saving.
      this.pointToPoint.skipAnim();
      this.angleToAngle.skipAnim();

      _get(_getPrototypeOf(ModelAlignmentExtension.prototype), "onSaveButton", this).call(this);
    }

    // Triggered if placementTransform was changed for a model.
  }, { key: "onPlacementChanged", value: function onPlacementChanged(event) {

      // Note that syncAlignments() may cause nested placementChanged events of other models.
      // So, it's important to only handle changes of the selected model here.
      if (event.model !== this.model) {
        return;
      }

      this.panel.updateMatrix();

      // If selected model was edited, make sure that other views of the same model file follow.
      this.syncAlignments();
    }

    // Sync placement for multiple views of the same urn:
    // If the viewer contains multiple views of the same urn, editing one of them moves all others with it.
  }, { key: "syncAlignments", value: function syncAlignments() {

      // Stop if no 3D model is selected
      if (!this.model || this.model.is2d()) {
        return;
      }
      var selectedUrn = this.model.myData.urn;
      var placementTf = this.model.getPlacementTransform();

      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        // Check if model is another view of the same modelUrn.
        var model = models[i];
        var urn = model.myData.urn;
        var needsSync = urn == selectedUrn && model !== this.model;

        // Note that syncing does only make sense for 3D views
        if (model.is3d() && needsSync) {
          this.viewer.impl.setPlacementTransform(model, placementTf);
        }
      }
    } }]);return ModelAlignmentExtension;}(_ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


namespace.ModelAlignment = ModelAlignmentExtension;
namespace.ModelAlignmentPanel = _ModelAlignmentPanel_js__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.AngleToAngle = _AngleToAngle_js__WEBPACK_IMPORTED_MODULE_3__["default"];

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, ModelAlignmentExtension);

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentBase.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentBase.js ***!
  \*********************************************************/
/*! exports provided: default, AlignmentChange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignmentChange", function() { return AlignmentChange; });
/* harmony import */ var _ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelTransformTool.js */ "./extensions/ModelAlignment/ModelTransformTool.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

var av = Autodesk.Viewing;

// Used in order to create a unique id for each screenOverlay per extension.
var screenOverlayId = 0;

var namespace = AutodeskNamespace("Autodesk.ModelAlignment");

var SnapperName = "Snapper_ModelAlignment";

var Events = {
  ALIGNMENT_MODIFIED: "alignmentModified",
  MODEL_SELECTED: "modelSelected" };var


ModelAlignmentBase = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentBase, _av$Extension);var _super = _createSuper(ModelAlignmentBase);

  function ModelAlignmentBase(viewer, options) {var _this;_classCallCheck(this, ModelAlignmentBase);
    _this = _super.call(this, viewer, options);

    // Should be overwritten by the extending class.
    _this.name = 'ModelAlignmentBase';

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));return _this;
  }_createClass(ModelAlignmentBase, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var _this2 = this;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (





                  this.viewer.loadExtension('Autodesk.Section'));case 2:_context.next = 4;return (

                  this.viewer.loadExtension('Autodesk.Snapping'));case 4:_context.next = 6;return (


                  this.viewer.loadExtension('Autodesk.Edit2D'));case 6:_context.next = 8;return (

                  this.viewer.loadExtension('Autodesk.Edit3D'));case 8:

                this.modelTransformTool = new _ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, this.name);
                this.viewer.toolController.registerTool(this.modelTransformTool);

                // Mark model as edited when using the tool
                this.modelTransformTool.addEventListener(_ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.MODEL_MOVED_EVENT, function () {
                  _this2.modified();
                });

                // Make sure that panel always displays the correct matrix
                this.viewer.addEventListener(av.MODEL_TRANSFORM_CHANGED_EVENT, function (event) {
                  _this2.modelTransformTool.initGizmo();
                });

                // init snapper
                this.snapper = this.viewer.toolController.getTool(SnapperName);

                if (!this.snapper) {
                  this.snapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(this.viewer, {
                    renderSnappedTopology: true,
                    toolName: SnapperName });


                  this.viewer.toolController.registerTool(this.snapper);
                }

                // Init coordinate picker tool
                this.coordPicker = this.viewer.toolController.getTool(Autodesk.Edit3D.CoordPicker.Name);

                if (!this.coordPicker) {
                  this.coordPicker = new Autodesk.Edit3D.CoordPicker(this.viewer, this.snapper);
                  this.viewer.toolController.registerTool(this.coordPicker);
                }

                // Create layer for temporary 2D vector overlays
                this.screenOverlay = new Autodesk.Edit2D.ScreenOverlay(this.viewer, "Autodesk.ModelAlignment.ScreenOverlay_".concat(screenOverlayId++));

                // Model whose alignment we are currently editing
                this.model = null;

                // Dictionary of AlignmentChanges indexed by alignmentItemKey 
                this.pendingChanges = {};case 19:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {var _this$modelTransformT;
      this.viewer.toolController.deactivateTool(_ModelTransformTool_js__WEBPACK_IMPORTED_MODULE_0__["default"].Name);

      (_this$modelTransformT = this.modelTransformTool) === null || _this$modelTransformT === void 0 ? void 0 : _this$modelTransformT.dtor();
      this.modelTransformTool = null;

      this.model = null;

      // Drop any pending changes
      this.pendingChanges = {};
    }

    // set model to be aligned next
  }, { key: "setModel", value: function setModel(model) {var _this$modelTransformT2;
      if (this.model === model) {
        return;
      }

      this.model = model;
      (_this$modelTransformT2 = this.modelTransformTool) === null || _this$modelTransformT2 === void 0 ? void 0 : _this$modelTransformT2.setModel(model);

      this.fireEvent({ type: Events.MODEL_SELECTED });
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      this.options.onSaveButton && this.options.onSaveButton();
    }

    // Save & clear all pending changes
    //  @param {AlignmentService} alignmentService
  }, { key: "saveChanges", value: function saveChanges(alignmentService) {

      // Used below to do unit scaling from viewer world-units to model units
      var toModelUnits = new THREE.Matrix4();

      for (var key in this.pendingChanges) {
        var item = this.pendingChanges[key];
        if (!item) {
          continue;
        }

        var model = item.model;
        var matrix = item.resetPlacement ? null : model.getPlacementTransform();
        var docNode = model.getDocumentNode();

        // The urn, used as the key, has to match _applyAlignmentService in AggregatedView
        var urn = docNode.getRootNode().urn();
        var guid = model.is2d() ? docNode.guid() : undefined;

        // If the client used 'applyScaling' in the model-load options, the placementTransform may include a unit-scaling
        // from model units to viewer world units. The saved transform must not depend on current viewer unit-scaling.
        // Instead, it must be specified in a way that it works directly in the coordinates and units of the model file.
        // To obtain this matrix, we have to revert the unitScaling. Note that this is different from just removing the scaling
        // part of the placementTransform, because:
        //  - It also rescales the position offset to model units.
        //  - In case the alignmentTransform would contain an own scaling part, this one would be preserved and saved. Currently,
        //    this will usually not happen in practice (e.g. Revit refPointTransforms usually just contain offset and angle),
        //    but this may change in the future.
        var scalingFactor = item.model.myData.scalingFactor;
        if (matrix && scalingFactor) {

          // get scaling from viewer units to model units
          var s = 1.0 / scalingFactor;
          toModelUnits.makeScale(s, s, s);

          // premultipy scaling, so that matrix now expresses the placement in model units
          matrix = toModelUnits.multiply(matrix);
        }

        alignmentService.saveTransform(urn, guid, matrix);
      }

      // Reset pending changes
      this.pendingChanges = {};
    } }, { key: "getAlignmentItemKey",

    // Unique string for items for which alignment can be saved separately.
    // Mostly, the alignmentKey will be unique per model. Only exception is if two
    // models are 3D views of the same urn, because the alignment is the same for all 3D views
    // of a model file.
    value: function getAlignmentItemKey(model) {

      var urn = model.myData.urn;

      // Only 2D views get separate IDs. 3D are all aligned together.
      var docNode = model.getDocumentNode();
      var viewPostfix = model.is2d() && docNode ? docNode.guid() : '';

      return urn + viewPostfix;
    }

    // Called whenever the user modified the transform of the current model.
    // Needed to track pending changes until we save.
  }, { key: "modified", value: function modified() {
      if (this.model) {

        var key = this.getAlignmentItemKey(this.model);
        this.pendingChanges[key] = new AlignmentChange(this.model, false);

        this.fireEvent({ type: Events.ALIGNMENT_MODIFIED });
      }
    } }, { key: "hasPendingChanges", value: function hasPendingChanges()

    {
      return Object.keys(this.pendingChanges).length;
    } }]);return ModelAlignmentBase;}(av.Extension);


// Encodes alignment change of a single model
var AlignmentChange =

function AlignmentChange(model, resetPlacement) {_classCallCheck(this, AlignmentChange);

  // The model that was realigned
  this.model = model;

  // False: Matrix was edited and needs to be saved
  // True:  Placement was reset to original source-file transform
  this.resetPlacement = resetPlacement;
};


namespace.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentLocales.js":
/*!************************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentLocales.js ***!
  \************************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-modelAlignment.loc.json */ "./res/locales/en/nobundle-modelAlignment.loc.json");
var _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-modelAlignment.loc.json */ "./res/locales/en/nobundle-modelAlignment.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_modelAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentPanel.css":
/*!***********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentPanel.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./ModelAlignmentPanel.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/ModelAlignment/ModelAlignmentPanel.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelAlignmentPanel.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentPanel; });
/* harmony import */ var _ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignmentPanel.css */ "./extensions/ModelAlignment/ModelAlignmentPanel.css");
/* harmony import */ var _ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ModelAlignmentPanel_css__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // IMPORTANT!!

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

var Events = {
  MODEL_TRANSFORM_EDITED: 'transformEdited',
  SELECT_MODEL_PRESSED: 'selectModelPressed',
  EDIT_POSITION_PRESSED: 'editPositionPressed',
  TAB_CHANGED: 'tabChanged', // Fired when tab is changed. Params: { tabId: string }
  VECTOR_INPUT_VALUE_CHANGED: 'vectorInputValueChanged',
  MODEL_SELECTED: 'modelSelected',

  SAVE_BUTTON_PRESSED: 'saveButtonPressed',

  // Position
  FIT_TO_VIEW_BUTTON_PRESSED: 'fitToViewButtonPressed',

  // Point-to-Point
  FROM_POINT_BUTTON_PRESSED: 'fromPointButtonPressed',
  TO_POINT_BUTTON_PRESSED: 'toPointButtonPressed',
  APPLY_PTP_PRESSED: 'applyPointToPointPressed',
  FROM_POINT_CHANGED: 'fromPointChanged', // Indicates that fromPoint was changed by panel editing. Params: { fromPoint: Vec3 }. May be undefined if entries are invalid. 
  TO_POINT_CHANGED: 'toPointChanged', // Indicates that toPoint was changed by modifying toPoint or offset in the panel. Params: { toPoint: Vec3 }
  OFFSET_CHANGED: 'offsetChanged', // Offset value was edited.

  // Angle-to-Angle
  CENTER_BUTTON_PRESSED: 'centerButtonPressed',
  FROM_ANGLE_BUTTON_PRESSED: 'fromAngleButtonPressed',
  TO_ANGLE_BUTTON_PRESSED: 'toAngleButtonPressed',
  APPLY_ATA_PRESSED: 'applyAngleToAnglePressed',
  CENTER_CHANGED: 'centerChanged',
  OFFSET_ANGLE_CHANGED: 'offsetAngleChanged', // Params: {angle: number|undefined}. Angle may be undefined if input is empty.
  FROM_ANGLE_CHANGED: 'fromAngleChanged', //
  TO_ANGLE_CHANGED: 'toAngleChanged', //
  FROM_EDGE_BUTTON_PRESSED: 'fromEdgeButtonPressed',
  TO_EDGE_BUTTON_PRESSED: 'toEdgeButtonPressed' };


var addHeaderBar = function addHeaderBar(parent) {
  var header = document.createElement('div');
  parent.appendChild(header);

  header.style.height = '55px';
  header.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';
  header.style.display = 'flex';
  header.style.flexDirection = 'row';
  header.style.padding = '10px';
  header.style.width = '100%';
  header.style.boxSizing = 'border-box'; // body including padding should span to 100%
  header.style.alignItems = 'center'; // vertical center
  header.style.marginTop = '15px';

  return header;
};

var addHeader = function addHeader(parent, text, button, id, button2) {

  // A bar containing text and (optionally) button
  var header = addHeaderBar(parent);

  if (id) {
    header.id = id;
  }

  // add text
  var textDiv = document.createElement('div');
  textDiv.textContent = text;
  textDiv.style.flexGrow = '90';
  textDiv.style.fontWeight = 'bold';

  header.appendChild(textDiv);

  // If no button is wanted, we are done
  if (!button) {
    return header;
  }

  var configureButtonStyle = function configureButtonStyle(button) {
    var bStyle = button.container.style;
    bStyle.backgroundColor = 'rgb(80,80,80)';
    bStyle.flexGrow = '10';
    bStyle.height = '15px';
    bStyle.width = 'auto'; // overwrite the fixed pixel-width enforced by adsk button style
    bStyle.textAlign = 'center';
    bStyle.fontSize = '12px';
  };

  // configure button and add it to header 
  configureButtonStyle(button);
  header.appendChild(button.container);

  if (!button2) {
    return header;
  }

  // configure and add button2
  configureButtonStyle(button2);
  header.appendChild(button2.container);

  return header;
};

var addEntry = function addEntry(parent, name) {

  var entry = document.createElement('div');
  parent.appendChild(entry);

  // add label
  var nameDiv = document.createElement('div');
  nameDiv.textContent = name;
  nameDiv.fontSize = '10px';
  entry.appendChild(nameDiv);

  // add input field
  var inputDiv = document.createElement('input');
  inputDiv.type = 'text';
  entry.appendChild(inputDiv);

  // TODO: auto-stretch to panel width.
  inputDiv.style.width = '80px';

  // return input element for external access
  return inputDiv;
};

// Verifys if the input value is a valid numeric prefix.
// Valid examples: 1, -13, 0, 0.1, .1, ., -, -., -1.112
var isNumericPrefix = function isNumericPrefix(value) {
  return !!value.match(/^-?\d*\.?\d*$/);
};var

ValueInput = /*#__PURE__*/function () {

  function ValueInput(parent, onInput) {var _this = this;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;_classCallCheck(this, ValueInput);
    av.EventDispatcher.prototype.apply(this);

    this.container = document.createElement('div');
    this.container.style.display = 'flex';
    this.container.style.flexDirection = 'row';
    this.container.style.padding = '0px 10px 30px 10px';
    this.container.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';

    parent.appendChild(this.container);

    // add input field
    this.input = document.createElement('input');
    this.input.type = 'text';
    this.input.style.width = '100px';

    this.container.appendChild(this.input);

    this.updateInput = true;

    if (onInput) {
      this.handleInput = function () {
        _this.updateInput = false;
        onInput();
        _this.updateInput = true;
      };

      this.input.addEventListener("input", this.handleInput);
    }

    this.input.addEventListener("blur", this.onBlur.bind(this));

    this.digits = digits;
  }_createClass(ValueInput, [{ key: "validate", value: function validate(

    val) {
      return val.toFixed(this.digits);
    } }, { key: "setValue", value: function setValue(

    value) {
      if (value == undefined || value === null) {
        this.clear();
        return;
      }

      var trimmedValue = parseFloat(value).toFixed(this.digits);

      if (isNaN(trimmedValue)) {
        return;
      }

      if (this.updateInput) {
        this.input.value = trimmedValue;
      }

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "setRawValue", value: function setRawValue(

    value) {
      if (isNumericPrefix(value)) {
        this.input.value = value;
      }
    } }, { key: "getValue", value: function getValue()

    {
      return this.valid() ? parseFloat(this.input.value) : undefined;
    } }, { key: "onBlur", value: function onBlur()

    {
      this.setValue(this.input.value);
    } }, { key: "clear", value: function clear()

    {
      this.input.value = '';

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "valid", value: function valid()

    {
      return isFinite(parseFloat(this.input.value));
    } }]);return ValueInput;}();


// Helper class to combine 3 table rows with entries for x,y,z of a vector
var VectorInput = /*#__PURE__*/function () {

  function VectorInput(parent, onInput) {var _this2 = this;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;_classCallCheck(this, VectorInput);
    av.EventDispatcher.prototype.apply(this);

    this.container = document.createElement('div');
    this.container.style.display = 'flex';
    this.container.style.flexDirection = 'row';
    this.container.style.padding = '0px 10px 30px 10px';
    this.container.style.backgroundColor = 'rgba(34, 34, 34, 0.4)';

    parent.appendChild(this.container);

    this.x = addEntry(this.container, 'X');
    this.y = addEntry(this.container, 'Y');
    this.z = addEntry(this.container, 'Z');

    this.digits = digits;

    this._value = new THREE.Vector3();

    this.updateInput = true;

    // register event handlers
    if (onInput) {
      this.handleInput = function () {
        _this2.updateInput = false;
        onInput();
        _this2.updateInput = true;
      };

      this.x.addEventListener("input", this.handleInput);
      this.y.addEventListener("input", this.handleInput);
      this.z.addEventListener("input", this.handleInput);
    }

    this.x.addEventListener("blur", this.onBlur.bind(this));
    this.y.addEventListener("blur", this.onBlur.bind(this));
    this.z.addEventListener("blur", this.onBlur.bind(this));

    // If true, we interpret empty inputs as 0.0 and consider them as valid
    this.enableEmpty = false;
  }_createClass(VectorInput, [{ key: "validate", value: function validate(

    val) {
      return val.toFixed(this.digits);
    } }, { key: "parseValue", value: function parseValue(

    str) {
      // If wanted, return 0.0 for empty fields
      if (this.enableEmpty && !str.length) {
        return 0.0;
      }
      return parseFloat(str);
    }

    // Returns true if all 3 components have values
  }, { key: "valid", value: function valid() {
      return this.enableEmpty || this.x.value.length && this.y.value.length && this.z.value.length;
    } }, { key: "getValue", value: function getValue()

    {
      var x = this.parseValue(this.x.value);
      var y = this.parseValue(this.y.value);
      var z = this.parseValue(this.z.value);
      this._value.set(x, y, z);
      return this._value;
    } }, { key: "isZero", value: function isZero()

    {
      var val = this.getValue();
      return val.x == 0 && val.y == 0 && val.z == 0;
    } }, { key: "setValue", value: function setValue(

    vec) {
      if (!vec) {
        this.clear();
        return;
      }

      var xValidated = this.validate(vec.x);
      var yValidated = this.validate(vec.y);
      var zValidated = this.validate(vec.z);

      if (isNaN(xValidated) || isNaN(yValidated) || isNaN(zValidated)) {
        return;
      }

      this._value.copy(vec);

      if (this.updateInput) {
        this.x.value = xValidated;
        this.y.value = yValidated;
        this.z.value = zValidated;
      }

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }, { key: "setRawValue", value: function setRawValue(

    strVec) {
      if (
      isNumericPrefix(strVec.x) &&
      isNumericPrefix(strVec.y) &&
      isNumericPrefix(strVec.z))
      {
        this.x.value = strVec.x;
        this.y.value = strVec.y;
        this.z.value = strVec.z;
      }
    } }, { key: "onBlur", value: function onBlur()

    {
      this.setValue(this._value);
    } }, { key: "clear", value: function clear()

    {
      this.x.value = '';
      this.y.value = '';
      this.z.value = '';

      this.fireEvent({ type: Events.VECTOR_INPUT_VALUE_CHANGED });
    } }]);return VectorInput;}();


var addButton = function addButton(parent, id, name) {

  var button = new Autodesk.Viewing.UI.Button(id);
  parent.appendChild(button.container);

  button.container.textContent = name;
  button.container.style.textAlign = 'center';

  // center button in column
  button.container.style.left = '50%';
  button.container.style.transform = 'translateX(-50%)';

  // adjust button size to text extents
  button.container.style.width = 'auto';
  button.container.style.height = 'auto';

  button.container.style.backgroundColor = 'rgb(80,80,80)';

  return button;
};


// Simple glow-highlight effect
// TODO: Use css class to avoid overwriting box-shadow setting on disable
var setButtonHighlight = function setButtonHighlight(button, enable) {
  button.container.style.boxShadow = enable ? '0px 0px 10px' : 'initial';
  button.highlight = enable; // Used by external UI.
};

var TabIds = {
  Transform: 'Transform',
  PointToPoint: 'Point-to-Point',
  AngleToAngle: 'Angle-to-Angle' };var


ModelAlignmentPanel = /*#__PURE__*/function (_Autodesk$Viewing$UI$) {_inherits(ModelAlignmentPanel, _Autodesk$Viewing$UI$);var _super = _createSuper(ModelAlignmentPanel);

  function ModelAlignmentPanel(viewer, id, title, options) {var _this3;_classCallCheck(this, ModelAlignmentPanel);
    _this3 = _super.call(this, viewer.container, id, title, options);

    _this3.viewer = viewer;

    av.EventDispatcher.prototype.apply(_assertThisInitialized(_this3));

    // Contains a table for each tab
    _this3.pages = [];

    // Selected Tab ID.
    _this3.selectedTabId = null;

    // Style like settings panel
    _this3.title.style.borderBottomColor = 'rgb(74, 85, 91)';

    _this3.container.classList.add('model-alignment-panel');

    // default size and position
    _this3.container.style.width = '300px';
    _this3.container.style.height = '815px';
    _this3.container.style.top = '6px';
    _this3.container.style.left = '6px';

    // Body is the part between header and footer
    _this3.body = document.createElement('div');
    _this3.body.style.backgroundColor = 'rgba(34, 34, 34, 0.9)';
    _this3.body.style.height = '100%';
    _this3.body.style.padding = '10px';

    _this3.container.appendChild(_this3.body);

    _this3.addModelSection(_this3.body);
    _this3.addTabHeaderSection(_this3.body);

    _this3.positionTab = _this3.addTab(TabIds.Transform, 'Position');
    _this3.pointToPointTab = _this3.addTab(TabIds.PointToPoint, 'Move');
    _this3.angleToAngleTab = _this3.addTab(TabIds.AngleToAngle, 'Rotate');

    _this3.initPositionTab();
    _this3.initPointToPointTab();
    _this3.initAngleToAngleTab();

    _this3.selectTab(TabIds.Transform);

    // Number of digits for numeric values
    // TODO: This should be synchronized with Measure settings
    _this3.digits = 2;return _this3;
  }

  // Restrict digits of automatically set values
  _createClass(ModelAlignmentPanel, [{ key: "filterValue", value: function filterValue(val) {
      return val.toFixed(this.digits);
    } }, { key: "addModelSection", value: function addModelSection(

    parent) {var _this4 = this;
      // create tab content
      var section = document.createElement('div');
      section.id = 'ModelSection';

      // Create "Select" button for model
      this.selectModelButton = new Autodesk.Viewing.UI.Button('SelectModel');
      this.selectModelButton.container.textContent = 'Select';
      this.selectModelButton.onClick = function () {
        _this4.fireEvent({ type: Events.SELECT_MODEL_PRESSED });
        setButtonHighlight(_this4.selectModelButton, true);
      };

      addHeader(section, 'Model', this.selectModelButton);

      // Create model-select combo-box
      this.modelCombo = document.createElement('select');
      //this.modelCombo.classList.add('option-drop-down');
      this.modelCombo.classList.add('model-select-combo');
      section.appendChild(this.modelCombo);
      this.updateModelCombo();

      // Make sure that it's updated if the list of models changes
      this.updateModelCombo = this.updateModelCombo.bind(this);
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateModelCombo);
      this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.updateModelCombo);

      this.modelCombo.addEventListener('change', function () {
        var index = _this4.modelCombo.selectedIndex;
        var item = _this4.modelCombo.items[index];
        _this4.setModel(item.model);
      });

      parent.appendChild(section);
    }

    // Update item list in model-select combo-box
  }, { key: "updateModelCombo", value: function updateModelCombo() {var _this5 = this;
      this.modelCombo.length = 0;

      var items = [];
      items.push({ name: "Please select", model: null });

      // There may be multiple views of the same urn. In this case, we only show an item for the first view
      // of the urn. For all other views, the placement is synced anyway.
      var urns = {};

      this.viewer.getVisibleModels().forEach(function (model) {

        // Skip urn if we already added an item for another view of this model urn
        var urn = model.myData.urn;
        if (urns[urn]) {
          return;
        }
        urns[urn] = true;

        var modelName = model.getDocumentNode().getModelName();
        items.push({ name: modelName, model: model });
      });

      var onItemHover = function onItemHover(model) {
        if (model) {
          _this5.viewer.impl.renderer().rollOverModelId(model.id);
        } else {
          _this5.viewer.impl.clearHighlight();
        }

        // rerun blend-pass to update selection highlighting
        _this5.viewer.impl.invalidate(false, false, true);
      };

      items.forEach(function (item, index) {
        var option = document.createElement("option");
        option.value = index;
        option.textContent = item.name;

        option.addEventListener('mouseenter', function () {return onItemHover(item.model);});
        option.addEventListener('mouseleave', function () {return onItemHover(null);});

        _this5.modelCombo.add(option);
      });
      this.modelCombo.items = items;
    } }, { key: "initPositionTab", value: function initPositionTab()

    {var _this6 = this;

      this.positionTab.padding = '10px';

      // Create "Edit" button for model position
      this.editPositionButton = this.createEventButton('EditPositionButton', 'Edit', Events.EDIT_POSITION_PRESSED);
      this.fitToViewButton = this.createEventButton('FitToViewButton', 'Fit to View', Events.FIT_TO_VIEW_BUTTON_PRESSED, null, false);

      // add table body
      addHeader(this.positionTab, 'Position', this.editPositionButton, 'PositionHeader', this.fitToViewButton);
      this.position = new VectorInput(this.positionTab, function () {return _this6.onTransformChanged();});

      addHeader(this.positionTab, 'Rotation');
      this.rotation = new ValueInput(this.positionTab, function () {return _this6.onTransformChanged();});

      this.saveButton = this.createEventButton('SaveButton', 'Save Transforms', Events.SAVE_BUTTON_PRESSED);
      addHeader(this.body, '', this.saveButton);
    } }, { key: "initPointToPointTab", value: function initPointToPointTab()

    {var _this7 = this;

      // Create "Select" buttons for FromPoint and ToPoint
      this.selectFromButton = this.createEventButton('SelectFromButton', 'Select', Events.FROM_POINT_BUTTON_PRESSED);
      this.selectToButton = this.createEventButton('SelectToButton', 'Select', Events.TO_POINT_BUTTON_PRESSED);

      addHeader(this.pointToPointTab, 'From point', this.selectFromButton, 'FromPointHeader');
      this.fromPoint = new VectorInput(this.pointToPointTab, function () {return _this7.onFromPointChanged(true);});

      addHeader(this.pointToPointTab, 'To point', this.selectToButton, 'ToPointHeader');
      this.toPoint = new VectorInput(this.pointToPointTab, function () {return _this7.onToPointChanged(true);});

      addHeader(this.pointToPointTab, 'Offset', null, 'OffsetHeader');
      this.offset = new VectorInput(this.pointToPointTab, function () {return _this7.onOffsetChanged(true);});

      // For offset values, we allow empty entries, because we can use 0.0 by default.
      this.offset.enableEmpty = true;

      // add separator
      var separator = addHeaderBar(this.pointToPointTab);

      // Add apply button
      this.applyPointToPointButton = addButton(separator, 'ApplyP2P', 'Apply');
      this.applyPointToPointButton.onClick = function () {
        // Clear point-to-point entries after applying them
        _this7.clearPointToPoint();

        // Fire event to trigger actual operation
        _this7.fireEvent({ type: Events.APPLY_PTP_PRESSED });
      };
    } }, { key: "initAngleToAngleTab", value: function initAngleToAngleTab()

    {var _this8 = this;

      // Create "Select" buttons for FromPoint and ToPoint
      this.selectCenterButton = this.createEventButton('SelectCenterButton', 'Select', Events.CENTER_BUTTON_PRESSED, function () {return _this8.onSelectCenterButton();});
      this.selectFromAngleButton = this.createEventButton('SelectFromAngleButton', 'Direction', Events.FROM_ANGLE_BUTTON_PRESSED);
      this.selectToAngleButton = this.createEventButton('SelectToAngleButton', 'Direction', Events.TO_ANGLE_BUTTON_PRESSED);

      this.selectFromEdgeButton = this.createEventButton('SelectFromEdgeButton', 'Edge', Events.FROM_EDGE_BUTTON_PRESSED);
      this.selectToEdgeButton = this.createEventButton('SelectToEdgeButton', 'Edge', Events.TO_EDGE_BUTTON_PRESSED);


      addHeader(this.angleToAngleTab, 'Center', this.selectCenterButton, 'CenterHeader');
      this.center = new VectorInput(this.angleToAngleTab, function () {return _this8.onCenterChanged(true);});

      addHeader(this.angleToAngleTab, 'From angle', this.selectFromEdgeButton, 'FromAngleHeader', this.selectFromAngleButton);
      this.fromAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onFromAngleChanged(true);});

      addHeader(this.angleToAngleTab, 'To angle', this.selectToEdgeButton, 'ToPointHeader', this.selectToAngleButton);
      this.toAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onToAngleChanged(true);});

      addHeader(this.angleToAngleTab, 'Offset angle', null, 'OffsetHeader');
      this.offsetAngle = new ValueInput(this.angleToAngleTab, function () {return _this8.onOffsetAngleChanged(true);});

      // For offset values, we allow empty entries, because we can use 0.0 by default.
      this.offset.enableEmpty = true;

      // add separator
      var separator = addHeaderBar(this.angleToAngleTab);

      // Add apply button
      this.applyAngleToAngleButton = addButton(separator, 'ApplyA2A', 'Apply');
      this.applyAngleToAngleButton.onClick = function () {
        // Clear point-to-point entries after applying them
        _this8.clearAngleToAngle();

        // Fire event to trigger actual operation
        _this8.fireEvent({ type: Events.APPLY_ATA_PRESSED });
      };
    } }, { key: "setModel", value: function setModel(

    model) {

      this.model = model;

      // Sync modelCombo
      var items = this.modelCombo.items;
      this.modelCombo.selectedIndex = items.findIndex(function (item) {return item.model === model;});

      this.updateMatrix();

      // If model selector was running, finish it now.
      setButtonHighlight(this.selectModelButton, false);

      // Fire event - while avoiding recursive event triggers
      if (!this.blockEvents) {
        this.blockEvents = true;
        this.fireEvent({ type: Events.MODEL_SELECTED });
        this.blockEvents = false;
      }
    } }, { key: "updateMatrix", value: function updateMatrix()

    {
      if (this.model) {

        // Note about unit-scaling:
        //     If the viewer client uses a unit-scaling for the model, the viewer world coords may be different from the model units.
        //     In this case, the position offset values are in viewer world units instead of model units. This ensures that position
        //     offsets of different models are comparable.
        //
        //     However, the unit scaling must finally be reverted again before saving the transform, because the saved transform
        //     must keep independent of current unitScaling settings of the viewer client.
        //
        //     TODO: Ideally, we should consider the display units from MeasureSettings as well.

        // Initialize panel with current placementTransform. If the model was not aligned in ACC before, the
        // placemenTransform will correspond with the refPointTransform of the source file.
        // I.e., rotation will match with the true-north angle and the offset with the refPointLMV of the model.
        var matrix = this.model.getPlacementTransform();
        this.setMatrix(matrix);
      }
    } }, { key: "setPosition", value: function setPosition(

    pos) {
      this.position.setValue(pos);
    } }, { key: "setRotation", value: function setRotation(

    rotation) {
      this.rotation.setValue(rotation);
    } }, { key: "setFromPoint", value: function setFromPoint(

    from) {
      this.fromPoint.setValue(from);
      this.onFromPointChanged();
    } }, { key: "setToPoint", value: function setToPoint(

    to) {
      this.toPoint.setValue(to);
      this.onToPointChanged();
    } }, { key: "setOffset", value: function setOffset(

    offset) {
      this.offset.setValue(offset);
      this.onOffsetChanged();
    } }, { key: "setCenter", value: function setCenter(

    center) {
      this.center.setValue(center);
    } }, { key: "setFromAngle", value: function setFromAngle(

    angle) {
      this.fromAngle.setValue(angle);
      this.onFromAngleChanged();
    } }, { key: "setToAngle", value: function setToAngle(

    angle) {
      this.toAngle.setValue(angle);
      this.onToAngleChanged();

    } }, { key: "fromPointValid", value: function fromPointValid()

    {return this.fromPoint.valid();} }, { key: "toPointValid", value: function toPointValid()
    {return this.toPoint.valid();} }, { key: "offsetValid", value: function offsetValid()
    {return this.offset.valid();} }, { key: "clearPointToPoint", value: function clearPointToPoint()

    {
      this.fromPoint.clear();
      this.toPoint.clear();
      this.offset.clear();
    } }, { key: "clearAngleToAngle", value: function clearAngleToAngle()

    {
      this.center.clear();
      this.fromAngle.clear();
      this.toAngle.clear();
      this.offsetAngle.clear();
    }

    // Get Vector3 values. Note that result may be undefined if not all components are set.
  }, { key: "getPosition", value: function getPosition() {return this.position.valid() && this.position.getValue();} }, { key: "getRotation", value: function getRotation()
    {return this.rotation.valid() && this.rotation.getValue();} }, { key: "getFromPoint", value: function getFromPoint()
    {return this.fromPoint.valid() && this.fromPoint.getValue();} }, { key: "getToPoint", value: function getToPoint()
    {return this.toPoint.valid() && this.toPoint.getValue();}

    // Note: Unlike from/to, the offset is considered valid as soon as >= one component is specified
  }, { key: "getOffset", value: function getOffset() {return !this.offset.isZero() && this.offset.getValue();} }, { key: "getCenter", value: function getCenter()

    {return this.center.valid() && this.center.getValue();}

    // Recover original scaling value based on the "unedited" placementTransform, i.e., the placement that was used at load-time
  }, { key: "extractModelScale", value: function extractModelScale() {
      // If no placement was applied, scaling is (1,1,1)
      var scale = new THREE.Vector3(1, 1, 1);
      var tf = this.model.myData.placementTransform;
      if (!tf) {
        return scale;
      }

      // Decompose original transform to obtain scaling
      return scale.setFromMatrixScale(tf);
    } }, { key: "onTransformChanged", value: function onTransformChanged()

    {
      if (!this.model) {
        return;
      }

      var pos = this.getPosition();
      var zAxis = new THREE.Vector3(0, 0, 1);
      var angle = THREE.Math.degToRad(this.getRotation());
      var rot = new THREE.Quaternion().setFromAxisAngle(zAxis, angle);
      var scale = this.extractModelScale(); // Preserve original scaling

      // Do nothing if values is not fully specified
      if (!pos || !rot) {
        return;
      }

      // compose placementMatrix from panel values
      var newPlacement = new avp.LmvMatrix4(true).compose(pos, rot, scale);
      this.viewer.impl.setPlacementTransform(this.model, newPlacement);

      this.fireEvent({ type: Events.MODEL_TRANSFORM_EDITED });
    } }, { key: "onFromPointChanged", value: function onFromPointChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      // Use offset only if any 

      if (from && to) {
        // Update offset
        this.offset.setValue(to.sub(from));
      } else if (from && offset) {
        // Setting from and offset also sets the toPoint
        this.toPoint.setValue(from.add(offset));
        fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
      }

      fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
    } }, { key: "onToPointChanged", value: function onToPointChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      if (from && to) {
        // Update offset
        this.offset.setValue(to.sub(from));
        fireEvent && this.fireEvent({ type: Events.OFFSET_CHANGED, offset: this.getOffset() });
      } else if (to && offset) {
        // Setting to and offset also sets the fromPoint
        this.fromPoint.setValue(to.sub(offset));
        fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
      }
      fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
    } }, { key: "onOffsetChanged", value: function onOffsetChanged(

    fireEvent) {

      var from = this.getFromPoint();
      var to = this.getToPoint();
      var offset = this.getOffset();

      if (from && offset) {
        this.toPoint.setValue(from.add(offset));
        fireEvent && this.fireEvent({ type: Events.TO_POINT_CHANGED, toPoint: this.getToPoint() });
      } else if (to && offset) {
        this.fromPoint.setValue(to.sub(offset));
        fireEvent && this.fireEvent({ type: Events.FROM_POINT_CHANGED, fromPoint: this.getFromPoint() });
      }
      fireEvent && this.fireEvent({ type: Events.OFFSET_CHANGED, offset: this.getOffset() });
    }

    // Helper functions to update one entry based on two others. The two others must be valid.
  }, { key: "updateFromAngle", value: function updateFromAngle(fireEvent) {
      var fromAngle = this.toAngle.getValue() - this.offsetAngle.getValue();
      this.fromAngle.setValue(fromAngle);
      fireEvent && this.fireEvent({ type: Events.FROM_ANGLE_CHANGED, angle: fromAngle });
    } }, { key: "updateToAngle", value: function updateToAngle(

    fireEvent) {
      var toAngle = this.fromAngle.getValue() + this.offsetAngle.getValue();
      this.toAngle.setValue(toAngle);
      fireEvent && this.fireEvent({ type: Events.TO_ANGLE_CHANGED, angle: toAngle });
    } }, { key: "updateOffsetAngle", value: function updateOffsetAngle(

    fireEvent) {
      var offsetAngle = this.toAngle.getValue() - this.fromAngle.getValue();
      this.offsetAngle.setValue(offsetAngle);
      fireEvent && this.fireEvent({ type: Events.OFFSET_ANGLE_CHANGED, angle: offsetAngle });
    } }, { key: "onCenterChanged", value: function onCenterChanged(

    fireEvent) {
      // TODO: Add additional logic here to clear / update the other angle input boxes according to the new center.

      fireEvent && this.fireEvent({ type: Events.CENTER_CHANGED, center: this.getCenter() });
    } }, { key: "onFromAngleChanged", value: function onFromAngleChanged(

    fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      // Update one value based on two others to keep from/to/center consistent.
      if (fromValid && toValid) {
        this.updateOffsetAngle(fireEvent);
      } else if (fromValid && offsetValid) {
        this.updateToAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.FROM_ANGLE_CHANGED, angle: this.fromAngle.getValue() });
    } }, { key: "onToAngleChanged", value: function onToAngleChanged(

    fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      // Update one value based on two others to keep from/to/center consistent.
      if (fromValid && toValid) {
        this.updateOffsetAngle(fireEvent);
      } else if (toValid && offsetValid) {
        this.updateFromAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.TO_ANGLE_CHANGED, angle: this.toAngle.getValue() });
    }

    // If offsetAngle changed, update fromAngle or toAngle to keep them consistent
  }, { key: "onOffsetAngleChanged", value: function onOffsetAngleChanged(fireEvent) {

      var fromValid = this.fromAngle.valid();
      var toValid = this.toAngle.valid();
      var offsetValid = this.offsetAngle.valid();

      if (fromValid && offsetValid) {
        this.updateToAngle(fireEvent);
      } else if (toValid && offsetValid) {
        this.updateFromAngle(fireEvent);
      } else if (offsetValid && !fromValid && !toValid) {
        this.fromAngle.setValue(0);
        this.toAngle.setValue(this.offsetAngle.getValue());
        this.updateFromAngle(fireEvent);
        this.updateToAngle(fireEvent);
      }
      fireEvent && this.fireEvent({ type: Events.OFFSET_ANGLE_CHANGED, angle: this.offsetAngle.getValue() });
    } }, { key: "setMatrix", value: function setMatrix(

    matrix) {

      matrix = matrix || new THREE.Matrix4().identity();

      // decompose into pos/scale/rotation
      var pos = new THREE.Vector3();
      var rot = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      THREE.Matrix4.prototype.decompose.call(matrix, pos, rot, scale); // Note that matrix.decompose would not exist on LmvMatrix4

      // apply pos
      this.setPosition(pos);

      // Extract absolute rotation angle
      var euler = new THREE.Euler().setFromQuaternion(rot);
      var angle = THREE.Math.radToDeg(euler._z);

      // apply rotation
      this.setRotation(angle);
    } }, { key: "addTabHeaderSection", value: function addTabHeaderSection(

    parent) {
      this.tabHeaders = document.createElement("div");
      this.tabHeaders.id = 'TabHeaders';

      this.tabHeaders.style.paddingTop = '15px';
      this.tabHeaders.style.paddingLeft = '10px';
      this.tabHeaders.style.backgroundColor = 'rgb(34, 34, 34, 0.94)';
      this.tabHeaders.style.display = 'flex';
      this.tabHeaders.style.flexDirection = 'row';

      // Add 3px border in the same color - as a placeholder for the understroke of selected item
      this.tabHeaders.style.borderBottomStyle = 'solid';
      this.tabHeaders.style.borderBottomWidth = '3px';
      this.tabHeaders.style.borderColor = 'rgb(34, 34, 34, 0.94)';

      parent.appendChild(this.tabHeaders);
    } }, { key: "addTabHeader", value: function addTabHeader(

    tabId, title) {var _this9 = this;

      // add text span to title element
      var tab = document.createElement("div");
      tab.style.paddingRight = '10px';

      var span = document.createElement("span");
      span.textContent = title;

      span.classList.add('tab-header');

      tab.appendChild(span);

      tab.tabId = tabId;
      tab.text = span;

      this.tabHeaders.appendChild(tab);

      // Select this tab on click
      var select = function select() {return _this9.selectTab(tabId);};
      tab.addEventListener('click', select);
    } }, { key: "addTab", value: function addTab(

    tabId, title) {
      this.addTabHeader(tabId, title);

      // create tab content
      var page = document.createElement('div');
      page.tabId = tabId;

      this.pages.push(page);
      this.body.append(page);

      return page;
    } }, { key: "selectTab", value: function selectTab(

    selectedTabId) {

      // highlight header of selected tab
      for (var i = 0; i < this.tabHeaders.children.length; i++) {
        var tab = this.tabHeaders.children[i];
        var isSelected = tab.tabId == selectedTabId;

        if (isSelected) {
          tab.text.classList.add('selected');
        } else {
          tab.text.classList.remove('selected');
        }
      }

      // set selected page visible
      for (var _i = 0; _i < this.pages.length; _i++) {
        var page = this.pages[_i];
        var _isSelected = page.tabId === selectedTabId;
        page.style.display = _isSelected ? 'block' : 'none';
      }

      this.selectedTabId = selectedTabId;

      this.fireEvent({ type: Events.TAB_CHANGED, tabId: selectedTabId });
    }

    // Called when point-to-point tool finished
  }, { key: "onFromSelected", value: function onFromSelected(point) {
      this.setFromPoint(point);
      setButtonHighlight(this.selectFromButton, false);

      // If toPoint is not specified yet, immediately trigger toPoint selected as well.
      if (this.fromPoint.valid() && !this.toPoint.valid()) {
        setButtonHighlight(this.selectToButton, true);
        this.fireEvent({ type: Events.TO_POINT_BUTTON_PRESSED });
      }
    } }, { key: "onToSelected", value: function onToSelected(

    point) {
      this.setToPoint(point);
      setButtonHighlight(this.selectToButton, false);
    }

    // Reflect coordinates on hover
  }, { key: "onFromHovered", value: function onFromHovered(point) {
      this.setFromPoint(point);
    } }, { key: "onToHovered", value: function onToHovered(
    point) {
      this.setToPoint(point);
    }

    // Create a button that triggers an event of the given type and sets itself to highlighted when pressed.
  }, { key: "createEventButton", value: function createEventButton(id, text, eventType, onClick) {var _this10 = this;var highlightOnClick = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var button = new Autodesk.Viewing.UI.Button(id);
      button.container.textContent = text;
      button.onClick = function () {
        onClick && onClick();
        _this10.fireEvent({ type: eventType });
        highlightOnClick && setButtonHighlight(button, true);
      };
      return button;
    } }, { key: "onCenterHovered", value: function onCenterHovered(

    point) {
      this.setCenter(point);
    } }, { key: "onCenterSelected", value: function onCenterSelected(

    point) {

      this.setCenter(point);
      setButtonHighlight(this.selectCenterButton, false);

      // If fromAngle is not specified yet, immediately trigger fromAngle selection as well.
      if (this.center.valid() && !this.fromAngle.valid()) {
        setButtonHighlight(this.selectFromAngleButton, true);
      }
    } }, { key: "onFromAngleHovered", value: function onFromAngleHovered(

    angle) {
      this.setFromAngle(angle);
    } }, { key: "onFromAngleSelected", value: function onFromAngleSelected(

    angle) {
      this.setFromAngle(angle);
      setButtonHighlight(this.selectFromAngleButton, false);
      setButtonHighlight(this.selectFromEdgeButton, false);

      // If toAngle is not specified yet, immediately trigger fromAngle selection as well.
      if (this.center.valid() && this.fromAngle.valid() && !this.toAngle.valid()) {
        setButtonHighlight(this.selectToAngleButton, true);
      }
    } }, { key: "onToAngleHovered", value: function onToAngleHovered(

    angle) {
      this.setToAngle(angle);
    } }, { key: "onToAngleSelected", value: function onToAngleSelected(

    angle) {
      this.setToAngle(angle);
      setButtonHighlight(this.selectToAngleButton, false);
      setButtonHighlight(this.selectToEdgeButton, false);
    }

    // When selecting a new center, clear all previous entries
  }, { key: "onSelectCenterButton", value: function onSelectCenterButton() {
      this.clearAngleToAngle();
    } }, { key: "uninitialize", value: function uninitialize()

    {
      _get(_getPrototypeOf(ModelAlignmentPanel.prototype), "uninitialize", this).call(this);
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateModelCombo);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.updateModelCombo);
    } }]);return ModelAlignmentPanel;}(Autodesk.Viewing.UI.DockingPanel);


ModelAlignmentPanel.Events = Events;
ModelAlignmentPanel.TabIds = TabIds;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelSelector.js":
/*!****************************************************!*\
  !*** ./extensions/ModelAlignment/ModelSelector.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelSelector; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var Events = {
  MODEL_SELECTED: 'modelSelected' // event.model contains selected model (may be null when clicking without a model under mouse)
};

var ToolName = 'ModelAlignment.ModelSelector';


// Simple tool for selecting a model in canvas within an aggregated view
var
ModelSelector = /*#__PURE__*/function () {

  function ModelSelector(viewer) {_classCallCheck(this, ModelSelector);
    this.viewer = viewer;

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.hoverColor = new THREE.Color(0.5, 0.5, 0.1);
  }_createClass(ModelSelector, [{ key: "getName", value: function getName()

    {
      return ToolName;
    } }, { key: "getNames", value: function getNames()

    {
      return [ToolName];
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.viewer.impl.renderer().setRollOverHighlightColor(this.hoverColor);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;

      // Make sure that we don't leak rollover-highlighting
      this.viewer.impl.clearHighlight();

      // reset to default rollOver highlight color
      this.viewer.impl.renderer().setRollOverHighlightColor();
    } }, { key: "register", value: function register()

    {}

    // Returns modelID under mouse or 0 if nothing is hit
  }, { key: "modelIdAtPixel", value: function modelIdAtPixel(canvasX, canvasY) {

      var res = [];

      // get model under mouse
      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);
      var dbId = this.viewer.impl.renderer().idAtPixel(vpVec.x, vpVec.y, res);

      // If there is only a single model, we don't get valid modelId values, because RenderContext may
      // just use a single idTarget for only dbIds. But for this case, it's not hard to tell which model was hit.
      var models = this.viewer.getVisibleModels();
      if (dbId && models.length === 1) {
        return models[0].id;
      }

      // If we have multiple models, we require the ID buffer.
      return res[1] ? res[1] : 0;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Don't apply hover highlight during dragging
      if (event.buttons !== 0) {
        this.viewer.impl.clearHighlight();
        return false;
      }

      var modelId = this.modelIdAtPixel(event.canvasX, event.canvasY);
      if (modelId >= 1) {
        this.viewer.impl.renderer().rollOverModelId(modelId);
      } else {
        this.viewer.impl.clearHighlight();
      }
      // rerun blend-pass to update selection highlighting
      this.viewer.impl.invalidate(false, false, true);

      // consume event to avoid the regular rollover-highlight per object 
      return true;
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Find selected model (may be null)
      var modelId = this.modelIdAtPixel(event.canvasX, event.canvasY);
      var model = modelId && this.viewer.impl.findModel(modelId);

      this.fireEvent({ type: Events.MODEL_SELECTED, model: model });

      return true;
    } }]);return ModelSelector;}();
;

ModelSelector.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/ModelTransformTool.js":
/*!*********************************************************!*\
  !*** ./extensions/ModelAlignment/ModelTransformTool.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelTransformTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var OverlayName = 'Autodesk.ModelAlignment_Gizmo';

var Events = {
  MODEL_MOVED_EVENT: 'modelMoved' };


var av = Autodesk.Viewing;

// Tool for moving and rotating a model 
var ModelTransformTool = /*#__PURE__*/function () {

  function ModelTransformTool(viewer, id) {_classCallCheck(this, ModelTransformTool);

    av.EventDispatcher.prototype.apply(this);

    this.viewer = viewer;
    this.id = id;

    // Anchor point in local model coordinates where
    // we place the gizmo
    // (local = excluding model transform)
    this.anchor = new THREE.Vector3();

    // Anchor after applying model matrix
    this.startPos = new THREE.Vector3();

    // Create overlay scene (no effect if alreay existing)
    this.viewer.impl.createOverlayScene(OverlayName);

    // Create axis gizmo
    this.gizmo = new THREE.TransformControls(this.viewer.impl.camera, this.viewer.canvas, 'translate');

    // The edit gizmo must be attached to a 3D object to work.
    // We use an empty target object here and sync the model matrix to the movements of this object.
    this.target = new THREE.Object3D();
    this.gizmo.attach(this.target);

    // Track activate/deactivate calls
    this.active = false;

    // reused tmp matrix
    this.tmpMatrix = new THREE.Matrix4();

    // bind event listeners
    this.onCameraChange = this.onCameraChange.bind(this);
  }_createClass(ModelTransformTool, [{ key: "dtor", value: function dtor()

    {
      this.deactivate();

      // Note that this only works as long no one needs multiple instances of this tool in parallel
      this.viewer.impl.removeOverlayScene(OverlayName);
    } }, { key: "setModel", value: function setModel(

    model, box) {

      this.model = model;

      if (!model) {
        this.setGizmoVisible(false);
        return;
      }

      // Compute anchor point in local model-coordinates
      // (unaffected by model matrix)
      box = box || this.model.getFuzzyBox({ ignoreTransforms: true });
      this.anchor.copy(box.min);

      this.initGizmo();
      this.setGizmoVisible(true);
    } }, { key: "setGizmoVisible", value: function setGizmoVisible(

    visible) {
      this.gizmo.visible = visible;
      this.viewer.impl.invalidate(false, false, true);
    }

    // Init gizmo to be located at minPoint of the model box
  }, { key: "initGizmo", value: function initGizmo() {

      if (!this.model) {
        return;
      }

      // compute start position for the gizmo:
      // This is where the anchor point goes
      this.startPos.copy(this.anchor);

      // ...after applying model transform
      var matrix = this.model.getModelToViewerTransform();
      if (matrix) {
        this.startPos.applyMatrix4(matrix);
      }

      // move gizmo to model anchor
      this.target.position.copy(this.startPos);

      // update gizmo position
      this.gizmo.update();
      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "getNames", value: function getNames()


    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return "ModelTransformTool_".concat(this.id);
    } }, { key: "activate", value: function activate()

    {
      if (this.active) {
        return;
      }

      // Show gizmo
      this.viewer.impl.addOverlay(OverlayName, this.gizmo);

      // update gizmo on camera change
      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      this.active = true;
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.active) {
        return;
      }

      // Hide gizmo
      this.viewer.impl.removeOverlay(OverlayName, this.gizmo);

      // Stop listening to camera changes
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      this.active = false;
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.gizmo.update();
      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // perform hover/move on gizmo
      var moved = this.gizmo.onPointerMove(event);
      var onGizmo = this.gizmo.onPointerHover(event);

      // update overlay. Also update model if gizmo was moved
      this.viewer.impl.invalidate(moved, moved, true);

      // If gizmo was dragged, move the model as well
      if (moved) {

        // get delta between current gizmo position and start position
        var delta = this.target.position.clone().sub(this.startPos);

        // apply same offset to the model placement
        var placement = this.model.getPlacementTransform();
        var el = placement.elements;
        el[12] += delta.x;
        el[13] += delta.y;
        el[14] += delta.z;

        this.viewer.impl.setPlacementTransform(this.model, placement);
        this.fireEvent({ type: Events.MODEL_MOVED_EVENT });
      }

      if (onGizmo || moved) {
        this.viewer.impl.clearHighlight();
      }

      return onGizmo || moved;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event) {
      if (event.button !== 0) {
        return false;
      }
      return this.gizmo.onPointerDown(event);
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event) {
      if (event.button !== 0) {
        return false;
      }
      return this.gizmo.onPointerUp(event);
    }

    // Make sure that this tool takes preference over OrbitDollyPanTool (which has default priority 0)
  }, { key: "getPriority", value: function getPriority() {
      return 1;
    } }]);return ModelTransformTool;}();


ModelTransformTool.Events = Events;

/***/ }),

/***/ "./extensions/ModelAlignment/PointToPoint.js":
/*!***************************************************!*\
  !*** ./extensions/ModelAlignment/PointToPoint.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointToPoint; });
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var
PointToPoint = /*#__PURE__*/function (_Autodesk$Edit3D$TwoP) {_inherits(PointToPoint, _Autodesk$Edit3D$TwoP);var _super = _createSuper(PointToPoint);

  function PointToPoint(viewer, coordPicker, screenOverlay) {var _this;_classCallCheck(this, PointToPoint);

    var options = {
      draggable: true,
      labels: ['From', 'To'],
      colors: [Autodesk.Edit3D.NPointPicker.Colors.Blue, Autodesk.Edit3D.NPointPicker.Colors.Red],
      connections: [
      {
        fromIndex: 0,
        toIndex: 1,
        type: Autodesk.Edit3D.NPointPicker.ConnectorTypes.Line,
        color: Autodesk.Edit3D.NPointPicker.Colors.Black,
        getEdgeLabelText: function getEdgeLabelText() {
          var length = _this.points[0].distanceTo(_this.points[1]);
          var text = _this.unitHandler.lengthToString(length);
          return text;
        } }] };




    _this = _super.call(this, viewer, coordPicker, screenOverlay, options);

    _this.unitHandler = new Autodesk.Edit2D.DefaultUnitHandler(_this.viewer);

    _this.updateGizmos = _this.updateGizmos.bind(_assertThisInitialized(_this));

    _this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, _this.updateGizmos);return _this;
  }_createClass(PointToPoint, [{ key: "dtor", value: function dtor()

    {
      _get(_getPrototypeOf(PointToPoint.prototype), "dtor", this).call(this);

      this.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, this.updateGizmos);
    }

    // Moves the given model, so that "from" point moves to "to" point
  }, { key: "apply", value: function apply(model) {var _this2 = this;

      var matrix = model.getPlacementTransform();

      // If possible, use fromPoint/toPoint. In this case, we also show the PointMarkers.
      // Otherwise, we only use the model of an offset value is specified directly.
      var fromToValid = this.pointValid[0] && this.pointValid[1];
      var offset = fromToValid ? this.points[1].clone().sub(this.points[0]) : this.offset;

      var startPos = new THREE.Vector3().setFromMatrixPosition(matrix);
      var endPos = startPos.clone().add(offset);
      var pos = new THREE.Vector3();

      // from-marker-position during animation
      var markerPos = new THREE.Vector3();

      // Fade-out lineGizmo during transition
      this.screenOverlay.fadeOutGizmo(this.connectors[0].gizmo);
      this.connectors[0].label.setOpacity(0, true);

      // blend between start/end position
      var onTimer = function onTimer(t) {

        t = THREE.Math.smootherstep(t, 0.0, 1.0);

        pos.lerpVectors(startPos, endPos, t);

        // move marker with the model
        markerPos.lerpVectors(_this2.points[0], _this2.points[1], t);
        _this2.markers[0].setPosition(markerPos);

        // Update model matrix
        matrix.setPosition(pos);
        _this2.viewer.impl.setPlacementTransform(model, matrix);
      };

      // Fade-out marker labels immediately, because it looks weird if they overlap.
      this.markers[0].setLabelVisible(false);
      this.markers[1].setLabelVisible(false);

      var onEnd = function onEnd(t) {
        _this2.clear();
        _this2.anim = null;
      };

      this.anim = Autodesk.Viewing.Private.fadeValue(0, 1, 1.0, onTimer, onEnd);
    }

    // Move model to the center of the current view
  }, { key: "fitModelToView", value: function fitModelToView(model) {

      // Compute a camera that would fit the model bbox
      var box = model.getBoundingBox();
      var cam = this.viewer.impl.camera;
      var view = Autodesk.Viewing.UnifiedCamera.getViewParamsFromBox(box, false, cam.aspect, cam.up, cam.fov);

      var fromPoint = box.center();

      // Choose toPoint in a way that it is:
      //  - at the current view center
      //  - at the same distance as 
      var dist = view.position.distanceTo(view.target);
      var dir = cam.getWorldDirection();
      var offset = dir.clone().multiplyScalar(dist);
      var toPoint = cam.position.clone().add(offset);

      // If the model is too far away, just animate a small piece of the movement to indicate from which direction the model came.
      // Animating over the full distance would not help anyway, because the model would be invisible for most animation frames.
      var moveDist = fromPoint.distanceTo(toPoint);
      var maxDist = 2.0 * box.size().length();
      if (moveDist > maxDist) {
        var skipDist = Math.max(moveDist - maxDist, 0.0);
        var skipOffset = toPoint.clone().sub(fromPoint).normalize().multiplyScalar(skipDist);

        // Move model immediately by skipOffset
        var matrix = model.getPlacementTransform();
        var modelPos = new THREE.Vector3().setFromMatrixPosition(matrix);
        modelPos.add(skipOffset);
        matrix.setPosition(modelPos);
        this.viewer.impl.setPlacementTransform(model, matrix);

        // Apply same offset to fromPoint
        fromPoint.add(skipOffset);
      }

      this.setFrom(fromPoint);
      this.setTo(toPoint);

      this.apply(model);
    }

    // Fast-forward animation
  }, { key: "skipAnim", value: function skipAnim() {
      this.anim && this.anim.skip();
    } }]);return PointToPoint;}(Autodesk.Edit3D.TwoPointPicker);

/***/ }),

/***/ "./extensions/ModelAlignment/SheetAlignment.js":
/*!*****************************************************!*\
  !*** ./extensions/ModelAlignment/SheetAlignment.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetAlignmentExtension; });
/* harmony import */ var _FourPointsAlignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FourPointsAlignment.js */ "./extensions/ModelAlignment/FourPointsAlignment.js");
/* harmony import */ var _SheetAlignmentLocals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetAlignmentLocals */ "./extensions/ModelAlignment/SheetAlignmentLocals.js");
/* harmony import */ var _ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModelAlignmentBase.js */ "./extensions/ModelAlignment/ModelAlignmentBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


/**
                                                   * SheetAlignment extension provides tools to align a 2D sheet and a 3D model.
                                                   * 
                                                   * @example
                                                   *   viewer.loadExtension('Autodesk.SheetAlignment')
                                                   *
                                                   * @memberof Autodesk.Viewing.Extensions
                                                   * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                                   * @alias Autodesk.Viewing.Extensions.SheetAlignment
                                                   * @class
                                                   */



var extensionName = "Autodesk.SheetAlignment";

var namespace = AutodeskNamespace("Autodesk.SheetAlignment");

var EPSILON = 0.0001;

var Events = {
  ADD_DRAWING_CLICKED: "addDrawingClicked" };var


SheetAlignmentExtension = /*#__PURE__*/function (_ModelAlignmentBase) {_inherits(SheetAlignmentExtension, _ModelAlignmentBase);var _super = _createSuper(SheetAlignmentExtension);

  function SheetAlignmentExtension(viewer, options) {var _this;_classCallCheck(this, SheetAlignmentExtension);
    _this = _super.call(this, viewer, options);

    _this.name = extensionName;

    // 2D sheet model to align.
    _this.model = null;

    // 3D model that the sheet should be aligned to.
    _this.target3DModel = null;

    _this.tmpBox = new THREE.Box3();

    _this.onCropChanged = _this.onCropChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(SheetAlignmentExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                this.extendLocalization(_SheetAlignmentLocals__WEBPACK_IMPORTED_MODULE_1__["locales"]);_context.next = 3;return _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "load", this).call(this);case 3:_context.next = 5;return (



                  this.viewer.loadExtension('Autodesk.Crop', { disableMoveTool: true }));case 5:this.cropExtension = _context.sent;

                this.cropExtension.addEventListener(Autodesk.Crop.Events.CROP_MODIFIED, this.onCropChanged);

                this.fourPointsAlignment = new _FourPointsAlignment_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, this.coordPicker, this.screenOverlay);

                this.fitCameraToTargetModel = this.fitCameraToTargetModel.bind(this);

                this.fourPointsAlignment.addEventListener(_FourPointsAlignment_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.DEST_POINT_SELECTION_STARTED, this.fitCameraToTargetModel);

                this.onContextMenu = this.onContextMenu.bind(this);
                // Invoked when the context menu is about to get opened.
                this.viewer.registerContextMenuCallback(extensionName, this.onContextMenu);

                // When selecting a sheet for alignment, use these values for initial positioning.
                this.targetPos = null;
                this.targetNormal = null;case 14:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "unload", this).call(this);

      if (this.fourPointsAlignment) {
        this.fourPointsAlignment.dtor();
        this.fourPointsAlignment = null;
      }

      this.cropExtension.removeEventListener(Autodesk.Crop.Events.CROP_MODIFIED, this.onCropChanged);

      this.target3DModel = null;

      this.viewer.unregisterContextMenuCallback(extensionName);
    }

    // Given a normal to a face, calculate right vector.
  }, { key: "getRightVector", value: function getRightVector(normal) {
      var up = this.viewer.navigation.getWorldUpVector();

      var right = new THREE.Vector3();
      right.crossVectors(normal, up);
      if (right.lengthSq() < EPSILON) {
        // If normal and up are collinear, choose vector:
        // If the normal direction is mostly along the y axis, choose +Z as up, else choose +Y as up.
        // If they match (e.g., both are zero), pick +Z, the default for maps and most mechanical.
        if (Math.abs(normal.z) >= Math.abs(normal.y)) {
          up.set(0, 1, 0);
        } else {
          up.set(0, 0, 1);
        }

        right.crossVectors(normal, up);
      }

      return right.normalize();
    }

    // Set initial sheet transform according to targetPos & targetNormal
  }, { key: "applyInitialSheetTransform", value: function applyInitialSheetTransform() {
      if (!this.targetPos || !this.targetNormal) {
        return;
      }

      // get delta between current gizmo position and start position.
      var center = this.model.getBoundingBox(true, true).center();

      this.targetNormal.negate();

      // Add epsilon to prevent Z fighting once the sheet is on top of the face.
      var delta = this.targetPos.sub(center).sub(this.targetNormal.clone().multiplyScalar(EPSILON));

      var right = this.getRightVector(this.targetNormal);
      var up = right.cross(this.targetNormal).normalize();

      var orientation = new THREE.Matrix4();
      orientation.lookAt(new THREE.Vector3(), this.targetNormal, up);

      var centerToOrigin = new THREE.Matrix4().makeTranslation(-center.x, -center.y, -center.z);
      var originToCenter = new THREE.Matrix4().makeTranslation(center.x, center.y, center.z);

      // apply same offset to the model placement
      var translation = new THREE.Matrix4().makeTranslation(delta.x, delta.y, delta.z);

      var transform = translation.
      multiply(originToCenter).
      multiply(orientation).
      multiply(centerToOrigin);

      this.viewer.impl.setPlacementTransform(this.model, transform);

      this.modified();

      this.targetPos = null;
      this.targetNormal = null;
    }

    // Set 2D model to be aligned next
  }, { key: "setModel", value: function setModel(model) {
      if (this.model === model) {
        return;
      }

      // This has to be first, before supet.setModel, in order that the tool will get activated only after the model and default cropRegion is being set.
      this.cropExtension.setModel(model);

      this.cropExtension.cropToModelBounds(true);

      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "setModel", this).call(this, model);

      this.fourPointsAlignment.clear();

      // We call modelTransformTool.setModel here with a specific bounding box - according to the intersection of the model bounds and crop bounds.
      this.modelTransformTool.setModel(model, this.getMinCroppedBox());

      this.applyInitialSheetTransform();
    }

    // Optionally set target 3D model. Used in order to later fit the camera to it.
  }, { key: "setTarget3DModel", value: function setTarget3DModel(targetModel) {
      this.target3DModel = targetModel;
    } }, { key: "onSaveButton", value: function onSaveButton()

    {
      // Make sure that any in-progress animation is skipped before we start saving.
      this.fourPointsAlignment.skipAnim();

      _get(_getPrototypeOf(SheetAlignmentExtension.prototype), "onSaveButton", this).call(this);
    }

    // Activates point to point selection.
  }, { key: "startPointToPointSelection", value: function startPointToPointSelection() {
      this.fourPointsAlignment.startSelect();
    }

    // Applies point to point transform on the 2D sheet.
  }, { key: "applyPointsToPoints", value: function applyPointsToPoints() {
      this.fourPointsAlignment.apply(this.model);
      this.modified();
    }

    // Are all points ready. Used in order to identify if we can use applyPointsToPoints.
  }, { key: "areAllPointsSet", value: function areAllPointsSet() {
      return this.fourPointsAlignment.areAllPointsSet();
    }

    // Fit camera to 2D sheet.
  }, { key: "fitCameraToSheet", value: function fitCameraToSheet() {
      if (!this.model) {
        return;
      }

      // Switch to an orthographic camera when aligning a sheet.
      this.viewer.navigation.toOrthographic();

      var bbox = this.getMinCroppedBox();

      var pt = this.model.getModelToViewerTransform() || new THREE.Matrix4();
      var center = bbox.center();

      // Apply transform to position.
      var position = center.clone().applyMatrix4(pt);

      var target = center;
      target.z -= bbox.size().y;

      // Apply transform to target.
      target.applyMatrix4(pt);

      var rotation = new THREE.Matrix4();
      rotation.extractRotation(pt);

      // Apply rotation to up vector - according to 2D model default up direction.
      var up = new THREE.Vector3(0, 1, 0).applyMatrix4(rotation).normalize();

      var dstView = {
        position: position,
        target: target,
        up: up };


      Autodesk.Viewing.Private.flyToView(this.viewer, dstView, 0.5, undefined, false);
    }

    // Fit camera to 3D target model.
  }, { key: "fitCameraToTargetModel", value: function fitCameraToTargetModel() {
      if (!this.target3DModel) {
        return;
      }

      // model.getBoundingBox returns an LmvBox3 instead of THREE.Box3.
      var bbox = new THREE.Box3().copy(this.target3DModel.getBoundingBox());
      this.viewer.navigation.fitBounds(false, bbox, false);
    } }, { key: "show", value: function show()

    {
      if (!this.model || this.active) {
        return;
      }

      this.active = true;

      this.fourPointsAlignment.setVisible(true);
      this.fourPointsAlignment.continuePointSelectionIfNeeded();

      this.cropExtension.activate();

      if (!this.viewer.toolController.isToolActivated(this.modelTransformTool.getName())) {
        this.viewer.toolController.activateTool(this.modelTransformTool.getName());
      }
    } }, { key: "hide", value: function hide()

    {
      if (!this.active) {
        return;
      }

      this.active = false;

      this.fourPointsAlignment.cancelPointSelection();
      this.fourPointsAlignment.setVisible(false);

      this.cropExtension.deactivate();

      this.viewer.toolController.deactivateTool(this.modelTransformTool.getName());
    }

    // Get the intersection of the sheet's original bounding box and the crop box.
  }, { key: "getMinCroppedBox", value: function getMinCroppedBox() {var _this$cropExtension$g;
      if (!this.model) {
        return null;
      }

      // Get the bounding box without a transform.
      var bbox = this.tmpBox.copy(this.model.getBoundingBox(true)); // Need to copy since the inner vectors of model.getBoundingBox are not THREE.Vector3.
      var cropBox = (_this$cropExtension$g = this.cropExtension.getCurrentCropRegion()) === null || _this$cropExtension$g === void 0 ? void 0 : _this$cropExtension$g.bbox;

      // Fit to the minimum box (intersection) of the original bounding box and the cropped area.
      if (cropBox) {
        bbox.intersect(cropBox);
      }

      return bbox;
    } }, { key: "onCropChanged", value: function onCropChanged()

    {
      var bbox = this.getMinCroppedBox();
      this.modelTransformTool.setModel(this.model, bbox);

      var cropRegion = this.cropExtension.getCurrentCropRegion();
      this.modified(cropRegion);
    } }, { key: "onContextMenu", value: function onContextMenu(

    menu, status) {var _intersection$model,_intersection$face,_this2 = this;
      var intersection = this.viewer.impl.hitTest(status.canvasX, status.canvasY, false);

      // If the intersected object does not belong to a 3D model, ignore it.
      if (!(intersection === null || intersection === void 0 ? void 0 : (_intersection$model = intersection.model) === null || _intersection$model === void 0 ? void 0 : _intersection$model.is3d())) {
        return;
      }

      // Make sure that the intersection has a valid face & normal.
      if (!(intersection === null || intersection === void 0 ? void 0 : (_intersection$face = intersection.face) === null || _intersection$face === void 0 ? void 0 : _intersection$face.normal)) {
        return;
      }

      var point = intersection.point;
      var mesh = this.viewer.impl.getRenderProxy(intersection.model, intersection.fragId);
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
      var normal = intersection.face.normal.clone().applyMatrix3(normalMatrix).normalize();

      var onSheetLoaded = function onSheetLoaded(model) {
        _this2.setModel(model);

        _this2.fitCameraToSheet();

        _this2.startPointToPointSelection();
      };

      var menuEntry = {
        title: 'Add drawing', // Gets translated inside ContextMenu.js
        target: function target() {
          _this2.viewer.clearSelection();
          _this2.targetPos = point;
          _this2.targetNormal = normal;
          _this2.setTarget3DModel(intersection.model);

          _this2.fireEvent({
            type: Events.ADD_DRAWING_CLICKED,
            onSheetLoaded: onSheetLoaded });

        } };


      menu.push(menuEntry);
    }

    /**
       * Saving sheet alignment changes is a process that involves:
       * 
       * - Creating a relationship between the 2D sheet and the target 3D model. Once the relationship is made, it returns a unique id.
       *   In case the relationship already exists, it won't create a new one - but return the existing id.
       * - Now that we have a relationshipId, we use it as an additional key in order to save with it the viewport & the transform of the 2D sheet.
       * - Notice that a 2D sheet viewport & transform is defined by three keys: urn, guid & relationshipId.
       */ }, { key: "saveChanges", value: function () {var _saveChanges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      alignmentService) {var matrix, sheetNode, sheetUrn, sheetGuid, target3DModelNode, target3DModelUrn, target3DModelGuid, cropRegion;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!(


                !this.model || !this.target3DModel)) {_context2.next = 2;break;}return _context2.abrupt("return");case 2:



                matrix = this.model.getPlacementTransform();
                sheetNode = this.model.getDocumentNode();
                sheetUrn = sheetNode.getRootNode().urn();
                sheetGuid = sheetNode.guid();

                target3DModelNode = this.target3DModel.getDocumentNode();
                target3DModelUrn = target3DModelNode.getRootNode().urn();
                target3DModelGuid = target3DModelNode.guid();

                cropRegion = this.cropExtension.getCurrentCropRegion();

                // Save relationship of 2D sheet and 3D model.
                _context2.t0 = this.model.alignmentRelationshipId;if (_context2.t0) {_context2.next = 15;break;}_context2.next = 14;return (
                  alignmentService.saveRelationship(
                  sheetUrn,
                  sheetGuid,
                  target3DModelUrn,
                  target3DModelGuid));case 14:_context2.t0 = _context2.sent;case 15:this.model.alignmentRelationshipId = _context2.t0;_context2.next = 18;return (



                  alignmentService.saveViewport(
                  sheetUrn,
                  sheetGuid,
                  this.model.alignmentRelationshipId,
                  cropRegion.bbox,
                  cropRegion.units));case 18:_context2.next = 20;return (



                  alignmentService.saveTransform(
                  sheetUrn,
                  sheetGuid,
                  this.model.alignmentRelationshipId,
                  matrix));case 20:


                this.pendingChanges = [];case 21:case "end":return _context2.stop();}}}, _callee2, this);}));function saveChanges(_x) {return _saveChanges.apply(this, arguments);}return saveChanges;}() }]);return SheetAlignmentExtension;}(_ModelAlignmentBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);



namespace.SheetAlignment = SheetAlignmentExtension;
namespace.Events = Events;

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, SheetAlignmentExtension);

/***/ }),

/***/ "./extensions/ModelAlignment/SheetAlignmentLocals.js":
/*!***********************************************************!*\
  !*** ./extensions/ModelAlignment/SheetAlignmentLocals.js ***!
  \***********************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-sheetAlignment.loc.json */ "./res/locales/en/nobundle-sheetAlignment.loc.json");
var _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-sheetAlignment.loc.json */ "./res/locales/en/nobundle-sheetAlignment.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_sheetAlignment_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/ModelAlignment/TransformCommon.js":
/*!******************************************************!*\
  !*** ./extensions/ModelAlignment/TransformCommon.js ***!
  \******************************************************/
/*! exports provided: animateEdgeToEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateEdgeToEdge", function() { return animateEdgeToEdge; });
/**
 * Transforms a model according to 2 pairs of points.
 * 
 * @param {THREE.Vector3} s0 - source point 1
 * @param {THREE.Vector3} s1 - source point 2
 * @param {THREE.Vector3} t0 - target point 1
 * @param {THREE.Vector3} t0 - target point 2
 * @param {Object}    [options] - Additional options. Not mandatory.
 * @param {Function}  [options.onChange] - callback called when an animation frame is being processed. Recives the calculated matrix as an argument.
 * @param {Function}  [options.onEnd] - callback called when transform is complete.
 * @param {Boolean}   [options.originalMatrix]    - Source matrix to start with.
 * @param {Boolean}   [options.applyTranslation]  - Whether to apply translation to the transform. Default to true.
 * @param {Boolean}   [options.applyRotation]     - Whether to apply rotation to the transform. Default to true.
 * @param {Boolean}   [options.applyScale]        - Whether to apply scale to the transform. Default to true.
 * @param {Number}    [options.duration]          - Duration for the transform in seconds. Default to 1s.
 */
var animateEdgeToEdge = function () {
  var endQuaternion = new THREE.Quaternion();
  var startQuaternion = new THREE.Quaternion();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Matrix4();
  var matrix = new THREE.Matrix4();
  var rotation = new THREE.Matrix4();
  var newPos = new THREE.Vector3();
  var startPos = new THREE.Vector3();
  var originToPivot = new THREE.Matrix4();
  var pivotToOrigin = new THREE.Matrix4();

  return function (s0, s1, t0, t1) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};var

    onChange =





    options.onChange,onEnd = options.onEnd,_options$applyTransla = options.applyTranslation,applyTranslation = _options$applyTransla === void 0 ? true : _options$applyTransla,_options$applyRotatio = options.applyRotation,applyRotation = _options$applyRotatio === void 0 ? true : _options$applyRotatio,_options$applyScale = options.applyScale,applyScale = _options$applyScale === void 0 ? true : _options$applyScale,_options$duration = options.duration,duration = _options$duration === void 0 ? 1.0 : _options$duration;

    var originalMatrix = options.originalMatrix ? options.originalMatrix.clone() : undefined;
    var offset = t0.clone().sub(s0);

    var sLength = s0.distanceTo(s1);
    var tLength = t0.distanceTo(t1);
    var scaleTarget = tLength / sLength;

    var sDir = s1.clone().sub(s0).normalize();
    var tDir = t1.clone().sub(t0).normalize();
    endQuaternion.setFromUnitVectors(sDir, tDir);
    originToPivot.identity().setPosition(s0);
    pivotToOrigin.identity().setPosition(s0.clone().multiplyScalar(-1));

    var onTimer = function onTimer(t) {
      t = THREE.Math.smootherstep(t, 0.0, 1.0);

      // Reset matrix.
      matrix.identity();

      if (applyTranslation) {
        newPos.lerpVectors(startPos, offset, t);
        matrix.makeTranslation(newPos.x, newPos.y, newPos.z);
      }

      // Restore origin.
      matrix.multiply(originToPivot);

      // Apply rotation.
      if (applyRotation) {
        THREE.Quaternion.slerp(startQuaternion, endQuaternion, quaternion, t);
        rotation.makeRotationFromQuaternion(quaternion);
        matrix.multiply(rotation);
      }

      // Apply scale.
      if (applyScale) {
        var s = Autodesk.Viewing.Private.lerp(1.0, scaleTarget, t);
        scale.makeScale(s, s, s);
        matrix.multiply(scale);
      }

      // Set pivot at origin.
      matrix.multiply(pivotToOrigin);

      // Initialize based on previous model matrix, if given.
      if (originalMatrix) {
        matrix.multiply(originalMatrix);
      }

      if (onChange) {
        onChange(matrix);
      }
    };

    var control = Autodesk.Viewing.Private.fadeValue(0, 1, duration, onTimer, onEnd);

    return control;
  };
}();

/***/ }),

/***/ "./extensions/ModelAlignment/index.js":
/*!********************************************!*\
  !*** ./extensions/ModelAlignment/index.js ***!
  \********************************************/
/*! exports provided: ModelAlignment, SheetAlignment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ModelAlignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelAlignment.js */ "./extensions/ModelAlignment/ModelAlignment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModelAlignment", function() { return _ModelAlignment_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _SheetAlignment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetAlignment.js */ "./extensions/ModelAlignment/SheetAlignment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SheetAlignment", function() { return _SheetAlignment_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });







/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/ModelAlignment/ModelAlignmentPanel.css ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".model-alignment-panel .tab-header {\n  border-bottom-color: transparent;\n  font-size: 12px;\n  font-weight: bold;\n  border-bottom-style: solid;\n  border-bottom-width: 3px;\n  padding-bottom: 2px; }\n\n.model-alignment-panel .tab-header.selected {\n  color: #1dc6f2;\n  border-bottom-color: #1dc6f2; }\n\n.model-alignment-panel .tab-header:hover {\n  color: #1dc6f2; }\n\n.model-alignment-panel .model-select-combo {\n  width: calc(100% - 20px);\n  margin: 15px 10px 15px 10px;\n  /* top-right-bottom-left */\n  font-size: 15px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./res/locales/en/nobundle-modelAlignment.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/en/nobundle-modelAlignment.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Pivot, From, To, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"ModelAlignment Extension\",\"Pivot\":\"Pivot\",\"From\":\"From\",\"To\":\"To\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-sheetAlignment.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/en/nobundle-sheetAlignment.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Add drawing, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"SheetAlignment Extension\",\"Add drawing\":\"Add drawing\"}");

/***/ })

/******/ });
//# sourceMappingURL=ModelAlignment.js.map